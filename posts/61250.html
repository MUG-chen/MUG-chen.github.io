<!DOCTYPE HTML><html lang=zh-CN><head><meta charset=utf-8><meta name=keywords content="计算机组成原理_Fin, MUG-chen&#39;s Blog"><meta name=description content="Computer Composition Principles 期末复习章"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><meta name=renderer content=webkit|ie-stand|ie-comp><meta name=mobile-web-app-capable content=yes><meta name=format-detection content="telephone=no"><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black-translucent><meta name=referrer content=no-referrer-when-downgrade><title>计算机组成原理_Fin | MUG-chen&#39;s Blog</title><link rel=icon type=image/png href=/favicon.png><style>body{background-image:url(https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Vivid%20theory.webp);background-repeat:no-repeat;background-size:100% 100%;background-attachment:fixed}</style><link rel=stylesheet type=text/css href=/libs/awesome/css/all.min.css><link rel=stylesheet type=text/css href=/libs/materialize/materialize.min.css><link rel=stylesheet type=text/css href=/libs/aos/aos.css><link rel=stylesheet type=text/css href=/libs/animate/animate.min.css><link rel=stylesheet type=text/css href=/libs/lightGallery/css/lightgallery.min.css><link rel=stylesheet type=text/css href=/css/matery.css><link rel=stylesheet type=text/css href=/css/my.css><link rel=stylesheet type=text/css href=/css/dark.css media=none onload='"all"!=media&&(media="all")'><link rel=stylesheet href=/libs/tocbot/tocbot.css><link rel=stylesheet href=/css/post.css><script src=/libs/jquery/jquery-3.6.0.min.js></script><link rel=stylesheet type=text/css href=/css/loading.css><meta name=generator content="Hexo 7.1.1"></head><body><header class=navbar-fixed><nav id=headNav class="bg-color nav-transparent"><div id=navContainer class="nav-wrapper container"><div class=brand-logo><a href=/ class="waves-effect waves-light"><img src=/medias/logo.png class=logo-img alt=LOGO> <span class=logo-span>MUG-chen&#39;s Blog</span></a></div><a href=# data-target=mobile-nav class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href=/ class="waves-effect waves-light"><i class="fas fa-home" style=zoom:.6></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/tags class="waves-effect waves-light"><i class="fas fa-tags" style=zoom:.6></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/categories class="waves-effect waves-light"><i class="fas fa-bookmark" style=zoom:.6></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/archives class="waves-effect waves-light"><i class="fas fa-archive" style=zoom:.6></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/about class="waves-effect waves-light"><i class="fas fa-user-circle" style=zoom:.6></i> <span>关于</span></a></li><li><a href=#searchModal class="modal-trigger waves-effect waves-light"><i id=searchIcon class="fas fa-search" title=搜索 style=zoom:.85></i></a></li><li><a href=javascript:; class="waves-effect waves-light" onclick=switchNightMode() title=深色/浅色模式><i id=sum-moon-icon class="fas fa-sun" style=zoom:.85></i></a></li></ul><div id=mobile-nav class="side-nav sidenav"><div class="mobile-head bg-color"><img src=/medias/logo.png class="logo-img circle responsive-img"><div class=logo-name>MUG-chen&#39;s Blog</div><div class=logo-desc>Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class=m-nav-item><a href=/ class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class=m-nav-item><a href=/tags class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class=m-nav-item><a href=/categories class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class=m-nav-item><a href=/archives class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class=m-nav-item><a href=/about class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li><div class=divider></div></li><li><a href=https://github.com/MUG-chen/MUG-chen.github.io class="waves-effect waves-light" target=_blank><i class="fab fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href=https://github.com/MUG-chen/MUG-chen.github.io class="github-corner tooltipped hide-on-med-and-down" target=_blank data-tooltip="Fork Me" data-position=left data-delay=50><svg viewBox="0 0 250 250" aria-hidden=true><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill=currentColor style="transform-origin:130px 106px" class=octo-arm></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill=currentColor class=octo-body></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style=background-image:url(/medias/featureimages/3.jpg)><div class=container style=right:0;left:0><div class=row><div class="col s12 m12 l12"><div class=brand><h1 class="description center-align post-title">计算机组成原理_Fin</h1></div></div></div></div></div><main class="post-container content"><div class=row><div id=main-content class="col s12 m12 l9"><div id=artDetail><div class=card><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class=article-tag><a href=/tags/Computer-Composition-Principles/ ><span class="chip bg-color">Computer Composition Principles</span></a></div></div><div class="col s5 right-align"><div class=post-cate><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes</a></div></div></div><div class=post-info><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-06-27</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-06-27</div><div class=info-break-policy><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 19.1k</div></div></div><hr class=clearfix><link rel=stylesheet href=/libs/prism/prism.min.css><div class="card-content article-card-content"><div id=articleContent><h1 id=计算机组成原理><a href=#计算机组成原理 class=headerlink title=计算机组成原理></a>计算机组成原理</h1><blockquote><p>写在前面:<br>本文是针对《计算机组成原理》(唐朔飞编著 &#x2F; 第三版) 一书的总结, 也是博主应对期末考试的知识梳理.<br>本文中使用了大量的图片, 它们大多来自课上的PPT, 在这里对于PPT作者致以诚挚的谢意, 如有侵权, 请联系作者进行博文的删除操作.<br>文中如果提到书目页数, 指向的也是上文提到的教材.</p><p>此外, 由于博主的课堂教授顺序与书中不尽然相同, 因此会按照课堂的教授顺序进行梳理, 章节名称以及序号会以书中的名称 &#x2F; 序号为准. 读者可根据目录快速查询到相关章节.</p></blockquote><h2 id=Chap-1-计算机系统概论><a href=#Chap-1-计算机系统概论 class=headerlink title="Chap.1 计算机系统概论"></a>Chap.1 计算机系统概论</h2><h3 id=1-1-计算机系统的组成><a href=#1-1-计算机系统的组成 class=headerlink title="1.1 计算机系统的组成"></a>1.1 计算机系统的组成</h3><h4 id=1）软硬件概念><a href=#1）软硬件概念 class=headerlink title=1）软硬件概念></a>1）软硬件概念</h4><ul><li>硬件：各类实体、主机 &#x2F; 外设等</li><li>软件：由具有各类特殊功能的信息（程序）组成<ul><li>系统软件：用于管理整个计算机系统</li><li>应用软件</li></ul></li></ul><h4 id=2）解题过程-层次结构><a href=#2）解题过程-层次结构 class=headerlink title="2）解题过程 &amp; 层次结构"></a>2）解题过程 &amp; 层次结构</h4><p>计算机的程序运行过程主要经过以下过程：</p><p>高级语言程序-&gt;翻译为机器语言程序-&gt;运行-&gt;输出结果</p><p>根据该解题过程，可以将计算机分为如下层次结构：</p><ul><li>虚拟机器M4：用高级语言书写，利用 <strong>编译程序</strong> 翻译为汇编语言程序。</li><li>虚拟机器M3：用汇编语言书写，利用 <strong>汇编程序</strong> 翻译为机器语言程序。</li><li>操作系统机器M2：用机器语言解释操作系统。</li><li>实际机器M1：用微指令解释机器指令。</li><li>微程序机器M0：用硬件直接执行微指令。</li></ul><h4 id=3）计算机体系结构-Vs-计算机组成><a href=#3）计算机体系结构-Vs-计算机组成 class=headerlink title="3）计算机体系结构 Vs 计算机组成"></a>3）计算机体系结构 Vs 计算机组成</h4><ul><li>计算机体系结构：包含的主要是程序员能够见到的计算机系统属性。 <strong>概念性的结构与功能</strong> 。指令集、寻址技术等。</li><li>计算机组成：包含如何 <strong>实现计算机体系结构</strong> 涉及到的属性，但这些属性对于程序员而言大部分是透明的。</li></ul><h3 id=1-2-计算机的基本组成><a href=#1-2-计算机的基本组成 class=headerlink title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h3><h4 id=1）冯·诺依曼计算机的特点><a href=#1）冯·诺依曼计算机的特点 class=headerlink title=1）冯·诺依曼计算机的特点></a>1）冯·诺依曼计算机的特点</h4><ul><li>由五大部件组成<ul><li>运算器：算术运算、逻辑运算，并暂存结果</li><li>存储器：存放数据、程序</li><li>控制器：控制、指挥程序和数据的输入、运行，并处理运算结果</li><li>输入设备：将人类能识别的信息转化为机器信息</li><li>输出设备：将机器信息（运算结果）转化为人类可识别的信息</li></ul></li><li>指令、数据以 <strong>同等地位</strong> 存于存储器，可按地址寻访</li><li>指令和数据均用二进制表示</li><li>指令由操作码和地址码组成</li><li>指令在存储器内按顺序存放</li><li>机器以运算器为中心</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A1%86%E5%9B%BE.png alt=冯·诺伊曼计算机框图></p><h4 id=2）现代计算机框图><a href=#2）现代计算机框图 class=headerlink title=2）现代计算机框图></a>2）现代计算机框图</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A1%86%E5%9B%BE.png alt=现代计算机框图></p><ul><li>主机<ul><li>CPU<ul><li>ALU运算器</li><li>CU控制单元</li></ul></li><li>主存储器</li></ul></li><li>I&#x2F;O设备</li></ul><h4 id=3）计算机工作步骤><a href=#3）计算机工作步骤 class=headerlink title=3）计算机工作步骤></a>3）计算机工作步骤</h4><ul><li>上机前的准备<ul><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序（不同的算法对应的解题程序完全不同）</li></ul></li></ul><p>如：计算 ax^2 + bx + c –&gt; (ax + b)x + c</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/ax%5E2%2Bbx%2Bc%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B.png alt=计算例></p><ul><li>解题过程</li></ul><p>（1）存储器的基本组成：</p><p>①存储体：</p><p>存储体-&gt;存储单元-&gt;存储元件</p><p>类比为：一栋大楼-&gt;一个房间-&gt;一个床位</p><p>一个存储元件能表示一位二进制数。<br>一个存储单元代表着一串二进制代码，这被称为一个字。</p><p>②MAR &amp; MDR：</p><p>MAR被称为地址寄存器，反应存储单元的个数。<br>MDR被称为数据寄存器，反应存储字长。</p><p>举例：MAR：4位，MDR：8位<br>代表有16个存储单元（2^4），一个存储单元由八位二进制数组成。</p><hr><p>（2）运算器的基本组成及操作过程：</p><p>加法：</p><ul><li>[M] -&gt; X</li><li>[ACC]+[X] -&gt; ACC</li></ul><p>减法：</p><ul><li>[M] -&gt; X</li><li>[ACC]-[X] -&gt; ACC</li></ul><blockquote><p>对于加减法，无需使用MQ，即乘商寄存器，只需要将最终结果暂存在ACC中即可。</p></blockquote><p>乘法：</p><ul><li>[M] -&gt; MQ</li><li>[ACC] -&gt; X</li><li>0 -&gt; ACC</li><li>[X]*[MQ] -&gt; ACC&#x2F;&#x2F;MQ</li></ul><blockquote><p>对于乘法，由于十分可能出现溢出，因此需要将ACC与MQ串在一起存储结果，我们记成 ACC&#x2F;&#x2F;MQ ，这里的MQ是乘商寄存器。</p></blockquote><p>除法：</p><ul><li>[M] -&gt; X</li><li>[ACC]&#x2F;[X] -&gt; MQ</li><li>R -&gt; ACC</li></ul><blockquote><p>对于除法，将结果暂存在乘商寄存器中，将余数存在ACC内。</p></blockquote><hr><p>（3）控制器的基本组成：</p><ul><li>PC：程序计数器，存放当前需要执行指令的地址</li><li>IR：指令寄存器，存放当前即将执行的指令</li><li>CU：控制单元</li></ul><p>完成一条指令需要三步：</p><ul><li>取指：PC（PC直接与MAR相连，方便取指）</li><li>分析：IR（IR的高位，即操作码会送到CU，记为OP(IR)-&gt;CU；IR的低位，即地址码会送到MAR，记作Ad(IR)-&gt;MAR）</li><li>执行：CU（发送各种位操作命令序列）</li></ul><p>例子：</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%96%E6%95%B0%E6%8C%87%E4%BB%A4%E5%AE%8C%E6%88%90%E8%BF%87%E7%A8%8B.png alt=取数指令完成过程></p><h3 id=1-3-计算机硬件的技术指标><a href=#1-3-计算机硬件的技术指标 class=headerlink title="1.3 计算机硬件的技术指标"></a>1.3 计算机硬件的技术指标</h3><h4 id=1）机器字长><a href=#1）机器字长 class=headerlink title=1）机器字长></a>1）机器字长</h4><p>CPU一次能处理数据的位数。</p><h4 id=2）存储容量><a href=#2）存储容量 class=headerlink title=2）存储容量></a>2）存储容量</h4><p>$$ 存储容量 &#x3D; 存储单元个数 * 存储字长 $$</p><p>存储单元个数由MAR体现，即：<strong>2^MAR 个存储单元</strong> ；而MDR反应存储字长， <strong>字长就是MDR位数本身</strong> 。</p><p>常用的存储单位：</p><p>1 byte &#x3D; 2^3 bit &#x3D; 8 bit</p><p>1 KB &#x3D; 2^10 byte</p><p>1 MB &#x3D; 2^10 KB</p><p>1 GB &#x3D; 2^10 MB</p><h4 id=3）运算速度><a href=#3）运算速度 class=headerlink title=3）运算速度></a>3）运算速度</h4><ul><li>主频</li><li>吉普森法： $ T_M &#x3D; \sum_{i&#x3D;1}^n f_i * t_i $ 其中TM为机器运行速度，fi表示第i种指令占全部操作的占比数，ti表示该种指令的运行时间。</li><li>MIPS：每秒执行百万条指令</li><li>CPI：执行一条指令所需时钟周期数</li><li>FLOPS：每秒浮点运算次数</li></ul><h2 id=Chap-6-计算机的运算方法><a href=#Chap-6-计算机的运算方法 class=headerlink title="Chap.6 计算机的运算方法"></a>Chap.6 计算机的运算方法</h2><h3 id=6-1-无符号数和有符号数><a href=#6-1-无符号数和有符号数 class=headerlink title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h3><h4 id=1）无符号数><a href=#1）无符号数 class=headerlink title=1）无符号数></a>1）无符号数</h4><p>顾名思义，无符号数无正负，所有的位数都用于表示数字的大小。</p><p>例：8位无符号数能表示的范围：0~255（$ 2^8 -1 $）</p><h4 id=2）有符号数><a href=#2）有符号数 class=headerlink title=2）有符号数></a>2）有符号数</h4><p>利用单独的一位符号位来表示正负，用0表示正，用1表示负。</p><p>下面提三种表示方法：</p><p>①原码表示法</p><p>最简单的一种方法，符号位+数值位，数值位上就是 <strong>真值的绝对值</strong> 。</p><p>严谨定义如下：</p><p>$$ x_{整数}[原] &#x3D; \begin{cases}<br>x, 2^n &gt; x \geq 0 \\<br>2^n - x, 0 \geq x &gt; -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[原] &#x3D; \begin{cases}<br>x, 1 &gt; x \geq 0 \\<br>1 - x, 0 \geq x &gt; -1\<br>\end{cases} $$</p><p>其实不用摁记原始定义，在实际换算上，整数使用带余除法，小数利用不断乘2，取整数位的操作来获得即可。</p><p><strong>需要注意的是，在x &#x3D; 0时，正零和负零利用原码的表示是不同的：</strong></p><p>$ [+0]_原 &#x3D; 0,0000 $<br>$ [-0]_原 &#x3D; 1,0000 $</p><hr><p>②补码表示法</p><p>计算机为了归一加法和减法，利用了另一种表示方法，即 <strong>补码</strong> 的概念。</p><p>补码的根本概念需要说起同余，即涉及到了带余除法的概念，具体而言，-3与+9在除以12时，余数是一样的，因此在模12的意义下，这俩是一个数。</p><p>因此，我们类比上面的思路，可以将负数转化为相对应的模数。</p><p>给出严谨定义如下：</p><p>$$ x_{整数}[补] &#x3D; \begin{cases}<br>x, 2^n &gt; x \geq 0 \\<br>2^{n+1} + x \space(mod \space 2^{n+1}), 0 &gt; x \geq -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[补] &#x3D; \begin{cases}<br>x, 1 &gt; x \geq 0 \\<br>2 + x \space (mod \space 2), 0 &gt; x \geq -1\<br>\end{cases} $$</p><p>需要说明的是，式子里的x是真值。</p><p>还是不用摁记定义，有一种快捷的方式可以求补码。</p><p>显然，正数的补码不用管，就是它自身；<br>负数的补码可以通过 <strong>除符号位每位取反，最后在末位再加1求得</strong> 。</p><p><strong>两个特殊的案例：</strong></p><p>首先，根据定义（这里不要用快捷的求补码方式），+0 和 -0 的补码是一样的，都是 0,0000</p><p>第二，关于多出来的 1,0000这个值怎么办，这个值原先是 -0的原码，但是现在-0被占据了，那就将其指向最小的那个负数，这也就是为什么补码可以比原码表示的负数个数多一个。</p><p>举个例子，8位原码表示的范围是： $ -2^7+1 \to 2^7-1 $</p><p>而8位补码能表示的范围是： $ -2^7 \to 2^7-1 $</p><hr><p>③反码表示法</p><p>反码表示法的严谨定义如下：</p><p>$$ x_{整数}[反] &#x3D; \begin{cases}<br>x, 2^n &gt; x \geq 0 \\<br>(2^{n+1} - 1) + x \space(mod \space 2^{n+1} - 1), 0 \geq x &gt; -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[反] &#x3D; \begin{cases}<br>x, 1 &gt; x \geq 0 \\<br>(2 - 2^{-n}) + x \space(mod \space 2 - 2^{-n}), 0 \geq x &gt; -1 \<br>\end{cases} $$</p><p>这里n是指小数的位数</p><p>同样的，有一种快速求反码的方式，即 <strong>除了符号位之外各位取反</strong> 即可。</p><p>我们把三种东西总结一下：</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%EF%BC%8C%E8%A1%A5%EF%BC%8C%E5%8F%8D.png alt=原，补，反></p><hr><p>最后，提一嘴关于移码的内容。</p><p>移码是为了解决补码无法非常直观的看出数字大小而发明的。</p><p>其定义为：</p><p>$$ x[移] &#x3D; 2^n + x $$</p><p>n是整数的位数。</p><p>其快捷算法即 <strong>先将补码算出来，改一个符号位即可</strong> 。</p><p>显然，根据移码的定义，移码这里也没有+0，-0的区分。</p><p>而对于对应数位上最小的那个值，其移码为全0。</p><p>举个例子：n&#x3D;5时， $ -2^5[移] &#x3D; 0,00000 $</p><p>这也与其补码相匹配，毕竟 $ -2^5[补] &#x3D; 1,00000 $</p><h3 id=6-2-数的定点表示和浮点表示><a href=#6-2-数的定点表示和浮点表示 class=headerlink title="6.2 数的定点表示和浮点表示"></a>6.2 数的定点表示和浮点表示</h3><h4 id=1）定点表示><a href=#1）定点表示 class=headerlink title=1）定点表示></a>1）定点表示</h4><p>即将小数点位置固定在某一位置，这样的方法容易在进行运算时产生溢出风险，尤其是在处理的数字不是纯整数或纯小数时。</p><h4 id=2）浮点表示><a href=#2）浮点表示 class=headerlink title=2）浮点表示></a>2）浮点表示</h4><p>浮点数是当前更多采用的方法，其一般形式为：</p><p>$$ N &#x3D; S * r^j $$</p><ul><li>S: 尾数，小数，可正可负</li><li>r: 基数，一般取2，4，8，16等</li><li>j: 阶码，整数，可正可负</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F.png alt=浮点数的表示形式></p><p>n，是尾数的位数，反映了浮点数的精度<br>m，是阶码的位数，反映了浮点数的表示范围</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4.png alt=浮点数的表示范围></p><hr><p>浮点数的规格化：即将类似 0.00001 这类的小数转化成 $ 0.10000 * 2^{1,0100} $ 这样的德行（这里全用的二进制机器数），说的再简单点，就是把小数点后面能用阶码表示的0全去了。</p><p>具体怎么规格化呢，先将真值对应的二进制数字进行规格化，比如： $ -0.0001011 &#x3D; 2^{-3} * -0.1011$ ，而后再进行对应的机器数转换，后面这个转换过程中不需要再做任何移位操作。</p><p>需要注意的是，规格化之后也涉及到补码、反码之类的一堆形式，一般会给要求，如 <strong>阶原尾补</strong> 之类的，即阶码用原码表示，尾数用补码表示。</p><p>关于机器0：当尾数为0时，不论阶码为何值，均按照机器0处理。</p><h3 id=6-3-定点运算><a href=#6-3-定点运算 class=headerlink title="6.3 定点运算"></a>6.3 定点运算</h3><p>计算机中的乘法是通过类似笔算乘法的方式通过移位来实现的：</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%AC%94%E7%AE%97%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png alt=笔算乘法的改进></p><p>这里A是 <strong>被乘数</strong> , B是 <strong>乘数</strong> .</p><p>因此我们将其化为下面的竖式:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%AC%94%E7%AE%97%E4%B9%98%E6%B3%95_%E7%AB%96%E5%BC%8F.png alt=改进笔算乘法的竖式表示></p><p>上面的步骤可以总结为:</p><ul><li>利用加法和移位进行乘法运算.</li><li>由乘数的末尾决定是否与被乘数相加, 而后进行 <strong>整体右移</strong> , 乘数最后一位丢弃, 同时结果(即原先部分积)右移一位, 将放不下的那一位放在 <strong>乘数右移空出的高位</strong> 上.</li><li>总次数取决于乘数的位数</li></ul><h4 id=6-3-1-原码一位乘><a href=#6-3-1-原码一位乘 class=headerlink title="6.3.1 原码一位乘"></a>6.3.1 原码一位乘</h4><p>原码一位乘与上述笔算乘法思想完全相同, 不过需要额外考虑 <strong>符号位</strong> 的问题, 这里一般采取 <strong>符号位和数值位分开处理</strong> 的方法.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98.png alt=原码一位乘></p><p>最终将符号位 ( $ 1 \bigoplus 0 &#x3D; 1 $ ) 加上即可得到最终结果: 1.10110110.</p><h4 id=6-3-2-原码两位乘><a href=#6-3-2-原码两位乘 class=headerlink title="6.3.2 原码两位乘"></a>6.3.2 原码两位乘</h4><p>两位乘法是为了后续为了节省时间而设计出来的算法, 但是两位乘法涉及到 <strong>加三个被乘数</strong> , 而计算机对于三这个数字并不高效, 因此通过单独一个进位位来进行处理:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98.png alt=原码两位乘_原理></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98_%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png alt=原码两位乘_运算规则></p><p>需要额外说明的是, 由于原码二位乘涉及到进位问题( 详细来说, 就是可能需要加两倍的被乘数[即左移一位], 或者减去一倍的被乘数[符号位全部置1] ) 因此在原码两位乘时, 我们需要 <strong>写三个符号位</strong> .</p><p>原码两位乘的符号位仍然需要单独处理, 乘法是否结束看的是乘数位数( <strong>x位需要右移 $ \frac{x}{2} $ 次, 每次右移两位</strong> ).</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98_%E4%BE%8B.png alt=原码两位乘_例></p><h4 id=6-3-3-补码乘法><a href=#6-3-3-补码乘法 class=headerlink title="6.3.3 补码乘法"></a>6.3.3 补码乘法</h4><p>补码一位乘:</p><p>补码一位乘即利用补码的形式进行与上述模式类似的优化乘法, 运算规则如下:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98_%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png alt=补码一位乘_运算规则></p><hr><p>这里着重介绍Booth算法:</p><p>Booth算法 <strong>无需考虑被乘数和乘数的符号</strong> , 这里不对其原理进行详细介绍, 仅给出计算规则:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Booth%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png alt=Booth_计算公式></p><p>请额外注意: <strong>Booth算法的乘数需要带着符号位</strong> , 也正因如此, <strong>Booth算法的最后一步加法无需右移</strong> .</p><p>此外, Booth算法的右移是 <strong>补码右移</strong> , 补上的数字 <strong>同当前计算结果的符号位</strong> .</p><p>给个例子:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Booth_%E4%BE%8B.png alt=Booth_例></p><h3 id=6-4-浮点四则运算><a href=#6-4-浮点四则运算 class=headerlink title="6.4 浮点四则运算"></a>6.4 浮点四则运算</h3><p>本节需要明确的问题是处理两个规格化的浮点数之间的运算.</p><p>对于浮点数:</p><p>$$ x &#x3D; S_x * 2^{j_x} $$</p><p>$$ y &#x3D; S_y * 2^{j_y} $$</p><h4 id=6-4-1-浮点加减><a href=#6-4-1-浮点加减 class=headerlink title="6.4.1 浮点加减"></a>6.4.1 浮点加减</h4><p>可以分为三步来进行:</p><ul><li>对阶: 相当于正常运算中的对齐对应位操作</li><li>尾数求和: 利用对应的补码加减定点运算进行</li><li>规格化</li><li>舍入: 如果规格化过程中出现了 <strong>尾数末尾丢失</strong> 的情况, 要考虑舍入</li></ul><hr><p>1.对阶:</p><p>显然, 阶数小的浮点数应当向阶数大的浮点数看齐.</p><p>为了方便, 这里应当 <strong>尽可能使用补码运算</strong> .</p><p>2.尾数求和:</p><p>利用化完的补码进行加减即可.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E5%8A%A0%E5%87%8F_%E4%BE%8B.png alt=浮点加减_例></p><p>3.规格化:</p><p>规格化, 意思为需要将加(减)完的数转变为规格化数.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A7%84%E6%A0%BC%E5%8C%96%E6%95%B0.png alt=规格化数></p><p>由于我们这里通常使用补码加, 因此要记住补码的规格化数特点: <strong>符号位和第一数位不同</strong> .</p><p>延续上例:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A7%84%E6%A0%BC%E5%8C%96_%E6%96%B9%E6%B3%95.png alt=规格化_方法></p><p>4.舍入:</p><p>即考虑被舍弃的尾数应当如何处理:</p><ul><li>0舍1入: 被舍弃的值是0则直接舍弃, 是1则将舍弃后尾数加1(精度较高)</li><li>恒置1: 不论舍弃的低位是什么, <strong>舍弃后的最低位</strong> 恒置为1</li></ul><h4 id=6-4-2-浮点乘除><a href=#6-4-2-浮点乘除 class=headerlink title="6.4.2 浮点乘除"></a>6.4.2 浮点乘除</h4><p>与加减不同, 浮点乘除不需要考虑对阶, 直接进行运算即可:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E4%B9%98%E9%99%A4.png alt=浮点乘除></p><p>除法运算并不要求掌握, 这里不细说了.</p><h3 id=6-5-算术逻辑单元ALU><a href=#6-5-算术逻辑单元ALU class=headerlink title="6.5 算术逻辑单元ALU"></a>6.5 算术逻辑单元ALU</h3><h4 id=6-5-1-ALU概述><a href=#6-5-1-ALU概述 class=headerlink title="6.5.1 ALU概述"></a>6.5.1 ALU概述</h4><p>因为这不是数字电路基础的复习, 因此对于ALU的详细电路组成不会进行非常详细的讲解.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/ALU.png alt=ALU></p><p>中间的ALU其实是相当复杂的组合逻辑电路, 典型的四位ALU芯片为74181, 在数字电路中有所提及.</p><p>这里只需要明确, ALU是 <strong>根据 $ K_i $ 的不同取值对 $ A_i, B_i $ 进行相应的操作, 从而使 $ F_i $ 输出对应的运算结果</strong> 的器件即可(明确一下, 这里i使可以取多位的, 要不然ALU只能进行一位数的两种运算也太low了).</p><h4 id=6-5-2-快速进位链><a href=#6-5-2-快速进位链 class=headerlink title="6.5.2 快速进位链"></a>6.5.2 快速进位链</h4><p>我们需要详细了解的是ALU的快速进位链, 即ALU进位的过程.</p><hr><p>1.并行加法器:</p><p>这种进位是最慢的, 因为它需要等待前面的位运算完毕产生进位信号 $ C_i $ 后, 才能进行自己的运算.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BF%AB%E9%80%9F%E8%BF%9B%E4%BD%8D%E9%93%BE_%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8.png alt=并行加法器></p><hr><p>2.串行进位链:</p><p>我们先看正常全加器中 $ C_i $ 的逻辑表达式</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%85%A8%E5%8A%A0%E5%99%A8%E9%80%BB%E8%BE%91_%E8%BF%9B%E4%BD%8D%E6%9D%A1%E4%BB%B6.png alt=进位条件></p><p>可见, 将其进位公式抽象成了:</p><p>$$ C_i &#x3D; d_i + t_i C_{i-1}, d_i &#x3D; A_i B_i, t_i &#x3D; A_i+B_i $$</p><p>显然, $ d_i, t_i $ 都是可以先算出来的, 而 $ C_{i-1} $ 需要等待下位传递.</p><p>因此, 一个像这样的串行进位链就出来了:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E9%93%BE.png alt=串行加法链></p><p>如果一个与非门的判断延迟时间: $ t_y $</p><ul><li>一位进位信号产生时间: $ 2t_y $</li><li>n位进位信号产生时间: $ 2nt_y $</li></ul><hr><p>3.并行进位链:</p><p>其实将上面的 $ C_0, C_1, C_2 $ 等元素进行递推, 就可以发现并行进位链的效率可以进一步提高(相当于 $ C_{-1} $ 的进位信号来了, 就可以一次产生4个进位信号).</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E9%93%BE.png alt=并行进位链></p><p>这样的结构需要额外在每个进位位前面加一个 <strong>与或非门</strong> , 我们假设其判断时间为: $ 1.5t_y $</p><p>可见, 仅需要 $ 1.5t_y + t_y &#x3D; 2.5t_y $ 的时间, 就可以产生四位的进位信号, 效率很高.</p><p>但是肉眼可见的, 这种进位的电路相当的复杂, 因此, 只能成组使用.</p><p>(1) 单重分组跳跃进位:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E9%93%BE_%E5%8D%95%E9%87%8D%E5%88%86%E7%BB%84.png alt=并行进位链_单重分组></p><p>可见, 将四位为1组, 每组可以在 $ 2.5t_y $ 的时间内产生进位信号, 并将最后一位的进位信号传向下一组.</p><p>(2) 双重分组跳跃进位链:</p><p>在上述分组的基础上, 每小组再分成一个大组:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D_%E7%94%B5%E8%B7%AF.png alt=双重分组跳跃进位_电路></p><p>我们以第八小组为例, 给出进位逻辑:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D%E9%93%BE_%E9%80%BB%E8%BE%91.png alt=双重分组跳跃进位链_逻辑></p><p>可见, 可以通过进一步拆解递推公式, 发现一大组中的四个小组的进位信号 $ C_i $ 都可以通过前一个大组传来的最终进位信号 $ C_{-1} $ 得到, 进而进一步设计电路节省时间.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E8%B7%B3%E8%B7%83%E5%88%86%E7%BB%84_%E5%A4%A7%E7%BB%84%E7%94%B5%E8%B7%AF.png alt=双重跳跃分组_大组电路></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E8%B7%B3%E8%B7%83%E5%88%86%E7%BB%84_%E5%B0%8F%E7%BB%84%E7%94%B5%E8%B7%AF.png alt=双重跳跃分组_小组电路></p><p>小组分组电路中, 由于第8小组的 <strong>最高位进位</strong> $ C_3 $ 可以根据 $ T_8, D_8 $ 得到, 而 $ T_8, D_8 $ <strong>还可以进一步用于后续小组(第5, 6, 7小组)的进位</strong> , 因此不再输出 $ C_3 $ , 转而输出 $ T_8, D_8 $</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D%E9%93%BE_%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90.png alt=双重分组跳跃进位链_时间分析></p><p>可见, 双重分组跳跃进位链产生16位进位的时间进一步缩短到 $ 7.5t_y $ , 究其根本原因在于每一个小组的最高位进位( $ C_15, C_11, C_7, C_3 $ )通过电路提前根据 $ C_{-1} $ 算出来了, 而不像单重分组那样需要等待前几个分组的信号.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/32%E4%BD%8D%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E9%93%BE_%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90.png alt=32位双重分组跳跃链_时间分析></p><h2 id=Chap-4-存储器><a href=#Chap-4-存储器 class=headerlink title="Chap.4 存储器"></a>Chap.4 存储器</h2><h3 id=4-1-存储器概述><a href=#4-1-存储器概述 class=headerlink title="4.1 存储器概述"></a>4.1 存储器概述</h3><h4 id=4-1-1-存储器分类><a href=#4-1-1-存储器分类 class=headerlink title="4.1.1 存储器分类"></a>4.1.1 存储器分类</h4><p>存储器有多种分类方式:</p><ul><li>按存储介质分类<ul><li>半导体存储器: TTL &#x2F; MOS</li><li>磁表面存储器: 磁头, 载磁体</li><li>磁芯存储器: 硬磁材料, 环状原件</li><li>光盘存储器: 激光, 激光材料</li></ul></li><li>按存取方式分类:<ul><li>存取时间与物理地址无关(随机访问)<ul><li>随机存储器( <strong>可读可写</strong> )</li><li>只读存储器( <strong>只读</strong> )</li></ul></li><li>存取时间与物理地址有关(串行访问)<ul><li>顺序存取存储器(磁带)</li><li>直接存取存储器(磁盘)</li></ul></li></ul></li><li><strong>按在计算机中的作用分类</strong> :<ul><li>主存储器:<ul><li>RAM<ul><li>静态RAM: SRAM</li><li>动态RAM: DRAM, SDRAM</li></ul></li><li>ROM<ul><li>MROM</li><li>PROM</li><li>EPROM</li><li>EEPROM</li></ul></li></ul></li><li>Flash Memory(闪存)</li><li>高速缓冲存储器(Cache)</li><li>辅助存储器: 磁盘, 磁带, 光盘</li></ul></li></ul><h4 id=4-1-2-存储器的层次结构><a href=#4-1-2-存储器的层次结构 class=headerlink title="4.1.2 存储器的层次结构"></a>4.1.2 存储器的层次结构</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%B9%E6%AF%94.png alt=存储器对比></p><p>由于目前比较常见的说法都按照在计算机中的作用分类, 因此我们通常利用该种分类方式来描述存储器的主要特性.</p><p>根据上图的层次性质对比, 可以将计算机的存储层次归纳为:</p><p>$$ CPU \iff 缓存 \iff 主存 \iff 辅存 $$</p><p>这其中:</p><ul><li><strong>$ 缓存 \iff 主存 $ 层次主要解决CPU与主存速度不匹配的问题</strong></li><li><strong>$ 主存 \iff 辅存 $ 层次主要解决存储系统的容量问题</strong></li></ul><h3 id=4-2-主存储器><a href=#4-2-主存储器 class=headerlink title="4.2 主存储器"></a>4.2 主存储器</h3><h4 id=4-2-1-概述><a href=#4-2-1-概述 class=headerlink title="4.2.1 概述"></a>4.2.1 概述</h4><p><strong>主存的基本组成</strong> 如下图所示:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png alt=主存的基本组成></p><p><strong>MAR &#x2F; MDR</strong> 即地址寄存器和数据寄存器在第一章中有所提及, CPU向MAR, MDR发送数据, 而后MAR, MDR分别通过地址总线和数据总线与内存的相应电路相连, 并以此达到读或写的目的.</p><h4 id=4-2-2-主存中存储单元的地址><a href=#4-2-2-主存中存储单元的地址 class=headerlink title="4.2.2 主存中存储单元的地址"></a>4.2.2 主存中存储单元的地址</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E9%85%8D_%E6%8C%89%E5%AD%97%E8%8A%82%E4%B8%8E%E6%8C%89%E5%AD%97%E5%AF%BB%E5%9D%80.png alt=按字节与按字寻址></p><p><strong>地址线</strong> 决定了计算机的寻址空间: 一根地址线能够一个二进制位.</p><p>如果按照字节编址: 寻址范围为 $ 2^{24} &#x3D; 16M $</p><p>如果按照字编址: 寻址范围则缩小为 $ \frac{2^{24}}{\frac{x}{8}}, x是字的位数 $ , 即 $ \frac{原寻址范围}{一个字包含的字节数} $</p><p>读者可以将按照字编制理解为将多个字节打了个包, 只能寻找到一个包裹而不能单独将包裹内的字节拿出来, 因此寻址范围也需要相应减少.</p><h4 id=4-2-3-主存的技术指标><a href=#4-2-3-主存的技术指标 class=headerlink title="4.2.3 主存的技术指标"></a>4.2.3 主存的技术指标</h4><p>主要有三种存储器指标可供参考:</p><ul><li>存储容量: 主存存放二进制代码的总位数</li><li>存储速度<ul><li>存取时间: 包括 <strong>访问时间, 读出时间, 写入时间</strong></li><li>存取周期: 连续两次 <strong>独立</strong> 的存储器操作所需的最小间隔时间</li></ul></li><li>存储器的带宽: 位&#x2F;秒</li></ul><blockquote><p>存储器带宽的算法要会, 具体而言, $ 单次取出位数*存储器频率 $ , 通常可能给出一个存取周期, 给出单次取出位数, 会让算存储器带宽.</p></blockquote><h4 id=4-2-4-半导体存储芯片><a href=#4-2-4-半导体存储芯片 class=headerlink title="4.2.4 半导体存储芯片"></a>4.2.4 半导体存储芯片</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87_%E5%AE%B9%E9%87%8F%E8%AF%B4%E6%98%8E.png alt=半导体存储芯片及容量说明></p><p>目前主流的半导体存储芯片利用地址线通过译码驱动电路指向存储矩阵中的内存单元, 再由数据线将内存单元中的数据取出.</p><blockquote><p>可以直接根据地址线和数据线的数量来计算出总芯片容量, $ 容量 &#x3D; 2^{地址线位数} * 数据线位数 $ , 即 <strong>总共多少个存储单元 * 一个存储单元内多少位</strong> .</p></blockquote><p><strong>片选线</strong> 用于选取存储芯片(后文会提及), <strong>读写控制线</strong> 用于决定进行何种(读 &#x2F; 写)操作.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%89%87%E9%80%89%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png alt=片选线></p><p>上图也能证明, 很多存储器是由 <strong>多片容量更小的存储器组合在一起</strong> 组成的.</p><h4 id=4-2-5-半导体存储芯片的译码驱动方式><a href=#4-2-5-半导体存储芯片的译码驱动方式 class=headerlink title="4.2.5 半导体存储芯片的译码驱动方式"></a>4.2.5 半导体存储芯片的译码驱动方式</h4><p>1.线选法:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8_%E7%BA%BF%E9%80%89%E6%B3%95.png alt=线选法></p><p>线选法原理简单, 如上图所示, 很多的存储单元组成 $ m*n $ 位的矩阵, 地址译码器先将地址线的二进制数译码为对应的行数, 而位线再通过与对应列数对齐将一行的所有位输出.</p><p>2.重合法:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8_%E9%87%8D%E5%90%88%E6%B3%95.png alt=重合法></p><p>重合法通过二维的地址译码器选中一个特定的存储单元. 两侧的译码单元作用与上面的线选法原理相同.</p><h4 id=4-2-6-静态RAM及芯片举例><a href=#4-2-6-静态RAM及芯片举例 class=headerlink title="4.2.6 静态RAM及芯片举例"></a>4.2.6 静态RAM及芯片举例</h4><p>静态RAM通过触发器与放大器等元器件进行数据读写, 这里不对具体的原理电路进行说明, 进进行芯片举例:</p><p><strong>Intel 2114</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%202114%20RAM%E7%9F%A9%E9%98%B5.png alt="Intel 2114 RAM"></p><p>总体思路与重合法(矩阵单元选择)的方法很像, 但2114的列地址译码器可以一次选择一行中的四位(即 $ x, x+16, x+32, x+48 $ 四列), 从而达到一次传输出4位二进制数据的效果.</p><p>这里以写操作举例:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%202114%20%E5%86%99%E6%93%8D%E4%BD%9C.png alt="Intel 2114 写操作"></p><h4 id=4-2-7-动态RAM及芯片举例><a href=#4-2-7-动态RAM及芯片举例 class=headerlink title="4.2.7 动态RAM及芯片举例"></a>4.2.7 动态RAM及芯片举例</h4><p>动态RAM通过电容存储电荷的原理来寄存信息. 电容上的电荷仅能持续 1~2 ms, 因此, 必须每2ms对所有存储单元恢复一次原状态, 这被称为 <strong>再生或刷新</strong> .</p><p>由于动态RAM的基本单元性质, 它读出的高低电平与 <strong>原存信息反相</strong> .</p><p><strong>Intel 1103</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%201103%20%E8%AF%BB%E6%93%8D%E4%BD%9C.png></p><hr><p><strong>动态RAM的刷新</strong></p><p>由于电容的特性, 动态RAM需要定时进行刷新.</p><p><strong>1.集中刷新</strong></p><p>即在一段时间后单独拉出一段整时间进行全体刷新:</p><p>需要明确的是, 刷新是跟行地址强相关的, 即一次存取周期刷新一整行.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png alt=集中刷新></p><p>图中两个概念:</p><ul><li>死区: 用于刷新的时间, 即 $ 存取周期 * 矩阵行数 $</li><li>死时间率: 死区时间占比, 即 $ \frac{死区时间}{刷新时间间隔} $</li></ul><p><strong>2.分散刷新</strong></p><p>分散刷新将刷新分布在了存取周期内, 即花一半的周期进行读 &#x2F; 写, 另一半的周期用于刷新.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM_%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png alt=分散刷新></p><p>由于刷新按行进行, 因此只需要 $ (0.5+0.5)*128 &#x3D; 128\mu s $ 就能完成一整次刷新. 并且不会存在停止读写的死区时间.</p><p>代价是存取周期更长了, 整个系统的速度受影响.</p><p><strong>3.异步刷新</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM_%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png alt=异步刷新></p><p>异步刷新想将分散刷新与集中刷新结合起来, 其做到每行隔 2ms 刷新一次, 平均到每行, 即 $ \frac{2*10^3}{128} &#x3D; 15.6 \mu s $ 刷新一行. 仍有死区, 但死区很短, 并且对系统速度影响较小.</p><h4 id=4-2-8-动态RAM与静态RAM的比较><a href=#4-2-8-动态RAM与静态RAM的比较 class=headerlink title="4.2.8 动态RAM与静态RAM的比较"></a>4.2.8 动态RAM与静态RAM的比较</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM%E4%B8%8E%E9%9D%99%E6%80%81RAM%E7%9A%84%E6%AF%94%E8%BE%83.png alt="动 / 静态比较"></p><h4 id=4-2-9-只读存储器ROM><a href=#4-2-9-只读存储器ROM class=headerlink title="4.2.9 只读存储器ROM"></a>4.2.9 只读存储器ROM</h4><ul><li>MROM</li><li>PROM(一次性编程)</li><li>EPROM(多次性编程)</li><li>EEPROM(电可擦写多次性编程)</li><li>Flash Memory(闪存)<ul><li>便宜</li><li>电可擦洗</li><li>比EEPROM快</li></ul></li></ul><h3 id=4-3-存储器与CPU的连接><a href=#4-3-存储器与CPU的连接 class=headerlink title="4.3 存储器与CPU的连接"></a>4.3 存储器与CPU的连接</h3><h4 id=4-3-1-存储容量扩展><a href=#4-3-1-存储容量扩展 class=headerlink title="4.3.1 存储容量扩展"></a>4.3.1 存储容量扩展</h4><p><strong>1.位扩展(增加存储字长)</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E4%BD%8D%E6%89%A9%E5%B1%95.png alt=位扩展></p><p><strong>2.字扩展(增加存储字(也可理解为存储单元)的数量)</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E5%AD%97%E6%89%A9%E5%B1%95.png alt=字扩展></p><p><strong>3.字 &#x2F; 位同时扩展(上述二者结合)</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E5%AD%97%2C%20%E4%BD%8D%E6%89%A9%E5%B1%95.png alt="字 / 位扩展"></p><p>由上述说明可知, 通过地址线的增加来实现字扩展(扩大寻址空间), 通过数据线的增加来实现位扩展(扩大存储单元位数)</p><h4 id=4-3-2-存储器与CPU的连接><a href=#4-3-2-存储器与CPU的连接 class=headerlink title="4.3.2 存储器与CPU的连接"></a>4.3.2 存储器与CPU的连接</h4><p>例题: 见书P94~99 例4.1 &#x2F; 4.2 &#x2F; 4.3</p><p>通常可以分为四步:</p><ul><li>写出要求主存地址空间分配的二进制码</li><li>确定使用的芯片数量及类型</li><li>分配CPU的地址线</li><li>形成片选信号</li></ul><p>需要注意的是, 这里题目中给出的4K, 8K往往代表 <strong>寻址空间</strong> 而并非 <strong>总容量</strong> (举例而言, 如果题目希望分配4K地址的系统程序区, 而系统又有8根数据线, 你应当分配一个4K*8位的存储芯片, 而并非是一个256bit*8位的存储芯片), 即这里的地址指的都是编好地址的一个个存储单元, 而并非单独的一位.</p><h3 id=4-4-提高访存速度的措施><a href=#4-4-提高访存速度的措施 class=headerlink title="4.4 提高访存速度的措施"></a>4.4 提高访存速度的措施</h3><p>总体而言, 提高访存速度有三种方法:</p><ul><li>采用高速器件</li><li>采用层次结构(Cache-主存)</li><li>调整主存结构</li></ul><p>从主存结构说起:</p><p><strong>1.单体多字系统</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E7%BB%93%E6%9E%84_%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F.png alt=单体多字系统></p><p>这种设计的目的在于单次从存储体中某一地址取出多条指令, 并在此后每隔一定时间送给CPU一条指令, 这极大程度上提高了主存的带宽, 但显然, 这种设计的前提在于指令必须是连续存储的.</p><blockquote><p>劣势: 遇到 <strong>转移指令</strong> 或 <strong>操作数不能连续存放的指令</strong> 时, 效果不明显</p></blockquote><p><strong>2.多体并行系统</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%28%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%29.png alt=多体并行系统(高位交叉编址)></p><p>相当于将主存再度分层, 分为N个模块, 每个模块都有自己的MAR, MDR可供独立使用, 这使得它们可以并行工作, 又可以交叉工作.</p><p>上图所谓 <strong>高位交叉</strong> 即高位地址表示体号, 低位地址表示体内地址. 这种编址可以使不同的请求源同时访问不同的体, 实现 <strong>多体并行操作</strong> ;</p><hr><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%28%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%29.png alt=多体并行系统(低位交叉编址)></p><p>与高位交叉相反的思路是 <strong>低位交叉</strong> , 即低位地址表示体号, 高位地址表示体内地址, ( <strong>将所有内存分成几个体, 就称作模几交叉, 比如上图就是一个模4的交叉编址</strong> ) 这种方式能够在不改变存取周期的前提下增加存储器的带宽:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89_%E5%A2%9E%E5%A4%A7%E5%B8%A6%E5%AE%BD.png alt=低位交叉_增大带宽></p><p>如上图, 低位交叉可以通过硬件设计使得 <strong>不同的体先后在同一个访存周期的不同时段启动</strong> , 以此达到一个访存周期传递多条指令的效果(上例中读顺序: 0-&gt;1-&gt;2-&gt;3-&gt;0-&gt;1-&gt;2-&gt;3)</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89_%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86.png alt=低位交叉_流水线原理></p><hr><p>存储器控制部件(存控)</p><p>存控中含有四个部件:</p><ul><li>控制线路</li><li>节拍发生器</li><li>存控标记触发器</li><li>排队器</li></ul><p>其中, 排队器是相当重要的, 它能根据请求源的紧急程度为CPU处理顺序排序, 具体顺序: 易发生代码丢失的请求源-&gt;严重影响CPU工作的请求源-&gt;其他请求源;</p><hr><p>高性能存储芯片</p><p>SDRAM(同步DRAM): 能在系统时钟的控制下进行写入和读出, 这使得 <strong>CPU无需等待</strong> ;</p><p>带Cache的DRAM: 继承了一个由SRAM组成的Cache, 有利于猝发式读取;</p><h3 id=4-5-高速缓冲存储器><a href=#4-5-高速缓冲存储器 class=headerlink title="4.5 高速缓冲存储器"></a>4.5 高速缓冲存储器</h3><p>简称 <strong>缓存</strong> , 位于CPU与主存之间, 负责解决CPU的 <strong>空等</strong> 现象, 容量比主存小, 速度比主存高;</p><h4 id=4-5-1-Cache工作原理><a href=#4-5-1-Cache工作原理 class=headerlink title="4.5.1 Cache工作原理"></a>4.5.1 Cache工作原理</h4><p>主存和缓存均按照块存储(类似于前面的多体并行系统), 块的大小相同, 一个块中有很多存储单元;</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%96%E5%9D%80.png alt=主存和缓存的编址></p><p>缓存内共有C块, 主存共有M块, 显然, M&gt;&gt;C;</p><p>因此, 需要根据某种规则将主存的块与缓存的块建立联系, 这就衍生出两个名词:</p><ul><li>命中: 主存块成功调入了缓存, 建立了对应关系;</li><li>未命中: 主存块未调入缓存, 对应关系未能建立;</li></ul><h4 id=4-5-2-Cache的命中率以及效率><a href=#4-5-2-Cache的命中率以及效率 class=headerlink title="4.5.2 Cache的命中率以及效率"></a>4.5.2 Cache的命中率以及效率</h4><p>即CPU希望访问的信息在Cache中的比率.</p><p>$$ Cache命中率 \space h &#x3D; \frac{Nc}{Nc+Nm} $$</p><p>上式中: Nc表示访问Cache的次数, Nm表示访问主存的次数;</p><p><strong>可以通过命中率推断主存系统的平均访问时间:</strong></p><p>设:</p><ul><li>访问Cache的时间 $ t_c $</li><li>访问主存的时间 $ t_m $</li><li>Cache命中率 $ h $</li></ul><p>则主存系统的平均访问时间:</p><p>$$ t_a &#x3D; h * t_c + (1-h) * t_m $$</p><blockquote><p>上面这个式子的意义就是: 命中缓存, 则直接从缓存里取; 未命中缓存, 则需要进一步访问主存;</p></blockquote><p>进一步推出 <strong>Cache-主存系统的效率</strong> :</p><p>$$ Efficiency &#x3D; \frac{访问Cache的时间}{平均访问时间} * 100 % &#x3D; \frac{t_c}{h * t_c + (1-h) * t_m} * 100 % $$</p><h4 id=4-5-3-Cache的读写><a href=#4-5-3-Cache的读写 class=headerlink title="4.5.3 Cache的读写"></a>4.5.3 Cache的读写</h4><p>下列框图为Cache的读操作</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Cache%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C.png alt=Cache的读操作></p><p>在写操作上, 则有两种方法:</p><ul><li>写直达法: 写操作时 <strong>既将数据写入Cache, 也写入主存</strong> , 花费时间为 <strong>访问主存的时间</strong></li><li>写回法: 写操作时 <strong>只把数据写入Cache</strong> , 当Cache数据需要被替换出去后再写回主存, 花费时间是 <strong>访问Cache的时间</strong></li></ul><h4 id=4-5-4-Cache-主存的地址映射><a href=#4-5-4-Cache-主存的地址映射 class=headerlink title="4.5.4 Cache-主存的地址映射"></a>4.5.4 Cache-主存的地址映射</h4><p><strong>1.直接映射</strong></p><p>直接映射很容易理解, 就是一个取模操作.</p><p>我们上面提到过的变量这里列一下:</p><ul><li>m: 主存地址中存储块数的位数, 这说明主存总共有 $ M &#x3D; 2^m $ 个块</li><li>c: Cache地址中用于存储块数的位数, 这说明Cache中共有 $ C &#x3D; 2^c $ 个块</li><li>i: Cache中的块号</li><li>j: 主存中的块号</li></ul><p>我们可以得到:</p><p>$$ i &#x3D; j(mod \space C) \space 或者 i &#x3D; j(mod\space 2^c) $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png alt=直接映射></p><p>此时, CPU传来的主存地址的高m位被分成了两部分: 低c位指的就是对应Cache的字块地址, 而高(m-c)位则代表 <strong>主存字块标记</strong> , 表示当前Cache中存放的是主存的第几组数据( <strong>相当于把主存按照Cache的总字块数量再度分了个类</strong> : 0<del>[C-1], C</del>[2C-1], …, [M-C]~[M-1]). 如果读者看过上一篇博文, 或者了解过数论相关的知识, 这就是 <strong>同余类</strong> 的概念.</p><p>当CPU传过来一个对应地址时, Cache先找到对应的同余类, 而后看 <strong>主存字块标记</strong> 字段能否与对应Cache地址的 <strong>标记</strong> 字段匹配, 如果匹配则命中缓存, 直接调用Cache中的数据, 如果不匹配则仍需要进一步访问主存, 并同时替换Cache的对应字块, 并修改该块Cache的 <strong>标记</strong> .</p><p>这种映射方式容易理解, 但不够灵活.</p><hr><p><strong>2.全相联映射</strong></p><p>即Cache中每一个字块都可以与主存的任何字块建立对应关系. 这意味着 <strong>主存字块标记字段</strong> 以及 Cache对应的 <strong>标记</strong> 字段均 <strong>上升到了m位</strong> , 并且CPU每传来一个主存地址, 都需要与Cache的每个 <strong>标记</strong> 全部比较一遍, 效率无疑是比较低的.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png alt=全相联映射></p><hr><p><strong>3.组相联映射</strong></p><p>组相联映射是对上面两种方式的一种折中.</p><p>具体而言, 组相联映射对Cache也进行了分组, 将Cache分成Q组, 每组有R块.</p><p>借鉴直接映射, 我们还是有这个式子:</p><p>$$ i &#x3D; j(mod \space Q) $$</p><p>相当于将主存对应组别映射到Cache对应同余类的组别中.</p><p>我们假设Q &#x3D; 16, R &#x3D; 2, C &#x3D; Q*R &#x3D; 32;(Cache中总共32块, 2块为一组, 共16组)</p><p>则主存标号为 0, 16, 32, …, M-16 的字块对应Cache的第0组, 它们中任意一个字块都能存储到这一组2个块中的任意一个之中.</p><p>即: 主存的第j块映射到Cache的第i组内(直接映射), 同时, 又能存在第i组R个字块中的任意一个中(全相联映射).</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png alt=组相联映射></p><p>这种映射方式仍然将CPU传来的主存地址的高m位分类了, 组地址 $ q &#x3D; c-r $ 表示对应Cache的第几组, 前面 $ m-q &#x3D; m-c+r $ 位代表主存字块标记, 需要与Cache中的对应组 $ 2^r &#x3D; R $ 个标记字段相比较.</p><hr><p>上面这一段可以说是存储器中最不好理解的一段, 主要是涉及到的变量确实很多, 读者还请尽力理解.</p><p>给几个例子:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E4%BE%8B.png alt=缓存_例></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E4%BE%8B2.png alt=缓存_例></p><h2 id=Chap-7-指令系统><a href=#Chap-7-指令系统 class=headerlink title="Chap.7 指令系统"></a>Chap.7 指令系统</h2><h3 id=7-1-机器指令><a href=#7-1-机器指令 class=headerlink title="7.1 机器指令"></a>7.1 机器指令</h3><h4 id=7-1-1-指令的一般格式><a href=#7-1-1-指令的一般格式 class=headerlink title="7.1.1 指令的一般格式"></a>7.1.1 指令的一般格式</h4><p>计算机的指令一般由 <strong>操作码</strong> 和 <strong>地址码</strong> 两部分构成.</p><p>总共有三种设计方式:</p><ul><li><p>长度固定指令: 主要用于指令字长较长的情况;</p></li><li><p>长度可变指令: 操作码分散在不同字段中, 显然, 这会增加指令译码 &#x2F; 分析 &#x2F; 控制器设计的难度;</p></li><li><p>扩展操作码指令: 随着地址数减少, 操作码的位数增加, 这里通过16位字长指令来解释一下这个设计思路:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8A%80%E6%9C%AF.png alt=扩展操作码技术></p><p>可见, 每将一种三地址指令分解, 则可以分解成 $ 2^4 $ 个二地址指令, $ 2^8 $ 个一地址指令</p><p>(这里一地址, 二地址, 三地址指的是地址数目)</p></li></ul><h4 id=7-1-2-地址码的设置机制><a href=#7-1-2-地址码的设置机制 class=headerlink title="7.1.2 地址码的设置机制"></a>7.1.2 地址码的设置机制</h4><p>一条指令中的地址数量有很多种情况, 通常分为:</p><ul><li><p>四地址<br>顾名思义, 四地址中含有四个地址;<br>通常情况下, 这分别表示 <strong>第一操作数 &#x2F; 第二操作数 &#x2F; 结果存储 &#x2F; 下一条指令的地址</strong> ;<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E5%9B%9B%E5%9C%B0%E5%9D%80.png alt=四地址></p></li><li><p>三地址<br>三地址区别于四地址, 它将下一条指令的地址隐去了, 通常隐含在程序计数器PC中(程序计数器见第一章);<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%B8%89%E5%9C%B0%E5%9D%80.png alt=三地址></p></li><li><p>二地址<br>二地址进一步简化指令, 它将结果存储的位置也隐去, 这意味着它必须将结果存在:</p><ol><li>$ A_1 $ &#x2F; $ A_2 $ 中</li><li>累加器ACC中<br>前者的情况, 一条指令需要访存4次(取指令, 读两个数, 存一个数), 而如果仅存在ACC中, 则只需要访存3次(取指令, 取两个数).<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%BA%8C%E5%9C%B0%E5%9D%80.png alt=二地址></li></ol></li><li><p>一地址<br>一地址进一步简化, 直接省去了一个操作数的位置, 因为它默认另一个操作数处于累加器ACC中;<br>它会固定将结果存在ACC中;<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%B8%80%E5%9C%B0%E5%9D%80.png alt=一地址></p></li><li><p>零地址<br>零地址没有地址码, 这意味着它无法执行正常的运算操作, 一般是空操作 &#x2F; 停机 &#x2F; 返回 &#x2F; 中断返回等.</p></li></ul><blockquote><p>需要指明的是, 并不是地址数越多越好, 因为地址数越少, 它能包含的位数就越多, 这说明其寻址范围就越大.</p></blockquote><h4 id=7-1-3-指令字长的设置><a href=#7-1-3-指令字长的设置 class=headerlink title="7.1.3 指令字长的设置"></a>7.1.3 指令字长的设置</h4><p>从上面的描述应该不难看出, 指令字长取决于:</p><ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数地址的个数</li></ul><p>一般而言, 指令字长可以有两种方法来设计:</p><ol><li>指令字长固定: 即 $ 指令字长 &#x3D; 存储字长 $ ;</li><li>指令字长可变: 即 $ 指令字长按照字节的倍数来变化 $ ;</li></ol><h3 id=7-2-操作数类型及操作种类><a href=#7-2-操作数类型及操作种类 class=headerlink title="7.2 操作数类型及操作种类"></a>7.2 操作数类型及操作种类</h3><h4 id=7-2-1-操作数类型><a href=#7-2-1-操作数类型 class=headerlink title="7.2.1 操作数类型"></a>7.2.1 操作数类型</h4><p>机器中的操作类型有: 地址 &#x2F; 数字 &#x2F; 字符 &#x2F; 逻辑数等.</p><p>它们的表示方法如下:</p><ul><li>地址: 无符号整数</li><li>数字: 定点数 &#x2F; 浮点数 &#x2F; 十进制数</li><li>字符: ASCⅡ</li><li>逻辑数: 逻辑运算</li></ul><h4 id=7-2-2-存储器中的数据存放><a href=#7-2-2-存储器中的数据存放 class=headerlink title="7.2.2 存储器中的数据存放"></a>7.2.2 存储器中的数据存放</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE.png alt=存储器中的数据存放></p><h4 id=7-2-3-操作类型><a href=#7-2-3-操作类型 class=headerlink title="7.2.3 操作类型"></a>7.2.3 操作类型</h4><p>操作类型大体可分为以下四类:</p><ul><li><p>数据传送: 从 <strong>寄存器或存储器</strong> 将数据送往 <strong>存储器或寄存器</strong> 的操作;<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B_%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81.png alt=数据传送></p></li><li><p>算术逻辑操作: 在运算器ALU中进行的各类计算操作;<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B_%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91.png alt=算术逻辑></p></li><li><p>移位: 算术移位(保留符号位, 适用于有符号数), 逻辑移位(不保留符号位, 适用于无符号数), 循环移位(将移出的位数重新移入, 分带进位 &#x2F; 不带进位)等:</p><ul><li>不带进位的循环移位: 直接将移出的值原样移到另一侧即可;</li><li>带进位的循环移位: 即在原先循环移位的基础上加了一个 <strong>进位位</strong>, 当移位时, 将 <strong>进位位</strong> 的值赋给空出的位置, 并将被移出的值赋给 <strong>进位位</strong> ;</li></ul></li><li><p>转移:</p><ul><li>无条件转移: JMP</li><li>条件转移:<ul><li>结果为零转移(Z &#x3D; 1): JZ</li><li>结果溢出转移(O &#x3D; 1): JO</li><li>结果有进位转移(C &#x3D; 1): JC</li><li>跳过一条指令: SKP, 其通常格式为: SKP DZ, 表示如果完成触发器D为0, 则跳过下一条指令;</li></ul></li></ul></li><li><p>陷阱(Trap)与陷阱指令: 陷阱一般指一种意外事故导致的中断, 这种类型的指令一般不提供给用户直接使用. 而是在出现事故时, 由CPU自动产生并执行.</p></li><li><p>输入输出:</p><ul><li>输入指令: 从 <strong>端口地址</strong> -&gt; CPU的寄存器;</li><li>输出指令: 从 CPU的寄存器 -&gt; 端口地址;<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4.png alt=输入输出指令></li></ul></li></ul><h3 id=7-3-寻址方式><a href=#7-3-寻址方式 class=headerlink title="7.3 寻址方式"></a>7.3 寻址方式</h3><p>寻址方式, 指的是如何 <strong>确定本条指令操作数的存放地址, 以及确定下一条欲执行指令的存放地址</strong> ;</p><p>更简单地讲, 就是完成了这两件事:</p><ul><li>指令寻址</li><li>数据寻址</li></ul><h4 id=7-3-1-指令寻址><a href=#7-3-1-指令寻址 class=headerlink title="7.3.1 指令寻址"></a>7.3.1 指令寻址</h4><p>指令寻址涉及到的操作相对简单, 分为 <strong>顺序寻址</strong> 和 <strong>跳跃寻址</strong> 两种.</p><p>顺序寻址即 <strong>直接在程序计数器PC上加1, 得到新一条指令的地址</strong> .</p><p>跳跃寻址需要通过 <strong>转移指令</strong> 给出下一条指令的地址(转移指令的定义见上一节).</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80.png alt=指令寻址></p><h4 id=7-3-2-数据寻址><a href=#7-3-2-数据寻址 class=headerlink title="7.3.2 数据寻址"></a>7.3.2 数据寻址</h4><p>数据寻址相对于指令寻址要复杂很多, 这里我们给出两个名词:</p><ul><li>形式地址A: 即指令字中的地址;</li><li>有效地址EA: 操作数的真实地址;</li></ul><p>在数据寻址中, 一般会将一个指令字分为 <strong>操作码</strong> &#x2F; <strong>寻址特征</strong> &#x2F; <strong>形式地址A</strong> 三部分. 机器通过寻址特征来进行相关操作, 进而找到有效地址.</p><p><strong>1.立即寻址:</strong></p><p>所谓立即寻址, 即 <strong>形式地址A就是操作数</strong> , 这也被称为 <strong>立即数</strong> , 显然, 这种形式的好处在于无需访存, 但A的位数也限制了操作数的大小.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png alt=立即寻址></p><p><strong>2.直接寻址:</strong></p><p>直接寻址即 <strong>有效地址由形式地址直接给出</strong> , 显然, 这种方式需要访存一次, A的位数决定了本次指令操作数的寻址范围.</p><p>$$ EA &#x3D; A $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png alt=直接寻址></p><p><strong>3.隐含寻址:</strong></p><p>隐含寻址, 说明有某一个操作数的地址时隐含在操作码中的, <strong>其实就是上面一地址指令的思路</strong> .</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.png alt=隐含寻址></p><p>举个例子: 比如8086中的MUL指令, 其被乘数是隐含在AX寄存器或AL寄存器中的, 而这个地址不用给出, 而是通过操作码(MUL)给出的.</p><p>这种方式使得指令字中少了一个地址字段, 可以有效缩短指令字长.</p><p><strong>4.间接寻址</strong></p><p>间接寻址, 即 <strong>有效地址由形式地址间接提供</strong> , 换言之, 即需要通过形式地址对应主存块的内容多次跳转才能得到有效地址.(读者如果有过编程基础, 其实就是 <strong>指针</strong> 的思想)</p><p>$$ EA &#x3D; (A) $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png alt=间接寻址></p><p>类似的, 指针也分单层和多层, 上图右侧即通过多次反复跳转进行寻址的过程. 这种方式的好处是扩大了寻址范围, 但每一次寻址都需要耗费对应的访存时间.</p><p>间接寻址其实运用的十分广泛, 典型代表比如当用户调用子程序时, 会通过间接寻址的方式给出子程序的起始地址.</p><p><strong>5.寄存器寻址</strong></p><p>寄存器寻址, 即 <strong>有效地址是寄存器编号, 由形式地址直接给出</strong> .</p><p>$$ EA &#x3D; R_i $$</p><p>这种方式省去了访存的时间成本, 只需要访问寄存器即可, 执行较快, 并且可以有效缩短指令字长(给一个编号与给一个地址的长度必然前者更短一些), 但寄存器个数有限, 代表着这种方式也有其局限性.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png alt=寄存器寻址></p><p><strong>6.寄存器间接寻址</strong></p><p>与第四种间接寻址的想法十分类似, 只不过这次有效地址存在寄存器中, 形式地址仍然只给出寄存器编号.</p><p>$$ EA &#x3D; (R_i) $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png alt=寄存器间接寻址></p><p>这种方式相比于间接寻址能够减少一次访存时间开销(因为第一次只需要访问寄存器即可).</p><p><strong>7.基址寻址</strong></p><p>基址寻址通过一个寄存器作为 <strong>基址寄存器(BR)</strong> , 其有效地址表示为:</p><p>$$ EA &#x3D; (BR) + A $$</p><p>通常, 在程序执行的过程中, BR内的内容是不变的, 这个值由操作系统或管理程序决定. 这种方式可以一定程度上扩大寻址范围, 有利于多道程序的运行.</p><p>相应的, 作为基址寄存器的寄存器也分两类:</p><ul><li>采用专用寄存器作为基址寄存器</li><li>采用通用寄存器作为基址寄存器(此时, 哪个通用寄存器作为基址寄存器由用户指定)</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%281%29.png alt=采用专用寄存器的基址寻址></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%282%29.png alt=采用通用寄存器的基址寻址></p><p><strong>8.变址寻址</strong></p><p>变址寻址的思路与基址寻址的思路恰好反过来, 有这么一个变址寄存器IX(可专用可通用), 在程序执行的过程中, IX的内容由用户给定, 并且 <strong>可以变化</strong> , 而对应的, 形式地址A不再变化.</p><p>$$ EA &#x3D; (IX) + A $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png alt=变址寻址></p><p>这种方式同样可以扩大寻址范围, 同时非常适合 <strong>处理数组问题</strong> .</p><p><strong>9.相对寻址</strong></p><p>相对寻址更特殊一点, 通过给出 <strong>操作数与当前指令的地址差值</strong> 来寻找操作数.</p><p>$$ EA &#x3D; (PC) + A $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png alt=相对寻址></p><p>这种方式对于书写程序浮动的情况相当有利, 也广泛被用于转移指令中.</p><p><strong>10.堆栈寻址</strong></p><p>堆栈寻址使用了 <strong>数据结构中的栈结构</strong> , 其通过先进后出的思路来设计寻址.</p><p>其通过一个变量 SP 来维护栈顶地址, 每当入栈一个指令后, 栈顶-1; 对应的, 每出栈一条指令, 则栈顶+1(注: 这是通过字编址的情况, 如果通过字节编址则需要加减相应指令以字节计数的长度);</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80.png alt=堆栈寻址></p><h3 id=7-4-指令格式><a href=#7-4-指令格式 class=headerlink title="7.4 指令格式"></a>7.4 指令格式</h3><p>这一节主要讲述设计指令时需要考虑的各类因素, 但它对考试不是很重要, 这里不在枚举了, 仅引出一个概念:</p><p>平均码长:</p><p>$$ \sum_{i} F_i * B_i $$</p><p>其中:</p><ul><li>$ i $ : 表示指令</li><li>$ F_i $ : 表示指令的频率</li><li>$ B_i $ : 表示编码该条指令所用的位数</li></ul><p>给个例子:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B3%E5%9D%87%E7%A0%81%E9%95%BF_%E4%BE%8B.png alt=平均码长_例></p><blockquote><p>本题中, 编码方式涉及到了一些霍夫曼树的知识, 简单来说, 频率越高的指令, 码长应当越短;</p></blockquote><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B3%E5%9D%87%E7%A0%81%E9%95%BF_%E4%BE%8B_%E8%A7%A3.png alt=平均码长_例_解></p><blockquote><p>本章中, 涉及到了RISC与CISC的对比, 在博文中不在列举, 请见PPT</p></blockquote><h2 id=Chap-8-CPU的结构与功能><a href=#Chap-8-CPU的结构与功能 class=headerlink title="Chap.8 CPU的结构与功能"></a>Chap.8 CPU的结构与功能</h2><h3 id=8-1-CPU的结构><a href=#8-1-CPU的结构 class=headerlink title="8.1 CPU的结构"></a>8.1 CPU的结构</h3><h4 id=8-1-1-CPU的功能><a href=#8-1-1-CPU的功能 class=headerlink title="8.1.1 CPU的功能"></a>8.1.1 CPU的功能</h4><p>在第一章中, 提及过CPU的两个重要组成部分: <strong>控制器(CU)</strong> 与 <strong>运算器(ALU)</strong> ;</p><ul><li>控制器<ul><li>取指令</li><li>分析指令</li><li>执行指令 &#x2F; 发出各种操作命令</li><li>控制程序输入 &#x2F; 结果输出</li><li>总线管理</li><li>处理异常 &#x2F; 特殊请求</li></ul></li><li>运算器<ul><li>实现算术运算 &#x2F; 逻辑运算</li></ul></li></ul><blockquote><p>总而言之, CPU实现的功能分五大类: 指令控制(PC, IR) &#x2F; 操作控制(CU, 时序电路) &#x2F; 时间控制(CU, 时序电路) &#x2F; 数据加工(ALU, 寄存器) &#x2F; 处理中断(中断系统)</p></blockquote><h4 id=8-1-2-CPU的结构框图><a href=#8-1-2-CPU的结构框图 class=headerlink title="8.1.2 CPU的结构框图"></a>8.1.2 CPU的结构框图</h4><p>结构框图</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png alt=CPU的结构框图></p><hr><p>内部结构</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/CPU%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png alt=CPU的内部结构></p><hr><p>关于CPU的寄存器:</p><ul><li>通用寄存器: 存放操作数</li><li>数据寄存器: 存放操作数</li><li>地址寄存器: 存放地址</li><li>条件码寄存器: 存放条件码(一般是程序分支的依据)</li></ul><p>通常的工作顺序:</p><p>$$ PC \to MAR \to M \to MDR \to IR $$</p><h3 id=8-2-指令周期><a href=#8-2-指令周期 class=headerlink title="8.2 指令周期"></a>8.2 指令周期</h3><h4 id=8-2-1-指令周期的概念><a href=#8-2-1-指令周期的概念 class=headerlink title="8.2.1 指令周期的概念"></a>8.2.1 指令周期的概念</h4><p>指令周期, 指 <strong>取出并完成一条指令所需的全部时间</strong> .</p><p>其基本组成过程分为:</p><ul><li>取指周期: 取指令</li><li>(间指周期): 取有效地址</li><li>执行周期: 取操作数</li><li>(中断周期): 保存程序断点</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.png alt=指令周期流程></p><h4 id=8-2-2-指令周期的数据流><a href=#8-2-2-指令周期的数据流 class=headerlink title="8.2.2 指令周期的数据流"></a>8.2.2 指令周期的数据流</h4><p><strong>1.取指周期数据流</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png alt=数据流_取指周期></p><ul><li>PC存放现行指令的地址, 该地址被送到MAR, 并随后被送至地址总线</li><li>CU向存储器发读命令</li><li>对应MAR指向单元的内容经过数据总线送到MDR, 再送至IR</li><li>CU控制PC+1</li></ul><p><strong>2.间指周期数据流</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E9%97%B4%E6%8C%87%E5%91%A8%E6%9C%9F.png alt=数据流_间指周期></p><ul><li>CU检查IR中的内容, 确定本条指令是否有间指操作</li><li>如果有间指操作, 则MDR中的右侧N位(被称作 <strong>Ad(MDR)</strong> )会被送到MAR, 并被进一步送至地址总线</li><li>CU向存储器发读命令</li><li>获取有效地址, 存入MDR</li></ul><p><strong>3.执行周期数据流</strong></p><p>不同指令的执行周期数据流往往差别较大, 因此这里无法利用框图表示.</p><p><strong>4.中断周期数据流</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png alt=数据流_中断周期></p><ul><li>CU将用于保存程序断点的存储器特殊地址(典型案例, 比如此前在堆栈寻址中讲到的SP, 即指向栈顶的指针)送往MAR, 进一步送往地址总线</li><li>CU向存储器发写命令</li><li>将PC中的内容(程序断点)送到MDR, 并经过数据总线写入存储器</li><li>CU将中断程序的入口地址送至PC, 为下一个取指周期做好准备</li></ul><h3 id=8-3-指令流水><a href=#8-3-指令流水 class=headerlink title="8.3 指令流水"></a>8.3 指令流水</h3><h4 id=8-3-1-系统并行性><a href=#8-3-1-系统并行性 class=headerlink title="8.3.1 系统并行性"></a>8.3.1 系统并行性</h4><p>所谓指令流水, 是提高 <strong>系统并行性</strong> 的一种称呼, 即希望两个或两个以上事件在同一时间段发生.</p><p>并行性分等级:</p><ul><li>过程级: 指作业, 进程之间的并行, 这可以通过软件实现</li><li>指令级: 指不同指令之间, 或指令内部的操作之间的并行, 这需要通过硬件实现</li></ul><h4 id=8-3-2-指令流水的具体设计><a href=#8-3-2-指令流水的具体设计 class=headerlink title="8.3.2 指令流水的具体设计"></a>8.3.2 指令流水的具体设计</h4><p><strong>最简单的方式: 串行执行</strong></p><p>串行指令是我们最容易想到的, 它的工作方式就是一条条指令进行下去, 没有任何并行性, 效率也自然很低.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E4%B8%B2%E8%A1%8C.png alt=指令流水_串行></p><p><strong>进一步设计: 二级流水</strong></p><p>第二种想法是将取指令和执行指令分开:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E4%BA%8C%E7%BA%A7%E5%B9%B6%E8%A1%8C.png alt=指令流水_二级并行></p><p>这种方式也被称为 <strong>指令预取</strong> , 如果取指阶段和执行阶段在时间上完全重叠, 那么理论上指令周期可以减半, 速度可以提高一倍.</p><p>但很遗憾, 指令的执行时间一般大于取指时间, 因此二者速度其实并不十分匹配; 另外, 遇到一些条件转移指令时, 往往下一步是不可知的, 必须等待上一条指令执行阶段结束, 判断出条件真伪后才能进行下一阶段的取指.</p><p><strong>再度分级: 六级流水</strong></p><p>为了解决二级流水遇到的以上问题, 我们将指令的处理过程继续细化分解:</p><ul><li>FI(Fetch Instruction): 取指</li><li>DI(Decode Instruction): 指令译码</li><li>CO(Calculate operand address): 计算操作数地址</li><li>FO(Fetch operand): 取操作数</li><li>EI(Execute instruction): 执行指令</li><li>WO(Write back operand): 写操作数</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E5%85%AD%E7%BA%A7%E5%B9%B6%E8%A1%8C.png alt=指令流水_六级并行></p><p>我们考虑一个含有六条指令的程序, 如果串行执行: 需要6*9 &#x3D; 54个时间单位, 而通过上述流水线的思路, 则只需要14个时间单位!</p><h4 id=8-3-3-流水线性能评估><a href=#8-3-3-流水线性能评估 class=headerlink title="8.3.3 流水线性能评估"></a>8.3.3 流水线性能评估</h4><p><strong>1.吞吐率</strong></p><p>即 <strong>单位时间内流水线所完成指令的数量</strong></p><p>设 m 段的流水线隔段时间为 $ \Delta t $</p><p>(1) 最大吞吐率</p><p>$$ T_{pmax} &#x3D; \frac{1}{\Delta t} $$</p><p>(2) 实际吞吐率: 连续处理n条指令的吞吐率</p><p>$$ T_p &#x3D; \frac{n}{m * \Delta t + (n-1) * \Delta t} $$</p><p><strong>2.加速比</strong></p><p>设流水线各段时间为 $ \Delta T $ , 每条指令共 m 段;</p><p>加速比即 <strong>非流水线的速度与 m 段的流水线的速度之比</strong></p><p>则:</p><p>$$ S_p &#x3D; \frac{n * m * \Delta t}{m * \Delta t + (n-1) * \Delta t} &#x3D; \frac{n * m}{m+n-1} $$</p><p><strong>3.效率</strong></p><p>流水线自身的效率, 即 <strong>流水线中各功能段的利用率</strong></p><p>$$ 效率 &#x3D; \frac{m * n * \Delta t}{m * (m+n-1) * \Delta t} &#x3D; \frac{n}{m+n-1} $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%88%E7%8E%87%E8%AF%B4%E6%98%8E.png alt=流水线效率说明></p><h3 id=8-4-中断系统><a href=#8-4-中断系统 class=headerlink title="8.4 中断系统"></a>8.4 中断系统</h3><p>本节本来放到了 I&#x2F;O 设备后讲述, 在本文中为了整体性将其与第八章其余内容放在一块, 读者也可以先不看这一节</p><h4 id=8-4-1-概述><a href=#8-4-1-概述 class=headerlink title="8.4.1 概述"></a>8.4.1 概述</h4><p>引发中断的因素有很多:</p><ul><li>人为设置的中断(转管指令)</li><li>程序性事故(移出, 操作码不能识别, 除法非法)</li><li>硬件故障</li><li>I&#x2F;O 设备</li><li>外部事件(用键盘中断现行程序)</li></ul><p>每个可能出现中断的请求源, 都有一个 <strong>INTR(中断请求标记触发器)</strong> , 其分散在多个中断源的接口电路中, 也集中在CPU的中断系统内</p><h4 id=8-4-2-中断判优逻辑><a href=#8-4-2-中断判优逻辑 class=headerlink title="8.4.2 中断判优逻辑"></a>8.4.2 中断判优逻辑</h4><p>1.分散在各个中断源的接口电路中, 比如 I&#x2F;O 设备的链式排队器(见第五章 5.5)</p><p>2.集中在CPU内:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9B%86%E4%B8%AD%E5%9C%A8CPU%E5%86%85%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F%E7%94%B5%E8%B7%AF.png alt=集中在CPU内的中断排队电路></p><p>3.通过软件轮流查询:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%80%9A%E8%BF%87%E8%BD%AF%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BD%AE%E6%B5%81%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F.png alt=通过软件逻辑轮流查询的中断排队></p><h4 id=8-4-3-中断服务程序入口地址的寻找><a href=#8-4-3-中断服务程序入口地址的寻找 class=headerlink title="8.4.3 中断服务程序入口地址的寻找"></a>8.4.3 中断服务程序入口地址的寻找</h4><ul><li>通过硬件直接形成中断向量寻找(见5.4)</li><li>通过软件查询</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80_%E8%BD%AF%E4%BB%B6%E6%9F%A5%E8%AF%A2.png alt=中断服务程序入口地址_软件查询></p><h4 id=8-4-4-中断响应的条件与时间><a href=#8-4-4-中断响应的条件与时间 class=headerlink title="8.4.4 中断响应的条件与时间"></a>8.4.4 中断响应的条件与时间</h4><p>见5.5</p><h4 id=8-4-5-多重中断><a href=#8-4-5-多重中断 class=headerlink title="8.4.5 多重中断"></a>8.4.5 多重中断</h4><p>即优先级别高的中断源有权中断优先级别低的中断源</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD.png alt=多重中断></p><p>需要说明的是, 保护多重中断中, 因为 <strong>存在多次保护现场操作</strong> , 因此保护现场的暂存地址不可能永远是那个特殊的0地址了, 每次新中断时, 要将 <strong>原先0地址内的内容转存</strong> .</p><h4 id=8-4-6-屏蔽技术><a href=#8-4-6-屏蔽技术 class=headerlink title="8.4.6 屏蔽技术"></a>8.4.6 屏蔽技术</h4><p>重点理解 <strong>屏蔽字与优先等级的改变</strong> , 具体而言, <strong>屏蔽字为1</strong> 代表 <strong>对应中断源的中断请求会被本中断请求屏蔽掉</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B1%8F%E8%94%BD%E5%AD%97%26%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%AD%89%E7%BA%A7.png alt=屏蔽字&amp;中断优先等级></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%96%B0%E5%B1%8F%E8%94%BD%E5%AD%97%E7%9A%84%E5%A4%84%E7%90%86%E9%A1%BA%E5%BA%8F.png alt=新屏蔽字的处理顺序></p><p>如上图所示, 响应优先级是不能被更改的, 因此A处理完后, 还是会优先响应B, 但是 <strong>C的处理优先级更高, 所以C可以打断B的响应</strong> , 同理, D打断C的响应, 并最先处理完, 随后C处理完, B处理完.</p><h2 id=Chap-9-控制单元的功能><a href=#Chap-9-控制单元的功能 class=headerlink title="Chap.9 控制单元的功能"></a>Chap.9 控制单元的功能</h2><h3 id=9-1-操作命令的分析><a href=#9-1-操作命令的分析 class=headerlink title="9.1 操作命令的分析"></a>9.1 操作命令的分析</h3><p>回忆第八章的内容, 指令的执行过程分四个周期, 在这里将每个周期实现的操作再度利用比较标准的语言描述一下:</p><p><strong>1.取指周期</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png alt=数据流_取指周期></p><ul><li>$ PC \to MAR \to 地址线 $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to IR $</li><li>$ OP(IR) \to CU $</li><li>$ (PC) + 1 \to PC $</li></ul><p><strong>2.间指周期</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E9%97%B4%E6%8C%87%E5%91%A8%E6%9C%9F.png alt=数据流_间指周期></p><ul><li>$ 指令形式地址 \to MAR $ 即 $ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to Ad(IR) $</li></ul><p><strong>3.执行周期</strong></p><p>(1)非访存指令:</p><ul><li>CLA(将ACC清零): $ 0 \to ACC $</li><li>COM(ACC取反): $ \overline{ACC} \to ACC $</li><li>SHR(算术右移): $ L(ACC) \to R(ACC), ACC_0 \to ACC_0 $ (后面一步代表符号位不变)</li><li>CSL(循环左移): $ R(ACC) \to L(ACC), ACC_0 \to ACC_n $</li><li>STP(停机): $ 0 \to G $</li></ul><p>(2)访存指令:</p><ul><li>加法指令: $ ADD \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ (ACC) + (MDR) \to ACC $</li></ul></li><li>存数指令: $ STA \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to W $</li><li>$ ACC \to MDR $</li><li>$ MDR \to M(MAR) $</li></ul></li><li>取数指令: $ LDA \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to ACC $</li></ul></li></ul><p>(3)转移指令(不访存)</p><ul><li>无条件转: $ JMP \space X $<ul><li>$ Ad(IR) \to PC $</li></ul></li><li>条件转移: $ BAN \space X $ , 这里假设 $ A_7 &#x3D; 1 $ 为满足条件<ul><li>$ A_7 * Ad(IR) + \overline{A_7} * (PC) \to PC $</li></ul></li></ul><p>上述指令的执行周期总结如下:<br><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E7%B1%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png alt=三类指令的指令周期></p><p><strong>4.中断周期</strong></p><p>中断分两种:</p><ul><li>关中断</li><li>程序中途中断</li></ul><p>二者区别只在需要执行的第一个操作</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png alt=数据流_中断周期></p><ul><li>保存程序断点:<ul><li>关中断: $ 0 \to MAR $ , 即断点存入0地址</li><li>程序中途中断: $ (SP)-1 \to SP \to MAR $ , 即断点进栈</li></ul></li><li>$ 1 \to W $</li><li>$ PC \to MDR $</li><li>$ MDR \to M(MAR) $</li><li>$ 中断程序入口地址M \to PC $</li><li>$ 0 \to EINT $</li></ul><h3 id=9-2-控制单元的功能><a href=#9-2-控制单元的功能 class=headerlink title="9.2 控制单元的功能"></a>9.2 控制单元的功能</h3><h4 id=9-2-1-控制单元的外特性><a href=#9-2-1-控制单元的外特性 class=headerlink title="9.2.1 控制单元的外特性"></a>9.2.1 控制单元的外特性</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83_%E5%A4%96%E7%89%B9%E6%80%A7.png alt=控制单元_外特性></p><p>从图中, 我们整理一下控制单元的输入 &#x2F; 输出信号来源:</p><ul><li>输入信号<ul><li>时钟: CU受到时钟控制</li><li>指令寄存器 ( $ OP(IR) \to CU $ ), 与操作码相关</li><li>标志: CU收到各类标志寄存器的控制</li><li>外来信号: 如INTR(中断请求) &#x2F; HRQ(总线请求)</li></ul></li><li>输出信号<ul><li>CPU内的各种控制信号<ul><li>来自寄存器的</li><li>来自PC的</li><li>来自ALU的</li></ul></li><li>送到控制总线的信号<ul><li>$ \overline{MREQ} $ , 访存控制信号</li><li>$ \overline{IO} &#x2F; M $ , 访问IO &#x2F; 存储器的控制信号</li><li>$ \overline{RD} $ , 读命令</li><li>$ \overline{WR} $ , 写命令</li><li>$ INTA $ , 中断响应信号</li><li>$ HLDA $ , 总线响应信号</li></ul></li></ul></li></ul><h4 id=9-2-2-控制信号举例><a href=#9-2-2-控制信号举例 class=headerlink title="9.2.2 控制信号举例"></a>9.2.2 控制信号举例</h4><p>详见书 $ P_{380} $</p><p>这里仅对是否使用CPU内部总线进行说明, CPU内部总线是一根将所有器件串连起来的总线, 相当于所有的信号都可以通过内部总线传递给其他部件.</p><h4 id=9-2-3-多级时序系统><a href=#9-2-3-多级时序系统 class=headerlink title="9.2.3 多级时序系统"></a>9.2.3 多级时序系统</h4><p><strong>1.机器周期</strong></p><p>机器周期是 <strong>所有指令执行过程中的一个基准时间</strong> ;</p><p>这个基准时间的确定需要考虑:</p><ul><li>完成最复杂的指令功能的时间</li><li>访问一次存储器的时间</li></ul><p>通常, 访存时间比CPU中的处理要长很多, 因此在 <strong>指令字长 &#x3D; 存储字长</strong> 的前提下, <strong>取指周期 &#x3D; 机器周期</strong></p><hr><p><strong>2.时钟周期</strong></p><p>一个机器周期内可以完成若干个微操作, 因此将 <strong>机器周期进一步细分为若干个时间相等的时钟周期</strong></p><p>时钟周期是 <strong>计算机操作的最小单位时间</strong> , 可以利用它产生一个或几个微操作命令</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%20%26%20%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png alt=机器周期&amp;时钟周期></p><hr><p><strong>3.多级时序系统</strong></p><p>一个指令周期包含多个机器周期, 一个机器周期包含多个时钟周期.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%A4%9A%E7%BA%A7%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F.png alt=多级时序系统></p><hr><p><strong>4.机器主频</strong></p><p>机器主频越快:</p><ul><li>机器速度越快</li><li>一个机器周期中包含的时钟周期数越多</li><li>一个指令周期中包含的机器周期数越多</li></ul><h4 id=9-2-4-控制方式><a href=#9-2-4-控制方式 class=headerlink title="9.2.4 控制方式"></a>9.2.4 控制方式</h4><p>1.同步控制方式</p><ul><li>采用定长的机器周期: 即以最长的微操作序列以及最繁的微操作作为标准, <strong>每个机器周期内节拍数目相同</strong></li><li>采用不定长的机器周期: 每个机器周期内节拍数不等</li><li>中央控制+局部控制: 将大部分指令安排在统一 &#x2F; 较短的机器周期内完成, 对于少数较复杂的指令, 采用局部控制方法完成</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E5%A4%AE%E6%8E%A7%E5%88%B6%2B%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6.png alt=中央控制+局部控制></p><p>2.异步控制方式</p><ul><li>无基准时标信号</li><li>无固定应答节拍和严格的时钟同步</li><li>采用应答方式</li></ul><p>3.联合控制方式</p><ul><li>同步+异步</li></ul><p>4.人工控制方式</p><ul><li>Reset</li><li>连续+单条指令执行转换开关</li><li>符合停机开关</li></ul><h2 id=Chap-10-控制单元的设计><a href=#Chap-10-控制单元的设计 class=headerlink title="Chap.10 控制单元的设计"></a>Chap.10 控制单元的设计</h2><h3 id=10-1-微程序设计><a href=#10-1-微程序设计 class=headerlink title="10.1 微程序设计"></a>10.1 微程序设计</h3><h4 id=10-1-1-微程序设计思想><a href=#10-1-1-微程序设计思想 class=headerlink title="10.1.1 微程序设计思想"></a>10.1.1 微程序设计思想</h4><p>将一条机器指令进一步细分, 一条机器指令对应一个 <strong>微程序</strong> , 一个微程序对应很多条 <strong>微指令</strong> .</p><p>如果预先将一些操作可预测的微程序写进ROM中, 则可以大大提高执行速度.</p><h4 id=10-1-2-微程序控制单元工作原理><a href=#10-1-2-微程序控制单元工作原理 class=headerlink title="10.1.2 微程序控制单元工作原理"></a>10.1.2 微程序控制单元工作原理</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83.png alt=微程序控制单元></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A1%86%E5%9B%BE.png alt=微程序控制单元框图></p><p>这其中:</p><ul><li>控制存储器(控存): 是核心部件, 负责存放全部微程序</li><li>CMAR(控存地址寄存器): 存放欲读出的微指令地址</li><li>CMDR(控存数据寄存器): 存放从控存读出的微指令</li><li>顺序逻辑: 用于控制微指令序列</li></ul><p>微指令的基本格式中:</p><ul><li>操作控制字段负责发出控制信号</li><li>顺序控制字段负责指出下一条微指令的地址(简称 <strong>下地址</strong> )</li></ul><p>给出工作方式:</p><ul><li>取指阶段<ul><li>取指周期微程序首地址 $ M \to CMAR $</li><li>将对应控存中的第一条微指令读到控存数据寄存器 $ CM(CMAR) \to CMDR $</li><li>根据微指令的操作控制字段发出控制信号, 如 $ PC \to MAR, 1 \to R $ 等诸如此类</li><li>根据微指令的顺序控制字段找到下一条微指令, 即 $ Ad(CMDR) \to CMAR $</li><li>回到第二步, 循环进行, 直到相应指令已经存入IR中为止</li></ul></li><li>执行阶段<ul><li>将操作码送至微地址形成部件, 其输出即第一条微指令的地址, $ OP(IR) \to 微地址形成部件 \to CMAR $</li><li>$ CM(CMAR) \to CMDR $</li><li>发出控制信号, $ Ad(CMDR) \to CMAR $ …</li><li>直至指令执行结束为止</li></ul></li></ul><p><strong>微指令有两个很重要的问题:</strong></p><ul><li>操作控制字段如何形成微操作命令</li><li>后续地址如何形成</li></ul><h4 id=10-1-3-微指令的编码方式-控制方式><a href=#10-1-3-微指令的编码方式-控制方式 class=headerlink title="10.1.3 微指令的编码方式(控制方式)"></a>10.1.3 微指令的编码方式(控制方式)</h4><p>即 <strong>微指令的操作控制字段如何产生应当产生的控制信号</strong> , 解决第一个问题.</p><p>1.直接编码(直接控制方式)</p><p>这种方式代表 在操作控制字段中 <strong>每一位代表一个微操作命令</strong> , 该位为1则代表该控制信号有效;</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81_%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6.png alt=微指令编码_直接控制></p><p>2.字段直接编码方式</p><p>这种方式将控制字段中的位分成了若干段, 每一段经过单独译码后发出控制信号, <strong>每段中的命令是互斥的</strong></p><p>其缩短了微指令字长, 但增加了译码时间</p><blockquote><p>为什么缩短了控制时间? 假设有7个互斥微操作, 第一种方法需要7位, 第二种方法只需要3位, 因为 $ 2^3 &#x3D; 8&gt;7 $</p></blockquote><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%8E%A7%E5%88%B6_%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81.png alt=微指令控制_字段直接编码></p><p>3.字段间接编码方式</p><p>这种方式代表 <strong>一个字段的某些微操作还需要另一个字段中的某些微命令来解释</strong> , 可以进一步缩短微指令字长, 但削弱了微指令的并行控制能力.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%8E%A7%E5%88%B6_%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81.png alt=微指令控制_字段间接编码></p><h4 id=10-1-4-微指令序列地址的形成><a href=#10-1-4-微指令序列地址的形成 class=headerlink title="10.1.4 微指令序列地址的形成"></a>10.1.4 微指令序列地址的形成</h4><p>通常有四种形成方式:</p><ul><li>下地址字段指出</li><li>根据机器指令的操作码形成</li><li>增量计数器, 即 $ (CMAR) + 1 \to CMAR $</li><li>分支转移:</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E4%B8%8B%E5%9C%B0%E5%9D%80_%E5%88%86%E6%94%AF%E8%BD%AC%E7%A7%BB.png alt=微指令下地址_分支转移></p><ul><li>测试网络:</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E4%B8%8B%E5%9C%B0%E5%9D%80_%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C.png alt=微指令下地址_测试网络></p><ul><li>直接由硬件产生: 通常常见于 <strong>第一条微指令地址的产生</strong> 以及 <strong>中断周期的中断周期微程序</strong></li></ul><h4 id=10-1-5-一些杂项><a href=#10-1-5-一些杂项 class=headerlink title="10.1.5 一些杂项"></a>10.1.5 一些杂项</h4><ul><li>水平型微指令: 一次能定义并执行多个并行操作</li><li>垂直型微指令: 类似机器指令操作码, 根据操作码字段规定微指令的功能</li></ul><p>相比而言, 水平型微指令 <strong>并行操作能力强, 灵活性强</strong>, 执行一条机器指令需要的水平型微指令 <strong>数目更少, 速度更快</strong> , 其用较短的微程序结构换取了较长的微指令结构.</p><hr><ul><li>静态微程序: 采用ROM, 微程序不需要改变</li><li>动态微程序: 采用EPROM, 可以通过改变微指令和微程序来改变机器指令</li></ul><hr><p>毫微程序设计</p><p>相当于对微指令进行了进一步细分, 好比微指令相对于机器指令</p><hr><p>串行微程序与并行微程序</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%B2%E8%A1%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F%26%E5%B9%B6%E8%A1%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F.png alt=串行微程序&amp;并行微程序></p><h3 id=10-2-微程序设计举例><a href=#10-2-微程序设计举例 class=headerlink title="10.2 微程序设计举例"></a>10.2 微程序设计举例</h3><p>所有微指令的涉及到的微命令都在9.1节中有所提及, 这里相当于将其整合, 根据每一条指令需要做的事情列出一个表.</p><p>具体表格见书 $ P_{419} $ , 这里强调几点:</p><ul><li>书中所有的0均省去了</li><li>书中的微指令地址是八进制, 这意味着后续顺序控制字段三位代表八进制一位字符</li></ul><h3 id=10-3-组合逻辑设计><a href=#10-3-组合逻辑设计 class=headerlink title="10.3 组合逻辑设计"></a>10.3 组合逻辑设计</h3><h4 id=10-3-1-组合逻辑控制单元框图><a href=#10-3-1-组合逻辑控制单元框图 class=headerlink title="10.3.1 组合逻辑控制单元框图"></a>10.3.1 组合逻辑控制单元框图</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A1%86%E5%9B%BE.png alt=组合逻辑控制单元框图></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%20%26%20%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png alt=节拍安排></p><h4 id=10-3-2-微操作的节拍安排><a href=#10-3-2-微操作的节拍安排 class=headerlink title="10.3.2 微操作的节拍安排"></a>10.3.2 微操作的节拍安排</h4><p>采用 <strong>同步控制方式</strong></p><p>一个机器周期内有 <strong>3个节拍(即3个时钟周期)</strong></p><p>安排微操作时序的原则如下:</p><ul><li>微操作的先后顺序不得随意更改</li><li>被控对象不同的微操作尽量安排在一个节拍内完成</li><li>占用时间较短的微操作尽量安排在一个节拍内完成, 并允许有先后顺序</li></ul><p>具体各个周期以及执行周期各个命令的节拍安排, 见书 $ P_{396} $ ~ $ P_{398} $</p><p>各个指令在 取指 &#x2F; 间指 &#x2F; 执行阶段的不同节拍内分别干了啥, 请见书 $ P_{402} $</p><h4 id=10-3-3-组合逻辑设计步骤><a href=#10-3-3-组合逻辑设计步骤 class=headerlink title="10.3.3 组合逻辑设计步骤"></a>10.3.3 组合逻辑设计步骤</h4><p>1.给出操作时间表(类似书 $ P_{402} $ )</p><p>2.写出微操作命令的最简表达式:</p><p>举例而言, 对于 $ M(MAR) \to MDR $ 这条微操作, 可以写出这样的表达式:</p><p>$$ M(MAR) \to MDR &#x3D; \\<br>FE * T_1 + IND * T_1(ADD+STA+LDA+JMP+BAN) \\<br>T_1 \lbrace FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA) \rbrace $$</p><p>3.画出逻辑图</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/M%28MAR%29%20to%20MDR%E9%80%BB%E8%BE%91%E5%9B%BE.png alt=" $ M(MAR) \to MDR $ "></p><h2 id=Chap-5-输入输出系统><a href=#Chap-5-输入输出系统 class=headerlink title="Chap.5 输入输出系统"></a>Chap.5 输入输出系统</h2><h3 id=5-1-概述><a href=#5-1-概述 class=headerlink title="5.1 概述"></a>5.1 概述</h3><h4 id=5-1-1-输入输出系统概况><a href=#5-1-1-输入输出系统概况 class=headerlink title="5.1.1 输入输出系统概况"></a>5.1.1 输入输出系统概况</h4><ul><li>早期输入输出系统<ul><li>分散连接方式</li><li>CPU 与 I&#x2F;O 设备串行工作, 采用程序查询方式</li></ul></li><li>接口模块 &#x2F; DMA阶段<ul><li>总线连接方式</li><li>CPU 与 I&#x2F;O 设备并行工作, 采用中断方式 &#x2F; DMA 方式</li></ul></li><li>具有通道结构的阶段</li><li>具有 I&#x2F;O 处理机的阶段</li></ul><h4 id=5-1-2-输入输出系统组成><a href=#5-1-2-输入输出系统组成 class=headerlink title="5.1.2 输入输出系统组成"></a>5.1.2 输入输出系统组成</h4><ul><li>I&#x2F;O 软件<ul><li>I&#x2F;O 指令, 是CPU指令的一部分</li><li>通道指令, 指通道自身的指令</li></ul></li><li>I&#x2F;O 硬件<ul><li>设备 &amp; I&#x2F;O接口</li><li>设备 &#x2F; 设备控制器 &#x2F; 通道</li></ul></li></ul><h4 id=5-1-3-I-O-设备与主机的联系方式><a href=#5-1-3-I-O-设备与主机的联系方式 class=headerlink title="5.1.3 I&#x2F;O 设备与主机的联系方式"></a>5.1.3 I&#x2F;O 设备与主机的联系方式</h4><ul><li>I&#x2F;O 设备编址方式<ul><li>统一编址: 使用取数 &#x2F; 存数指令即可</li><li>不统一编址: 需要使用专门的 I&#x2F;O 指令</li></ul></li><li>设备选址<ul><li>用设备选择电路识别是否被选中</li></ul></li><li>传送方式<ul><li>串行传送</li><li>并行传送</li></ul></li><li>联络方式<ul><li>立即响应</li><li>异步工作, 采用应答信号(常用于IO设备与主机工作速度不匹配时)</li><li>同步工作, 采用同步时标( <strong>要求 I&#x2F;O 设备与CPU工作速度完全同步</strong> )</li></ul></li><li>连接方式<ul><li>辐射式: 每台设备有一套专门的控制线路和信号线</li><li>总线连接: 通过总线连接所有的 I&#x2F;O 设备( <strong>便于增删设备</strong> )</li></ul></li></ul><h4 id=5-1-4-I-O-设备与主机信息传送的控制方式><a href=#5-1-4-I-O-设备与主机信息传送的控制方式 class=headerlink title="5.1.4 I&#x2F;O 设备与主机信息传送的控制方式"></a>5.1.4 I&#x2F;O 设备与主机信息传送的控制方式</h4><ul><li>程序查询方式: CPU 和 IO 串行工作, 踏步等待;</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png alt=程序查询方式></p><ul><li>程序中断方式: CPU不查询, I&#x2F;O 设备准备好后向 CPU 发送中断请求, CPU 暂停当前程序, 进入中断服务程序;</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png alt=程序中断方式></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F_%E6%B5%81%E7%A8%8B%E5%9B%BE.png alt=程序中断方式_流程图></p><ul><li>DMA方式: 通过周期挪用(周期窃取)使得 CPU 和 I&#x2F;O 设备并行工作;</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E6%96%B9%E5%BC%8F.png alt=DMA方式></p><h3 id=5-2-I-O-设备><a href=#5-2-I-O-设备 class=headerlink title="5.2 I&#x2F;O 设备"></a>5.2 I&#x2F;O 设备</h3><p>外部设备大致分为三类</p><ul><li>人机交互设备: 键盘 &#x2F; 鼠标 &#x2F; 打印机 &#x2F; 显示器</li><li>计算机信息存储设备: 磁盘 &#x2F; 光盘 &#x2F; 磁带</li><li>机-机通信设备: 调制解调器</li></ul><p>不是计组的主要讲述内容, 这里不进行详细阐述</p><h3 id=5-3-I-O-接口><a href=#5-3-I-O-接口 class=headerlink title="5.3 I&#x2F;O 接口"></a>5.3 I&#x2F;O 接口</h3><p>所谓 IO 接口, 指的是主机与 IO 设备之间设置一个硬件电路以及其相应的软件控制.</p><p>设置接口的目的主要是</p><ul><li>实现设备选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串-并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反应设备状态</li></ul><h4 id=5-3-1-接口的功能和组成><a href=#5-3-1-接口的功能和组成 class=headerlink title="5.3.1 接口的功能和组成"></a>5.3.1 接口的功能和组成</h4><p>1.总线连接方式</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/IO%E6%8E%A5%E5%8F%A3_%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.png alt=IO接口_总线连接方式></p><p>其组成主要为:</p><ul><li>设备选择电路</li><li>命令寄存器 &#x2F; 命令译码器<ul><li>完成触发器 D</li><li>工作触发器 B</li><li>中断请求触发器 INTR</li><li>屏蔽触发器 MASK</li></ul></li><li>数据缓冲寄存器</li><li>设备状态标记</li></ul><h3 id=5-4-程序查询方式><a href=#5-4-程序查询方式 class=headerlink title="5.4 程序查询方式"></a>5.4 程序查询方式</h3><h4 id=5-4-1-程序查询流程><a href=#5-4-1-程序查询流程 class=headerlink title="5.4.1 程序查询流程"></a>5.4.1 程序查询流程</h4><p>对于单个设备而言, 程序查询方式十分简单:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E5%8D%95%E4%B8%AA%E8%AE%BE%E5%A4%87.png alt=程序查询_单个设备></p><p>多个设备, 则需要将很多个这样的电路组合在一起:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87.png alt=程序查询_多个设备></p><p>对于程序查询这种方式, 总流程如下:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E6%80%BB%E6%B5%81%E7%A8%8B.png alt=程序查询_总流程></p><h4 id=5-4-2-程序查询的接口电路和具体流程><a href=#5-4-2-程序查询的接口电路和具体流程 class=headerlink title="5.4.2 程序查询的接口电路和具体流程:"></a>5.4.2 程序查询的接口电路和具体流程:</h4><p>见书 $ P_{191} $ ~ $ P_{192} $</p><h3 id=5-5-程序中断方式><a href=#5-5-程序中断方式 class=headerlink title="5.5 程序中断方式"></a>5.5 程序中断方式</h3><p>中断的概念前面有提及, 这里不再详细叙述了, 简而言之, 就是 <strong>暂存程序断点-&gt;进入中断服务程序-&gt;返回程序断点继续执行</strong> 这样的过程.</p><h4 id=5-5-1-I-O-中断的产生><a href=#5-5-1-I-O-中断的产生 class=headerlink title="5.5.1 I&#x2F;O 中断的产生"></a>5.5.1 I&#x2F;O 中断的产生</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/IO%E4%BA%A7%E7%94%9F%E4%B8%AD%E6%96%AD_%E4%BE%8B.png alt=IO产生中断_例></p><h4 id=5-5-2-中断方式的接口电路><a href=#5-5-2-中断方式的接口电路 class=headerlink title="5.5.2 中断方式的接口电路"></a>5.5.2 中断方式的接口电路</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF_%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png alt=接口电路_中断方式></p><p>由于计算机连接的 I&#x2F;O 设备肯定不止一个, 因此不同的中断请求需要被排序, 这涉及到 <strong>排队器</strong> 的设计.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F%E5%99%A8.png alt=中断排队器></p><p>在中断被触发后, 需要根据对应的中断请求给出相应的中断程序地址(比如打印机的中断请求需要对应打印机的中断服务程序), 因此还涉及到 <strong>中断向量地址形成部件</strong> ;</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E9%83%A8%E4%BB%B6.png alt=中断向量地址形成部件></p><p>关于 <strong>中断方式的完整接口电路</strong> , 见书 $ P_{196} $</p><p>此外, 有一道关于中断排队器以及中断向量地址的综合设计例题, 请看书 $ P_{196} $ 的例5.2</p><h3 id=5-5-3-I-O-中断处理过程><a href=#5-5-3-I-O-中断处理过程 class=headerlink title="5.5.3 I&#x2F;O 中断处理过程"></a>5.5.3 I&#x2F;O 中断处理过程</h3><ul><li>CPU相应中断的条件<ul><li>允许中断触发器 EINT &#x3D; 1;</li><li>EINT的更改可以通过:<ul><li>开中断: 1 -&gt; EINT</li><li>关中断: 0 -&gt; EINT</li><li>硬件自动复位: 0 -&gt; EINT</li></ul></li></ul></li><li>CPU相应中断的时间<ul><li>D &#x3D; 1 且 MASK &#x3D; 0;</li><li>在每条指令执行阶段的结束前CPU发送中断查询信号(相当于在上面的中断接口电路中将 INTR 置1)</li></ul></li></ul><p>关于 <strong>终端服务程序的流程</strong> :</p><ul><li>保护现场</li><li>中断服务</li><li>恢复现场</li><li>中断返回</li></ul><p>关于 <strong>单重中断与多重中断</strong> :</p><ul><li>单重中断: 一旦某一中断程序开始, 则必须运行完后才能进行下一次中断处理</li><li>多重中断: <strong>允许级别更高的中断源 中断 现行的中断服务程序</strong></li></ul><h3 id=5-6-DMA方式><a href=#5-6-DMA方式 class=headerlink title="5.6 DMA方式"></a>5.6 DMA方式</h3><h4 id=5-6-1-DMA方式的特点><a href=#5-6-1-DMA方式的特点 class=headerlink title="5.6.1 DMA方式的特点"></a>5.6.1 DMA方式的特点</h4><p>DMA方式与前两者的数据通路并不相同, I&#x2F;O 设备的DMA接口直接与主存相连.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E6%96%B9%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png alt=DMA方式数据通路></p><p>因此, DMA有三种与主存交换数据的方式:</p><ul><li>停止CPU访问主存: 即让CPU暂停一段时间, 把总线的控制权交给DMA</li><li>周期挪用(周期窃取):<ul><li>CPU此时不访存, 则DMA直接拿到控制权</li><li>CPU此时正在访存, DMA等待</li><li>CPU与DMA同时请求访存, 则CPU将总线控制权交给DMA;</li></ul></li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA_%E5%91%A8%E6%9C%9F%E7%AA%83%E5%8F%96.png alt=DMA_周期窃取></p><ul><li>CPU与DMA交替访问: 将CPU的工作周期分为两部分, 一部分专供DMA访存, 另一部分供CPU访存.(这种方式 <strong>不需要申请建立和归还总线的使用权</strong> )</li></ul><h4 id=5-6-2-DMA接口的功能和组成><a href=#5-6-2-DMA接口的功能和组成 class=headerlink title="5.6.2 DMA接口的功能和组成"></a>5.6.2 DMA接口的功能和组成</h4><p>DMA接口需要实现的功能如下:</p><ul><li>向CPU申请DMA传送</li><li>处理总线控制权的移交</li><li>管理系统总线 &#x2F; 控制数据传送</li><li>确定数据传送的首地址 &#x2F; 长度</li><li>传送结束后, 给出操作完成信号</li></ul><p>其 <strong>工作过程</strong> 主要分三步:</p><ul><li>预处理<ul><li>CPU向DMA输出指令, 预置一些必要信息<ul><li>主存起始地址</li><li>设备地址</li><li>传送数据个数</li></ul></li><li>可看作是DMA接口的初始化过程</li></ul></li><li>数据传送<ul><li>以数据块为单位传送数据</li><li>CPU此时继续执行主程序</li><li>传送结束后DMA向CPU申请中断</li></ul></li><li>后处理<ul><li>CPU停止主程序的执行, 进入中断服务程序</li><li>进行DMA的结束工作<ul><li>是否继续传送<ul><li>继续传送则初始化</li><li>否则停止外设</li></ul></li><li>检查传送过程是否出错</li></ul></li></ul></li></ul><h4 id=5-6-3-DMA方式与中断方式的比较><a href=#5-6-3-DMA方式与中断方式的比较 class=headerlink title="5.6.3 DMA方式与中断方式的比较"></a>5.6.3 DMA方式与中断方式的比较</h4><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83.png alt=DMA与中断方式的比较></p><h4 id=5-6-4-DMA接口类型><a href=#5-6-4-DMA接口类型 class=headerlink title="5.6.4 DMA接口类型"></a>5.6.4 DMA接口类型</h4><ul><li>选择型: 物理上连接多个设备, 但逻辑上只能同时连接一个设备</li><li>多路型: 物理上连接多个设备, 逻辑上允许多个设备同时工作</li></ul><h2 id=Chap-3-系统总线><a href=#Chap-3-系统总线 class=headerlink title="Chap.3 系统总线"></a>Chap.3 系统总线</h2><h3 id=3-1-总线的基本概念><a href=#3-1-总线的基本概念 class=headerlink title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h3><p>总线, 即 <strong>各个部件共享的传输介质</strong>, 分串行传送和并行传送.</p><p>总线结构的计算机举例:</p><p>1.面向CPU的双总线:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF.png alt=面向CPU的双总线></p><p>2.单总线:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%95%E6%80%BB%E7%BA%BF.png alt=单总线></p><p>3.面向存储器的双总线:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF.png alt=面向存储器的双总线></p><h3 id=3-2-总线分类><a href=#3-2-总线分类 class=headerlink title="3.2 总线分类"></a>3.2 总线分类</h3><p>大体上, 总线可分为</p><ul><li>片内总线: 即芯片内部的总线</li><li>系统总线<ul><li>数据总线: 双向, 与机器字长 &#x2F; 存储字长有关</li><li>地址总线: 单向, 与存储地址 &#x2F; I&#x2F;O 地址有关</li><li>控制总线: 有出有入</li></ul></li><li>通信总线: 用于 <strong>计算机系统之间</strong> 或 计算机系统与其它系统之间</li></ul><h3 id=3-3-总线的特性与性能指标><a href=#3-3-总线的特性与性能指标 class=headerlink title="3.3 总线的特性与性能指标"></a>3.3 总线的特性与性能指标</h3><h4 id=3-3-1-总线的物理实现><a href=#3-3-1-总线的物理实现 class=headerlink title="3.3.1 总线的物理实现"></a>3.3.1 总线的物理实现</h4><p>总线位于 <strong>主板</strong> 上, 而连接不同设备是由 <strong>插板</strong> 实现的.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0.png alt=总线的物理实现></p><h4 id=3-3-2-总线的特性><a href=#3-3-2-总线的特性 class=headerlink title="3.3.2 总线的特性"></a>3.3.2 总线的特性</h4><p>总线有以下几种值得关注的特性</p><ul><li>机械特性: 尺寸 &#x2F; 形状 &#x2F; 管脚数目 &#x2F; 排列顺序</li><li>电气特性: 传输方向 &#x2F; 有效电平范围</li><li>功能特性: 每根传输线的功能</li><li>时间特性: 信号的时序关系</li></ul><h4 id=3-3-3-总线的性能指标><a href=#3-3-3-总线的性能指标 class=headerlink title="3.3.3 总线的性能指标"></a>3.3.3 总线的性能指标</h4><ul><li>总线宽度: 数据线根数</li><li>总线带宽: 每秒传输的最大字节数(MBps)</li><li>时钟类型: 同步 &#x2F; 异步</li><li>总线复用: 地址线与数据线复用</li><li>信号线数: 地址线 &#x2F; 数据线 &#x2F; 控制线的总和</li><li>总线控制方式: 并发 &#x2F; 自动 &#x2F; 仲裁 &#x2F; 逻辑 &#x2F; 计数</li><li>其他指标: 负载能力等</li></ul><h3 id=3-4-总线结构><a href=#3-4-总线结构 class=headerlink title="3.4 总线结构"></a>3.4 总线结构</h3><h4 id=3-4-1-单总线结构><a href=#3-4-1-单总线结构 class=headerlink title="3.4.1 单总线结构"></a>3.4.1 单总线结构</h4><p>前面有所提及:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%95%E6%80%BB%E7%BA%BF.png alt=单总线></p><h4 id=3-4-2-多总线结构><a href=#3-4-2-多总线结构 class=headerlink title="3.4.2 多总线结构"></a>3.4.2 多总线结构</h4><p>1.双总线:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png alt=双总线结构></p><hr><p>2.三总线:</p><p>有两种方式.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%281%29.png alt=三总线结构(1)></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%282%29.png alt=三总线结构(2)></p><hr><p>3.四总线</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9B%9B%E6%80%BB%E7%BA%BF.png alt=四总线></p><h3 id=3-5-总线控制><a href=#3-5-总线控制 class=headerlink title="3.5 总线控制"></a>3.5 总线控制</h3><h4 id=3-5-1-总线判优控制><a href=#3-5-1-总线判优控制 class=headerlink title="3.5.1 总线判优控制"></a>3.5.1 总线判优控制</h4><p>主线中的模块有优先之分:</p><ul><li>主设备(模块): 它对总线有控制权</li><li>从设备(模块): 它响应从主设备发来的总线命令</li><li>判优控制有两种方式<ul><li>集中式<ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li><li>分布式</li></ul></li></ul><hr><p>1.链式查询:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png alt=总线判优_链式查询></p><p>通过BS &#x2F; BR &#x2F; BG三个信号来决定总线的操作</p><p>2.计数器定时查询:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png alt=总线判优_计数器定时查询></p><p>通过计数器进行计时, 定时查询各个接口是否需要进行操作</p><p>3.独立请求方式:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82.png alt=总线判优_独立请求></p><p>在总线控制部件内部内置排队器, 接受来自各个接口的请求, 通过排队器决定处理顺序</p><h4 id=3-5-2-总线通信控制><a href=#3-5-2-总线通信控制 class=headerlink title="3.5.2 总线通信控制"></a>3.5.2 总线通信控制</h4><p>通信控制的目的在于解决双方的 <strong>协调配合问题</strong> .</p><p>总线传输周期有四个阶段:</p><ul><li>申请分配阶段: 主模块申请, 总线仲裁决定</li><li>寻址阶段: 主模块向从模块给出地址 &#x2F; 命令</li><li>传数阶段: 主模块和从模块交换数据</li><li>结束阶段: 主模块撤销有关信息</li></ul><p>主模块通过总线与从模块的数据通信也分四种:</p><ul><li>同步通信: 通过 <strong>统一时标</strong> 控制数据传送</li><li>异步通信: 采用 <strong>应答方式</strong> , 没有公共时钟标准</li><li>半同步通信: 同步 + 异步</li><li>分离式通信: 为了充分挖掘总线潜力而出现</li></ul><hr><p><strong>1.同步通信:</strong></p><p>通过统一时钟进行数据交互</p><p>以同步式数据输入为例:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png alt=同步式数据输入></p><p>这种方式使得 <strong>速度快的模块必将需要等待速度慢的模块准备完成</strong> 才能进行下一步, 因此会造成资源浪费.</p><p><strong>2.异步通信:</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1.png alt=异步通信></p><p>主模块发送请求信号时, 会一直等待从模块的应答信号, 而后再开始传输</p><ul><li>不互锁: 主模块确认从模块接收到请求后, 就撤销请求申请</li><li>半互锁: 主模块收到来自从模块的回答信号后, 再撤销其请求申请</li><li>全互锁: 主模块必须等待从模块回答后, 撤销其请求信号; 同时, 从模块必须等待主模块已经撤销其请求信号后, 才能撤销其应答信号.</li></ul><p><strong>3.半同步通信:</strong></p><p>增加一个 WAIT 信号, 即如果从模块速度过慢, 必须 <strong>在下一个时钟到来前给出 $ \overline{WAIT} $ 信号(低电平)</strong> , 主模块如果检测到这个低电平, 则会主动插入一个 $ T_w $ 进行等待, 直到 $ \overline{WAIT} $ 信号变为高电平了为止.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png alt=半同步通信></p><p><strong>4.分离式通信</strong></p><p>上述三种通信方法, 都分三个过程:</p><ul><li>主模块发地址 &#x2F; 命令(占用总线)</li><li>从模块准备数据( <strong>占用总线, 但总线空闲</strong> )</li><li>从模块向主模块发送数据(占用总线)</li></ul><p>分离式通信希望将 <strong>第二个过程浪费的总线传输也利用起来</strong> .</p><p>分离式通信将一个传输周期(总线周期)分成了两部分:</p><ul><li>$ T_1 $ : 主模块发送地址 &#x2F; 命令 &#x2F; <strong>自己的编号(在有多个主模块时, 这很重要, 涉及到从模块在下半个周期中的寻址)</strong> , 然后立即放弃总线使用权</li><li>$ T_2 $ : 从模块准备好后, 将收到主模块的编号 &#x2F; 自己的地址 &#x2F; 主模块所需数据发送到总线上, 供对应主模块接受.</li></ul><p>该方法:</p><ul><li>各模块都有权申请占用总线</li><li>采用同步方式通信, 不等对方回答</li><li><strong>在准备数据时不会占用总线(节省了时间)</strong></li><li>总线被占用时, 不会空闲, 一直在传输数据</li></ul><p>充分提高了总线的有效占用.</p><h3 id=3-6-几个名词><a href=#3-6-几个名词 class=headerlink title="3.6 几个名词"></a>3.6 几个名词</h3><ul><li>串行传送: 只有一条传输线, 按顺序传送表示一个数码的所有二进制位脉冲信号, 通常 <strong>第一位为最低位, 最后一位为最高位</strong> ;</li><li>位时间: 一个二进制位在传输线上占用的时间长度;</li><li>波特率: 单位时间内传送码元(要用若干个比特表示的最小单位)的数目;</li><li>比特率: 单位时间内传送有效数据比特的数目;</li></ul><hr><p>这篇博文应该是至今以来最长的一篇, 并未分片.</p><p>至此，计算机组成原理这门课的大部分内容就梳理完毕了.</p><p>希望这篇博文能对后来的读者有所帮助, 此外, 博主限于水平有限, 难免出现各种知识上的纰漏与笔误, 还请各位谅解.</p><p>在这里再次对本文引用到PPT的作者致以诚挚的谢意.</p><p>这篇博文就到这里~</p></div><hr><div class=reprint id=reprint-statement><div class=reprint__author><span class=reprint-meta style=font-weight:700><i class="fas fa-user">文章作者: </i></span><span class=reprint-info><a href=/about rel="external nofollow noreferrer">MUG-chen</a></span></div><div class=reprint__type><span class=reprint-meta style=font-weight:700><i class="fas fa-link">文章链接: </i></span><span class=reprint-info><a href=http://mug-chen.github.io/posts/61250.html>http://mug-chen.github.io/posts/61250.html</a></span></div><div class=reprint__notice><span class=reprint-meta style=font-weight:700><i class="fas fa-copyright">版权声明: </i></span><span class=reprint-info>本博客所有文章除特別声明外，均采用 <a href=https://creativecommons.org/licenses/by/4.0/deed.zh rel="external nofollow noreferrer" target=_blank>CC BY 4.0</a> 许可协议。转载请注明来源 <a href=/about target=_blank>MUG-chen</a> !</span></div></div><script async defer=defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class=tag_share style=display:block><div class=post-meta__tag-list style=display:inline-block><div class=article-tag><a href=/tags/Computer-Composition-Principles/ ><span class="chip bg-color">Computer Composition Principles</span></a></div></div><div class=post_share style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel=stylesheet type=text/css href=/libs/share/css/share.min.css><div id=article-share><div class=social-share data-sites=twitter,facebook,google,qq,qzone,wechat data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src=/libs/share/js/social-share.min.js></script></div></div></div></div></div><article id=prenext-posts class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos=fade-up><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class=card><a href=/posts/3283.html><div class=card-image><img src=/medias/featureimages/23.jpg class=responsive-img alt=Blockchain-2> <span class=card-title>Blockchain-2</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Blockchain-Ethereum Notes</div><div class=publish-info><span class=publish-date><i class="far fa-clock fa-fw icon-date"></i>2024-07-04 </span><span class=publish-author><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes</a></span></div></div><div class="card-action article-tags"><a href=/tags/Blockchain/ ><span class="chip bg-color">Blockchain</span></a></div></div></div><div class="article col s12 m6" data-aos=fade-up><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class=card><a href=/posts/56920.html><div class=card-image><img src=/medias/featureimages/16.jpg class=responsive-img alt=信安数学基础_Fin> <span class=card-title>信安数学基础_Fin</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Mathematical basis of Information Security 期末复习章</div><div class=publish-info><span class=publish-date><i class="far fa-clock fa-fw icon-date"></i>2024-06-10 </span><span class=publish-author><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes</a></span></div></div><div class="card-action article-tags"><a href=/tags/Mathematical-basis-of-Information-Security/ ><span class="chip bg-color">Mathematical basis of Information Security</span></a></div></div></div></div></article></div><script type=text/javascript src=/libs/codeBlock/codeBlockFuction.js></script><script type=text/javascript src=/libs/prism/prism.min.js></script><script type=text/javascript src=/libs/codeBlock/codeLang.js></script><script type=text/javascript src=/libs/codeBlock/codeCopy.js></script><script type=text/javascript src=/libs/codeBlock/codeShrink.js></script></div><div id=toc-aside class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style=background-color:#fff><div class=toc-title><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id=toc-content></div></div></div></div><div id=floating-toc-btn class=hide-on-med-and-down><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src=/libs/tocbot/tocbot.min.js></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const n="expanded";let i=$("#toc-aside"),l=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){i.hasClass(n)?(i.removeClass(n).hide(),l.removeClass("l9")):(i.addClass(n).show(),l.addClass("l9"));var e="artDetail",o="prenext-posts";if(0!==(e=$("#"+e)).length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#"+o).width(t)}})})</script></main><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><footer class="page-footer bg-color"><div class="container row center-align" style=margin-bottom:15px!important><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id=year>2022-2024</span> <a href=/about target=_blank>MUG-chen</a> |&nbsp;Powered by&nbsp;<a href=https://hexo.io/ target=_blank>Hexo</a> |&nbsp;Theme&nbsp;<a href=https://github.com/blinkfox/hexo-theme-matery target=_blank>Matery</a><br><span id=busuanzi_container_site_pv>&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp; <span id=busuanzi_value_site_pv class=white-color></span> </span><span id=busuanzi_container_site_uv>&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp; <span id=busuanzi_value_site_uv class=white-color></span></span><br><span id=sitetime>Loading ...</span><script>var calcSiteTime=function(){var e=new Date,t="2022",n=e.getFullYear(),i=e.getMonth()+1,a=e.getDate(),r=e.getHours(),o=e.getMinutes(),e=e.getSeconds(),s=Date.UTC(t,"12","25","22","45","0"),i=Date.UTC(n,i,a,r,o,e)-s,a=Math.floor(i/31536e6),r=Math.floor(i/864e5-365*a);t===String(n)?(document.getElementById("year").innerHTML=n,o="This site has been running for "+r+" days",o="本站已运行 "+r+" 天",document.getElementById("sitetime").innerHTML=o):(document.getElementById("year").innerHTML=t+" - "+n,e="This site has been running for "+a+" years and "+r+" days",e="本站已运行 "+a+" 年 "+r+" 天",document.getElementById("sitetime").innerHTML=e)};calcSiteTime()</script><br></div><div class="col s12 m4 l4 social-link social-statis"><a href=https://github.com/MUG-chen class=tooltipped target=_blank data-tooltip=访问我的GitHub data-position=top data-delay=50><i class="fab fa-github"></i></a></div></div></footer><div class=progress-bar></div><div id=searchModal class=modal><div class=modal-content><div class=search-header><span class=title><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type=search id=searchInput name=s placeholder=请输入搜索的关键字 class=search-input></div><div id=searchResult></div></div></div><script type=text/javascript>$(function(){!function(t,r,s){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),t=document.getElementById(r),n=document.getElementById(s);t.addEventListener("input",function(){var o='<ul class="search-result-list">',h=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,s=!0,i=t.title.trim().toLowerCase(),l=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),a=0===(a=t.url).indexOf("/")?t.url:"/"+a,c=-1,u=-1;""!==i&&""!==l&&h.forEach(function(t,e){n=i.indexOf(t),c=l.indexOf(t),n<0&&c<0?s=!1:(c<0&&(c=0),0===e&&(u=c))}),s&&(o+="<li><a href='"+a+"' class='search-result-title'>"+i+"</a>",a=t.content.trim().replace(/<[^>]+>/g,""),0<=u&&(t=u+80,(t=0===(e=(e=u-20)<0?0:e)?100:t)>a.length&&(t=a.length),r=a.substr(e,t),h.forEach(function(t){var e=new RegExp(t,"gi");r=r.replace(e,'<em class="search-keyword">'+t+"</em>")}),o+='<p class="search-result">'+r+"...</p>"),o+="</li>")}),o+="</ul>",n.innerHTML=o)})}})}("/search.xml","searchInput","searchResult")})</script><div class=stars-con><div id=stars></div><div id=stars2></div><div id=stars3></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id=backTop class=top-scroll><a class="btn-floating btn-large waves-effect waves-light" href=#!><i class="fas fa-arrow-up"></i></a></div><script src=/libs/materialize/materialize.min.js></script><script src=/libs/masonry/masonry.pkgd.min.js></script><script src=/libs/aos/aos.js></script><script src=/libs/scrollprogress/scrollProgress.min.js></script><script src=/libs/lightGallery/js/lightgallery-all.min.js></script><script src=/js/matery.js></script><script type=text/javascript>var windowWidth=$(window).width();768<windowWidth&&document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>')</script><script src=https://ssl.captcha.qq.com/TCaptcha.js></script><script src=/libs/others/TencentCaptcha.js></script><button id=TencentCaptcha data-appid=xxxxxxxxxx data-cbfn=callback type=button hidden></button><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0],e=(t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}()</script><script async src=/libs/others/busuanzi.pure.mini.js></script><script src=/libs/instantpage/instantpage.js type=module></script><div id=loading-box><div class=loading-left-bg></div><div class=loading-right-bg></div><div class=spinner-box><div class=configure-border-1><div class=configure-core></div></div><div class=configure-border-2><div class=configure-core></div></div><div class=loading-word>加载中...</div></div></div><script>window.addEventListener("load",function(){document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},!1)</script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!0,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script></body></html>
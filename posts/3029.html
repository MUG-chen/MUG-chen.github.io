<!DOCTYPE HTML><html lang=zh-CN><head><meta charset=utf-8><meta name=keywords content="数据库系统概论-Chap.3, MUG-chen&#39;s Blog"><meta name=description content="数据库系统概论 Chap.3 关系数据库标准语言SQL"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><meta name=renderer content=webkit|ie-stand|ie-comp><meta name=mobile-web-app-capable content=yes><meta name=format-detection content="telephone=no"><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black-translucent><meta name=referrer content=no-referrer-when-downgrade><title>数据库系统概论-Chap.3 | MUG-chen&#39;s Blog</title><link rel=icon type=image/png href=/favicon.png><style>body{background-image:url(https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Vivid%20theory.webp);background-repeat:no-repeat;background-size:100% 100%;background-attachment:fixed}</style><link rel=stylesheet type=text/css href=/libs/awesome/css/all.min.css><link rel=stylesheet type=text/css href=/libs/materialize/materialize.min.css><link rel=stylesheet type=text/css href=/libs/aos/aos.css><link rel=stylesheet type=text/css href=/libs/animate/animate.min.css><link rel=stylesheet type=text/css href=/libs/lightGallery/css/lightgallery.min.css><link rel=stylesheet type=text/css href=/css/matery.css><link rel=stylesheet type=text/css href=/css/my.css><link rel=stylesheet type=text/css href=/css/dark.css media=none onload='"all"!=media&&(media="all")'><link rel=stylesheet href=/libs/tocbot/tocbot.css><link rel=stylesheet href=/css/post.css><script src=/libs/jquery/jquery-3.6.0.min.js></script><link rel=stylesheet type=text/css href=/css/loading.css><meta name=generator content="Hexo 7.1.1"></head><body><header class=navbar-fixed><nav id=headNav class="bg-color nav-transparent"><div id=navContainer class="nav-wrapper container"><div class=brand-logo><a href=/ class="waves-effect waves-light"><img src=/medias/logo.png class=logo-img alt=LOGO> <span class=logo-span>MUG-chen&#39;s Blog</span></a></div><a href=# data-target=mobile-nav class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href=/ class="waves-effect waves-light"><i class="fas fa-home" style=zoom:.6></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/tags class="waves-effect waves-light"><i class="fas fa-tags" style=zoom:.6></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/categories class="waves-effect waves-light"><i class="fas fa-bookmark" style=zoom:.6></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/archives class="waves-effect waves-light"><i class="fas fa-archive" style=zoom:.6></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/about class="waves-effect waves-light"><i class="fas fa-user-circle" style=zoom:.6></i> <span>关于</span></a></li><li><a href=#searchModal class="modal-trigger waves-effect waves-light"><i id=searchIcon class="fas fa-search" title=搜索 style=zoom:.85></i></a></li><li><a href=javascript:; class="waves-effect waves-light" onclick=switchNightMode() title=深色/浅色模式><i id=sum-moon-icon class="fas fa-sun" style=zoom:.85></i></a></li></ul><div id=mobile-nav class="side-nav sidenav"><div class="mobile-head bg-color"><img src=/medias/logo.png class="logo-img circle responsive-img"><div class=logo-name>MUG-chen&#39;s Blog</div><div class=logo-desc>Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class=m-nav-item><a href=/ class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class=m-nav-item><a href=/tags class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class=m-nav-item><a href=/categories class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class=m-nav-item><a href=/archives class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class=m-nav-item><a href=/about class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li><div class=divider></div></li><li><a href=https://github.com/MUG-chen/MUG-chen.github.io class="waves-effect waves-light" target=_blank><i class="fab fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href=https://github.com/MUG-chen/MUG-chen.github.io class="github-corner tooltipped hide-on-med-and-down" target=_blank data-tooltip="Fork Me" data-position=left data-delay=50><svg viewBox="0 0 250 250" aria-hidden=true><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill=currentColor style="transform-origin:130px 106px" class=octo-arm></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill=currentColor class=octo-body></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style=background-image:url(/medias/featureimages/19.jpg)><div class=container style=right:0;left:0><div class=row><div class="col s12 m12 l12"><div class=brand><h1 class="description center-align post-title">数据库系统概论-Chap.3</h1></div></div></div></div></div><main class="post-container content"><div class=row><div id=main-content class="col s12 m12 l9"><div id=artDetail><div class=card><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class=article-tag><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ ><span class="chip bg-color">数据库系统概论</span> </a><a href=/tags/Database/ ><span class="chip bg-color">Database</span></a></div></div><div class="col s5 right-align"><div class=post-cate><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes </a><a href=/categories/Study-Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE%E6%80%BB%E5%A4%8D%E4%B9%A0%E7%AF%87/ class=post-category>计算机专业课总复习篇</a></div></div></div><div class=post-info><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2025-06-12</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2025-06-12</div><div class=info-break-policy><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 10.4k</div></div></div><hr class=clearfix><link rel=stylesheet href=/libs/prism/prism.min.css><div class="card-content article-card-content"><div id=articleContent><h1 id=Chap-3-关系数据库标准语言SQL><a href=#Chap-3-关系数据库标准语言SQL class=headerlink title="Chap.3 关系数据库标准语言SQL"></a>Chap.3 关系数据库标准语言SQL</h1><h2 id=3-1-SQL概述><a href=#3-1-SQL概述 class=headerlink title="3.1 SQL概述"></a>3.1 SQL概述</h2><p><strong>SQL(Structured Query Language)</strong> , 中文叫 <strong>结构化查询语言</strong> , 是关系数据库的标准语言.</p><h3 id=3-1-1-SQL发展><a href=#3-1-1-SQL发展 class=headerlink title="3.1.1. SQL发展"></a>3.1.1. SQL发展</h3><p>SQL在上世纪70年代被发明, 在80年代后正式通过审批并成为关系数据库的标准语言.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/SQL%E6%A0%87%E5%87%86%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B.png alt=SQL标准的发展过程></p><p>可见SQL这玩意是非常庞大的. <strong>目前没有任何一个数据库系统能够支持SQL的全部特性</strong> .</p><h3 id=3-1-2-SQL的特点><a href=#3-1-2-SQL的特点 class=headerlink title="3.1.2 SQL的特点"></a>3.1.2 SQL的特点</h3><p>SQL之所以能够经久不衰成为关系数据库的标准语言, 理由如下:</p><ul><li>综合统一: SQL能够独立完成数据库生命周期中的全部活动.<ul><li>定义</li><li>查询</li><li>更新</li><li>维护重构</li><li>安全性 &#x2F; 完整性控制等</li></ul></li><li>高度非过程化: 不像其余类型数据库语言的面向过程, SQL只需要让应用设计者指明 <strong>做什么</strong> 即可.</li><li>面向集合的操作模式: 关系型数据库用表来表示关系, 因此SQL的查询 &#x2F; 更新对象都可以是元组的集合(其实也就是一个表)</li><li>同一种语法结构能提供多种使用方式<ul><li>能够独立交互使用, 也可以嵌入到高级语言中</li></ul></li><li>语言简洁, 易学易用 <del>(?)</del></li></ul><p>总结两点:</p><ol><li>SQL是操作数据库的, 因此它无法独立完成应用开发, 不同于其它的大型高级语言.</li><li>SQL不能等同于DBMS, 它只是DBMS提供给用户的交互语言.</li></ol><h3 id=3-1-3-SQL的基本概念><a href=#3-1-3-SQL的基本概念 class=headerlink title="3.1.3 SQL的基本概念"></a>3.1.3 SQL的基本概念</h3><p>对应着我们第二章说的数据库三级模式(内模式 -&gt; 模式 -&gt; 外模式), SQL提供了一些对应的名词(也就是实现了一些对应模式的结构):</p><ul><li>基本表: 本身独立存在的表<ul><li>对应 <em>模式</em> 这一层</li><li>一个关系就是一个基本表</li><li>一个基本表对应一个存储文件</li><li>一个表可以带若干索引(也就是外键)</li></ul></li><li>存储文件: 关系在物理存储介质上的存储方式<ul><li>对应 <em>内模式</em> 这一层</li><li>由SQL自身实现, 对用户透明</li></ul></li><li>视图: 由一个或几个基本表导出的表<ul><li>对应 <em>外模式</em> 这一层</li><li>只存放外模式的定义, 而不存放外模式的数据</li><li>是一个虚表</li></ul></li></ul><p>除此之外, SQL针对数据库需要实现的功能, 提供了如下命令:</p><ul><li>数据定义语言(DDL) : 负责创建 &#x2F; 修改 &#x2F; 删除数据库中各种对象(模式, 基本表, 视图, 索引等)</li><li>查询语言(QL) : 按照指定的组合, 条件表达式查找已存在的数据</li><li>数据操纵语言(DML) : 对已经存在的数据库进行元组的插入 &#x2F; 删除 &#x2F; 修改等操作</li><li>数据控制语言(DCL) : 用来授予 &#x2F; 收回某种权限, 并对数据库进行监视.</li></ul><p>下面, 就从上述四种语言的角度, 分别捣鼓捣鼓.</p><h3 id=3-1-4-本章基于的关系模型><a href=#3-1-4-本章基于的关系模型 class=headerlink title="3.1.4 本章基于的关系模型"></a>3.1.4 本章基于的关系模型</h3><p>我们在下方梳理四种语言的时候, 需要一个具体的案例来为各位读者演示其具体语句的含义.<br>这里给出本章基于的关系模型供各位参考.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%AD%A6%E7%94%9F%E8%A1%A8.png alt=学生表></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E8%AF%BE%E7%A8%8B%E8%A1%A8.png alt=课程表></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E9%80%89%E8%AF%BE%E8%A1%A8.png alt=选课表></p><h2 id=3-2-数据定义语言-DDL><a href=#3-2-数据定义语言-DDL class=headerlink title="3.2 数据定义语言 DDL"></a>3.2 数据定义语言 DDL</h2><p>SQL的数据定义分以下三类:</p><ul><li>模式定义</li><li>表定义</li><li>视图和索引的定义</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/SQL%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E5%8F%A5.png alt=SQL的数据定义语言></p><h3 id=3-2-1-模式相关定义语言><a href=#3-2-1-模式相关定义语言 class=headerlink title="3.2.1 模式相关定义语言"></a>3.2.1 模式相关定义语言</h3><h4 id=3-2-1-1-模式的创建><a href=#3-2-1-1-模式的创建 class=headerlink title="3.2.1.1 模式的创建"></a>3.2.1.1 模式的创建</h4><p>这里会跟我们之前提到的一个地方有点冲突.<br>现代数据库中, 一个 <strong>数据库(DATABASE)</strong> 是允许存在多个 <strong>模式(SCHEMA)</strong> 的. 这通常用于不同逻辑的分区(相当于在一个大文件夹底下单独分了几个小文件夹, 小文件夹下面又能有很多表).</p><p>定义模式的语句如下:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> <span class="token operator">&lt;</span>模式名<span class="token operator">></span> <span class="token keyword">AUTHORIZATION</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>两点需要注意:</p><ul><li>创建模式必须具有数据库管理员(DBA)权限, 或者具有DBA授予的创建模式的权限.</li><li>如果没有指定 &lt;模式名&gt; , 则模式名隐含为 &lt;用户名&gt;</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F-%E4%BE%8B.png alt=创建模式-例></p><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>第二点的原因正是我们所说的数据库多模式的目的, 用于逻辑分区. 比如一个学校数据库(School)中可以创建两种模式: 校内职工(Worker) 和 公开可见(Public) , 这二中模式里面的关系(表)显然可能不同对吧.</p></blockquote><hr><p>我们还需要特别强调一下, <strong><font color=#ff3131>MySQL中一个数据库只能有一种模式, 这是其与其它数据库系统的显著区别!!!</font></strong><br>究其根本在于 MySQL 是一个开源的中小型数据库系统, 因此未能像 Postgre SQL 中实现这种逻辑分流的结构.<br>这也就意味着, Schema 与 Database 在MySQL中其实是同义词.</p><hr><p>一个模式下可下属多个表, 多个视图, 多个授权定义等.<br>那问题来了, 我该怎么把一个表 &#x2F; 视图 &#x2F; 授权定义附在一个模式下面?<br>有以下三种方法:</p><ul><li>直接在定义表的时候显式的指出模式名</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">Create</span> <span class="token keyword">table</span><span class="token string">"S-T"</span><span class="token punctuation">.</span>Student<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li>在创建模式的时候同时创建表 &#x2F; 视图 &#x2F; 授权定义</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> <span class="token operator">&lt;</span>模式名<span class="token operator">></span> <span class="token keyword">AUTHORIZATION</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span>表定义子句<span class="token operator">></span><span class="token operator">|</span><span class="token operator">&lt;</span>视图定义子句<span class="token operator">></span><span class="token operator">|</span><span class="token operator">&lt;</span>授权定义子句<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><ul><li>设置所属模式</li></ul><p>在创建基本表的时候, 系统会根据当前的 <strong>搜索路径</strong> 来指定表所在的模式, 如果当前搜索路径为空, 则系统会报错.<br>设置搜索路径的语句如下:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SET</span> search_path <span class="token keyword">TO</span> <span class="token string">"S-T"</span><span class="token punctuation">;</span>
<span class="token keyword">Create</span> <span class="token keyword">table</span> Student<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><h4 id=3-2-1-2-模式的删除><a href=#3-2-1-2-模式的删除 class=headerlink title="3.2.1.2 模式的删除"></a>3.2.1.2 模式的删除</h4><p>删除模式要简单不少:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DROP</span> <span class="token keyword">SCHEMA</span> <span class="token operator">&lt;</span>模式名<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token keyword">CASCADE</span><span class="token operator">|</span><span class="token keyword">RESTRICT</span><span class="token operator">></span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>后面会有可选项, 我们解释一下:</p><ul><li>CASCADE: 级联, 代表着只要模式删了, 模式下面的所有数据库对象全删掉(Linux中的递归删除)</li><li>RESTRICT: 限制, 只有模式SCHEMA下面啥都没有的时候, 才能把这个模式删除.(否则会报错)</li></ul><h3 id=3-2-2-基本表的相关定义语言><a href=#3-2-2-基本表的相关定义语言 class=headerlink title="3.2.2 基本表的相关定义语言"></a>3.2.2 基本表的相关定义语言</h3><h4 id=3-2-2-1-基本表的创建><a href=#3-2-2-1-基本表的创建 class=headerlink title="3.2.2.1 基本表的创建"></a>3.2.2.1 基本表的创建</h4><p>基本表, 也就是我们熟悉的 <strong>关系(表)</strong> , 通常通过如下语言进行定义:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>
<span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">[</span> <span class="token operator">&lt;</span>列级完整性约束条件<span class="token operator">></span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">[</span> <span class="token operator">&lt;</span>列级完整性约束条件<span class="token operator">></span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
    …<span class="token punctuation">,</span>
    <span class="token operator">&lt;</span>表级完整性约束条件<span class="token operator">></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个定义方式需要解释一下:</p><ul><li>列名: 就是你自己定义的 <strong>属性名</strong> .</li><li>数据类型: 你希望用什么数据类型来表示这一个属性.<ul><li>全部的数据类型实在太多了, 我们下面会给一个表.</li></ul></li><li>列级完整性约束条件: 其实就是这一列需要满足什么完整性条件<ul><li>主键约束: PRIMARY KEY</li><li>唯一性约束: UNIQUE</li><li>非空值约束: NOT NULL</li><li>取值范围的规定等</li></ul></li><li>表级完整性约束条件: 对于这一整个表(包括其中有些元素), 需要满足什么完整性条件<ul><li>外键的定义</li><li>主键如果不是某个属性, 而是一个属性集合, 则需要在这里定义</li></ul></li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png alt=常用数据类型></p><p>我们这里给个例子:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> SC
<span class="token punctuation">(</span>
    Sno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Cno <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    Grade <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span>
    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Cno<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">/* 主码由两个属性构成，必须作为表级完整性进行定义*/</span>
    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Sno<span class="token punctuation">)</span> <span class="token keyword">REFERENCES</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">/* 表级完整性约束条件，Sno是外码，被参照表是Student */</span>
    <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>Cno<span class="token punctuation">)</span><span class="token keyword">REFERENCES</span> Course<span class="token punctuation">(</span>Cno<span class="token punctuation">)</span>
    <span class="token comment">/* 表级完整性约束条件，Cno是外码，被参照表是Course*/</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=3-2-2-2-基本表的修改><a href=#3-2-2-2-基本表的修改 class=headerlink title="3.2.2.2 基本表的修改"></a>3.2.2.2 基本表的修改</h4><p>修改基本表用 <strong>ALTER</strong> 关键字来进行.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>
    <span class="token punctuation">[</span> <span class="token keyword">ADD</span> <span class="token punctuation">[</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">]</span> <span class="token operator">&lt;</span>新列名<span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">[</span> 完整性约束 <span class="token punctuation">]</span> <span class="token punctuation">]</span>
    <span class="token punctuation">[</span> <span class="token keyword">ADD</span> <span class="token operator">&lt;</span>表级完整性约束<span class="token operator">></span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span> <span class="token keyword">DROP</span> <span class="token punctuation">[</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">CASCADE</span><span class="token operator">|</span> <span class="token keyword">RESTRICT</span><span class="token punctuation">]</span> <span class="token punctuation">]</span>
    <span class="token punctuation">[</span> <span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span><span class="token operator">&lt;</span>完整性约束名<span class="token operator">></span> <span class="token punctuation">]</span>
    <span class="token punctuation">[</span><span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">]</span> <span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解释一下:</p><ul><li>ADD就不说了, 跟上面的定义基本上是一样的.</li><li>DROP用于删除原有表中的一些东西:<ul><li>删除某个属性(列)的时候, 可以用两种关键字:<ul><li>CASCADE: 把这列删了, 外面如果有引用这一列的对象, 也删了.</li><li>RESTRICT: 如果外面有引用这一列的对象, 则禁止删除这列.</li></ul></li><li>用于删除某个完整性约束的时候, 直接删除即可.</li></ul></li><li>ALTER用于修改原有的列定义.</li></ul><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>虽然SQL标准定义上说删除列的时候可以用CASCADE关键字, 但是事实上, 大部分数据库对于外键引用是要单独处理的.<br>即只要有外键引用就不允许删除该列.</p></blockquote><h4 id=3-2-2-3-删除基本表><a href=#3-2-2-3-删除基本表 class=headerlink title="3.2.2.3 删除基本表"></a>3.2.2.3 删除基本表</h4><p>删除基本表与删除模式很类似:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">RESTRICT</span><span class="token operator">|</span> <span class="token keyword">CASCADE</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>使用CASCADE则会一并删除所有引用改表的对象.<br>使用RESTRICT, 则如果这个被删除的表还有别的引用关系, 就拒绝删除, 报错.</p><h3 id=3-2-3-索引的相关定义语言><a href=#3-2-3-索引的相关定义语言 class=headerlink title="3.2.3 索引的相关定义语言"></a>3.2.3 索引的相关定义语言</h3><p><strong>索引</strong> 是个啥?<br>引入这个玩意的意义很简单, 就是要增加对指定属性的搜索速度.</p><p>通常而言, 数据库系统会把怎么建立索引, 具体实现等方式都包了, 而只需要用户给一句建立语句即可.<br>并且, 有些数据库会自动为主键完整性(PRIMARY KEY) &#x2F; 唯一完整性(UNIQUE)的属性建立索引.</p><p>常见的索引包括:</p><ul><li>B &#x2F; B+树索引</li><li>散列(Hash)索引</li><li>顺序文件索引</li><li>位图索引</li></ul><h4 id=3-2-3-1-索引的创建><a href=#3-2-3-1-索引的创建 class=headerlink title="3.2.3.1 索引的创建"></a>3.2.3.1 索引的创建</h4><p>SQL中索引通常这样创建:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>CLUSTER<span class="token punctuation">]</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">></span>
<span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">[</span><span class="token operator">&lt;</span>次序<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">[</span><span class="token operator">&lt;</span>次序<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>解释一下:</p><ul><li>&lt;次序&gt; : 指定索引值的排列次序<ul><li>升序: ASC</li><li>降序: DESC</li><li>缺省值: ASC(升序)</li></ul></li><li>可以选择两种关键字:<ul><li>UNIQUE: 每个索引值只对应唯一的数据记录</li><li>CLUSTER: 建立聚簇索引</li></ul></li></ul><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>聚簇索引类似于将数据分组, 每组建立一个索引值.<br>对于范围查找的情况效率会远高于唯一索引.</p><p>但是聚簇索引有其局限性:</p><ul><li>一个基本表上只能有一个聚簇索引</li><li>经常更新的属性上不适合建立聚簇索引(排序和重组织代价高)</li><li>已有大规模数据表中建立聚簇索引的代价很高</li></ul></blockquote><h4 id=3-2-3-2-索引的修改><a href=#3-2-3-2-索引的修改 class=headerlink title="3.2.3.2 索引的修改"></a>3.2.3.2 索引的修改</h4><p>修改索引比较简单, 只能修改索引名:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">ALTER</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>旧索引名<span class="token operator">></span> <span class="token keyword">RENAME</span> <span class="token keyword">TO</span> <span class="token operator">&lt;</span>新索引名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><h4 id=3-2-3-3-索引的删除><a href=#3-2-3-3-索引的删除 class=headerlink title="3.2.3.3 索引的删除"></a>3.2.3.3 索引的删除</h4><p>删除索引也很简单:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><h3 id=3-2-4-数据字典><a href=#3-2-4-数据字典 class=headerlink title="3.2.4 数据字典"></a>3.2.4 数据字典</h3><p>我们之前的章节中提过这个玩意, 现在了解完数据定义语言之后, 可以再把这个东西拿出来了.<br>它记录了数据库中所有定义信息:</p><ul><li>关系模式</li><li>视图</li><li>索引</li><li>完整性约束</li><li>操作权限</li><li>统计信息</li></ul><p>执行数据定义语言时, 实际上就是在更新数据字典表内的相关信息.</p><h2 id=3-3-数据查询语言-QL><a href=#3-3-数据查询语言-QL class=headerlink title="3.3 数据查询语言 QL"></a>3.3 数据查询语言 QL</h2><p>SQL中, 数据查询这个事情是最复杂的, 它涉及到很多很多的额外机制.<br>但在开始介绍之前, 我们先要把最基本的结构搞明白:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> A1<span class="token punctuation">,</span> A2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> An
<span class="token keyword">FROM</span> R1<span class="token punctuation">,</span> R2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> Rn
<span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>查询条件表达式<span class="token operator">></span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><h3 id=3-3-1-单表查询><a href=#3-3-1-单表查询 class=headerlink title="3.3.1 单表查询"></a>3.3.1 单表查询</h3><p>单表查询是比较简单的情况, 查询只涉及到一个表.</p><h4 id=3-3-1-1-选择表中的若干列><a href=#3-3-1-1-选择表中的若干列 class=headerlink title="3.3.1.1 选择表中的若干列"></a>3.3.1.1 选择表中的若干列</h4><p>就是把指定的属性拿出来单成一个表:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Sname
<span class="token keyword">FROM</span> Student<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>特殊的, 如果要直接把所有列都拿出来, 可以这么写:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><p>当然, 时至今日, 查询还可以支持一些别的机制, 比如:</p><ul><li>查询经过计算的值 &#x2F; 经过函数处理的值</li><li>单独多加一个常量</li><li>改变列的标题</li></ul><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%20%E9%A2%9D%E5%A4%96%E6%9C%BA%E5%88%B6.png alt=单表查询-额外机制></p><h4 id=3-3-1-2-选择表中的若干元组><a href=#3-3-1-2-选择表中的若干元组 class=headerlink title="3.3.1.2 选择表中的若干元组"></a>3.3.1.2 选择表中的若干元组</h4><p>可以通过如下写法来选择表中的若干元组:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span> <span class="token operator">|</span> <span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>这里的关键字:</p><ul><li>ALL: 缺省值, 代表着直接全部取出, 不做处理</li><li>DISTINCT: 会对取出的表项做去重处理</li></ul><hr><p>当然, 如果只能这么拿, 未免显得太简陋了.<br>SQL支持通过使用条件表达式来进行条件筛选的拿法:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span> <span class="token operator">|</span> <span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">]</span> …
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span> <span class="token punctuation">]</span>…
<span class="token punctuation">[</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span> <span class="token punctuation">]</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6.png alt=常用的查询条件></p><p>只给出这么一张表未免太生硬了点, 我们给几个常用的例子:</p><ul><li>比较大小:</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span>‘CS’<span class="token punctuation">;</span> <span class="token comment">//专业是CS</span>
<span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;</span><span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">//年龄小于20</span>
<span class="token keyword">WHERE</span> Grade<span class="token operator">&lt;</span><span class="token number">60</span><span class="token punctuation">;</span> <span class="token comment">//成绩小于60</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><ul><li>确定范围:</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">WHERE</span> Sage <span class="token operator">BETWEEN</span> <span class="token number">20</span> <span class="token operator">AND</span> <span class="token number">23</span><span class="token punctuation">;</span> <span class="token comment">//年龄在20~23之间</span>
<span class="token keyword">WHERE</span> Sage<span class="token operator">>=</span><span class="token number">20</span> <span class="token operator">AND</span> Sage<span class="token operator">&lt;=</span><span class="token number">23</span><span class="token punctuation">;</span> <span class="token comment">//与上文同义</span>

<span class="token keyword">WHERE</span> Sage <span class="token operator">NOT</span> <span class="token operator">BETWEEN</span> <span class="token number">20</span> <span class="token operator">AND</span> <span class="token number">23</span><span class="token punctuation">;</span> <span class="token comment">//年龄不在20~23之内</span>
<span class="token keyword">WHERE</span> Sage<span class="token operator">&lt;</span><span class="token number">20</span> <span class="token operator">OR</span> Sage<span class="token operator">></span><span class="token number">23</span><span class="token punctuation">;</span> <span class="token comment">//与上文同义</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>确定集合:</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">WHERE</span> Sdept <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'CS'</span><span class="token punctuation">,</span><span class="token string">'IS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//专业取值在集合('CS', 'IS')内</span>
<span class="token keyword">WHERE</span> Sdept<span class="token operator">=</span><span class="token string">'CS'</span> <span class="token operator">OR</span> Sdept<span class="token operator">=</span><span class="token string">'IS'</span><span class="token punctuation">;</span> <span class="token comment">//与上文同义</span>

<span class="token keyword">WHERE</span> Sdept <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'IS'</span><span class="token punctuation">,</span><span class="token string">'CS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//专业取值不在集合('CS', 'IS')内</span>
<span class="token keyword">WHERE</span> Sdept<span class="token operator">!=</span><span class="token string">'CS'</span> <span class="token operator">AND</span> Sdept<span class="token operator">!=</span><span class="token string">'IS'</span><span class="token punctuation">;</span> <span class="token comment">//与上文同义</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>字符匹配:</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token punctuation">[</span><span class="token operator">NOT</span><span class="token punctuation">]</span> <span class="token operator">LIKE</span> ‘<span class="token operator">&lt;</span>匹配串<span class="token operator">></span>’ <span class="token punctuation">[</span><span class="token keyword">ESCAPE</span> ‘ <span class="token operator">&lt;</span>换码字符<span class="token operator">></span>’<span class="token punctuation">]</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><hr><p>这里这个匹配串需要提一下:<br>它可以是一个完整的字符串, 也可以含有通配符 <strong>%</strong> 和 <strong>_</strong> .</p><p>其中 <strong>%</strong> 可以代指任意长度的字符串; <strong>_</strong> 则只能代指任意单个字符.</p><p>比如: a%b 在系统中可以代指以a开头, 以b结尾的任何字符串.</p><hr><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">WHERE</span> Sno <span class="token operator">LIKE</span> <span class="token string">'202215121'</span><span class="token punctuation">;</span> <span class="token comment">//学号为202215121的元组</span>
<span class="token keyword">WHERE</span> Sno <span class="token operator">=</span> <span class="token string">' 202215121 '</span><span class="token punctuation">;</span> <span class="token comment">//与上文同义</span>

<span class="token keyword">WHERE</span> Sname <span class="token operator">LIKE</span> <span class="token string">'刘%'</span><span class="token punctuation">;</span> <span class="token comment">//姓刘的所有元组</span>
<span class="token keyword">WHERE</span> Sname <span class="token operator">NOT</span> <span class="token operator">LIKE</span> <span class="token string">'刘%'</span><span class="token punctuation">;</span> <span class="token comment">//不姓刘的所有元组</span>
<span class="token keyword">WHERE</span> Sno <span class="token operator">LIKE</span> <span class="token string">'_0%'</span><span class="token punctuation">;</span> <span class="token comment">//学号第二位是0的所有元组</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>有个非常常见的问题了, 如果我要搜 <strong>%</strong> 和 <strong>_</strong> 字符呢?<br>后面那个 <strong>换码字符</strong> 就是这个意思: 自定义一个换码字符, 然后把它写成 <strong>&lt;换码字符&gt;%</strong> 和 <strong>&lt;换码字符&gt;_</strong></p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">WHERE</span> Cname <span class="token operator">LIKE</span> <span class="token string">'DB\_Design'</span> <span class="token keyword">ESCAPE</span> '\' <span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><ul><li>涉及空值的查询:</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">WHERE</span> Grade <span class="token operator">IS</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">WHERE</span> Grade <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><ul><li>多重条件查询: 就是把前面几种用谓词合并起来, 有 <strong>OR</strong> 和 <strong>AND</strong> 两种谓词.</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">WHERE</span> <span class="token punctuation">(</span>Ssex <span class="token operator">=</span> <span class="token string">'男'</span> <span class="token operator">OR</span> Sage <span class="token operator">></span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token operator">AND</span> Sdept <span class="token operator">=</span> <span class="token string">'IS'</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><h4 id=3-3-1-3-按照查询结果排序-ORDER-BY><a href=#3-3-1-3-按照查询结果排序-ORDER-BY class=headerlink title="3.3.1.3 按照查询结果排序 ORDER BY"></a>3.3.1.3 按照查询结果排序 ORDER BY</h4><p>如标题所说, 这个子句是来解决按照查询结果属性列来排序的.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span> <span class="token operator">|</span> <span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">]</span> …
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span> <span class="token punctuation">]</span>…
<span class="token punctuation">[</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span> <span class="token punctuation">[</span> <span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>可以按照一个 &#x2F; 多个属性列排序, 排序与建索引的时候的关键字同义, ASC表升序, DESC表降序.</p><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>对于升序, 会将NULL排在最后; 对于降序, 会将NULL排在最前.</p></blockquote><p>给个例子:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Sdept<span class="token punctuation">,</span> Sno <span class="token keyword">DESC</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>意思是会按照学生专业升序, 学号降序排列查询结果.</p><h4 id=3-3-1-4-聚集函数><a href=#3-3-1-4-聚集函数 class=headerlink title="3.3.1.4 聚集函数"></a>3.3.1.4 聚集函数</h4><p>聚集函数其实就是对表中的一些基本信息进行统计, 并显示出来的.<br>它的查询目的不在于某个具体的元组 &#x2F; 属性, 而在于整个表的一些总体统计数据.</p><p>常见的聚集函数包括:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token comment">//统计元组个数</span>
<span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span> <span class="token comment">//统计一个列中值的个数</span>
<span class="token function">SUM</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span> <span class="token comment">//一列值的总和</span>
<span class="token function">AVG</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span> <span class="token comment">//一列值的平均值</span>
<span class="token function">MAX</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span> <span class="token comment">//一列值的最大值</span>
<span class="token function">MIN</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">DISTINCT</span><span class="token operator">|</span><span class="token keyword">ALL</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">)</span> <span class="token comment">//一列值的最小值</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举几个例子:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC <span class="token comment">//选课表</span>
<span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'2'</span><span class="token punctuation">;</span>
<span class="token comment">//选修2号课程学生的平均成绩</span>

<span class="token keyword">SELECT</span> <span class="token function">MAX</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'2'</span><span class="token punctuation">;</span>
<span class="token comment">//选修2号课程学生的最高 / 最低成绩</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>聚集函数不能用在WHERE的条件语句中, 如果希望利用聚集函数做筛选, 则需要使用下面讲到的GROUP BY语句.</p></blockquote><h4 id=3-3-1-5-分组子句-GROUP-BY-HAVING><a href=#3-3-1-5-分组子句-GROUP-BY-HAVING class=headerlink title="3.3.1.5 分组子句 GROUP BY &#x2F; HAVING"></a>3.3.1.5 分组子句 GROUP BY &#x2F; HAVING</h4><p>分组子句的出现意义其实在于细化聚集函数的作用域. 这句话啥意思呢?</p><p>我们考虑上面说过的情况, 如果我们就是希望查询每一门课程的平均成绩, 怎么办?<br>我们会发现好像写不出来一个很高效的子句, 总不能一个个WHERE吧.<br>GROUP BY相当于为查询结果提供了一个分组依据, 尝试将查询结果 <strong>按照某一列</strong> 分组, 这样聚集函数就可以分别作用在它们的上面, 而不是整个查询结果上面.</p><p>考虑这个例子:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Cno<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>Sno<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Cno<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><ul><li>要什么? 课程号和对于学生号的计数.</li><li>从哪选? 选课表SC中选.</li><li>怎么分组? 按照课程号分组.</li></ul><p>那意思很明确了, 我查的就是每门课程选修的学生数目.</p><hr><p>到这里, 可能读者有个想法, 我能不能用聚集函数来作为筛选条件? 比如筛选出平均分80以上的学生?<br>可以, 但是这里需要用到的子句不是WHERE, 而是GROUP BY的HAVING.<br>我们先看错误案例:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">WHERE</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">80</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>它看起来语义没什么问题, 但是犯了个很严重的错误, <strong>聚集函数不能用在WHERE子句中</strong> .</p></blockquote><p>正确写法是这样:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno
<span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">80</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>读者可以这样理解 WHERE 与 HAVING的区别:</p><ul><li>WHERE作用于整个表 &#x2F; 整个视图上, 这个作用域是变不了的.</li><li>HAVING作用于根据GROUP BY分出来的每个分组上.</li></ul><p>在明确了以上内容后, 我们给出GROUP BY语句的通用形式:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span> <span class="token operator">|</span> <span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">]</span> …
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span> <span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span> <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span> <span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span> <span class="token punctuation">]</span> <span class="token punctuation">]</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><h4 id=3-3-1-6-限制查询结果的元组数量-LIMIT><a href=#3-3-1-6-限制查询结果的元组数量-LIMIT class=headerlink title="3.3.1.6 限制查询结果的元组数量 LIMIT"></a>3.3.1.6 限制查询结果的元组数量 LIMIT</h4><p>这玩意乍看有点无厘头, 但是如果跟前面我们提过的 ORDER BY 组合起来看就好了, 它可以只展示某一个排名范围内的查询结果.</p><p>其标准语法如下:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">LIMIT</span> <span class="token operator">&lt;</span>行数<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">OFFSET</span> <span class="token operator">&lt;</span>行数<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>含义为:</p><ul><li>取 行数1 行的元组.</li><li>忽略前 行数2 的元组.</li></ul><p>举个例子, 我们要课程2中成绩排名3~7名的学生学号和姓名:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> Sname
<span class="token keyword">FROM</span> SC
<span class="token keyword">WHERE</span> Cno <span class="token operator">=</span> <span class="token string">'2'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Grade
<span class="token keyword">LIMIT</span> <span class="token number">5</span> <span class="token keyword">OFFSET</span> <span class="token number">2</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=3-3-2-连接查询><a href=#3-3-2-连接查询 class=headerlink title="3.3.2 连接查询"></a>3.3.2 连接查询</h3><p>上面讲了很多, 但读者仔细想想其实都是针对一个表的查询操作, 现在我们要更进一步, 针对多个表进行同时查询.<br>哎, 这就想起来了, 上一章我们好像叨叨过一个叫做连接的运算, 忘记的读者回去看看哈. <a target=_blank rel=noopener href=https://mug-chen.site/posts/51988.html#2-4-7-%E8%BF%9E%E6%8E%A5-bowtie>连接</a></p><h4 id=3-3-2-1-等值-非等值连接查询><a href=#3-3-2-1-等值-非等值连接查询 class=headerlink title="3.3.2.1 等值 &#x2F; 非等值连接查询"></a>3.3.2.1 等值 &#x2F; 非等值连接查询</h4><p>我们考虑这么一种情况, 我们要所有学生的选课情况以及其全部信息:<br>我们要做的, 首先是要考虑将数据源扩展成两个表(学生表Student, 选课表SC)<br>其次是要将学生表中学号与选课表学号相同的表项连起来.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span> SC<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png alt=等值连接查询></p><p>挺好, 但是我们会发现, 由于采用的是等值连接, 它不会自动去掉重复列.<br>这导致学号被显示了两次, 有点愣愣的.</p><p>因此其实我们完全可以用自然连接的方式来做这个事情:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span> Sname<span class="token punctuation">,</span> Ssex<span class="token punctuation">,</span> Sage<span class="token punctuation">,</span> Sdept<span class="token punctuation">,</span> Cno<span class="token punctuation">,</span> Grade
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>相当于去掉了相同的属性列对吧.</p><p>对了, 这里读者别被连接限制住了思想, 我们仍然可以在连接后面加一些别的筛选条件:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span> Sname
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> SC<span class="token punctuation">.</span>Cno <span class="token operator">=</span> <span class="token string">'2'</span> <span class="token operator">AND</span> SC<span class="token punctuation">.</span>Grade <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><hr><p>在这一小节的最后说一下当前数据库对于这种连接采取的主要三种方法:</p><ul><li>嵌套循环法(NESTED-LOOP): 就是两层循环嵌套, 对于表1的一个元组, 会依次扫描表2的每个表项进行连接操作. 从算法时间复杂度的角度来看, 这种是最慢的( $ n^2 $ )</li><li>排序合并法(SORT-MERGE): 类似于排序算法中的 <strong>归并排序</strong> , 它先将两个表按照指定连接列进行排序, 随后再归并即可.</li><li>索引连接(INDEX-JOIN): 对两个表的指定连接列都建立索引, 随后按照索引范围来建立符合条件的连接.</li></ul><h4 id=3-3-2-2-自身连接><a href=#3-3-2-2-自身连接 class=headerlink title="3.3.2.2 自身连接"></a>3.3.2.2 自身连接</h4><p>自身连接很好理解, 我自己跟自己需要建立连接展示某种关系对吧.<br>这种跟上面直接连接又一点点区别, 即这次连接的两个表是同一个名字, 因此需要做区分:<br>考虑这个例子: 查询每门课的间接先修课</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token keyword">FIRST</span><span class="token punctuation">.</span>Cno<span class="token punctuation">,</span> <span class="token keyword">SECOND</span><span class="token punctuation">.</span>Cno
<span class="token keyword">FROM</span> Course <span class="token keyword">FIRST</span><span class="token punctuation">,</span> Course <span class="token keyword">SECOND</span>
<span class="token keyword">WHERE</span> <span class="token keyword">FIRST</span><span class="token punctuation">.</span>Cpno <span class="token operator">=</span> <span class="token keyword">SECOND</span><span class="token punctuation">.</span>Cno  <span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E8%87%AA%E8%BA%AB%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png alt=自身连接查询></p><h4 id=3-3-2-3-外连接><a href=#3-3-2-3-外连接 class=headerlink title="3.3.2.3 外连接"></a>3.3.2.3 外连接</h4><p>外连接这个概念我们在之前的连接运算中写过, 就是保留左边 &#x2F; 右边 &#x2F; 两边不符合连接要求的表项, 并将对应的对方表项填成NULL.<br>在SQL中, 这个连接方式用 <strong>OUTER JOIN</strong> 表示.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span>
<span class="token comment">//列出左边表中所有的元组</span>

<span class="token keyword">RIGHT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span>
<span class="token comment">//列出右边表中所有的元组</span>

<span class="token keyword">FULL</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span>
<span class="token comment">//列出所有表中所有的元组</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看这个例子: 查询所有选课学生的信息, 包括没选课的学生.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span> Sname<span class="token punctuation">,</span> Ssex<span class="token punctuation">,</span> Sage<span class="token punctuation">,</span> Sdept<span class="token punctuation">,</span> Cno<span class="token punctuation">,</span> Grade
<span class="token keyword">FROM</span> Student <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> SC
<span class="token keyword">ON</span> <span class="token punctuation">(</span>Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno<span class="token punctuation">)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%A4%BA%E4%BE%8B.png alt=外连接查询></p><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>细心的读者应该看到了, 这里使用的关键词是 <strong>ON</strong> , 不是 <strong>WHERE</strong> .<br>因为 WHERE 本质上做的是一个过滤操作, 而 OUTER JOIN 恰恰不需要这个过滤操作.<br>这里还请读者记忆一下.</p></blockquote><h4 id=3-3-2-4-多表查询><a href=#3-3-2-4-多表查询 class=headerlink title="3.3.2.4 多表查询"></a>3.3.2.4 多表查询</h4><p>这个就很简单了, 只需要把多个表都写到FROM里面就行:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span> Sname<span class="token punctuation">,</span> Cname<span class="token punctuation">,</span> Grade
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC<span class="token punctuation">,</span> Course <span class="token comment">/*多表连接*/</span>
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> SC<span class="token punctuation">.</span>Cno <span class="token operator">=</span> Course<span class="token punctuation">.</span>Cno<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><hr><p>博主大概能知道读者的感受, 这玩意其实初看是有点乱的, 得多用.<br>来, 看俩例子回顾理解一下:</p><p>(1) 查询选修课程号2或4课程的学生学号和姓名, 写出关系代数表达式和SQL语句.</p><p>关系代数表达式: $ \pi_{Sno, Sname}(\sigma_{Cno &#x3D; ‘2’ \lor Cno &#x3D; ‘4’}(Student \bowtie SC)) $</p><p>SQL:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span> Sname
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> <span class="token punctuation">(</span>SC<span class="token punctuation">.</span>Cno<span class="token operator">=</span><span class="token string">'2'</span> <span class="token operator">OR</span> SC<span class="token punctuation">.</span>Cno<span class="token operator">=</span><span class="token string">'4'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>(2) 查询平均成绩80分以上的女生姓名（假设姓名不重复）, 写出关系代数表达式和SQL语句.</p><p>关系代数表达式: $ \pi_{Sname}(\sigma_{Avg(Grade)&gt;80 \land Ssex &#x3D; ‘女’}(Student \bowtie SC)) $</p><p>SQL:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sname
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span> SC
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> Ssex <span class="token operator">=</span> <span class="token string">'女'</span>
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Student<span class="token punctuation">.</span>Sname
<span class="token keyword">HAVING</span> <span class="token function">AVG</span><span class="token punctuation">(</span>SC<span class="token punctuation">.</span>Grade<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">80</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=3-3-3-嵌套查询><a href=#3-3-3-嵌套查询 class=headerlink title="3.3.3 嵌套查询"></a>3.3.3 嵌套查询</h3><p>我们之前说了一个标准的查询语句结构:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span>
<span class="token keyword">FROM</span>
<span class="token keyword">WHERE</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>它能起到一个筛选的作用, 将已有的模式转化成一个虚拟的表.<br>既然是这样, 那理论上这个虚拟的表也可以进行查询啊, 这就引出了我们嵌套查询的概念:</p><p><em>将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询，允许多层嵌套查询</em> .</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2.png alt=嵌套查询></p><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>子查询不能使用ORDER BY语句, 这点还请读者着重注意!</p></blockquote><h4 id=3-3-3-1-带有-IN-谓词的嵌套查询><a href=#3-3-3-1-带有-IN-谓词的嵌套查询 class=headerlink title="3.3.3.1 带有 IN 谓词的嵌套查询"></a>3.3.3.1 带有 IN 谓词的嵌套查询</h4><p>经常使用 IN 谓词来表示不相关子查询(即子查询可以自行运行, 与父查询无关).<br>这种查询其实是一个将查询分步的思想:</p><p>看这个例子: 查询与 “刘晨” 在同一个系学习的学生.<br>我们把这个查询分成两步:</p><ul><li>查询 “刘晨” 所在系</li><li>查询在这个系内的学生.</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token comment">//Step 1</span>
<span class="token keyword">SELECT</span> Sdept
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sname <span class="token operator">=</span> <span class="token string">'刘晨'</span>

<span class="token comment">//Step 2</span>
<span class="token keyword">SELECT</span> Student<span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sname <span class="token operator">IN</span> <span class="token punctuation">(</span> Step <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//两步合一块</span>
<span class="token keyword">SELECT</span> Student<span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">IN</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> Sdept
  <span class="token keyword">FROM</span> Student
  <span class="token keyword">WHERE</span> Sname <span class="token operator">=</span> <span class="token string">'刘晨'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=3-3-3-2-带比较运算符的嵌套查询><a href=#3-3-3-2-带比较运算符的嵌套查询 class=headerlink title="3.3.3.2 带比较运算符的嵌套查询"></a>3.3.3.2 带比较运算符的嵌套查询</h4><p>这种查询其实是条件筛选查询的一种特殊情况. 当我们明确查询结果是 <strong>一个</strong> 明确的值时, 自然可以使用比较运算符号来进行查询:</p><p>看这个例子: 找出每个学生超过他选修课程平均成绩的课程号.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> Cno
<span class="token keyword">FROM</span> SC x
<span class="token keyword">WHERE</span> x<span class="token punctuation">.</span>Grade <span class="token operator">>=</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>Grade<span class="token punctuation">)</span>
  <span class="token keyword">FROM</span> SC y
  <span class="token keyword">WHERE</span> y<span class="token punctuation">.</span>Sno <span class="token operator">=</span> x<span class="token punctuation">.</span>Sno
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=3-3-3-3-带-ANY-SOME-ALL-的子查询><a href=#3-3-3-3-带-ANY-SOME-ALL-的子查询 class=headerlink title="3.3.3.3 带 ANY(SOME) &#x2F; ALL 的子查询"></a>3.3.3.3 带 ANY(SOME) &#x2F; ALL 的子查询</h4><p>这俩谓词是对比较运算符的一种扩展: 简而言之, ANY(SOME)就是对子查询中的结果取 <strong>或</strong> 关系, 而ALL则是取 <strong>与</strong> 关系.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token operator">></span> <span class="token keyword">ANY</span> <span class="token comment">//大于子查询结果中的某个值</span>
<span class="token operator">></span> <span class="token keyword">ALL</span> <span class="token comment">//大于子查询结果中的所有值</span>
<span class="token operator">=</span> <span class="token keyword">ANY</span> <span class="token comment">//等于子查询结果中的某个值</span>
<span class="token operator">=</span> <span class="token keyword">ALL</span> <span class="token comment">//等于子查询结果中的所有值(通常没有意义)</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>其它的运算符我们就不写了, 相信读者能够理解这俩的作用.</p><hr><p>这里其实可以提一句, 大部分的ANY和ALL其实都可以通过我们之前说过的 <strong>聚集函数</strong> 来实现.<br>举个例子: 查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名及年龄。</p><p>如果我们用ALL:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> x<span class="token punctuation">.</span>Sname<span class="token punctuation">,</span> x<span class="token punctuation">.</span>Sage
<span class="token keyword">FROM</span> Student x
<span class="token keyword">WHERE</span> x<span class="token punctuation">.</span>Sage <span class="token operator">&lt;</span> <span class="token keyword">ALL</span><span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> y<span class="token punctuation">.</span>Sage
  <span class="token keyword">FROM</span> Student y
  <span class="token keyword">WHERE</span> y<span class="token punctuation">.</span>Sdept <span class="token operator">=</span> <span class="token string">'CS'</span>
<span class="token punctuation">)</span> <span class="token operator">AND</span> x<span class="token punctuation">.</span>Sdept <span class="token operator">!=</span> <span class="token string">'CS'</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是其实这个玩意完全可以用聚集函数来解决:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> x<span class="token punctuation">.</span>Sname<span class="token punctuation">,</span> x<span class="token punctuation">.</span>Sage
<span class="token keyword">FROM</span> Student x
<span class="token keyword">WHERE</span> x<span class="token punctuation">.</span>Sage <span class="token operator">&lt;</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>Sage<span class="token punctuation">)</span>
  <span class="token keyword">FROM</span> Student y
  <span class="token keyword">WHERE</span> y<span class="token punctuation">.</span>Sdept <span class="token operator">=</span> <span class="token string">'CS'</span>
<span class="token punctuation">)</span> <span class="token operator">AND</span> x<span class="token punctuation">.</span>Sdept <span class="token operator">!=</span> <span class="token string">'CS'</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=3-3-3-4-带有-EXISTS-谓词的子查询><a href=#3-3-3-4-带有-EXISTS-谓词的子查询 class=headerlink title="3.3.3.4 带有 EXISTS 谓词的子查询"></a>3.3.3.4 带有 EXISTS 谓词的子查询</h4><p>EXISTS, 即存在量词 $ \exists $ 的意思. 它的子查询很有意思, 不会返回任何具体的元组, 而是只看有没有结果返回真值.<br>如果查询结果为空, 就返回false; 反之, 则返回true.</p><p>举个例子读者大概能明白: 查询所有选修了1号课程的学生姓名.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> s<span class="token punctuation">.</span>Sname
<span class="token keyword">FROM</span> Student s
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> <span class="token operator">*</span>
  <span class="token keyword">FROM</span> SC sc
  <span class="token keyword">WHERE</span> sc<span class="token punctuation">.</span>Sno <span class="token operator">=</span> S<span class="token punctuation">.</span>sno <span class="token operator">AND</span> sc<span class="token punctuation">.</span>Cno <span class="token operator">=</span> <span class="token string">'1'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它相当于将学生表Student的每个元组提取出来, 放到另一个选课表SC中查, 找到满足条件的就返回true, 否则返回false. 外层根据内层返回的true &#x2F; false决定要不要输出这个学生的姓名.</p><hr><p>接下来会涉及到一个比较复杂的东西, 叫 <strong>全称量词</strong> . 这玩意烦就烦在数据库里面没实现这个东西, 因此我们只能用这个存在量词来实现它.</p><p>举个例子: 查询选修了全部课程的学生姓名.</p><p>我们先不写SQL呢, 先把这东西转成存在量词: 选修了全部课程 &#x3D;&gt; $ \neg $ 至少有一门课没选</p><p>所以就这么写:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> s<span class="token punctuation">.</span>Sname
<span class="token keyword">FROM</span> Student s
<span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> <span class="token operator">*</span>
  <span class="token keyword">FROM</span> Course c
  <span class="token keyword">WHERE</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token operator">*</span>
    <span class="token keyword">FROM</span> SC
    <span class="token keyword">WHERE</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">=</span> s<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> c<span class="token punctuation">.</span>Cno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Cno
  <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一大串非常不好理解, 我们解释一下:<br>读者可以把外层的SELECT FROM理解成循环, 我们从里向外看:</p><ul><li>最内层: 这个双层循环当前的学生选了当前这个课程.</li><li>次外层: 存在有一个课程, 当前最外层的学生没有选这个课程.</li><li>最外层: 存在这么个学生, 这个学生没有 <strong>没有选的课程</strong> .</li></ul><p>这我们就表示出来了全称量词, 我去, 这可真费劲.</p><hr><p><strong>有没有一种更加简单的方法来模拟全称代词?</strong><br>有的, 兄弟, 有的.</p><p>我们通常可以用计数的方式来模拟全称代词, 比如把上面那一坨简化成:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> S<span class="token punctuation">.</span>Sno
<span class="token keyword">FROM</span> SC S
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> S<span class="token punctuation">.</span>Sno
<span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token keyword">DISTINCT</span> S<span class="token punctuation">.</span>Cno<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> Course<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span></span></code></pre><p>我选修的课程数目跟课程数总量一样, 那不就是我选了所有的课程嘛?<br>就是这么个理.</p><h3 id=3-3-4-集合查询><a href=#3-3-4-集合查询 class=headerlink title="3.3.4 集合查询"></a>3.3.4 集合查询</h3><p>集合查询就是我们之前讲的几个基本运算, SQL中给的集合查询语句包括:</p><ul><li>并集: UNION</li><li>交集: INTERSECT</li><li>差集: EXCEPT</li></ul><p>但是集合查询有严格的限制, 即对应的表列数(也可以说目数)必须相同, 对应的列数据结构还要一致.</p><h4 id=3-3-4-1-并集-UNION><a href=#3-3-4-1-并集-UNION class=headerlink title="3.3.4.1 并集 UNION"></a>3.3.4.1 并集 UNION</h4><p>直接给例子了: 查询计算机科学系的学生及年龄不大于19岁的学生.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span>
<span class="token keyword">UNION</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sage <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是一个OR的事情:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span> <span class="token operator">OR</span> Sage <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>UNION会自动去除重复的元组, 而 UNION ALL不会.</p></blockquote><h4 id=3-3-4-2-交集-INTERSECT><a href=#3-3-4-2-交集-INTERSECT class=headerlink title="3.3.4.2 交集 INTERSECT"></a>3.3.4.2 交集 INTERSECT</h4><p>直接给例子:查询计算机科学系并且年龄不大于19岁的学生.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span>
<span class="token keyword">INTERSECT</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sage <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实就是一个AND的事情:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span> <span class="token operator">AND</span> Sage <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><h4 id=3-3-4-3-差集-EXCEPT><a href=#3-3-4-3-差集-EXCEPT class=headerlink title="3.3.4.3 差集 EXCEPT"></a>3.3.4.3 差集 EXCEPT</h4><p>查询计算机科学系的学生与年龄不大于19岁的学生的差集.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span>
<span class="token keyword">EXCEPT</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sage <span class="token operator">&lt;=</span> <span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上, A-B不就是 $ A \cap \overline{B} $ 嘛, 也就是计算机科学系大于19岁的学生:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span> <span class="token operator">AND</span> Sage <span class="token operator">></span> <span class="token number">19</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><h3 id=3-3-5-基于派生表的查询><a href=#3-3-5-基于派生表的查询 class=headerlink title="3.3.5 基于派生表的查询"></a>3.3.5 基于派生表的查询</h3><p>啥叫派生表呢, 就是在 FROM 那里先构建一个表, 然后在这个虚拟的派生表里面查.</p><p>还是举例子吧: 找出每个学生超过他自己选修课程平均成绩的课程号</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> Cno
<span class="token keyword">FROM</span> SC<span class="token punctuation">,</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> <span class="token function">Avg</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
  <span class="token keyword">FROM</span> SC
  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno
<span class="token punctuation">)</span> <span class="token keyword">AS</span> Avg_sc<span class="token punctuation">(</span>avg_sno<span class="token punctuation">,</span>avg_grade<span class="token punctuation">)</span>
<span class="token keyword">WHERE</span> 
  SC<span class="token punctuation">.</span>Sno <span class="token operator">=</span> Avg_sc<span class="token punctuation">.</span>avg_sno <span class="token operator">AND</span>
  SC<span class="token punctuation">.</span>Grade <span class="token operator">>=</span>Avg_sc<span class="token punctuation">.</span>avg_grade<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子其实在嵌套查询里面出现过, 读者可以去看看对比一下哈.</p><p>我们发现这里后面加了一个 Avg_sc(avg_sno,avg_grade), 这是为啥?<br>我们这个操作相当于新建了一个表, 因此也必然需要给这个表赋表名和列名对吧.</p><p>当然, SQL还是很智能的, 如果没有用聚集函数, 那么不加列名也可以, SQL会使用子查询中SELECT中的名字自动当成新表列的名字.</p><h3 id=3-3-6-总结><a href=#3-3-6-总结 class=headerlink title="3.3.6 总结"></a>3.3.6 总结</h3><p>哎呀, 这查询语句不愧是最复杂的一部分, 基本上捋完了哈.<br>相信读者应该现在有点迷迷瞪瞪的, <del>笔者也是</del> .</p><p>给个总结:</p><p>SELECT语句的一般形式如下:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span><span class="token operator">|</span><span class="token keyword">DISTINCT</span><span class="token punctuation">]</span>
  <span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span> <span class="token punctuation">[</span>别名<span class="token punctuation">]</span> <span class="token punctuation">[</span> <span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span> <span class="token punctuation">[</span>别名<span class="token punctuation">]</span><span class="token punctuation">]</span> …
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span> <span class="token punctuation">[</span>别名<span class="token punctuation">]</span>
  <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span> <span class="token punctuation">[</span>别名<span class="token punctuation">]</span><span class="token punctuation">]</span> …
  <span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">SELECT</span>语句<span class="token operator">></span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token keyword">AS</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>别名<span class="token operator">></span>
<span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">HAVING</span><span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span> <span class="token keyword">LIMIT</span> <span class="token operator">&lt;</span>行数<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">OFFSET</span> <span class="token operator">&lt;</span>行数<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E7%9B%AE%E6%A0%87%E5%88%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%AF%E9%80%89%E5%BD%A2%E5%BC%8F.png alt=目标列表达式></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F.png alt="聚集函数的一般形式(只能在SELECT和GROUP BY里面用)"></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/WHERE%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F.png alt=WHERE表达式的一般形式></p><h2 id=3-4-数据操纵语言-DML><a href=#3-4-数据操纵语言-DML class=headerlink title="3.4 数据操纵语言 DML"></a>3.4 数据操纵语言 DML</h2><p>我们把最麻烦, 最多样的查询搞完了, 操纵语言就会显得简单许多.<br>主要针对的就是 <strong>增 &#x2F; 删 &#x2F; 改</strong> 操作</p><h3 id=3-4-1-插入数据><a href=#3-4-1-插入数据 class=headerlink title="3.4.1 插入数据"></a>3.4.1 插入数据</h3><p>插入数据一般分两种:</p><ul><li>单独插入一个元组</li><li>插入子查询结果</li></ul><p>有了查询的基础, 上面这两种应该都很好理解. 前者相当于单独插入一行, 后者一次插入多行.</p><h4 id=3-4-1-1-插入元组><a href=#3-4-1-1-插入元组 class=headerlink title="3.4.1.1 插入元组"></a>3.4.1.1 插入元组</h4><p>插入元组的通用语句格式为:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">INSERT</span>
<span class="token keyword">INTO</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>属性列<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token operator">&lt;</span>属性列<span class="token number">2</span> <span class="token operator">></span>…<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>常量<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>常量<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>从这个定义其实能看出来, 插入单个元组的时候有两种方式:</p><ul><li>你可以直接把属性列列上去, 然后按照你列的顺序在后面直接写要插入的常量</li><li>也可以直接不写属性列, 直接写常量. 但这种方式的前提是 <strong>你写的顺序必须跟表本身的顺序一致</strong> .</li></ul><p>针对两种情况分别举两个例子:</p><ul><li>显式写出属性顺序:</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">INSERT</span>
<span class="token keyword">INTO</span> Student <span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Ssex<span class="token punctuation">,</span>Sdept<span class="token punctuation">,</span>Sage<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'202215128'</span><span class="token punctuation">,</span> <span class="token string">'陈冬'</span><span class="token punctuation">,</span> <span class="token string">'男'</span><span class="token punctuation">,</span> <span class="token string">'IS'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><ul><li>隐式不写出属性顺序:</li></ul><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">INSERT</span>
<span class="token keyword">INTO</span> Student
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'202215126'</span><span class="token punctuation">,</span> <span class="token string">'张成民'</span><span class="token punctuation">,</span> <span class="token string">'男'</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'CS'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><hr><p>当然, 还有一种方式是你可以只显式的写出部分属性列, 并插入部分值.<br>这个时候其它属性列会自动填入默认值或者NULL.</p><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>要明确, 当你这个属性列未填入被设置成 NOT NULL的时候, 这样插入会报错的.<br>很好理解嘛, 你都说让它不空了, 还不填它, 那肯定出问题.</p></blockquote><p>给个例子:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">INSERT</span>
<span class="token keyword">INTO</span> SC<span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Cno<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'202215128'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>这样插入选课表, 会给选课表的 Grade 属性自动赋一个NULL.</p><h4 id=3-4-1-2-插入子查询结果><a href=#3-4-1-2-插入子查询结果 class=headerlink title="3.4.1.2 插入子查询结果"></a>3.4.1.2 插入子查询结果</h4><p>这种就相当于批量化插入, 或者插入若干个需要利用聚集函数来计算出的值.<br>这时候需要保证 <strong>SELECT目标列与INTO子句的属性列匹配</strong> .</p><p>比如我们要求每个系学生的平均年龄:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token comment">//Step1 建表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Dept_age&#123;
  Sdept <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span> <span class="token comment">//系名</span>
  Avg_age <span class="token keyword">INT</span> <span class="token comment">//平均年龄</span>
&#125;

<span class="token comment">//Step2 插入查询结果</span>
<span class="token keyword">INSERT</span>
<span class="token keyword">INTO</span> Dept_age<span class="token punctuation">(</span>Sdept<span class="token punctuation">,</span> Avg_age<span class="token punctuation">)</span>
  <span class="token keyword">SELECT</span> Sdept<span class="token punctuation">,</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Sage<span class="token punctuation">)</span>
  <span class="token keyword">FROM</span> Student
  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sdept<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=3-4-2-修改数据><a href=#3-4-2-修改数据 class=headerlink title="3.4.2 修改数据"></a>3.4.2 修改数据</h3><p>修改数据的标准格式如下:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>
<span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">]</span>…
<span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>思路很清晰, 通过UPDATE后面的表名和WHERE后面的条件来确定修改位置, SET是具体修改方法.<br>类似的, 还是有三种修改方式:</p><ul><li>修改某一个元组的值</li><li>修改多个元组的值</li><li>带子查询的修改语句</li></ul><h4 id=3-4-2-1-修改某一个元组的值><a href=#3-4-2-1-修改某一个元组的值 class=headerlink title="3.4.2.1 修改某一个元组的值"></a>3.4.2.1 修改某一个元组的值</h4><p>直接给例子: 将某个学生的年龄修改为22岁:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">UPDATE</span> Student
<span class="token keyword">SET</span> Sage <span class="token operator">=</span> <span class="token number">22</span>
<span class="token keyword">WHERE</span> Sno <span class="token operator">=</span> <span class="token string">'202215121'</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><h4 id=3-4-2-2-修改多个元组的值><a href=#3-4-2-2-修改多个元组的值 class=headerlink title="3.4.2.2 修改多个元组的值"></a>3.4.2.2 修改多个元组的值</h4><p>直接给例子: 将整个学生表中学生的年龄增加1岁:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">UPDATE</span> Student
<span class="token keyword">SET</span> Sage <span class="token operator">=</span> Sage <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><h4 id=3-4-2-3-带子查询的修改语句><a href=#3-4-2-3-带子查询的修改语句 class=headerlink title="3.4.2.3 带子查询的修改语句"></a>3.4.2.3 带子查询的修改语句</h4><p>这个需求很好理解, 我总不能一动要么动一个, 要么动整个表吧, 我如果只要动一部分呢?<br>那就还是要用我们的查询语句:</p><p>给例子: 将计算机科学系全部学生的成绩置为100:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">UPDATE</span> SC
<span class="token keyword">SET</span> Grade <span class="token operator">=</span> <span class="token string">'100'</span>
<span class="token keyword">WHERE</span> Sno <span class="token operator">IN</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> Sno
  <span class="token keyword">FROM</span> Student
  <span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=3-4-3-删除数据><a href=#3-4-3-删除数据 class=headerlink title="3.4.3 删除数据"></a>3.4.3 删除数据</h3><p>删除数据就很简单了:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DELETE</span>
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>
<span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>就是删除表名中符合条件的元组.<br>跟修改类似, 有三种方式:</p><ul><li>删除某一个元组</li><li>删除多个元组</li><li>删除带查询语句的元组</li></ul><h4 id=3-4-3-1-删除某一个元组><a href=#3-4-3-1-删除某一个元组 class=headerlink title="3.4.3.1 删除某一个元组"></a>3.4.3.1 删除某一个元组</h4><p>直接给例子: 删除学号为202215128的学生记录.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DELETE</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sno <span class="token operator">=</span> <span class="token string">'202215128'</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><h4 id=3-4-3-2-删除多个元组><a href=#3-4-3-2-删除多个元组 class=headerlink title="3.4.3.2 删除多个元组"></a>3.4.3.2 删除多个元组</h4><p>直接给例子: 删除所有的学生选课记录.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DELETE</span>
<span class="token keyword">FROM</span> SC<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span></span></code></pre><h4 id=3-4-3-3-带子查询的删除语句><a href=#3-4-3-3-带子查询的删除语句 class=headerlink title="3.4.3.3 带子查询的删除语句"></a>3.4.3.3 带子查询的删除语句</h4><p>直接给例子: 删除计算机科学系所有学生的选课记录.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DELETE</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">WHERE</span> Sno <span class="token operator">IN</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> Sno
  <span class="token keyword">FROM</span> Student
  <span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'CS'</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=3-5-空值的处理><a href=#3-5-空值的处理 class=headerlink title="3.5 空值的处理"></a>3.5 空值的处理</h2><p>所谓空值, 就是我们很熟悉的 <strong>NULL</strong> , 这玩意出现一般有三种情况:</p><ul><li>属性应该有值, 但是现在暂时不知道这个值(未考试考生的成绩)</li><li>属性本身不应该有值(缺考考生的成绩)</li><li>由于某种原因不便填写(个人隐私)</li></ul><p>之所以要把这玩意但拉出来, 就是因为它稍微有点特殊.</p><h3 id=3-5-1-空值的判断与相关约束条件><a href=#3-5-1-空值的判断与相关约束条件 class=headerlink title="3.5.1 空值的判断与相关约束条件"></a>3.5.1 空值的判断与相关约束条件</h3><p>空值的判断相关语句就两个:</p><ul><li>IS NULL</li><li>IS NOT NULL</li></ul><p>相关的约束条件包括:</p><ul><li>NOT NULL约束: 顾名思义, 就是这个位置不能为空.</li><li>PRIMARY KEY主码约束: 主码默认不能为空. <del>(主码空了还怎么标识一个元组?)</del></li></ul><h3 id=3-5-2-空值相关的运算><a href=#3-5-2-空值相关的运算 class=headerlink title="3.5.2 空值相关的运算"></a>3.5.2 空值相关的运算</h3><ul><li>算数运算: 只要存在操作数是空值的情况, 结果就是空值.</li><li>比较运算: 只要存在操作数为空值的情况，比较结果就是UNKNOWN</li><li>逻辑运算: 三值逻辑(TRUE, FALSE, UNKNOWN)</li></ul><p>值得提一下的是这个逻辑运算:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.3/%E5%85%B3%E4%BA%8ENULL%E7%9A%84%E7%9C%9F%E5%80%BC%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97.png alt=关于空值的逻辑运算></p><h2 id=3-6-视图><a href=#3-6-视图 class=headerlink title="3.6 视图"></a>3.6 视图</h2><p><strong>视图</strong> 是一个虚表. 它只存放视图的定义, 不存放视图对应的数据.<br>通常意味着某一种虚表要经常用到(比如某个应用程序中)<br><strong>基表中的数据变化时, 视图中的数据同样会发生变化!</strong></p><h3 id=3-6-1-定义视图><a href=#3-6-1-定义视图 class=headerlink title="3.6.1 定义视图"></a>3.6.1 定义视图</h3><h4 id=3-6-1-1-建立视图><a href=#3-6-1-1-建立视图 class=headerlink title="3.6.1.1 建立视图"></a>3.6.1.1 建立视图</h4><p>建立视图的语句格式如下:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token punctuation">]</span>…<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">AS</span> <span class="token operator">&lt;</span>子查询<span class="token operator">></span>
<span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>有两个地方需要讲一下:</p><ul><li>关于列名是否要写:<ul><li>要么全不写, 那么你下方的子查询查到哪些列, 你的视图就会包含哪些列.(列名也相同)</li><li>要么全写, 通常要写列名的时候有几种情况:<ul><li>子查询中有列名相同的情况</li><li>某个目标列是列表达式或者聚集函数</li><li>需要更合适的名字</li></ul></li></ul></li><li>这个 <strong>WITH CHECK OPTION</strong> 是啥意思?<ul><li>说白了就是, 给你的这个视图加上了一个限制条件, 这个视图以后只能插入 &#x2F; 修改符合你的查询语句条件的元组.</li></ul></li></ul><p>举个例子: 建立信息系学生的视图.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> IS_Student
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span> Sname<span class="token punctuation">,</span> Sage<span class="token punctuation">,</span> Sdept
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">=</span> <span class="token string">'IS'</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们加上了 <strong>WITH CHECK OPTION</strong> , 这就意味着, 你之后插入 &#x2F; 修改的元组必须还都满足 Sdept &#x3D; ‘IS’ 这个条件.</p><blockquote><p><strong><font color=#ff3131>注意</font></strong><br>我们可以发现, 上面这个例子中的视图, 实际上就是把一个表做了一点点筛选, 然后再呈现.<br>这种视图被称作 <strong>行列子集视图</strong> .</p></blockquote><p>再写几个带表达式 &#x2F; 带聚集函数的视图:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token comment">//所有学生的生日视图(带表达式)</span>
<span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> BT_S<span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Sbirth<span class="token punctuation">)</span>
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span><span class="token number">2025</span><span class="token operator">-</span>Sage
<span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>

<span class="token comment">//学生的平均成绩视图(也叫分组视图)</span>
<span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> S_G<span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Gavg<span class="token punctuation">)</span>
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然, 既然视图是子表, 那自然也可以从视图中进一步导出下一个视图. 这个我们就不说了, 无非就是查询语句改一下而已.</p><h4 id=3-6-1-2-删除视图><a href=#3-6-1-2-删除视图 class=headerlink title="3.6.1.2 删除视图"></a>3.6.1.2 删除视图</h4><p>删除视图要简单很多:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token keyword">CASCADE</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>跟之前的删除很像, 加上 CASCADE 会使得从这个视图导出的其余视图一并被删除.<br>反之, 如果这个视图下面还有导出视图, 那就拒绝删除.</p><h3 id=3-6-2-查询视图><a href=#3-6-2-查询视图 class=headerlink title="3.6.2 查询视图"></a>3.6.2 查询视图</h3><p><strong>从用户角度来看</strong> , 查询视图与查询基本表是相同的操作, 只需要把表名换成视图名, 表列换成视图列即可.</p><p>对于关系数据库而言: 使用 <strong>视图消解法</strong> 进行查询:</p><ul><li>进行有效性检查</li><li>转化成等价的针对基本表的查询</li><li>执行修正后的查询</li></ul><hr><p>视图消解法有时候会出问题:<br>举个例子: 我们有这么个视图, 它是通过聚集函数导出的.</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> S_G <span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Gavg<span class="token punctuation">)</span>
<span class="token keyword">AS</span>
<span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno<span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设我们要这么查找:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> S_G
<span class="token keyword">WHERE</span> Gavg<span class="token operator">>=</span><span class="token number">90</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span></span></code></pre><p>这时候, 表面上这个查询确实没问题, 但是别忘了, <strong>这个Gavg是通过聚集函数导出的</strong> , 所以这种查询实际上犯了我们之前三令五申的一个错误:<br>它把聚集函数放到WHERE后面了.</p><p>这时候就得需要我们手动来了, 比如转换成导出表:</p><pre class="line-numbers language-sql" data-language=sql><code class=language-sql><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span><span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
  <span class="token keyword">FROM</span> SC
  <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno
<span class="token punctuation">)</span> <span class="token keyword">AS</span> S_G<span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Gavg<span class="token punctuation">)</span>
<span class="token keyword">WHERE</span> Gavg<span class="token operator">>=</span><span class="token number">90</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=3-6-3-视图的增-删-改><a href=#3-6-3-视图的增-删-改 class=headerlink title="3.6.3 视图的增 &#x2F; 删 &#x2F; 改"></a>3.6.3 视图的增 &#x2F; 删 &#x2F; 改</h3><p>更新视图与更新基本表从用户视角也是相同的, 通过 <strong>INSERT &#x2F; UPDATE &#x2F; DELETE</strong> 来进行.</p><p>需要注意的一点是: <strong>不是什么视图都可以随便修改的!</strong> , 通常原则如下:</p><ul><li>如果视图是通过多个基本表通过连接操作导出的, 则不允许更新(一更新涉及到很多表, 容易出错)</li><li>如果视图涉及到分组和聚集操作, 也不允许更新(你只更新一个函数值, 但是不告诉原表怎么产生的这个新函数值, 那怎么行?)</li><li>只有视图是 <strong>行列子集视图</strong> , 即是从单表导出, 并且不涉及到聚集函数等操作的情况下, 才允许更新.</li></ul><h3 id=3-6-4-视图的作用><a href=#3-6-4-视图的作用 class=headerlink title="3.6.4 视图的作用"></a>3.6.4 视图的作用</h3><p>视图, 在我们之前的章节中讲过数据库的三个模式, 不知道读者还记得否?<br>这个视图, 通常而言跟 <strong>外模式</strong> 有些关系, 即它是对接应用设计的.</p><p>回过头来, 我们就能明白为什么说一个模式能有很多个外模式, 因为从基本表能够导出各种各样不同的视图, 进而对接各种各样的应用.<br>一定程度上保证了数据库的逻辑独立性和数据安全性对吧.</p><hr><p>这一章应该是整个数据库中最复杂的一章, 主要针对的是长久发展以来的SQL语言, 语法比较细碎, 并且还涉及到了外模式和模式之间的一些关系.</p><p>但这一章正是应用数据库的核心. 还望读者能够耐心读完它.</p></div><hr><div class=reprint id=reprint-statement><div class=reprint__author><span class=reprint-meta style=font-weight:700><i class="fas fa-user">文章作者: </i></span><span class=reprint-info><a href=/about rel="external nofollow noreferrer">MUG-chen</a></span></div><div class=reprint__type><span class=reprint-meta style=font-weight:700><i class="fas fa-link">文章链接: </i></span><span class=reprint-info><a href=http://mug-chen.github.io/posts/3029.html>http://mug-chen.github.io/posts/3029.html</a></span></div><div class=reprint__notice><span class=reprint-meta style=font-weight:700><i class="fas fa-copyright">版权声明: </i></span><span class=reprint-info>本博客所有文章除特別声明外，均采用 <a href=https://creativecommons.org/licenses/by/4.0/deed.zh rel="external nofollow noreferrer" target=_blank>CC BY 4.0</a> 许可协议。转载请注明来源 <a href=/about target=_blank>MUG-chen</a> !</span></div></div><script async defer=defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class=tag_share style=display:block><div class=post-meta__tag-list style=display:inline-block><div class=article-tag><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ ><span class="chip bg-color">数据库系统概论</span> </a><a href=/tags/Database/ ><span class="chip bg-color">Database</span></a></div></div><div class=post_share style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel=stylesheet type=text/css href=/libs/share/css/share.min.css><div id=article-share><div class=social-share data-sites=twitter,facebook,google,qq,qzone,wechat data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src=/libs/share/js/social-share.min.js></script></div></div></div></div></div><article id=prenext-posts class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos=fade-up><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class=card><a href=/posts/51604.html><div class=card-image><img src=/medias/featureimages/18.jpg class=responsive-img alt=数据库系统概论-Chap.4> <span class=card-title>数据库系统概论-Chap.4</span></div></a><div class="card-content article-content"><div class="summary block-with-text">数据库系统概论 Chap.4 数据库安全性</div><div class=publish-info><span class=publish-date><i class="far fa-clock fa-fw icon-date"></i>2025-06-13 </span><span class=publish-author><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes </a><a href=/categories/Study-Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE%E6%80%BB%E5%A4%8D%E4%B9%A0%E7%AF%87/ class=post-category>计算机专业课总复习篇</a></span></div></div><div class="card-action article-tags"><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ ><span class="chip bg-color">数据库系统概论</span> </a><a href=/tags/Database/ ><span class="chip bg-color">Database</span></a></div></div></div><div class="article col s12 m6" data-aos=fade-up><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class=card><a href=/posts/51988.html><div class=card-image><img src=/medias/featureimages/20.jpg class=responsive-img alt=数据库系统概论-Chap.2> <span class=card-title>数据库系统概论-Chap.2</span></div></a><div class="card-content article-content"><div class="summary block-with-text">数据库系统概论 Chap.2 关系模型</div><div class=publish-info><span class=publish-date><i class="far fa-clock fa-fw icon-date"></i>2025-06-09 </span><span class=publish-author><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes </a><a href=/categories/Study-Notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE%E6%80%BB%E5%A4%8D%E4%B9%A0%E7%AF%87/ class=post-category>计算机专业课总复习篇</a></span></div></div><div class="card-action article-tags"><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/ ><span class="chip bg-color">数据库系统概论</span> </a><a href=/tags/Database/ ><span class="chip bg-color">Database</span></a></div></div></div></div></article></div><script type=text/javascript src=/libs/codeBlock/codeBlockFuction.js></script><script type=text/javascript src=/libs/prism/prism.min.js></script><script type=text/javascript src=/libs/codeBlock/codeLang.js></script><script type=text/javascript src=/libs/codeBlock/codeCopy.js></script><script type=text/javascript src=/libs/codeBlock/codeShrink.js></script></div><div id=toc-aside class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style=background-color:#fff><div class=toc-title><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id=toc-content></div></div></div></div><div id=floating-toc-btn class=hide-on-med-and-down><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src=/libs/tocbot/tocbot.min.js></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const n="expanded";let i=$("#toc-aside"),l=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){i.hasClass(n)?(i.removeClass(n).hide(),l.removeClass("l9")):(i.addClass(n).show(),l.addClass("l9"));var e="artDetail",o="prenext-posts";if(0!==(e=$("#"+e)).length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#"+o).width(t)}})})</script></main><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><footer class="page-footer bg-color"><div class="container row center-align" style=margin-bottom:15px!important><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id=year>2022-2025</span> <a href=/about target=_blank>MUG-chen</a> |&nbsp;Powered by&nbsp;<a href=https://hexo.io/ target=_blank>Hexo</a> |&nbsp;Theme&nbsp;<a href=https://github.com/blinkfox/hexo-theme-matery target=_blank>Matery</a><br><span id=busuanzi_container_site_pv>&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp; <span id=busuanzi_value_site_pv class=white-color></span> </span><span id=busuanzi_container_site_uv>&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp; <span id=busuanzi_value_site_uv class=white-color></span></span><br><span id=sitetime>Loading ...</span><script>var calcSiteTime=function(){var e=new Date,t="2022",n=e.getFullYear(),i=e.getMonth()+1,a=e.getDate(),r=e.getHours(),o=e.getMinutes(),e=e.getSeconds(),s=Date.UTC(t,"12","25","22","45","0"),i=Date.UTC(n,i,a,r,o,e)-s,a=Math.floor(i/31536e6),r=Math.floor(i/864e5-365*a);t===String(n)?(document.getElementById("year").innerHTML=n,o="This site has been running for "+r+" days",o="本站已运行 "+r+" 天",document.getElementById("sitetime").innerHTML=o):(document.getElementById("year").innerHTML=t+" - "+n,e="This site has been running for "+a+" years and "+r+" days",e="本站已运行 "+a+" 年 "+r+" 天",document.getElementById("sitetime").innerHTML=e)};calcSiteTime()</script><br></div><div class="col s12 m4 l4 social-link social-statis"><a href=https://github.com/MUG-chen class=tooltipped target=_blank data-tooltip=访问我的GitHub data-position=top data-delay=50><i class="fab fa-github"></i></a></div></div></footer><div class=progress-bar></div><div id=searchModal class=modal><div class=modal-content><div class=search-header><span class=title><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type=search id=searchInput name=s placeholder=请输入搜索的关键字 class=search-input></div><div id=searchResult></div></div></div><script type=text/javascript>$(function(){!function(t,r,s){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),t=document.getElementById(r),n=document.getElementById(s);t.addEventListener("input",function(){var o='<ul class="search-result-list">',h=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,s=!0,i=t.title.trim().toLowerCase(),l=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),a=0===(a=t.url).indexOf("/")?t.url:"/"+a,c=-1,u=-1;""!==i&&""!==l&&h.forEach(function(t,e){n=i.indexOf(t),c=l.indexOf(t),n<0&&c<0?s=!1:(c<0&&(c=0),0===e&&(u=c))}),s&&(o+="<li><a href='"+a+"' class='search-result-title'>"+i+"</a>",a=t.content.trim().replace(/<[^>]+>/g,""),0<=u&&(t=u+80,(t=0===(e=(e=u-20)<0?0:e)?100:t)>a.length&&(t=a.length),r=a.substr(e,t),h.forEach(function(t){var e=new RegExp(t,"gi");r=r.replace(e,'<em class="search-keyword">'+t+"</em>")}),o+='<p class="search-result">'+r+"...</p>"),o+="</li>")}),o+="</ul>",n.innerHTML=o)})}})}("/search.xml","searchInput","searchResult")})</script><div class=stars-con><div id=stars></div><div id=stars2></div><div id=stars3></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id=backTop class=top-scroll><a class="btn-floating btn-large waves-effect waves-light" href=#!><i class="fas fa-arrow-up"></i></a></div><script src=/libs/materialize/materialize.min.js></script><script src=/libs/masonry/masonry.pkgd.min.js></script><script src=/libs/aos/aos.js></script><script src=/libs/scrollprogress/scrollProgress.min.js></script><script src=/libs/lightGallery/js/lightgallery-all.min.js></script><script src=/js/matery.js></script><script type=text/javascript>var windowWidth=$(window).width();768<windowWidth&&document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>')</script><script src=https://ssl.captcha.qq.com/TCaptcha.js></script><script src=/libs/others/TencentCaptcha.js></script><button id=TencentCaptcha data-appid=xxxxxxxxxx data-cbfn=callback type=button hidden></button><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0],e=(t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}()</script><script async src=/libs/others/busuanzi.pure.mini.js></script><script src=/libs/instantpage/instantpage.js type=module></script><div id=loading-box><div class=loading-left-bg></div><div class=loading-right-bg></div><div class=spinner-box><div class=configure-border-1><div class=configure-core></div></div><div class=configure-border-2><div class=configure-core></div></div><div class=loading-word>加载中...</div></div></div><script>window.addEventListener("load",function(){document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},!1)</script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!0,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script></body></html>
<!DOCTYPE HTML><html lang=zh-CN><head><meta charset=utf-8><meta name=keywords content="信安数学基础_Fin, MUG-chen&#39;s Blog"><meta name=description content="Mathematical basis of Information Security 期末复习章"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=no"><meta name=renderer content=webkit|ie-stand|ie-comp><meta name=mobile-web-app-capable content=yes><meta name=format-detection content="telephone=no"><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=black-translucent><meta name=referrer content=no-referrer-when-downgrade><title>信安数学基础_Fin | MUG-chen&#39;s Blog</title><link rel=icon type=image/png href=/favicon.png><style>body{background-image:url(https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Vivid%20theory.webp);background-repeat:no-repeat;background-size:100% 100%;background-attachment:fixed}</style><link rel=stylesheet type=text/css href=/libs/awesome/css/all.min.css><link rel=stylesheet type=text/css href=/libs/materialize/materialize.min.css><link rel=stylesheet type=text/css href=/libs/aos/aos.css><link rel=stylesheet type=text/css href=/libs/animate/animate.min.css><link rel=stylesheet type=text/css href=/libs/lightGallery/css/lightgallery.min.css><link rel=stylesheet type=text/css href=/css/matery.css><link rel=stylesheet type=text/css href=/css/my.css><link rel=stylesheet type=text/css href=/css/dark.css media=none onload='"all"!=media&&(media="all")'><link rel=stylesheet href=/libs/tocbot/tocbot.css><link rel=stylesheet href=/css/post.css><script src=/libs/jquery/jquery-3.6.0.min.js></script><link rel=stylesheet type=text/css href=/css/loading.css><meta name=generator content="Hexo 7.1.1"></head><body><header class=navbar-fixed><nav id=headNav class="bg-color nav-transparent"><div id=navContainer class="nav-wrapper container"><div class=brand-logo><a href=/ class="waves-effect waves-light"><img src=/medias/logo.png class=logo-img alt=LOGO> <span class=logo-span>MUG-chen&#39;s Blog</span></a></div><a href=# data-target=mobile-nav class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href=/ class="waves-effect waves-light"><i class="fas fa-home" style=zoom:.6></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/tags class="waves-effect waves-light"><i class="fas fa-tags" style=zoom:.6></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/categories class="waves-effect waves-light"><i class="fas fa-bookmark" style=zoom:.6></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/archives class="waves-effect waves-light"><i class="fas fa-archive" style=zoom:.6></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href=/about class="waves-effect waves-light"><i class="fas fa-user-circle" style=zoom:.6></i> <span>关于</span></a></li><li><a href=#searchModal class="modal-trigger waves-effect waves-light"><i id=searchIcon class="fas fa-search" title=搜索 style=zoom:.85></i></a></li><li><a href=javascript:; class="waves-effect waves-light" onclick=switchNightMode() title=深色/浅色模式><i id=sum-moon-icon class="fas fa-sun" style=zoom:.85></i></a></li></ul><div id=mobile-nav class="side-nav sidenav"><div class="mobile-head bg-color"><img src=/medias/logo.png class="logo-img circle responsive-img"><div class=logo-name>MUG-chen&#39;s Blog</div><div class=logo-desc>Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class=m-nav-item><a href=/ class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class=m-nav-item><a href=/tags class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class=m-nav-item><a href=/categories class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class=m-nav-item><a href=/archives class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class=m-nav-item><a href=/about class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li><div class=divider></div></li><li><a href=https://github.com/MUG-chen/MUG-chen.github.io class="waves-effect waves-light" target=_blank><i class="fab fa-github-square fa-fw"></i>Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href=https://github.com/MUG-chen/MUG-chen.github.io class="github-corner tooltipped hide-on-med-and-down" target=_blank data-tooltip="Fork Me" data-position=left data-delay=50><svg viewBox="0 0 250 250" aria-hidden=true><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill=currentColor style="transform-origin:130px 106px" class=octo-arm></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill=currentColor class=octo-body></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style=background-image:url(/medias/featureimages/16.jpg)><div class=container style=right:0;left:0><div class=row><div class="col s12 m12 l12"><div class=brand><h1 class="description center-align post-title">信安数学基础_Fin</h1></div></div></div></div></div><main class="post-container content"><div class=row><div id=main-content class="col s12 m12 l9"><div id=artDetail><div class=card><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class=article-tag><a href=/tags/Mathematical-basis-of-Information-Security/ ><span class="chip bg-color">Mathematical basis of Information Security</span></a></div></div><div class="col s5 right-align"><div class=post-cate><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes</a></div></div></div><div class=post-info><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2024-06-10</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2024-06-10</div><div class=info-break-policy><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 7.3k</div></div></div><hr class=clearfix><link rel=stylesheet href=/libs/prism/prism.min.css><div class="card-content article-card-content"><div id=articleContent><h1 id=信安数学基础><a href=#信安数学基础 class=headerlink title=信安数学基础></a>信安数学基础</h1><blockquote><p>写在前边，本文是作者应对期末考试写的复习文, 感觉应该有点用, 就顺带着传上来, 其中有些直接标注了ppt页数, 是作者得到的课件, 读者不必太在意.</p><p>另外, 本文大量使用了Mathjax语法, 希望不会引起很多渲染错误吧…</p></blockquote><h2 id=Chap-1-整除，带余除法><a href=#Chap-1-整除，带余除法 class=headerlink title="Chap.1 整除，带余除法"></a>Chap.1 整除，带余除法</h2><h3 id=1-1-基础概念阐述><a href=#1-1-基础概念阐述 class=headerlink title="1.1 基础概念阐述"></a>1.1 基础概念阐述</h3><p>全体整数的集合Z，全体自然数的集合N</p><p>整除的记法： <strong>a|b</strong> ，称为 <strong>b被a整除</strong> ，意味着 <strong>b是a的倍数，a是b的因子</strong> 。</p><h3 id=1-2-整除的性质><a href=#1-2-整除的性质 class=headerlink title="1.2 整除的性质"></a>1.2 整除的性质</h3><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%95%B4%E9%99%A4%E7%9A%84%E6%80%A7%E8%B4%A8.png alt=整除的性质></p><h3 id=1-3-素数><a href=#1-3-素数 class=headerlink title="1.3 素数"></a>1.3 素数</h3><p>素数即 <strong>其正因子只有1和它自己</strong> 的整数。反之，则称为 <strong>合数</strong> 。</p><p>对于素数和合数，有几个定理：</p><ul><li>合数的最小真因子一定是素数（Chap1 P14）</li><li>素数有无穷多个（Chap1 P15）</li></ul><p>素数分布： <strong>$ \pi(x) $</strong> 表示 <strong>不超过x的素数的个数</strong> 。</p><p>比较好的估计方法——素数定理： <strong>$ \pi(x) \approx \frac{x}{lnx}, x\to\infty $</strong></p><p>具体去看Chap1 P19</p><h3 id=1-4-带余除法><a href=#1-4-带余除法 class=headerlink title="1.4 带余除法"></a>1.4 带余除法</h3><p>$$ b &#x3D; qa + r $$</p><p>显然，r &#x3D; 0 是 a|b 的充要条件</p><p>这里有两个取法：</p><ul><li>最小正剩余：r取值范围为 (0, a-1);</li><li>最小绝对剩余：r取值范围围绕0左右；</li></ul><p>一般都取最小正剩余。</p><hr><p>根据这种带余除法，可以根据除数对于整个整数集Z分类。即</p><p>$$ S_{a, j} &#x3D; a*k+j $$</p><p>这其中：</p><ul><li>$ j &#x3D; 0, 1, …, a-1 $</li><li>$ k &#x3D; 0, \pm 1, \pm2, … $</li></ul><p>相当于将Z分成了a类，每类中的数字除以a所得的余数就是j。</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%95%B4%E6%95%B0%E5%88%86%E7%B1%BB.png alt=整数分类的性质></p><p>关于 <strong>进制转换，见 Chap1 P34</strong> ，这里不再赘述。</p><h2 id=Chap-2-最大公因子，欧几里得算法><a href=#Chap-2-最大公因子，欧几里得算法 class=headerlink title="Chap.2 最大公因子，欧几里得算法"></a>Chap.2 最大公因子，欧几里得算法</h2><h3 id=2-1-公因子-最大公因子><a href=#2-1-公因子-最大公因子 class=headerlink title="2.1 公因子 &amp; 最大公因子"></a>2.1 公因子 &amp; 最大公因子</h3><p>公因子： <strong>d|a 且 d|b</strong> ，则d是a、b的公因子。</p><p>最大公因子就是其中最大的那个。</p><p>记法： <strong>$ gcd(a_1, a_2, …, a_n) $</strong></p><p>性质：</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BE%8B.png alt=最大公因子性质_例子></p><p>更严谨一点的说法：</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8.png alt=最大公因子性质></p><p>关于这些性质的证明, 见Chap.2 P9</p><p>这其中第二条用的尤其多, 意味着最大公因子前后是可以互相加减的.</p><h3 id=2-2-互素><a href=#2-2-互素 class=headerlink title="2.2 互素"></a>2.2 互素</h3><p>如果 $ gcd(a_1, a_2) &#x3D; 1 $ , 则称a1, a2是互素的.</p><p>$ gcd(a_1, a_2, a_3, …, a_n) &#x3D; 1 $ , 称他们整体互素.</p><p>如果他们之间任意两个都互素, 则称 a1, a2, …, ak <strong>两两互素</strong> .</p><p>显然, 根据上面的性质5, $ 两两互素\implies整体互素 $ , <strong>反之不然</strong> .</p><hr><p>费马数:</p><p>$$ F_n &#x3D; 2^{2^n}+1 , n为非负整数$$</p><p>任意两个不同的费马数互素. 关于这个定理的证明, 见Chap2 P13</p><p>明确一点: <strong>两个合数也有可能互素, 即便它们是合数</strong> , 如8和15, 或者费马数F5(这是个合数).</p><hr><p>有关互素的最大公因子性质:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BA%92%E7%B4%A0%E7%9B%B8%E5%85%B3%281%29.png alt=最大公因子性质_互素(1)></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BA%92%E7%B4%A0%E7%9B%B8%E5%85%B3%282%29.png alt=最大公因子性质_互素(2)></p><p>最后这一条比较重要, 欧几里得算法成立的基础就是这玩意.</p><p>更多最大公因子的性质, 见Chap.2 P18 以及 Chap.2 P21</p><h3 id=2-3-最小公倍数><a href=#2-3-最小公倍数 class=headerlink title="2.3 最小公倍数"></a>2.3 最小公倍数</h3><p>公倍数: a|d 且 b|d, 称d为a, b的公倍数.</p><p>最小公倍数, 即其中最小的那个, 记作 $ [a, b] $ .</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E6%80%A7%E8%B4%A8.png alt=最小公倍数性质></p><p>有一个需要摁记住的, <strong>$ [a_1, a_2](a_1, a_2) &#x3D; |a_1a_2| $</strong></p><h3 id=2-4-最大公因子的求解-欧几里得算法><a href=#2-4-最大公因子的求解-欧几里得算法 class=headerlink title="2.4 最大公因子的求解-欧几里得算法"></a>2.4 最大公因子的求解-欧几里得算法</h3><p>基本思路:</p><p>$$ (a, b) &#x3D; (qb+r, b) &#x3D; (r, b) $$</p><p>将大的数字换成小的数字的带余除法形式, 而后依据最大公因子性质2, 直接将乘积去掉.</p><p>这个方法也叫做 <strong>辗转相除法</strong> .</p><p>直到没有余数为止, 此时的数字被就是二者的最大公因子.</p><hr><p>扩展欧几里得算法, 可以将 gcd(a, b) 表示成 a, b的线性组合的形式.</p><p>具体过程就是从下向上推, 每一次将余数换掉就可以了.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Euclid%E7%AE%97%E6%B3%95%E4%BE%8B.png alt=Euclid算法例></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%89%A9%E5%B1%95Euclid%E7%AE%97%E6%B3%95%E4%BE%8B.png alt=扩展Euclid算法例></p><p>关于这个,可以扩展出一个性质:</p><p><strong>a, b的整系数线性组合恰好构成了 gcd(a, b)的所有整数倍.</strong></p><p>而如果a, b互素, 即gcd(a, b) &#x3D; 1, 则任何整数都可以被表示成a, b的整系数线性组合了.</p><hr><p>这里还要给一个方法, 用于给出一个整数x 如何用a, b线性组合表示出来.</p><p>首先, 如果x可以用a, b的线性组合表示, 则 gcd(a, b)|x 必定成立.</p><p>那么, 我们先用欧几里得算法以及扩展欧几里得算法算出gcd(a, b), 以及gcd(a, b)如何用a, b线性表示.</p><p>而后在式子前面乘上x与gcd(a, b)的倍数即可.</p><hr><p>关于其它的性质, 见Chap.2 P48</p><h3 id=2-5-一次不定方程的求解><a href=#2-5-一次不定方程的求解 class=headerlink title="2.5 一次不定方程的求解"></a>2.5 一次不定方程的求解</h3><p>一次不定方程:</p><p>$$ a_1x_1+a_2x_2+…+a_nx_n &#x3D; c $$</p><p>其有解的充要条件是, $ gcd(a_1, a_2, …, a_n)|c $</p><hr><p>主要看二元一次不定方程: $ ax+by &#x3D; c $</p><p>如果该方程已经有一组解: $ (x_0, y_0) $ , 则我们可以给出其全部解:</p><p>$$<br>\begin{cases}{c}<br>x &#x3D; x_0+\frac{b}{(a, b)}t \\<br>y &#x3D; y_0+\frac{a}{(a, b)}t \<br>\end{cases}<br>$$</p><p>由此, 我们明确了二元一次不定方程的求解:</p><ul><li>验证是否有解: 即 $ gcd(a, b)|c $ 是否成立</li><li>如果有解, 利用扩展欧几里得算法求出一组特解(相当于通过扩展欧几里得算法将c表达成a, b的线性组合的形式), 而后根据上面的公式给出通解.</li></ul><h3 id=2-6-算术基本定理><a href=#2-6-算术基本定理 class=headerlink title="2.6 算术基本定理"></a>2.6 算术基本定理</h3><p>通俗的讲, 就是 <strong>任何大于1的整数都能化为有限个素数的乘积</strong> .</p><p>利用公式表达:</p><p>$$ a&gt;1 \implies a &#x3D; p_1p_2…p_s $$</p><p>这其中, p1, p2, …都是素数</p><hr><p>推论: <strong>标准素因数分解式</strong></p><p>$$ a &#x3D; p_1^{\alpha_1}p_2^{\alpha_2}…p_n^{\alpha_n} $$</p><p>通过这个式子,我们可以给出求最大公因式以及最小公倍数的比较简单的方法:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%A0%87%E5%87%86%E7%B4%A0%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3_%E9%87%8D%E8%A6%81%E6%8E%A8%E8%AE%BA.png alt=标准素因数分解_重要推论></p><ul><li>最大公因数: 把每个素因子取最小值,相乘即可.</li><li>最小公倍数: 把每个素因子取最大值,相乘即可.</li></ul><p>这个玩意也能用于证明一些东西, 具体见Chap.2 P79.</p><hr><p>素因式的更多推论, 见Chap.2 P82</p><h2 id=Chap-3-同余><a href=#Chap-3-同余 class=headerlink title="Chap.3 同余"></a>Chap.3 同余</h2><h3 id=3-1-同余-概述><a href=#3-1-同余-概述 class=headerlink title="3.1 同余_概述"></a>3.1 同余_概述</h3><p>若m, a, b 满足 $ m|a-b $ , 则我们称a, b同余, 记作:</p><p>$$ a \equiv b\space (mod\space m) $$</p><p>跟前面带余除法其实挺像的, 也分非负最小剩余和绝对最小剩余, 这里一般用非负最小剩余来写.</p><hr><p>同余的性质:</p><p>显然, 既然叫同余了, 自然能得到如下定理, 即 <strong>a, b被m除后所得余数相同</strong> .</p><p>对于同余式左右而言, 加法 \ 减法 \ 乘法均成立, 但除法比较特殊.</p><p>$$ ca \equiv cb\space(mod\space m) \iff<br>a \equiv b \space (mod \space \frac{m}{(c, m)}) $$</p><p>显然, 当且仅当c, m互素, 即(c, m) &#x3D; 1时, 消去律(除法)才能成立.</p><h3 id=3-2-乘法逆元-重要概念><a href=#3-2-乘法逆元-重要概念 class=headerlink title="3.2 乘法逆元(重要概念)"></a>3.2 乘法逆元(重要概念)</h3><p>若 $ m&gt;1 $ , 且 $ (a, m) &#x3D; 1 $ , 如果存在 c 使:</p><p>$$ ca \equiv 1 \space(mod \space m) $$</p><p>我们就可以把c称为a对m的逆元, 记为 $ a^{-1}(mod \space m) $</p><hr><p>乘法逆元的求法?</p><p>利用欧几里得算法.</p><p>因为 (a, m) &#x3D; 1 , 则有 $ sa + tm &#x3D; 1 $ , 即1可以通过 a 和 m 的线性组合表示, 只需要取 c &#x3D; s 即满足要求.</p><p>至于怎么求解线性组合, 这是第二章的事情, 忘了往回看.</p><hr><p>乘法逆元的性质:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E6%80%A7%E8%B4%A8.png alt=乘法逆元的性质></p><hr><p>给两类典型题目:</p><p>1.分数的最小剩余:</p><p>求 $ \frac{53}{46} \space (mod \space 25) $</p><p>相当于: $ 3 * (46)^{-1} \space (mod \space 25) $</p><p>就需要算一个46关于25的乘法逆, 也就是21关于25的乘法逆.</p><p>给出过程供参考:</p><ul><li>$ (21, 25) &#x3D; 1 $</li><li>$ 1 &#x3D; 6*21 + (-5)*25 $</li><li>21关于25的乘法逆就是6</li></ul><p>因此 $ \frac{53}{46} \space (mod \space 25) &#x3D; 3*6 &#x3D; 18 $</p><p>2.大数带余除法</p><p>求 $ 3^{1001} mod\space 13 $</p><p>利用同余式子的可乘性质(最好找一个除以模数模1的, 这样能直接消掉):</p><p>$ 3^3 \equiv 1\space(mod\space 13) $</p><p>则:</p><p>$ 3^{3*333} &#x3D; 3^{999} \equiv 1\space(mod\space 13) $</p><p>因此:</p><p>$ 3^{1001}\space(mod\space 13) &#x3D; 3^2\space(mod\space 13) &#x3D; 9 $</p><hr><p>关于换模的条件:</p><p>如果 $ d&gt;1 且 d|m $ , 并且同余式 $ a\equiv b \space (mod\space m) $ 成立;</p><p>则能推出 $ a\equiv b\space(mod\space d) $</p><p>由上面这个式子, 可以得到推论:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%8D%A2%E6%A8%A1%E6%8E%A8%E8%AE%BA.png alt=换模推论></p><h3 id=3-3-剩余类和剩余系><a href=#3-3-剩余类和剩余系 class=headerlink title="3.3 剩余类和剩余系"></a>3.3 剩余类和剩余系</h3><h4 id=3-3-1-剩余类><a href=#3-3-1-剩余类 class=headerlink title="3.3.1 剩余类"></a>3.3.1 剩余类</h4><p>根据除以模数 m 所得的余数对于整数集合Z进行分类.</p><p>总共m个剩余类, 每个剩余类的代表元是: 0, 1, 2, …, m-1</p><p>如果该剩余类的 <strong>代表元与模数m互素</strong> , 称这个剩余类为m的 <strong>既约剩余类</strong> , 既约剩余类的总个数即欧拉函数(Eular函数), 记作 $ \varphi(m) $</p><p>两个记法:</p><p>所有m的剩余类组成的集合:</p><p>$$ Z_m $$</p><p>所有m的既约剩余类组成的集合:</p><p>$$ Z_m^* $$</p><p>有时候为了简写, 会通过一个代表元来表示一整个集合:</p><p>$$ Z_{12} &#x3D; \lbrace 0, 1, 2, 3, …, 11\rbrace $$</p><p>$$ Z_{12}^* &#x3D; \lbrace 1, 5, 7, 11 \rbrace $$</p><blockquote><p>剩余类是一堆同余的整数组成的集合</p></blockquote><h4 id=3-3-2-剩余系><a href=#3-3-2-剩余系 class=headerlink title="3.3.2 剩余系"></a>3.3.2 剩余系</h4><p>从 <strong>每个剩余类中取出一个元素</strong> (即共取出m个元素), 组成一个集合, 叫做m的一个完全剩余系.</p><p>相应的, 从 <strong>每个既约剩余系中取出一个元素</strong> (即共取出 $ \varphi(m) $ 个元素), 组成一个集合, 叫做m的一个既约剩余系.</p><p>完全剩余系最简单的取法就是取 {0, 1, …, m-1}</p><p>既约剩余系最简单的取法就是取 <strong>小于m的,与m互素的元素</strong> .</p><h3 id=3-4-欧拉函数-欧拉定理-Euler定理><a href=#3-4-欧拉函数-欧拉定理-Euler定理 class=headerlink title="3.4 欧拉函数 &amp; 欧拉定理(Euler定理)"></a>3.4 欧拉函数 &amp; 欧拉定理(Euler定理)</h3><p>前面提到, $ \varphi(m) $ 是m的既约剩余类的个数.</p><p><strong>三条性质:</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8.png alt=欧拉函数的性质></p><p><strong>这三条能够解决全部整数欧拉函数的求法</strong></p><hr><p><strong>两条推论:</strong></p><p>除了 $ \varphi(1) &#x3D; \varphi(2) &#x3D; 1 $ , 对于其余的欧拉函数, 都有:</p><p>$$ 2|\varphi(m) $$</p><p>对于任意n:</p><p>$$ \sum_{d|n} \varphi(d) &#x3D; n $$</p><p>即 <strong>n的所有因子 (包括n自己) 的欧拉函数相加等于n</strong></p><hr><p><strong>欧拉定理:</strong></p><p>如果 (a, m) &#x3D; 1(a与m互素), 则:</p><p>$$ a^{\varphi(m)} \equiv 1 \space(mod\space m) $$</p><p><strong>费马小定理:</strong></p><p>p为素数, 则:</p><p>$$ \varphi(p) &#x3D; p-1 $$</p><p>这定理挺好理解的, 就是素数有p-1个既约剩余系(把代表元为0的既约剩余系抛了就行)</p><p>结合欧拉定理, 有:</p><p>$$ a^{\varphi(p)} &#x3D; a^{p-1} \equiv 1\space(mod\space p) $$</p><hr><p>欧拉定理给出了另一种求a对于m乘法逆元的方式:</p><p>$$ a^{-1} \equiv a^{\varphi(m)-1}\space(mod\space m) $$</p><hr><p>有了欧拉带余除法, 我们再看这类题:</p><p>2.大数带余除法</p><p>求 $ 3^{1001} mod\space 13 $</p><p>利用同余式子的可乘性质(最好找一个除以模数模1的, 这样能直接消掉):</p><p>要找一个除以模数余1的就很简单: 因为 $ 3^{\varphi(13)} &#x3D; 3^{12} \equiv 1\space(mod\space 13) $</p><p>此后消去 $ 3^{12} $ 的元即可, 即:</p><p>$$ 3^{1001} &#x3D; 3^{12*83}*3^{5} $$</p><p>即计算:</p><p>$$ 3^5 \space(mod\space 13) $$</p><p>结果相同.</p><h2 id=Chap-4-同余方程><a href=#Chap-4-同余方程 class=headerlink title="Chap.4 同余方程"></a>Chap.4 同余方程</h2><h3 id=4-1-一元高次同余方程的概念><a href=#4-1-一元高次同余方程的概念 class=headerlink title="4.1 一元高次同余方程的概念"></a>4.1 一元高次同余方程的概念</h3><p>同余方程：</p><p>$$ f(x) &#x3D; a_nx^n + … + a_1x+a_0 $$</p><p>形如:</p><p>$$ f(x) \equiv 0\space(mod\space m) $$</p><p>的同余式叫做模m的同余方程.</p><p>我们将满足上面的式子的x&#x3D;c称作该方程的一个解.</p><p>显然, 如果c是上面方程的一个特解, 那么c对于m的同余类中的所有数都应当是上面这个方程的解(有关m的因子可以直接消掉)</p><p><strong>同余方程的次数就是多项式的次数</strong></p><p><strong>从本质上, 同余方程就是系数取自 $ Z_m $ 的方程</strong></p><p>接下来是两个问题:</p><ul><li>有没有解?</li><li>有多少解?</li><li>如何求解?</li></ul><hr><p>关于有没有解这个问题:</p><p><strong>同余方程 $ f(x) \equiv 0\space(mod\space m) $ 有解的必要条件是, 对于m的每个因子d (即d|m) , $ f(x) \equiv 0\space(mod\space d) $ 均有解.</strong></p><p>这个定理使得可以 <strong>通过简单的枚举来判断一个同余方程是不是无解.</strong></p><p>如: $ f(x) \equiv 0\space(mod\space 15) $</p><p>可以先枚举 $ f(1), f(2), f(3) $ , 判断 $ f(x) \equiv 0\space(mod\space 3) $ 有没有解, 如果模3都无解, 则模15必定无解.</p><hr><p>关于有多少解这个问题:</p><p>考虑模数是素数的情况:</p><p>$$ f(x) \equiv 0\space(mod\space p) $$</p><p>的解数不会超过 f(x) 的次数 n.</p><hr><p>关于如何求解这个问题:</p><p><strong>穷举法:</strong></p><p>首先, 也是最简单的方法, 直接从1到p-1穷举.</p><p><strong>多项式化简:</strong></p><p>其次, 通过多项式的性质来化简系数和次数.</p><p>1.化简系数:</p><p>如将 $ 15x^2 + 20x + 12(mod\space 11) $ 化简为 $ 4x^2+9x+1(mod\space 11) $ .</p><p>2.化简次数:</p><p>如果 $ f(x) &#x3D; q(x)h(x) + r(x) $ , 并且 $ h(x) \equiv 0(mod\space m) $ 是恒等同余式, 则可以将原方程化简为 $ r(x) \equiv 0(mod\space m) $</p><p><strong>关键在于找这个h(x)</strong></p><p>如果m是素数, 那这个式子可以用欧拉-费马小定理直接给出:</p><p>$$ x^{\varphi(p)} \equiv 1(mod\space p) $$</p><p>即(把1挪到左边, 两侧同乘x):</p><p>$$ x^{p} - x \equiv 0(mod\space p) $$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B_%E5%8C%96%E7%AE%80%E6%AC%A1%E6%95%B0.png alt=同余方程_化简次数></p><blockquote><p>上面这两个方法其实本质目的在于 <strong>把f(x)变得更简单</strong> , 从而更轻松的进行枚举.</p></blockquote><h3 id=4-2-一次同余方程><a href=#4-2-一次同余方程 class=headerlink title="4.2 一次同余方程"></a>4.2 一次同余方程</h3><p>一次同余方程是最简单的情况:</p><p>$$ ax \equiv b(mod\space m) $$</p><p>1.a,m同余的情况:</p><p>根据同余式的除法性质, 当(a, m) &#x3D; 1时(即a, m互素), 可以直接将a除到右边.</p><p>此时就一个解: $ x \equiv a^{-1}b(mod\space m) $</p><p>2.一般情况:</p><p>此时有解的充要条件是:</p><p>$$ (a, m)|b $$</p><p>同时, 解数也正好是 (a, m);</p><p>其通解正好是: $ x \equiv x_0 + \frac{m}{(a,m)}t(mod\space m) $</p><p>这里: t &#x3D; 0, 1, …, (a, m)-1;</p><p><strong>可以类比一次不定方程的解法, 事实上, 这俩几乎一模一样</strong></p><p>因为可以直接将上面这个同余方程等价于:</p><p>$$ ax + my &#x3D; b $$</p><p><strong>因此</strong> ,我们继续类比一次不定方程的解题过程:</p><ul><li>判断有没有解: 即(a,m)|b是否成立</li><li>如果有解, 通过扩展Euclid算法计算一个特解</li><li>利用公式给出通解</li></ul><h3 id=4-3-一次同余方程组><a href=#4-3-一次同余方程组 class=headerlink title="4.3 一次同余方程组"></a>4.3 一次同余方程组</h3><p>一次同余方程组的通用形式:</p><p>$$ f_i(x) \equiv 0(mod\space m_i) $$</p><p>i可以取多个值.</p><p>通过 <strong>孙子定理</strong> 可以对一次同余方程组进行刻画与求解</p><hr><p>孙子定理:</p><p>设 $ m_1, m_2, …, m_k $ <strong>两两互素</strong> , 则对于任意整数 $ a_1, a_2, …, a_k $ , 一次同余方程组:</p><p>$$ x \equiv a_i(mod\space m_i) , \space 1\leq i\leq k$$</p><p>一定有解, 并且解在模m的意义下唯一.</p><p>这个唯一解是:</p><p>$$ x \equiv a_1t_1M_1 + … + a_kt_kM_k(mod\space m) $$</p><p>其中:</p><ul><li>$ a_i $ : 就是每个方程后面的整数</li><li>$ m &#x3D; m_1 * m_2 * … * m_k &#x3D; m_i * M_i $</li><li>$ t_iM_i \equiv 1(mod\space m_i) $ , 即ti是Mi在模mi意义下的乘法逆元 (Mi的定义上面已经给出)</li></ul><hr><p>给个例子:</p><p>$$<br>\begin{cases}{c}<br>x \equiv 2(mod\space 3) \\<br>x \equiv 3(mod\space 5) \\<br>x \equiv 2(mod\space 7) \<br>\end{cases}<br>$$</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86_%E4%BE%8B.png alt=孙子定理_例></p><hr><p>如果 <strong>模数两两不互诉?</strong></p><p>$$<br>\begin{cases}{c}<br>4x \equiv 14(mod\space 15) \\<br>9x \equiv 11(mod\space 20) \<br>\end{cases}<br>$$</p><p>先要将其拆开, 如下:</p><p>$$<br>\begin{cases}{c}<br>4x \equiv 14(mod\space 3) \\<br>4x \equiv 14(mod\space 5) \\<br>9x \equiv 11(mod\space 4) \\<br>9x \equiv 11(mod\space 5) \<br>\end{cases}<br>$$</p><p>对上面的方程式一一化简即可</p><p>$$<br>\begin{cases}{c}<br>x \equiv 2(mod\space 3) \\<br>x \equiv 1(mod\space 5) \\<br>x \equiv 3(mod\space 4) \\<br>x \equiv -1(mod\space 5) \<br>\end{cases}<br>$$</p><p>而后, 有矛盾则无解, 无矛盾则依照正常解法求解即可</p><h2 id=Chap-5-二次剩余><a href=#Chap-5-二次剩余 class=headerlink title="Chap.5 二次剩余"></a>Chap.5 二次剩余</h2><h3 id=5-1-二次剩余概述><a href=#5-1-二次剩余概述 class=headerlink title="5.1 二次剩余概述"></a>5.1 二次剩余概述</h3><p>二次同余方程:</p><p>$$ ax^2 + bx + c &#x3D; 0(mod\space p) $$</p><p>解法如下:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B_%E8%A7%A3%E6%B3%95.png alt=一元二次同余方程_解法></p><p>这玩意看一眼就行, 主要为了引出二次剩余.</p><hr><p><strong>二次剩余:</strong></p><p>素数 p&gt;2 , (p, d) &#x3D; 1.</p><p>如果 $ x^2 \equiv d(mod\space p) $ 有解, 称d是模p的二次剩余.</p><p>如果无解,则称d是模p的二次非剩余.</p><p>记法:</p><p>二次剩余全体组成的集合:</p><p>$$ QR_p &#x3D; \lbrace a|a\in Z^*_p, 存在x\in Z^*_p使得x^2 \equiv a(mod\space p)\rbrace $$</p><p>二次非剩余组成的集合:</p><p>$$ QR_p &#x3D; \lbrace a|a\in Z^*_p, 任意x\in Z^*_p均有x^2 \ne a(mod\space p)\rbrace $$</p><blockquote><p>这里直接表明了a属于p的既约非剩余系, 是因为前面提到了(p, d) &#x3D; 1</p></blockquote><p>给个例子:</p><p>$$ QR_7 &#x3D; \lbrace 1, 2, 4 \rbrace $$</p><p>$$ NQR_7 &#x3D; \lbrace 3, 5, 6 \rbrace $$</p><hr><p>关于既约剩余系中二次剩余与二次非剩余的个数:</p><p><strong>二次剩余与二次非剩余各占一半, 即: $ |QR_p| &#x3D; |NQR_p| &#x3D; \frac{p-1}{2} $</strong></p><hr><p><strong>如何判别 d 是否是 模p 的二次剩余?</strong></p><p>欧拉判别法:</p><p><strong>d 是 模p 的二次剩余的充要条件:</strong></p><p>$$ d^{\frac{p-1}{2}} \equiv 1(mod\space p) $$</p><p><strong>d 是 模p 的二次非剩余的充要条件:</strong></p><p>$$ d^{\frac{p-1}{2}} \equiv -1(mod\space p) $$</p><p>推论: Chap.5 P16 P17</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99_%E4%B9%98%E7%A7%AF%E5%88%A4%E5%88%AB%E6%8E%A8%E8%AE%BA.png alt=二次剩余_乘积判别></p><blockquote><p>这个d的次方可能很大,具体该怎么算,参见前面的大数带余除法问题(3.4 &amp; 3.2)</p></blockquote><h3 id=5-2-Legendre符号><a href=#5-2-Legendre符号 class=headerlink title="5.2 Legendre符号"></a>5.2 Legendre符号</h3><p><strong>Legendre符号定义:</strong></p><p>设素数p &gt; 2, 令:</p><p>$$ (\frac{d}{p}) &#x3D;<br>\begin{cases}{c}<br>0, 当p|d时 \\<br>1, 当d是p的二次剩余时 \\<br>-1, 当d是p的二次非剩余时 \<br>\end{cases}<br>$$</p><p>我们称 $ (\frac{d}{p}) $ 为 <strong>模p的Legendre符号</strong></p><hr><p>Legendre符号性质:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Legendre%E7%AC%A6%E5%8F%B7%E6%80%A7%E8%B4%A8.png alt=Legendre符号性质></p><blockquote><p>由第一条, Legendre符号就是欧拉判别式的另一种写法.</p></blockquote><hr><p>Legendre符号的有效计算: Gauss二次互反律</p><p>设p, q都是奇素数, 那么:</p><p>$$ (\frac{q}{p})(\frac{p}{q}) &#x3D; (-1)^{(\frac{p-1}{2})(\frac{q-1}{2})} $$</p><blockquote><p>如果p, q不是奇素数, 请利用Legendre符号的性质3, 将其转化为奇素数.<br>划出来的2, 可以用性质5求解</p></blockquote><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Gauss%E4%BA%8C%E6%AC%A1%E4%BA%92%E5%8F%8D%E5%BE%8B_%E4%BE%8B.png alt=Gauss二次互反律_例></p><p>更复杂的例子, 见Chap.5 P28.</p><h2 id=Chap-6-原根与指数><a href=#Chap-6-原根与指数 class=headerlink title="Chap.6 原根与指数"></a>Chap.6 原根与指数</h2><h3 id=6-1-阶-原根><a href=#6-1-阶-原根 class=headerlink title="6.1 阶 &#x2F; 原根"></a>6.1 阶 &#x2F; 原根</h3><p>讨论：</p><p>$$ a^x \equiv b(mod\space m) $$</p><p>这方程目前不会涉及, 但一种最简单的情况需要考虑: 即</p><p>$$ a^x \equiv 1(mod\space m) $$</p><p>使得这个式子成立的 <strong>最小的正整数</strong> x 被称为 <strong>a模m的阶</strong> , 记作 $ ord_m(a) $ .</p><p>特别的, 如果 <strong>$ ord_m(a) &#x3D; \varphi(m) $</strong> 时, 称a是 <strong>模m的原根</strong> .</p><hr><p>阶的性质:</p><ul><li><strong>与代表元无关:</strong></li></ul><p>如果a和b在关于模m的同一个 <strong>既约剩余类</strong> 中, 即:</p><p>$$ b \equiv a(mod\space m) , \space (a, m) &#x3D; 1$$</p><p>则我们一定能推出:</p><p>$$ ord_m(a) &#x3D; ord_m(b) $$</p><ul><li><strong>阶的周期性:</strong></li></ul><p>即如果有:</p><p>$$ a^d \equiv 1(mod\space m) $$</p><p>则必定能推出:</p><p>$$ ord_m(a)|d $$</p><blockquote><p>相当于阶这个概念自己划定了一个周期, 每经过一个周期, 都会再次回到1.</p></blockquote><ul><li><strong>阶与欧拉函数:</strong></li></ul><p>对任何正整数m, 均有:</p><p>$$ ord_m(a)|\varphi(m) $$</p><blockquote><p>说明任何元素模m的阶, 都必定是m欧拉函数的因子.</p></blockquote><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/17%E7%9A%84%E5%8E%9F%E6%A0%B9.png alt=17的原根></p><ul><li><strong>性质4见Chap.6 P15(a的乘方同余, 则乘方之间有关系)</strong></li><li><strong>乘法逆元的阶:</strong></li></ul><p>有:</p><p>$$ ord_m(a) \equiv ord_m(a^{-1}) $$</p><ul><li><strong>a的k次幂的阶与a有关(Chap.6 P17)</strong></li></ul><p>有:</p><p>$$ ord_m(a^k) &#x3D; \frac{ord_m(a)}{(ord_m(a), k)} $$</p><ul><li><strong>原根个数:</strong></li></ul><p><strong>如果m有原根(这是大前提)</strong> , 则m的原根个数必然是:</p><p>$$ \varphi(\varphi(m)) $$</p><p>并且所有原根的集合:</p><p>$$ \lbrace g^i|(i, \varphi(m)) &#x3D; 1, 1\leq i&lt;\varphi(m) \rbrace $$</p><p>这其中:</p><ul><li>g是m的其中一个原根;</li><li>i是乘方数, 必须满足与m的欧拉函数互素;</li></ul><p>举例而言:(还是上面那个17的原根的例子)</p><p>17的原根个数:</p><p>$$ \varphi(\varphi(17)) &#x3D; \varphi(16) &#x3D; \varphi(2^4) &#x3D; 2^3*(2-1) &#x3D; 8 $$</p><p>最后这步是欧拉函数的性质1. (详见3.4)</p><ul><li><p><strong>性质7, 8见Chap.6 P20, 21</strong></p></li><li><p><strong>一个数有原根的充要条件:</strong></p></li></ul><p>当:</p><p>$$ m &#x3D; 2, 4, p^\alpha, 2p^\alpha $$</p><p>时, m一定有原根.</p><p>这其中:</p><ul><li>p 是奇素数;</li><li>$ \alpha $ 是任意正整数;</li></ul><p>这条性质, 和上面那条原根个数的性质, 能够轻松的判断出 <strong>一个正整数是否有原根, 有多少原根.</strong></p><hr><p>原根的有效求解:</p><p>在m有原根的前提下, 对于 $ \varphi(m) $ 所有的素因子 $ q_1, q_2, …, q_s $ , g是模m的原根的充要条件是:</p><p>$$ g^{\frac{\varphi(m)}{q_j}} \neq 1(mod\space m), \space j &#x3D; 1, 2, …, s $$</p><p>上面这个式子其实不是一个直接计算的式子, 只能算一个检验式.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%B1%82%E5%8E%9F%E6%A0%B9_%E4%BE%8B.png alt=求原根_例></p><hr><p><strong>关于原根生成的剩余系:</strong></p><p>任意原根g都可以生成模m的既约剩余系, 即</p><p>$$ \lbrace g^0, g^1, …, g^{\varphi(m)-1} \rbrace $$</p><p>这时, 我们称呼g为模m既约剩余系的一个生成元.</p><blockquote><p>请务必明确, 每个原根都能生成一个既约剩余系, 但这 <strong>不代表每个既约剩余类的代表元都是原根.</strong></p></blockquote><h3 id=6-2-指数><a href=#6-2-指数 class=headerlink title="6.2 指数"></a>6.2 指数</h3><p>指数的概念由原根引出.</p><p>g为m的原根, 给定与m互素的元素a, 则必定存在一个指数 $ \gamma $ , 使得:</p><p>$$ a \equiv g^{\gamma}(mod\space m) $$</p><p>我们称这个 $ \gamma $ 为 <strong>a对模m的以g为底的指数</strong>.</p><p>这个概念建议结合上面原根能够生成既约剩余系的性质来理解. 因为原根必定能够生成一个剩余系, 所以这个指数必定存在(这里的a就相当于一个既约剩余类的代表元).</p><hr><p>引入指数, 主要是为了这个性质:</p><p>g是模m的原根, a与m互素(即(a, m) &#x3D; 1), 则:</p><p>$$ ord_m(a) &#x3D; \frac{\varphi(m)}{(ind_{m, g}(a), \varphi(m))} $$</p><p>这性质的推论很重要.</p><p>推论即: <strong>当模m有原根时, 对于每个正除数d| $ \varphi(m) $ , 在模的一个既约剩余系中, 恰好有 $ \varphi(d) $ 个元素的阶等于d.</strong></p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%8C%87%E6%95%B0%E6%80%A7%E8%B4%A8_%E4%BE%8B.png alt=指数性质_例></p><p><strong>这个结论后来证明对一般循环群也是对的.</strong></p><h2 id=Chap-7-多项式><a href=#Chap-7-多项式 class=headerlink title="Chap.7 多项式"></a>Chap.7 多项式</h2><blockquote><p>从这一章开始, 会将讨论范围扩大到多项式, 而不仅仅限制在整数域内</p></blockquote><h3 id=7-1-多项式的概念><a href=#7-1-多项式的概念 class=headerlink title="7.1 多项式的概念"></a>7.1 多项式的概念</h3><p>$$ K[x] &#x3D; \lbrace a_nx^n + a_{n-1}x^{n-1} + … + a_1x+a_0|\space a_i \in K \rbrace $$</p><p>这里的K可以指代整数Z, 有理数Q, 实数R, 复数C中的任意一个.</p><p>多项式的运算此处不再赘述, 仅定义一个多项式的次数:</p><p>$$ deg\space f $$</p><p>表示多项式f(x)中最高次项的次数.</p><h3 id=7-2-多项式上的整除-不可约-唯一分解><a href=#7-2-多项式上的整除-不可约-唯一分解 class=headerlink title="7.2 多项式上的整除 \ 不可约 \ 唯一分解"></a>7.2 多项式上的整除 \ 不可约 \ 唯一分解</h3><p>类似于整数域, 多项式域内也可以定义整除的概念:</p><p>$$ f(x) &#x3D; g(x)h(x) $$</p><p>记作: $ g(x)|f(x) $</p><p>相似的, 如果找不到这么个 h(x) , 那么记作: $ g(x) \nmid f(x) $ .</p><hr><p>多项式整除的性质:</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%A4%9A%E9%A1%B9%E5%BC%8F_%E6%95%B4%E9%99%A4%E6%80%A7%E8%B4%A8.png alt=多项式_整除性质></p><hr><p>多项式的不可约性:</p><p>$ deg\space p \geq 1$ , 并且在K[x]这个域中仅有平凡分解(就是因子只有1和它自己), 则称p(x)是K[x]内的不可约多项式.</p><p>虽然多项式的不可约性随着K所指向的域的变化而变化, 但至少有两个域中, 可以划等号:</p><p>$$ f(x)在Z[x]中不可约 \iff f(x) 在Q[x]中不可约 $$</p><hr><p>多项式在K[x]上的唯一分解:</p><p>因为有不可约多项式的存在(可以理解为 <strong>多项式域上的素数</strong> ), 因此每个多项式也必然能够通过一系列不可约多项式表示出来.</p><p>$$ f(x) &#x3D; c * p_1(x)^{e1} * p_2(x)^{e2} * … * p_t(x)^{e_t} $$</p><h3 id=7-3-不可约多项式的判别方法><a href=#7-3-不可约多项式的判别方法 class=headerlink title="7.3 不可约多项式的判别方法"></a>7.3 不可约多项式的判别方法</h3><p>又称爱森斯坦判别法(Eisenstein判别法)</p><p>$$ f(x) &#x3D; a_nx^n + …+ a_0 $$</p><p>f(x)是整系数多项式, 如果存在一个素数p, 使得 $ p\nmid a_n $ , $ p^2 \nmid a_0 $ , 但对于剩余的 $ i&lt;n $, 都存在 $ p|a_i $, 则f(x)在Z(Q)上均不可约.</p><h3 id=7-4-模p约化><a href=#7-4-模p约化 class=headerlink title="7.4 模p约化"></a>7.4 模p约化</h3><p>将多项式f(x)的所有系数化为它们的模p剩余类的代表元(就相当于模p)的过程.</p><p>为什么要引入这个概念, 因为以下这个定理是一个非常重要的判别不可约多项式的定理:</p><p>如果f(x)的模p约化的多项式 $ \overline{f} $ 在 $ Z_p[x] $ 中不可约, 那么f(x) 在 Z[x] 中一定不可约.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%A8%A1p%E7%BA%A6%E5%8C%96%E5%88%A4%E5%AE%9A%E4%B8%8D%E5%8F%AF%E7%BA%A6%E2%80%94%E2%80%94%E4%BE%8B.png alt=模p约化判定不可约_例></p><h2 id=Chap-8-域上的一元多项式><a href=#Chap-8-域上的一元多项式 class=headerlink title="Chap.8 域上的一元多项式"></a>Chap.8 域上的一元多项式</h2><h3 id=8-1-环和域><a href=#8-1-环和域 class=headerlink title="8.1 环和域"></a>8.1 环和域</h3><blockquote><p>就是离散中的概念, 这里不会很详细的说明.</p></blockquote><p>(R, +)构成交换群, (R, *)构成半群, 则(R, +, *)称为环, 特别的, 如果 * 运算 <strong>也满足交换律, 则称为交换环</strong> .</p><p>显然, 对于多项式环, 就是一个很典型的交换环.</p><hr><p>域:</p><p>交换环的基础上, R中的所有元素都 <strong>乘法可逆</strong> , 则称为域.</p><ul><li>$ Z_p $ 是域, 这里p是素数</li><li>$ Z_m $ , 如果m是合数, 那就不是域, 因为并非所有的元素都有乘法逆元(乘法逆元存在的前提是必须互素, 而合数并不是跟其中所有元素都互素, 比如2在 $ Z_4 $ 中就没有乘法逆元).</li></ul><h3 id=8-2-域上的一元多项式><a href=#8-2-域上的一元多项式 class=headerlink title="8.2 域上的一元多项式"></a>8.2 域上的一元多项式</h3><p>我们上面介绍的多项式的整除 \ 可约 \ 不可约 均可以类似的搬下来. 不过要注意, 这里的域可能会由于带余除法的存在导致一些此前不成立的性质.</p><p>显然, K[x] 上有无穷多个首项系数为 1 的不可约多项式.</p><p>同时还有定理:</p><p>设p(x)不可约, 如果 $ p(x) | f(x)g(x)…h(x) $ , 那么p(x)至少整除它们其中之一(即p(x)至少是它们其中之一的因子).</p><blockquote><p>上面这个定理, 类比整数上由很多素数乘积组成的合数.</p></blockquote><h3 id=8-3-域上多项式的不可约性判定><a href=#8-3-域上多项式的不可约性判定 class=headerlink title="8.3 域上多项式的不可约性判定"></a>8.3 域上多项式的不可约性判定</h3><p>上面提到了, 只要多项式在 $ Z_m $ 域上不可约, 则多项式在Z上就是不可约的.</p><p>如何判断多项式在 $ Z_m $ 上不可约?</p><hr><p>1.当m较小时, 可以用筛法:</p><p>如 $ Z_2 $上全部小于等于三次的不可约多项式:</p><ul><li>1次多项式均不可约</li><li>2次多项式可约当且仅当它有1次多项式因子 -&gt; 将全部因子两两相乘枚举出来所有可约的, 剩下的就是不可约的.</li><li>3次多项式同理.</li></ul><hr><p>2.当m较大时, 二次多项式是否可约可以通过二次剩余解决:</p><p>由于二次多项式的形式: $ f(x) &#x3D; ax^2+bx+c $</p><p>其可约代表着: $ f(x) \equiv 0(mod\space m) $ 有解.</p><p>即令 $ X &#x3D; b^2 + 4 * a * c $ ;</p><p>如果X是模m的二次剩余, 则方程有解, f(x)可约;</p><p>如果X是模m的二次非剩余, 则方程无解, f(x)不可约;</p><p>至于X是不是模m的二次剩余, 则利用Legendre符号 $ (\frac{X}{m}) $ 来进行判断.</p><blockquote><p>Legendre符号的计算见5.2</p></blockquote><h3 id=8-4-最大公因式-欧几里得算法><a href=#8-4-最大公因式-欧几里得算法 class=headerlink title="8.4 最大公因式 &amp; 欧几里得算法"></a>8.4 最大公因式 &amp; 欧几里得算法</h3><p>同理, 域上的多项式也有其最大公因式, 同样可以利用欧几里得算法进行求解, 只不过要把整数带余除法变更为多项式带余除法.</p><p>比如: $ (x^2-1, x^2+x-2) $ 的求解过程:</p><ul><li>$ x^2+x-2 &#x3D; 1*(x^2-1) + (x-1) $ , 转变为求 $ (x^2-1, x-1) $</li><li>$ x^2-1 &#x3D; (x+1)*(x-1) $</li><li>最大公因式: x-1;</li></ul><p>相应的, 这个过程也可以逆推回去, 跟整数的欧几里得扩展算法一个道理, 这里不再详述.</p><blockquote><p>提一下, 每次求出结果之后别忘了根据域的范围化简, 比如在 $ Z_2 $ 中, 所有的带2的项都可以直接消掉</p></blockquote><hr><p>很显然, 当两个多项式的最大公因式为1时(类比整数互素), <strong>两个多项式可以通过扩展欧几里得算法求得一个关于另一个的乘法逆元.</strong></p><p>具体步骤与整数那里完全相同:</p><ul><li>利用欧几里得算法求出 $ (f(x), g(x)) &#x3D; 1 $ ;</li><li>利用扩展欧几里得算法将1表示成两个多项式的线性组合 $ 1 &#x3D; f(x)*h(x) + g(x)*\varphi(x) $</li><li>h(x)就是该域上f(x)关于g(x)的乘法逆元, 可以表达为: $ f(x)*h(x) \equiv 1(mod\space g(x)) $</li></ul><h2 id=Chap-9-多项式同余><a href=#Chap-9-多项式同余 class=headerlink title="Chap.9 多项式同余"></a>Chap.9 多项式同余</h2><h3 id=9-1-多项式同余-剩余类环><a href=#9-1-多项式同余-剩余类环 class=headerlink title="9.1 多项式同余 \ 剩余类环"></a>9.1 多项式同余 \ 剩余类环</h3><p>我们还是要类比整数域上的同余计算, 即</p><p>$$ f(x) \equiv g(x)(mod\space m(x)) $$</p><p>只不过这里全换成了多项式.</p><p>显然, 对于m(x), 肯定也存在很多个剩余类, 但这里的剩余类的个数与域有关:<br>比如, 在 $ Z_2[x] $ 中, $ x^2+1 $ 的所有剩余类代表元:</p><p>$$ 0, 1, x, x+1, x^2 $$</p><p>由m(x)在域K[x]上的所有剩余类构成的环, 叫做模m(x)的剩余类环, 记作:</p><p>$$ K[x] &#x2F; (m(x)) $$</p><h3 id=9-2-多项式剩余类域><a href=#9-2-多项式剩余类域 class=headerlink title="9.2 多项式剩余类域"></a>9.2 多项式剩余类域</h3><p>当m(x)不可约时(类比到整数域中m是素数), 此时除了0所在剩余类, 其他的剩余类均可逆.</p><p>此时这个剩余类环构成了一个域.</p><blockquote><p>关于多项式的乘法逆怎么求: 类比整数域, 通过多项式域中的扩展欧几里得算法进行计算.(见8.4)</p></blockquote><h3 id=9-3-多项式版本中国剩余定理><a href=#9-3-多项式版本中国剩余定理 class=headerlink title="9.3 多项式版本中国剩余定理"></a>9.3 多项式版本中国剩余定理</h3><p>当遇到多项式同余方程组时, 可以用多项式版本的中国剩余定理来求解, 具体形式与整数域完全相同.</p><p><img src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg data-original=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%88%E6%9C%AC%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png alt=多项式版本中国剩余定理></p><ul><li>先将后面的模数改为两两互素的形式</li><li>套公式, 求逆</li><li>得到通解即可</li></ul><p>至此, 信安数学基础这门课的主要内容就结束了.</p><hr><p>这篇博文就到这里.</p></div><hr><div class=reprint id=reprint-statement><div class=reprint__author><span class=reprint-meta style=font-weight:700><i class="fas fa-user">文章作者: </i></span><span class=reprint-info><a href=/about rel="external nofollow noreferrer">MUG-chen</a></span></div><div class=reprint__type><span class=reprint-meta style=font-weight:700><i class="fas fa-link">文章链接: </i></span><span class=reprint-info><a href=http://mug-chen.github.io/posts/56920.html>http://mug-chen.github.io/posts/56920.html</a></span></div><div class=reprint__notice><span class=reprint-meta style=font-weight:700><i class="fas fa-copyright">版权声明: </i></span><span class=reprint-info>本博客所有文章除特別声明外，均采用 <a href=https://creativecommons.org/licenses/by/4.0/deed.zh rel="external nofollow noreferrer" target=_blank>CC BY 4.0</a> 许可协议。转载请注明来源 <a href=/about target=_blank>MUG-chen</a> !</span></div></div><script async defer=defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class=tag_share style=display:block><div class=post-meta__tag-list style=display:inline-block><div class=article-tag><a href=/tags/Mathematical-basis-of-Information-Security/ ><span class="chip bg-color">Mathematical basis of Information Security</span></a></div></div><div class=post_share style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel=stylesheet type=text/css href=/libs/share/css/share.min.css><div id=article-share><div class=social-share data-sites=twitter,facebook,google,qq,qzone,wechat data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src=/libs/share/js/social-share.min.js></script></div></div></div></div></div><article id=prenext-posts class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos=fade-up><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class=card><a href=/posts/61250.html><div class=card-image><img src=/medias/featureimages/3.jpg class=responsive-img alt=计算机组成原理_Fin> <span class=card-title>计算机组成原理_Fin</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Computer Composition Principles 期末复习章</div><div class=publish-info><span class=publish-date><i class="far fa-clock fa-fw icon-date"></i>2024-06-27 </span><span class=publish-author><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes</a></span></div></div><div class="card-action article-tags"><a href=/tags/Computer-Composition-Principles/ ><span class="chip bg-color">Computer Composition Principles</span></a></div></div></div><div class="article col s12 m6" data-aos=fade-up><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class=card><a href=/posts/41829.html><div class=card-image><img src=/medias/featureimages/20.jpg class=responsive-img alt=Blockchain> <span class=card-title>Blockchain</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Blockchain-Bitcoin Notes</div><div class=publish-info><span class=publish-date><i class="far fa-clock fa-fw icon-date"></i>2024-05-03 </span><span class=publish-author><i class="fas fa-bookmark fa-fw icon-category"></i> <a href=/categories/Study-Notes/ class=post-category>Study Notes</a></span></div></div><div class="card-action article-tags"><a href=/tags/Blockchain/ ><span class="chip bg-color">Blockchain</span></a></div></div></div></div></article></div><script type=text/javascript src=/libs/codeBlock/codeBlockFuction.js></script><script type=text/javascript src=/libs/prism/prism.min.js></script><script type=text/javascript src=/libs/codeBlock/codeLang.js></script><script type=text/javascript src=/libs/codeBlock/codeCopy.js></script><script type=text/javascript src=/libs/codeBlock/codeShrink.js></script></div><div id=toc-aside class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style=background-color:#fff><div class=toc-title><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id=toc-content></div></div></div></div><div id=floating-toc-btn class=hide-on-med-and-down><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src=/libs/tocbot/tocbot.min.js></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=parseInt(.4*$(window).height()-64),e=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>t?e.addClass("toc-fixed"):e.removeClass("toc-fixed")});const n="expanded";let i=$("#toc-aside"),l=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){i.hasClass(n)?(i.removeClass(n).hide(),l.removeClass("l9")):(i.addClass(n).show(),l.addClass("l9"));var e="artDetail",o="prenext-posts";if(0!==(e=$("#"+e)).length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#"+o).width(t)}})})</script></main><script id=MathJax-script async src=https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/mathjax%403.0.0.js></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><footer class="page-footer bg-color"><div class="container row center-align" style=margin-bottom:15px!important><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id=year>2022-2025</span> <a href=/about target=_blank>MUG-chen</a> |&nbsp;Powered by&nbsp;<a href=https://hexo.io/ target=_blank>Hexo</a> |&nbsp;Theme&nbsp;<a href=https://github.com/blinkfox/hexo-theme-matery target=_blank>Matery</a><br><span id=busuanzi_container_site_pv>&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp; <span id=busuanzi_value_site_pv class=white-color></span> </span><span id=busuanzi_container_site_uv>&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp; <span id=busuanzi_value_site_uv class=white-color></span></span><br><span id=sitetime>Loading ...</span><script>var calcSiteTime=function(){var e=new Date,t="2022",n=e.getFullYear(),i=e.getMonth()+1,a=e.getDate(),r=e.getHours(),o=e.getMinutes(),e=e.getSeconds(),s=Date.UTC(t,"12","25","22","45","0"),i=Date.UTC(n,i,a,r,o,e)-s,a=Math.floor(i/31536e6),r=Math.floor(i/864e5-365*a);t===String(n)?(document.getElementById("year").innerHTML=n,o="This site has been running for "+r+" days",o="本站已运行 "+r+" 天",document.getElementById("sitetime").innerHTML=o):(document.getElementById("year").innerHTML=t+" - "+n,e="This site has been running for "+a+" years and "+r+" days",e="本站已运行 "+a+" 年 "+r+" 天",document.getElementById("sitetime").innerHTML=e)};calcSiteTime()</script><br></div><div class="col s12 m4 l4 social-link social-statis"><a href=https://github.com/MUG-chen class=tooltipped target=_blank data-tooltip=访问我的GitHub data-position=top data-delay=50><i class="fab fa-github"></i></a></div></div></footer><div class=progress-bar></div><div id=searchModal class=modal><div class=modal-content><div class=search-header><span class=title><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type=search id=searchInput name=s placeholder=请输入搜索的关键字 class=search-input></div><div id=searchResult></div></div></div><script type=text/javascript>$(function(){!function(t,r,s){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),t=document.getElementById(r),n=document.getElementById(s);t.addEventListener("input",function(){var o='<ul class="search-result-list">',h=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,s=!0,i=t.title.trim().toLowerCase(),l=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),a=0===(a=t.url).indexOf("/")?t.url:"/"+a,c=-1,u=-1;""!==i&&""!==l&&h.forEach(function(t,e){n=i.indexOf(t),c=l.indexOf(t),n<0&&c<0?s=!1:(c<0&&(c=0),0===e&&(u=c))}),s&&(o+="<li><a href='"+a+"' class='search-result-title'>"+i+"</a>",a=t.content.trim().replace(/<[^>]+>/g,""),0<=u&&(t=u+80,(t=0===(e=(e=u-20)<0?0:e)?100:t)>a.length&&(t=a.length),r=a.substr(e,t),h.forEach(function(t){var e=new RegExp(t,"gi");r=r.replace(e,'<em class="search-keyword">'+t+"</em>")}),o+='<p class="search-result">'+r+"...</p>"),o+="</li>")}),o+="</ul>",n.innerHTML=o)})}})}("/search.xml","searchInput","searchResult")})</script><div class=stars-con><div id=stars></div><div id=stars2></div><div id=stars3></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id=backTop class=top-scroll><a class="btn-floating btn-large waves-effect waves-light" href=#!><i class="fas fa-arrow-up"></i></a></div><script src=/libs/materialize/materialize.min.js></script><script src=/libs/masonry/masonry.pkgd.min.js></script><script src=/libs/aos/aos.js></script><script src=/libs/scrollprogress/scrollProgress.min.js></script><script src=/libs/lightGallery/js/lightgallery-all.min.js></script><script src=/js/matery.js></script><script type=text/javascript>var windowWidth=$(window).width();768<windowWidth&&document.write('<script type="text/javascript" src="/libs/others/snow.js"><\/script>')</script><script src=https://ssl.captcha.qq.com/TCaptcha.js></script><script src=/libs/others/TencentCaptcha.js></script><button id=TencentCaptcha data-appid=xxxxxxxxxx data-cbfn=callback type=button hidden></button><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0],e=(t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",document.getElementsByTagName("script")[0]);e.parentNode.insertBefore(t,e)}()</script><script async src=/libs/others/busuanzi.pure.mini.js></script><script src=/libs/instantpage/instantpage.js type=module></script><div id=loading-box><div class=loading-left-bg></div><div class=loading-right-bg></div><div class=spinner-box><div class=configure-border-1><div class=configure-core></div></div><div class=configure-border-2><div class=configure-core></div></div><div class=loading-word>加载中...</div></div></div><script>window.addEventListener("load",function(){document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},!1)</script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!0,preloadRatio:3,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script></body></html>
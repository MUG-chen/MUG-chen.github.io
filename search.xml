<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTML&amp;CSS Part2</title>
      <link href="/posts/54588.html"/>
      <url>/posts/54588.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-2-进入CSS"><a href="#Part-2-进入CSS" class="headerlink" title="Part.2 进入CSS"></a>Part.2 进入CSS</h1><blockquote><p>第一部分中，我们谈完了html的一些基本标签，但是它们的样式多少还有些简朴，要想加点花里胡哨的玩意，就还得看css的内容</p></blockquote><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><p>读者如果进行了一些尝试的话，可以发现HTML的表格，表单都十分的简朴，甚至简陋， <del>不够花里胡哨</del> ，这在前端设计中是不可接受的，因此我们这里引出CSS的样式表。</p><blockquote><p>CSS，cascading style sheets，译为层叠样式表，是web中的表现标准语言，可以达成修改网页显示信息的样式的目的，目前遵循CSS3.0的标准</p></blockquote><h3 id="CSS的组成部分"><a href="#CSS的组成部分" class="headerlink" title="CSS的组成部分"></a>CSS的组成部分</h3><p>CSS的基本组成部分有 <strong>选择符</strong> 和 <strong>声明</strong> ，而每条声名内又由 <strong>属性</strong> 与 <strong>属性值</strong> 组成</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">选择符</span><span class="token punctuation">&#123;</span>    <span class="token property">属性</span><span class="token punctuation">:</span> 属性值<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要说明的是，css的书写是和html同时存在的，但显然直接把css的玩意扔到body中，显得就有些突兀，也很杂乱，因此，我们通常利用html中的 <strong>style</strong> 标签框住css的内容。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        这是个例子        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">h1:</span><span class="token punctuation">&#123;</span>                <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>第一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过上述的例子实现了将所有的第一级标题都更改为红色。</p><p>这里有个众人一块规定的事情，因为文中出现太多style有点影响观感，也不方便阅读，因此我们一般将style写到head中。</p><h3 id="内部样式-外部样式"><a href="#内部样式-外部样式" class="headerlink" title="内部样式 &amp; 外部样式"></a>内部样式 &amp; 外部样式</h3><p><strong>内部样式</strong> ，即 <strong>将对当前html文件起作用的css直接通过style标签写在html内部</strong> ，也就是上方咱们进行css引入的方法。</p><p>但这种方式对于html结构很复杂，内容很繁多的情况就不是很友好，每次想要修改标签还需要翻到文件最上方，不方便。</p><p>因此 <strong>外部样式</strong> 是更常用的一种方法，即在文件外单独写一个css，在需要使用这个css的html中利用 <strong>链接</strong> 来告知html文件需要套用的css内容。</p><p>关于外部样式的链接方式，通常有以下两种：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 第一种 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">herf</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>Css文件路径<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 第二种 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    @import <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>      <span class="token comment">/* 括号里是Css文件的路径 */</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两种方式还是有一定的区别的：</p><ul><li>link标签是XHTML提供的标签，而@import是css提供的方式</li><li>当一个页面被加载时，link引用的css会被同时加载，但@import引用的css会等待页面加载完成后再进行加载，这会导致使用@import引用的css在网速比较慢时页面会出现闪烁</li><li>@import在较老的浏览器（IE5以下）是不兼容的</li></ul><p>因此，在引入标签时，还是建议更多的使用link标签的方式。</p><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><p><strong>行内样式</strong> ，即在html中的某一行单独运用style属性对该标签的样式进行个性化编辑</p><p>像这样：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token special-attr"><span class="token attr-name">style</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>11111111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这玩意尽量不要用太多，因为这东西还是会影响文件可读性的。</p><h3 id="样式表的优先级"><a href="#样式表的优先级" class="headerlink" title="样式表的优先级"></a>样式表的优先级</h3><p>上面讲了三种样式：内部样式、外部样式、行内样式，如果这仨全都存在，则它们总归会有一个顺序优先级的问题。</p><p>这里给出明确结论，内部样式和外部样式的作用取决于谁在head标签更靠下的位置（即谁最后加载），但一般html的书写习惯是将link标签写在style标签上方。</p><p>同理，外部标签与内部标签的优先级都不如行内标签高。</p><p>因此基本上可以说：行内样式 &gt; 内部样式 &gt; 外部样式</p><p>当然，还有一种特殊情况，即 <strong>!important</strong> 标签的存在会使当前指向的样式优先生效。</p><p>总结一下：!important &gt; 行内样式 &gt; 内部样式 &gt; 外部样式</p><p>这里推荐以代码的自上而下的执行顺序来对优先级进行理解。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p><strong>选择器</strong> 的存在是为了实现对html内元素的一对一，一对多的控制。</p><p>存在以下几种类别：</p><ul><li>元素选择器</li><li>类选择器</li><li>id选择器</li><li>通配符选择器</li><li>群组选择器</li><li>包含选择器</li><li>伪类选择器</li></ul><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p>元素选择器就是之前咱们css的写法，即通过选择某一类的元素并添加相应的样式。</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>元素选择器的范围有些太广了，因此我们还需要进行进一步的细分，这就催生了 <strong>类选择器</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* 在指定样式时需要前方加. */</span>    <span class="token selector">.type1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.type2</span><span class="token punctuation">&#123;</span>        <span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 一个标签可以有多个类，中间用空格分隔 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>type1 type2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以理解为，类选择器就是人工将各种标签重新进行了分类。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器与类选择器有些相似，但是id选择器是一对一的，相当于对一个单独的玩意起一个单独的id，在css文件中单独开一片区域来对其进行单独的样式设置。（有点类似身份证号）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* 在指定id之前加# */</span>    <span class="token selector">#box1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 一个标签相应的只能有一个id --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>111111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p><strong>通配符</strong> 顾名思义，即选择所有元素的意义，在html中用 * 进行表示。</p><p>这种选择器会直接选择到一个html中所有的标签，通常用于对所有标签的属性进行整体调试，比如间距等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">*</span><span class="token punctuation">&#123;</span>        <span class="token comment">/* 外边距 */</span>        <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token comment">/* 内边距 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="群组选择器-包含选择器"><a href="#群组选择器-包含选择器" class="headerlink" title="群组选择器 &amp; 包含选择器"></a>群组选择器 &amp; 包含选择器</h3><p>其实群组选择器这玩意就是偷懒用的，如果一个html中存在多个不同的标签，但是想要设置成一个样式，一方面可以用类，但更方便的方法则是利用群组选择器：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">div, p, h1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 当然，也可以直接把类也写进去 */</span>    <span class="token selector">div, .class1, h1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token comment">/* 相当于所有的class1类也都设置了背景颜色 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们可以直接将不同的标签一块写，用逗号隔开即可。</p><p>由此，我们又衍生出了一个叫做包含选择器的玩意（也叫后代选择器），其意义在于选择一个包含在一个标签内的标签。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">div p</span> <span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>        <span class="token comment">/* 在div内的p都会受到影响 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>2222222222    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is first paragraph.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器主要针对超链接标签进行个性化编辑。主要有四种语法，对应超链接具有的四种状态：</p><ul><li>a:link{} 超链接的初始状态</li><li>a:visited{} 超链接被访问后的状态</li><li>a:hover{} 鼠标悬停在超链接上的状态</li><li>a:active{} 超链接被激活（即鼠标按下超链接时其状态）</li></ul><p>这里需要明确，即这四个状态在css中的顺序是固定的，即上方列举的顺序，请务必注意。</p><h3 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h3><p>上边讲了一堆选择器，针对的是不同的标签，但当多个选择器选中了一个标签，并且它们的属性发生了冲突的时候，就涉及到了一个选择器的权重的问题（即哪个选择器中的样式真正对其起作用）</p><p>从尝试结果上来讲，规律为：</p><p>!important &gt; id选择器 &gt; 类选择器 &gt; 元素选择器</p><p>至于包含选择器，其权重为层级权重之和，此后再根据上方的规则进行生效判断。</p><p>当然，上述除了important之外的玩意，在行内样式面前，都无法生效（即在标签内直接写一个style）</p><p>这里额外说一句，上面写过 <strong>样式表的优先级</strong> ，那只是一个大致叙述，而这里则细化到了 <strong>选择器的权重</strong> 。一个样式表是可以包括很多选择器的。</p><hr><p>至此，我们算是初步了解了css的作用，并明确了css应当如何书写，如何与html相关联。这时候读者大概率会想大展宏图，对自己的html网页一同改头换面了。</p><p>下一节，将进入各种css中各种属性的详细设置。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part1</title>
      <link href="/posts/54396.html"/>
      <url>/posts/54396.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-1-概述-一些基础"><a href="#Part-1-概述-一些基础" class="headerlink" title="Part.1 概述 &amp; 一些基础"></a>Part.1 概述 &amp; 一些基础</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（HyperText Markup Language）是一种用于创建网页的标准标记语言，这种语言与此前的C，Java并不十分相同，它的用处主要停留在前端开发的层面上，不会像先前的两门那样那么复杂。</p><p>相应的，目前的浏览器支持的主流格式也以相应的语言后缀进行命名，即（）.html</p><h3 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h3><p>浏览器千千万，不同的浏览器对HTML的标记支持也不尽然相同，这就催生了一群大佬在一块商讨了一个标准出来，规定web的格式规范等等内容，即我们说的 <strong>W3C</strong> 万维网联盟</p><p>这个联盟制定了相应的标准，使得同样的HTML文件在大部分浏览器下能够正常，正确的显示。</p><p>当然，总有个例，在目前已经停用的IE6浏览器中，由于当年微软独树一帜地决定不遵循W3C的标准，因此导致当年写HTML时还要专门对IE6进行一定的适配工作，也是导致IE6名声很臭的原因之一。<del>（后续微软没办法还是在后续的IE版本中进行了W3C的支持）</del></p><h3 id="Web的组成部分"><a href="#Web的组成部分" class="headerlink" title="Web的组成部分"></a>Web的组成部分</h3><p>总而言之，前端的需求内容有三部分：</p><ul><li>HTML结构</li><li>CSS表现</li><li>JS（JavaScript）行为</li></ul><p>HTML规定了网页的结构，但它局限于静态，不好看。<br>CSS可以对网页进行进一步的布局，配色，以及动画制作<br>Javascript则负责一些网页行为的实现，比如点按操作，动画播放，暂停等等。</p><h2 id="第一个HTML文件"><a href="#第一个HTML文件" class="headerlink" title="第一个HTML文件"></a>第一个HTML文件</h2><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt; &lt;!--    我的第一个网页--&gt;&lt;html lang &#x3D; &quot;en&quot;&gt;    &lt;head&gt;        &lt;title&gt;My first HTML pages&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;center&gt;            Hello,&lt;br&#x2F;&gt;World.        &lt;&#x2F;center&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;!--    html: 最外层标签    head: 头部标签    body: 主体标签    常规标记：类似上述的，有头有尾的    单标记（空标记）：&lt;标记&#x2F;&gt;，可以没尾    这里的&lt;br&#x2F;&gt;是换行的意思--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的玩意大伙看一眼就成，下面会分块的进行基本概述</p><h2 id="标签详述"><a href="#标签详述" class="headerlink" title="标签详述"></a>标签详述</h2><h3 id="文档声明与字符编码"><a href="#文档声明与字符编码" class="headerlink" title="文档声明与字符编码"></a>文档声明与字符编码</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在html中，第一步要做的永远是先声明文档类型，即告诉你的浏览器你写的是个什么玩意，在2024年的今天，主流的文档类型是HTML5。</p><p>而后，可以选择性的写入你这个文档的编码类型，由于不同的字符编码规则不同，因此声明编码类型可以帮助浏览器了解应该按照哪种原则进行解码，解决一些兼容性问题。</p><p>需要保证你写的编码格式与你编写HTML程序时的编码类型相同。</p><h3 id="文本的语义化"><a href="#文本的语义化" class="headerlink" title="文本的语义化"></a>文本的语义化</h3><blockquote><p>读一段文字，我们必然希望文字是有重点，有分隔的，而并非是杂糅成一团来进行呈现，这一过程就叫做 <strong>文本的语义化</strong></p></blockquote><p>这里，给出一些常用的语义化标签：</p><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>三级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>四级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span><span class="token punctuation">></span></span>五级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>额外说一嘴，一级标题的数量不建议过多，这是因为网页爬虫会将一级标题放到权重最大的位置，因此一级标题应该是你书写HTML时最简练，最精准的内容概括。</p><h4 id="段落-换行-水平线"><a href="#段落-换行-水平线" class="headerlink" title="段落 &#x2F; 换行 &#x2F; 水平线"></a>段落 &#x2F; 换行 &#x2F; 水平线</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>段落文本内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三者中，换行与水平线是两个空标记。</p><h4 id="加粗-倾斜-各种线"><a href="#加粗-倾斜-各种线" class="headerlink" title="加粗 &#x2F; 倾斜 &#x2F; 各种线"></a>加粗 &#x2F; 倾斜 &#x2F; 各种线</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 加粗 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>加粗的内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>突出的文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 倾斜 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>强调文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">></span></span>斜体内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 删除线 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>s</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>s</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 下划线 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">></span></span>下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 上下标 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sub</span><span class="token punctuation">></span></span>下标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sub</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sup</span><span class="token punctuation">></span></span>上标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sup</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了便于爬虫处理，在处理时推荐使用</p><ul><li>strong</li><li>em</li><li>del</li></ul><h3 id="关于属性值的一些说明"><a href="#关于属性值的一些说明" class="headerlink" title="关于属性值的一些说明"></a>关于属性值的一些说明</h3><p>我们可以看到HTML给了我们很大的操作空间，但同时也有问题，如果我们希望更改一条线的颜色，长度这一类的 <strong>属于其标记本身的属性</strong> ，那这时， <strong>标记的属性值</strong> 就显得尤为重要了。</p><p>我们回到两类标记上：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 双标记 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标记</span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>标记</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 单标记 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标记</span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到标记本身后方是可以附加属性的。</p><p>我们拿很常见的分割线 hr 来举例</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">color</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>green<span class="token punctuation">"</span></span> <span class="token attr-name">width</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">align</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">noshade</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过第一个操作，我们可以达成：</p><ul><li>线的颜色为绿色: color</li><li>线的长度为300px（像素）: width</li><li>线的位置在右侧: align</li></ul><p>通过第二个操作，可以达成：</p><ul><li>去除默认分割线的阴影效果</li></ul><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>由于HTML本身是个标签语言，在我们需要用到标签内的字符是，这是就涉及到了特殊符号的问题<br>（其实这个玩意挺像C里面想要打反斜杠&#x2F;时候的办法）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 左尖角 --></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span><span class="token comment">&lt;!-- 右尖角 --></span><span class="token entity named-entity" title="&gt;">&amp;gt;</span><span class="token comment">&lt;!-- 空格 --></span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span> //这玩意受到字体的影响，可能会导致一些问题<span class="token entity named-entity" title="&emsp;">&amp;emsp;</span> //稍微好一些<span class="token comment">&lt;!-- 当然，其实用CSS进行空格的书写才是更应当推广的方式，这里先权且这样放着 --></span><span class="token comment">&lt;!-- 版权符 --></span><span class="token entity named-entity" title="&copy;">&amp;copy;</span><span class="token comment">&lt;!-- 商标 --></span><span class="token entity named-entity" title="&trade;">&amp;trade;</span><span class="token entity named-entity" title="&reg;">&amp;reg;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="div-span"><a href="#div-span" class="headerlink" title="div &amp; span"></a>div &amp; span</h3><blockquote><p>这两个标签是没有具体意义的，但这二者对于一个HTML页面的分割，划分很有作用</p></blockquote><p>div在直接使用时，会独占一行，作为一个区域的元素。</p><p>span在使用时，能实现内容多宽，就占用多宽的空间距离，常用于独立修饰文本。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>I like <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>gray<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 我们实现了一个标题中对于一个单词的单独修饰 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要提一嘴的是，span单独写是没什么用的，span一般而言需要配合各类属性，样式来进行使用</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><blockquote><p>列表常用于对分类的事物进行罗列</p></blockquote><p>在HTML中，列表有这么几类：</p><ul><li>无序列表：前面没有标号</li><li>有序列表：前面有相应的行号</li><li>自定义列表：形式更加多样</li></ul><p><del>(这玩意尝试写过markdown的看官应该会比较熟悉)</del></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表的标签：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- orderlist --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ol</strong> 标签里面只能包含 <strong>li</strong> 标签，而 li 标签里面就可以加一些花里胡哨的玩意了。</p><p>此外，ol标签本身也可以加一些属性：</p><ul><li>type属性：有序列表前方的标号从什么符号开始：<ul><li>“a” : 小写字母开始</li><li>“A” : 大写字母开始</li><li>“i” : 小写罗马数字开始</li><li>“I” : 大写罗马数字开始</li><li>“1” : 数字1开始</li></ul></li><li>start属性：有序列表从哪个位置开始计数，其取值只能是一个数字</li></ul><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表本身没有顺序之分，因此比有序列表相对简单一些</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- unorderlist --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，ul标签里面也只能放li标签，至于花里胡哨的玩意请放在li内搞</p><p>无序列表前面默认是一个黑色实心圆，其样式可以通过type属性来进行更改：</p><ul><li>“disc” : 黑色实心圆</li><li>“circle” : 黑色空心圆</li><li>“square” : 黑色实心正方形</li><li>“none” : 隐藏，什么都不显示</li></ul><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>这里可以放图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>这里可以放文字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>自定义列表通常整体进行复制，从而方便对每个自定义列表进行单独的样式编辑</p><h3 id="一种缩写"><a href="#一种缩写" class="headerlink" title="一种缩写"></a>一种缩写</h3><p>当我们需要进行多个标签的书写时，可以通过Emmet缩写进行快捷写入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">ol>li&#123;Part&#125;*3<span class="token comment">&lt;!-- 一个具有三个项的有序列表，每个项的内容都是Part --></span>dl>dt&#123;图片&#125;+dd&#123;文字&#125;<span class="token comment">&lt;!-- 一个自定义列表 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片在html中使用 <strong>img</strong> 标签进行插入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>图片的相对路径<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，一般进行html的图片插入时，使用 <strong>相对路径</strong> 。（绝对路径在服务器中不起效果）</p><p>具体相对路径的写法，建议读者自行上网进行了解，这其中涉及到一些Linux的相关知识。</p><h3 id="图片的属性"><a href="#图片的属性" class="headerlink" title="图片的属性"></a>图片的属性</h3><p>对于图片，主要有以下属性：</p><ul><li>src : 即图片的路径（通常为相对路径）</li><li>title : 即鼠标悬停到图片上会显示什么信息</li><li>alt : 图片如果加载不出来会显示的提示信息</li><li>width : 宽度</li><li>height : 高度</li></ul><p>当我们需要让图片自动缩放时，可以只对宽度或高度中一个属性进行预设，可以达到自动缩放的效果。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>超链接，目的在于在不同的html界面中进行跳转</p><p>其具体写法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">title</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">target</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>超链接内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这其中：</p><ul><li><strong>超链接内容</strong> 表示这个跳转链接的显示内容（就是哪个蓝底字的具体内容）</li><li><strong>herf</strong> 表示链接路径</li><li><strong>title</strong> 表示鼠标悬停上去后的显示信息</li><li><strong>target</strong> 表示在哪个位置打开文档<ul><li>“_self” : 默认值，在当前窗口打开新页面</li><li>“_blank” : 在新窗口打开跳转页面</li></ul></li></ul><p>还需要说个事，就是超链接的内容可以是多种多样的，可以是文字，也可以是个图片（利用img标签），这样可以实现点击图片跳转的效果，思路要打开。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这部分就顾名思义，就是咱们平常常见的表格了，其有 <strong>行</strong> ， <strong>列</strong> 等等属性。</p><p>在HTML中，表格的创建如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- tr表示行 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- td表示单元格 --></span>            1        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>            2        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表格-table-的相关属性"><a href="#表格-table-的相关属性" class="headerlink" title="表格(table)的相关属性"></a>表格(table)的相关属性</h3><p>表格总共有8个属性：</p><ul><li>边框线：border &#x3D; “1” ，后方这个数字是表格外边框的像素大小</li><li>宽度：width &#x3D; “500”，同理（也可以写成width &#x3D; “50%”，表示相对于父元素的百分比，直接写的话就是窗口）</li><li>高度：height &#x3D; “500”，同理（同上，也可以通过百分比，但是高度的父元素（即body部分）是由内容决定的，因此不会达到直接占据页面一半这么高的效果）</li><li>位置：align &#x3D; “left &#x2F; center &#x2F; right”，表示表格在横向占据的位置</li><li>背景颜色：bgcolor &#x3D; “blue”</li><li>边框颜色：bordercolor &#x3D; “red”</li><li>单元格之间的间距：cellspacing &#x3D; “0”</li><li>单元格与内容之间的间距：cellpadding</li></ul><h3 id="表格行-tr-的相关属性"><a href="#表格行-tr-的相关属性" class="headerlink" title="表格行(tr)的相关属性"></a>表格行(tr)的相关属性</h3><p>表格行总共有4个属性：</p><ul><li>高度：height</li><li>颜色：color &#x3D; “yellow”，在表格本身有颜色时，这一行会相应的覆盖掉之前的颜色</li><li>文字对齐相关：<ul><li>水平对齐：align &#x3D; “left &#x2F; right &#x2F; center”，同理</li><li>竖直对齐：valign &#x3D; “top &#x2F; middle &#x2F; bottom”，同理</li></ul></li></ul><h3 id="表格单元格-td-的相关属性"><a href="#表格单元格-td-的相关属性" class="headerlink" title="表格单元格(td)的相关属性"></a>表格单元格(td)的相关属性</h3><p>表格单元格总共有5个属性：</p><ul><li>宽度：width，这里要注意，一个单元格设置了宽度，会影响一整列的宽度</li><li>高度：height，同理，一个单元格设置了高度，也会影响一整行的高度</li><li>颜色：bgcolor</li><li>文字对齐相关：<ul><li>水平对齐：align</li><li>竖直对齐：valign</li></ul></li></ul><h3 id="表格的合并列-合并行"><a href="#表格的合并列-合并行" class="headerlink" title="表格的合并列 &amp; 合并行"></a>表格的合并列 &amp; 合并行</h3><p>表格合并列 &#x2F; 行通常这样写：</p><ul><li>colspan &#x3D; “2”，合并列，后方的值即合并后其占据的单元格数目</li><li>rowspan &#x3D; “3”，合并行，后方的值同理</li></ul><p>这里要注意，在合并后，需要将被合并的单元格注释掉，否则会呈现出一种被合并的单元格被 <strong>挤出去</strong> 的感觉。</p><p>咱们要想了，咱这表格都整出来了，是不是该进行一点点自定义化，比如说能在里面输入各种各样的东西之类的？</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单，其最重要的目的，就在于收集信息。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span> <span class="token attr-name">action</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    用户信息：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里咱们得一个个讲：</p><ul><li>form的属性：<ul><li>method &#x3D; “get &#x2F; post”</li><li>action &#x3D; “向何处发送数据”</li></ul></li><li>input内的属性：<ul><li>type &#x3D; “text &#x2F; password &#x2F; submit &#x2F; button &#x2F; reset” 他们分别表示文本输入区，密码输入区，提交按钮，常规按钮，重置功能</li><li>placeholder &#x3D; “显示的简短提示信息”</li><li>name 必须设置，表示提交给后端时能被识别到的名字</li><li>value 常常与按钮一并使用，可以表示按钮上显示的内容</li></ul></li></ul><p>我们需要明确，既然要收集信息，就必定有发射端与接收端，而接收端就在form的action属性内进行说明，而 get &#x2F; post 目的在于提交过后不会对你提交的信息在网址框内进行明确显示。</p><p>在后面的工作中，我们常常使用 “input type &#x3D; button” ，这意味着我们创建了一个完全可自定义的按钮，会在此后的JS行为中对其进行进一步的定义（如校验密码之类的操作可以在这个过程内完成）</p><hr><p>这个坑开的十分的突然，其实主要是博主有了相应的需求，需要了解一下前端相关的知识，因此权且作为一个栏目放在博客中吧。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-7</title>
      <link href="/posts/55458.html"/>
      <url>/posts/55458.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote><p>这标题看着多友善~<br>话说在前，其实从博主的学习顺序上来看，这第七章应该是 图 这一部分的内容，但一来认为刚刚说完树，应该让读者（也是让博主）缓一缓节奏，二来排序这一章在C语言的章节中就想着要进一步扩展一下，正好在此直接说完了事。<br>好嘞，咱正式开始。</p></blockquote><p>在我们C语言的章节中，曾经提过 <strong>冒泡排序</strong> 这一种最基础，最简单的排序方式。诚然，这种排序方式清晰且易懂，但还是那个问题，耗时太长了，时间复杂度太高。因此本章会介绍更多种排序方式，权当为读者扩展思路。</p><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><p>虽然读者应该大体了解了，但这里为了仪式感还是提一嘴。</p><p><strong>排序</strong> 指的是将一个 <strong>无序</strong> 的记录序列调整为 <strong>有序</strong> 的记录序列的过程。</p><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><p><strong>排序的稳定性</strong> 指的是排序算法对于 <strong>相同关键字</strong> 进行排序前后的 <strong>相对次序</strong> 是否有改变。</p><p>这个词算是个新词，咱举个例子说一下，比如有如下这么个数组：</p><p>2, 1, 5<sub>(1)</sub>, 8, 7, 5<sub>(2)</sub></p><p>可以看出，这个序列中有两个 <strong>5</strong> ，而在排序之前，这俩元素是有先后顺序的。<br>如果通过一种排序算法，本来在前面的5<sub>(1)</sub>还会稳定的处于5<sub>(2)</sub>的前侧，我们则称这种排序算法是 <strong>稳定的</strong> ，反之，如果排完序不确定哪个5在前，我们则称这种排序算法是不稳定的。</p><h3 id="内排和外排"><a href="#内排和外排" class="headerlink" title="内排和外排"></a>内排和外排</h3><p><strong>内排</strong> 是 <strong>内部排序</strong> 的简称，其意义为将数据存储在计算机的内存中直接进行排序过程。</p><p>相对应的， <strong>外排</strong> 是 <strong>外部排序</strong> 的简称，其意义为当需要排序的纪录很多时，内存无法全部一次性容纳，则我们在排序的过程中还需要多次访问外存来完成排序的全过程。</p><p>在本章中，我们探讨的主要内容为内部排序。</p><h3 id="内部排序的方法"><a href="#内部排序的方法" class="headerlink" title="内部排序的方法"></a>内部排序的方法</h3><p>本章中主要涉及到的排序方法有：</p><ul><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>基数排序</li></ul><p>它们进行排序的方法有区别，进而导致了其时间复杂度的区别，但总归，内部排序的目标，都在于 <strong>逐步扩大有序序列长度</strong> 。</p><p>与以往不同的是，我们这里先对待排序的数据类型进行定义，这是因为不同排序的方法操作的对象总是需要统一的，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span> </span><span class="token comment">//顺序表长度</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span> <span class="token comment">//你需要定义的关键词类型（也可以直接写，这里不必要太纠结）</span><span class="token comment">//待排序的数据类型定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span> <span class="token comment">//关键字</span>    InfoType otherinfo <span class="token comment">//其他数据</span><span class="token punctuation">&#125;</span>RcdType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    RcdType r<span class="token punctuation">[</span>MAXSIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//在排序中，往往第一个存储区域（即r[0]）处于闲置状态</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//顺序表长度</span><span class="token punctuation">&#125;</span>SqList<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，接下来我们正式进入算法部分。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序的基本思想"><a href="#插入排序的基本思想" class="headerlink" title="插入排序的基本思想"></a>插入排序的基本思想</h3><p><strong>插入排序</strong> ，简称插排，基本思想在于将待排序区域划分为已排序区域(R<sub>1</sub>, R<sub>2</sub>, …, R<sub>i-1</sub>)以及未排序部分(R<sub>i</sub>, R<sub>i+1</sub>, …, R<sub>n</sub>)，我们在涉及到 R<sub>i</sub> 这个元素时，会先找到其在这个有序序列中应当插入的位置，将其插入，同时其原位置上的元素至原先的已排序区域结尾元素顺序后移一位。</p><p>根据上述思路，我们可以将 <strong>一趟插入排序</strong> 分为以下三步：</p><ul><li>在有序区域找到插入位置</li><li>后移后续的有序区元素</li><li>将设计元素插入到该位置上</li></ul><p>与此同时，基于实现方法的不同，插排还有进一步的细分：</p><ul><li>直接插入</li><li>折半插入</li><li>希尔排序</li><li>表插入</li></ul><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序是最简单的，它直接从后往前找，并每次都进行一次比较，直到找到应当插入的位置为止：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertionSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//第一个元素不用进行插排，因为它肯定在第一轮时在第一个位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//还记得之前定义待排序列空出的下标为0的位置吗，这个位置叫做监视哨。</span>            <span class="token comment">//每次排序时会先将待插入的元素赋给监视哨</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//当没到达插入位置时，将该位置的元素往后移一位</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//for跑完了，就到达插入位置了</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//再把监视哨的内容插入到这个位置即可</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码应该注释的很清楚了，读者只需要注意一下这个叫做 <strong>监视哨</strong> 的玩意，这东西在后续的排序算法中会有很广泛的应用。</p><p>这种排序的时间复杂度其实还是挺高，因为其相当于每一次都还得跑两层循环，为O(n<sup>2</sup>)，正因如此，它也还是只适用于排序的元素非常少的情况。</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>我们一寻思了，本来前面的序列就是有序的，那我们干脆用折半查找的方式来找插入位置多好，确实，这就是折半插入排序的基本思路。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//折半插入排序</span><span class="token keyword">void</span> <span class="token function">BiInsertionSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//下面需要通过折半查找找到插入位置</span>        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> high <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//折半</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                high <span class="token operator">=</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//插入点在前半部分</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                low <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//插入点在后半部分</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//当找到插入点时，会将low变到high+1（或将high变到low-1），此时不满足循环条件，退出循环</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录后移</span>        <span class="token punctuation">&#125;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//插入</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，这种排序算法其实时间复杂度总体还是O(n<sup>2</sup>)，但好在当数据很多时，其寻找插入位置比此前直接插入的方式要快很多，因此还是很值得考虑的。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的思路跟此前两者的思路并不相同，它意图先对待排序序列做出 <strong>宏观</strong> 的调整，此后再将调整范围逐步缩小至 <strong>微观</strong> 层面。</p><p>这个思路确实非常令人眼前一亮，其具体实现方式为先进行 <strong>跳跃式的插入排序</strong> ，比如我们将整个序列分为 <strong>d个子序列</strong>：</p><p>R[1], R[1+d], R[1+2d], …, R[1+kd];<br>R[2], R[2+d], R[2+2d], …, R[2+kd];<br>…<br>R[d-1], R[2d-1], R[3d-1], …, R[(k+1)d-1];<br>R[d], R[2d], R[3d], …, R[(k+1)d];</p><p>这个 <strong>d</strong> 被称为排序过程的增量，而这个量是在逐渐减小的，直到最后一趟排序时它会变成1。</p><p>我们在每次排序时，先对每一组中的元素进行排序，最后将d降为1时，就相当于对整体再进行一次直接插入排序。</p><p>到这读者可能会问了，这有啥用呢？最后反正都得进行一次插排？</p><p>别忘了希尔排序的思想，这个方式使得我们在进行最后的整体插排时，整个序列已经 <strong>基本有序</strong> 了，这使得最后的直接插排耗时大幅度降低，这就是希尔排序在前面对宏观顺序的调整的价值。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.7/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p><p>理解了方式，我们给代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//希尔排序</span><span class="token keyword">void</span> <span class="token function">ShellInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//每一趟希尔排序的函数，该趟增量为d</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//对于增量为d的每一组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span>d<span class="token punctuation">;</span> j<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">+=</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//遍历这一组中的每个元素</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将当前元素放在哨兵位</span>            <span class="token keyword">int</span> t<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>t <span class="token operator">=</span> j<span class="token operator">-</span>d<span class="token punctuation">;</span> t<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">>=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> t<span class="token operator">-=</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//对每一个元素，找到其插入位置</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//每个插入位置之后的每个元素后移一位</span>            <span class="token punctuation">&#125;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将该元素插入到这一组的适当位置上</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> dlta<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//dlta数组用于存放每一趟希尔排序的增量，而t用于存储dlta数组的大小</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;</span>t<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">ShellInsert</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> dlta<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对每一趟希尔排序单写函数</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，希尔排序的时间复杂度是一个关于dlta序列（即增量序列）的函数。</p><hr><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>这种排序咱们很熟悉了，在C语言的篇章中就提及过，但是问题在于效率太低了。</p><p>其具体思想在于每一轮排序会逐次进行前后元素的比较并交换，达到每一次将最大元素 &#x2F; 最小元素放到数组最后的效果，这样进行n-1轮，就能够将数组排序完成。</p><blockquote><p>提一嘴，冒泡排序是可以进行改进的，即单独设置一个变量在每次进行排序时检测是否有交换次数的产生，如果没有交换则可以直接退出该次排序进程（数列已有序）</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//冒泡排序</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//flag用于标记是否有交换现象产生</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//在每一轮冒泡之前将标记位置0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">Swap</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        i<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//如果有交换现象则继续</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序（Qsort）"><a href="#快速排序（Qsort）" class="headerlink" title="快速排序（Qsort）"></a>快速排序（Qsort）</h3><p>快排的思想也是分轮的，其思想在于分轮排序：</p><ul><li>一轮快速排序：</li></ul><p>目标在于选出一个枢轴，将比它小的元素放到它的左边，再将比它大的元素放到它的右边：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//单轮快速排序</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivotkey <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>    <span class="token comment">//这个元素作为枢轴</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pivotkey<span class="token punctuation">;</span> <span class="token comment">//放入哨兵位置</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">>=</span>pivotkey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            high<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//如果high指向的元素比枢轴大，则继续搜索</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//当此时high指向的元素比枢轴小了，将high的元素与low的元素交换</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;=</span>pivotkey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//最终low会与high相同，停止循环，此时low / high的位置就是枢轴应该放到的位置</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span> <span class="token comment">//把最后枢轴所在的位置返回</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>快速排序</li></ul><p>有了一轮排序，我们可以通过多轮快排进行对一整个数组的快排：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//多轮快排</span><span class="token keyword">void</span> <span class="token function">QSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//对L.r的s至t的位置进行快速排序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&lt;</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//当前需要排序的长度序列大于1</span>        pivotloc <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对s到t进行一次划分</span>        <span class="token function">QSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s<span class="token punctuation">,</span> pivotloc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对比pivotloc小的序列进行递归</span>        <span class="token function">QSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> pivotloc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对比pivotloc大的序列进行递归</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排的时间复杂度为nlog(n)。</p><p>但还存在一个问题，当快速排序要处理的对象本身就有序时，这就势必导致快排效率的退化（因为每次都拿第一个元素当枢轴），这时，快排会退化为冒泡的时间复杂度。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>简单排序的思路很简单，我们将数组分为一部分有序序列以及另一部分无序序列，将无序序列中最小 &#x2F; 最大的元素挑出来，放到有序序列与无序序列分界处的位置。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//简单选择排序</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//j存储数组中第i小的元素</span>        <span class="token comment">//此时前[1, i]的数组已经排序完成，因此在[i+1, L.length]之间寻找最小值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                j <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//交换到位</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其时间复杂度为O(n<sup>2</sup>)</p><h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p>树形选择排序的主要优化点在于将 <strong>选择最小值</strong> 这一过程的时间复杂度降低了。</p><p>其采用类似于锦标赛的思路，在无序序列中先让元素两两一组，互相比较，记录两者之间最小的那个，而后在挑选出来的新一组中继续两两一组，如此循环，直至最后只剩下一个元素时，这时就是最小的那个。</p><p>这种算法，每一次选出最小值的复杂度是log<sub>2</sub>(n)，而显然我们需要进行n次这样的选择，故整体算法的时间复杂度为nlog<sub>2</sub>(n)</p><blockquote><p>注：log<sub>2</sub>(n)其实就是一棵完全二叉树的深度。</p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>这块咱得重点说一下，因为涉及到了一个全新的玩意，叫 <strong>堆</strong></p><p>堆的定义为满足如下规定的数组：</p><ul><li>r<sub>i</sub> &lt;(&gt;) r<sub>2i</sub></li><li>r<sub>i</sub> &lt;(&gt;) r<sub>2i+1</sub></li></ul><p>这样的数组可以被称为 <strong>小顶堆（大顶堆）</strong></p><p>其实形象地了解一下，我们借助一下上一章中讲的二叉树的知识，就是将一个数组写成一个二叉树，而其每个双亲结点都要比其子节点要小（大）</p><p>那这玩意又跟排序怎么扯上关系呢？</p><p>我们拿小顶堆举例子，显然，小顶堆虽然后面的元素顺序不确定，但是其最顶部的元素则很显然是整个数组中最小的那个。</p><p>那么，我们只需要对这个数组的n个元素先进行建堆操作，将其调整成小顶堆，而后将最小的那个元素扔到最后边，在对前面的n-1个元素继续进行建堆操作，如此循环往复，就能将这个数组变成一个从大到小的有序数组了。</p><p>到这里，就可以引出我们要解决的两个问题了：</p><ul><li>怎么建堆？</li><li>堆顶元素扔到最后去了，那我们怎么对剩余元素建立新堆？</li></ul><p>咱先说第二个：</p><hr><p>我们假设有一个大顶堆：</p><p>98, 81, 49, 73, 36, 27, 40, 55, 64, 12</p><p>现在把最大的那个元素扔到最后面（即98与12交换）<br>数组变为：</p><p>12, 81, 49, 73, 36, 27, 40, 55, 64, 98</p><p>现在要对前n-1个元素继续建堆，其实是一个自上而下 <strong>筛选</strong> 的过程：<br>我们先比较12与其两个子节点81，49；<br>因为要建大顶堆，因此肯定要把最大的元素放到最上边，这三个元素显然81最大，因此将81放到12的位置，交换：</p><p>81, 12, 49, 73, 36, 27, 40, 55, 64, 98</p><p>好的，继续筛选，12现在下标为2，对应的子结点为4、5，即比较12，73，36；<br>显然，73要和12换位置：</p><p>81, 73, 49, 12, 36, 27, 40, 55, 64, 98</p><p>继续筛选，12的下标为4，对应的子节点为8、9，即比较12，55，64；<br>继续，64和12换位置：</p><p>81, 73, 49, 64, 36, 27, 40, 55, 12, 98</p><p>好了，目前我们发现12没数可比了，就结束调整，我们发现此时前n-1个元素又变成了一个大顶堆。</p><blockquote><p>注：别忘了在排序中，数组下标从1开始哦（0号元素是哨兵位）。</p></blockquote><p>通过这种方式，我们可以达成调整大顶堆的目的。</p><hr><p>那再回到第一个问题，我们就可以用与第二个问题类似的思路继续往下走：</p><p>我们想到了，其实建堆的过程就是一个逐层递进，一层一层建立堆的过程：</p><p>上面的过程中根结点的两棵子树其实没有变，这就意味着我们如果能把根结点的两棵子树分别调整成大顶堆，就可以再进行一次上面的算法，将整棵树都变成大顶堆。</p><p>这就形成了一个循环的思路。</p><p>给出代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//调整大顶堆</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token comment">//哨兵位暂存堆顶元素</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>s<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span> i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>m <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//将i指向子节点中最大的那个元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">>=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//如果堆顶元素比两个元素都大</span>            <span class="token comment">// 说明这个当前位置就是堆顶元素应该插入的位置，退出循环</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> s <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//否则将比较大的那个元素移到顶部，继续下一轮判断</span>        <span class="token comment">//这里之所以不是交换是因为L.r[0]已经暂存了我们要调整的元素</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//结束循环后，s会指向堆顶元素需要插入的位置</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//堆排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//从底层树开始一层层调整为大顶堆</span>        <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">,</span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//将整个数组建成大顶堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//将最前面的元素（最大的元素）与未经排序的最后一个元素交换</span>        <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调整成大顶堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>堆排序的时间复杂度为O(nlogn);</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的思路又不一样了，其思路在于逐次排序，并两两合并。</p><p>比如一个数组有8个元素，归并排序是 12 &#x2F; 34 &#x2F; 56 &#x2F; 78 ，将元素分为四组，先将这四组都改为有序列，而后两两合并，即变为 1234 &#x2F; 5678，再对这两组元素分别排成有序序列，而后继续合并为 12345678，并排序。最终变为有序序列。</p><p>每一趟归并的时间复杂度是O(n)，而归并排序总共需要进行O(log<sub>2</sub>n)趟</p><p>因此归并排序的总时间复杂度为O(nlogn)</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序针对多关键字，同时根据关键字数位不同，需要进行多次 <strong>分配-收集</strong> 的过程。</p><p>咱举个例子</p><hr><p>假如说，有如下这些关键字：<br>209, 386, 768, 185, 247, 606, 230, 834, 539</p><p>我们如果想要将其进行有序排列，除了可以直接进行数字之间的比较外，我们还可以将其看为一个个的个体，即由个位数，十位数，百位数三个部分组成的一个整体。</p><p>那我们只需要对三个部分按照合适的顺序分别进行排序即可成功将这个序列变为有序序列。</p><p>我们先按个位数来一遍：<br>230, 834, 185, 386, 606, 247, 768, 209, 539</p><p>在个位数的基础上，再按十位数进行排序：<br>606, 209, 230, 834, 539, 247, 768, 185, 386</p><p>而后，在以上两次排序排出序列的基础上，我们再按百位数进行排序：<br>185, 209, 230, 247, 386, 539, 606, 768, 834</p><p>会发现数组已经有序。</p><hr><p>以上，是基数排序的一个经典的案例，这个例子很恰当的说明了这种排序方法在多关键字的情况下的适用性。</p><p>时间复杂度是O(d(n+rd));</p><p>d是 <strong>分配-收集</strong> 的趟数，rd是 <strong>基数的取值范围</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK，这么多种排序过去，咱做个总结。</p><h3 id="时间性能："><a href="#时间性能：" class="headerlink" title="时间性能："></a>时间性能：</h3><ul><li>O(nlogn) : 快速排序（QSort），堆排序（HeapSort），归并排序（MergeSort）</li><li>O(n<sup>2</sup>) : 直接插入排序，冒泡排序，简单选择排序</li><li>O(n) : 基数排序（有限制）</li></ul><p>如果本来待排序列就有序，则直接插入排序，冒泡排序的时间复杂度进化为 O(n)，而快速排序退化为 O(n<sup>2</sup>)</p><h3 id="空间性能："><a href="#空间性能：" class="headerlink" title="空间性能："></a>空间性能：</h3><p>空间性能指排序过程中需要的辅助空间大小：</p><ul><li>O(1) : 所有简单排序（插入，冒泡，选择），堆排序</li><li>O(logn) : 快速排序（递归过程占用的栈空间）</li><li>O(n) : 归并排序（需要复制一个数组进行归并的操作）</li></ul><h3 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h3><p>在文章开头介绍了稳定性的概念。</p><p>像快速排序，直接选择排序，堆排序，希尔排序这种有 <strong>频繁元素交换操作</strong> 的排序方法往往是不稳定的。</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-6</title>
      <link href="/posts/6243.html"/>
      <url>/posts/6243.html</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><blockquote><p>本节，是数据结构的第一部分重难点 <strong>树</strong> 的知识梳理。其涉及到的知识体系极其繁杂，同时会常常与前面的数据结构有所联系。</p></blockquote><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树——概述"><a href="#树——概述" class="headerlink" title="树——概述"></a>树——概述</h3><blockquote><p>我们首先需要了解，树这个玩意到底是个啥？</p></blockquote><p>我们在学习前面的数据结构时，往往其结构都是 <strong>线性的</strong> ，这意味着其结构中的每一个元素都只有一个前驱，也只有一个后继。</p><p><strong>树</strong> 与之不同，树中的每个节点（除根结点外）只有一个前驱，但其可以包含多个后继，这就是其与此前的数据结构在根本上的区别。</p><h3 id="树——常用术语"><a href="#树——常用术语" class="headerlink" title="树——常用术语"></a>树——常用术语</h3><p>由于树的结构复杂性，我们需要先做出一些术语上的约定，以防止此后我们在进行描述时，产生歧义。</p><ul><li>树的 <strong>根</strong> ：一棵树中的第一个元素，它没有前驱，只有后继</li><li>树的 <strong>结点</strong> ：包含一个元素，以及若干个指向其子树（后继）的分支；</li><li>结点的 <strong>度</strong> ：一个节点所连接的子树的数目；</li><li>树的度：这棵树里面所有结点度的最大值；</li><li><strong>叶子结点</strong> ：没有子树的结点；</li><li>分支节点：有子树的结点；</li><li><strong>孩子结点</strong> ：一个结点的两个子树的根；</li><li><strong>双亲结点</strong> ：一个结点的前驱结点；</li><li><strong>兄弟结点</strong> ：两个具有相同双亲结点的结点互相称为兄弟；</li><li><strong>堂兄弟结点</strong> ：两个双亲结点在同一层的结点互相称为堂兄弟；</li><li>结点的 <strong>层次</strong> ：从根结点到该结点的路径长度+1；</li><li>树的 <strong>深度</strong> ：树中所有叶子结点的层次的最大值；</li></ul><p>相信看到这一堆名词已经能让一部分读者感到头疼了…<br>别着急，我们先从最简单的树——二叉树讲起。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>二叉树</strong> 是最简单的树，其特殊性在于规定了每个结点最多只能有两棵子树，这这两棵子树被称为 <strong>左 &#x2F; 右子树</strong> 。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>二叉树的形式非常特殊，因此在这里我们浅谈一下其具体性质：</p><ul><li>在二叉树的第 i 层上至多有 2<sup>i-1</sup> 个结点</li><li>深度为 k 的二叉树上至多有 2<sup>k</sup> - 1 个结点<blockquote><p>注：考虑结点最多的情况，即 2<sup>0</sup> + 2<sup>1</sup> + … + 2<sup>k-1</sup> &#x3D; 2<sup>k</sup> - 1</p></blockquote></li><li>对任意的一棵二叉树，若其度为0的结点（叶子结点）的数目为N，度为2的结点的数目为N<sub>2</sub>，则N &#x3D; N<sub>2</sub> + 1<blockquote><p>注：这里我们不给严谨证明，我们只给一个思路，即在任意一棵二叉树中，多一个度为2的结点就必定意味着多出了一个叶子节点，而一棵二叉树在只有根结点的时候叶子节点数量为1，因此可以推出上式</p></blockquote></li></ul><p>在叙述第四个性质之前，我们需要先了解两类特殊的二叉树：</p><hr><ul><li>满二叉树：深度为k，且含有 2<sup>k</sup> - 1 个结点的二叉树<blockquote><p>顾名思义，这个二叉树里面除了叶子结点之外，所有的结点的度都是2，因此得名</p></blockquote></li><li>完全二叉树：树中所含的n个结点和满二叉树编号为 1 -&gt; n 的结点一一对应。<blockquote><p>啥意思呢，这里得给两个图来解释一下：</p></blockquote></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><hr><p>好的，了解完这两种特殊的二叉树，我们接下来回到此前性质的学习中：</p><ul><li>具有n个结点的 <strong>完全二叉树</strong> 的深度为：[log<sub>2</sub>n] +1<blockquote><p>证：我们设完全二叉树的深度 k ；由于第二条性质的存在，得到 2<sup>k-1</sup> &lt; 2<sup>k</sup> ，对该式进行化简，即可得到 k-1 &lt; [log<sub>2</sub>n] &lt; k ，同时k又只能是整数，因此得到这个性质。</p></blockquote></li><li>对于任意的 <strong>完全二叉树</strong> ，我们对其进行从上至下，从左至右的编号（就类似上图的编号方式），可以得到如下性质：<ul><li>若结点编号 i &#x3D; 1 ，则这个结点是其根结点，否则编号为 [i&#x2F;2] 的结点就是其双亲结点。</li><li>对于任意结点，如果对于其编号 i 满足 <strong>2i &gt; n</strong> ，则该结点没有左孩子。否则，编号为 <strong>2i</strong> 的结点是其左孩子。</li><li>对于任意结点，如果对于其编号 i 满足 <strong>2i +1 &gt; n</strong> ，则该结点没有右孩子。否则，编号为 <strong>2i + 1</strong> 的结点是其右孩子。</li></ul></li></ul><p>关于二叉树的性质，大体就这么些，其中大部分的性质是比较容易就能推出来的，最后两个关于完全二叉树的性质也可以在读者对于完全二叉树的理解加深之后轻易写出。 <del>（实在不行咱画一个图看一眼，举例嘛，不寒碜）</del></p><h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><blockquote><p>说了挺多，现在咱来看看这东西在计算机里面该怎么实现</p></blockquote><h4 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h4><p>相信挺多读者一看顺序存储应该挺诧异，觉着不是很好实现。确实，顺序存储（即利用数组的方式存储二叉树）仅比较适用于完全二叉树，这是因为其标号是有规律可循的（详见上面的最后一条性质）。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="完全二叉树的顺序存储"></p><p>如果想在非完全二叉树的基础上进行顺序存储，那我们为了保持结构以及访问的便利性，只能先创建一个与之相对的完全二叉树的数组，而后将其不存在的结点值赋值为0。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="非完全二叉树的顺序存储"></p><p>读者应该看出来了，如果这样存储二叉树，会产生极大的内存浪费，因为需要占用很大的空间来存储中间的0元素，这是得不偿失的。</p><h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><ul><li>二叉链表</li></ul><p>非常自然地，加入二叉树的每一个结点都最多有两个孩子，那我们自然可以利用一个链表结构，只不过这个链表中的每个结点都有两个指针，分别指向其左孩子以及右孩子。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span> <span class="token comment">//节点内存储的内容</span>    BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment">//分别指向其左孩子与右孩子</span><span class="token punctuation">&#125;</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li>三叉链表</li></ul><p>有二叉链表，我们又想了，能不能达成一个通过子节点能够找到它双亲结点的结构呢？当然可以，无非就是加一个指针的事情：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TriTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    TriTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    TriTNode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">//新增一个指向双亲结点的指针，但是维护起来会更费时</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>三叉链表的存储比二叉链表更加清晰一些，但是维护起来明显更加费时，这里的选择可以由读者自行决定，本文中大部分的代码演示会通过二叉链表来进行。</p></blockquote><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><blockquote><p>我们说完了这玩意该怎么在计算机里面实现存储，现在就需要说一说它的一些基础操作了。</p></blockquote><p>我们首先需要明确遍历的原则，即二叉树中的每个结点均 <strong>被访问且仅被访问一次</strong> 。</p><p>对于二叉树而言，有两种遍历思路可选：</p><ul><li>深度优先遍历：先进行左（右）子树的遍历，待这一过程完毕后，再遍历右（左）子树。</li><li>广度优先遍历：从上至下按照树的层次一层层遍历。</li></ul><p>我们从广度优先的先左后右的遍历说起。</p><h4 id="先左后右的深度优先遍历算法"><a href="#先左后右的深度优先遍历算法" class="headerlink" title="先左后右的深度优先遍历算法"></a>先左后右的深度优先遍历算法</h4><p>这种思路又分为三种子思路，即我的根结点应该在什么时候进行访问：</p><ul><li>先序遍历：即先访问根结点，再依次访问左子树，右子树</li><li>中序遍历：即先访问左子树，再访问根结点，最后访问右子树</li><li>后序遍历：即先访问左子树，右子树，最后访问根结点</li></ul><p>这里额外说一句，构建二叉树的时候，我们是可以通过不同的遍历方式作为依据的，具体来说，我们可以通过中序遍历以及其余任意一种遍历方式来唯一确定一棵二叉树。</p><hr><ul><li>递归遍历算法</li></ul><p>由于二叉树的特殊性，我们很容易想到递归的遍历方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//先序遍历</span><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印当前节点的值</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分别先后利用递归遍历左子树与右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//中序遍历</span><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先遍历左子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印当前节点的值</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后遍历右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//后序遍历</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先遍历左子树</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//再遍历右子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后打印当前节点的值</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种遍历算法利用递归，写起来简单明了，但存在效率问题。<br>相信写C语言递归的读者经常遇到递归深度过深的问题，我们试想一下，如果有一棵树，其深度达到100，那几乎不用考虑，这种算法肯定直接报错退出。</p><p>这也就需要引出我们的第二种算法。</p><hr><ul><li>非递归遍历算法</li></ul><p>在这种算法中，我们使用此前我们学过的 <strong>栈</strong> 这种结构来对树进行遍历。</p><p>我们先把思想搞明白，然后再上代码，以中序遍历为例：</p><p>这种算法的思路为：</p><ul><li>我们先从根结点一直向左下找，途中只要遇到一个结点，我们就将其入栈；</li><li>直到我们找到了NULL结点，这说明它上一个结点是整棵树最靠左下的结点了，这时我们将其出栈，并访问它，而后继续访问其右子树；</li><li>访问其右子树的过程与上述过程相同，直到整棵右子树被访问完毕。</li><li>此后，我们可以继续出栈一个结点，重复上述过程。</li><li>当栈空时，整棵二叉树就被我们遍历完毕了</li></ul><p>上面的文字描述比较晦涩难懂，这里给出一棵具体的树作为例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%20%E5%AE%9E%E4%BE%8B%E6%A0%91.png" alt="实例树"></p><p>我们将遍历过程写一遍：</p><ul><li>对于这一棵二叉树，我们单独设置一个栈，初始为空。</li><li>从根结点找到最左下的结点，路径上所有的结点均入栈。即 1入栈 、 2入栈 、 4入栈；<ul><li>现在栈中的元素：1, 2, 4;</li></ul></li><li>到达4的左孩子，发现是NULL，因此此时出栈一个元素（4），访问它，并遍历它的右子树。</li><li>我们发现4的右子树是NULL，因此直接退出遍历，此时再次检测栈中是否有元素，发现栈不空，再次出栈一个元素（2），访问它，并遍历它的右子树。<ul><li>此时根结点是5，同样的向左下找，路径上所有的结点均入栈。即5入栈 、 6入栈；<ul><li>此时栈中的元素：1, 5, 6;</li></ul></li><li>到达6的左子树，发现是NULL，因此此时出栈一个元素（6），访问它，遍历它的右子树（NULL）；</li><li>检测栈中是否有元素，发现栈不空，出栈一个元素（5），访问它，遍历其右子树</li><li>此时根结点是7，向左下找，路径上元素入栈。即7入栈；<ul><li>此时栈中元素：1, 7;</li></ul></li><li>到达7的左孩子，发现是NULL，出栈一个元素（7），访问它，遍历其右子树（NULL）；</li></ul></li><li>此时再次检测栈中元素，栈非空，出栈一个元素（1），访问它，遍历其右子树；</li><li>3入栈；<ul><li>此时栈中元素：3;</li></ul></li><li>3的左孩子是NULL，3出栈，同时遍历3的右子树（NULL）；</li><li>检测栈中元素，栈空，退出算法</li></ul><p>上述过程就是这种算法进行遍历的方式，请读者务必理解，下面我们给出具体代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//中序遍历——非递归算法</span><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BiTNode <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m根据你的树的深度来决定，足够大就行</span>    BiTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//来表示栈顶的位置</span>    p <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//p入栈</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment">//p指向其左孩子</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//这个循环在p指向的左孩子是NULL的时候会停止</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//判断栈不空</span>            p <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>            top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//出栈一个元素</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问刚刚出栈的元素（打印）</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//继续扫描右子树，开始下一层循环</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//当 p不空或者栈不空时，继续该循环</span>    <span class="token comment">//额外提一嘴，这里最外层的do_while循环的停止条件是p为NULL，并且栈空，此时才会退出循环</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在读者能够看明白上述代码的时候，我们可以继续将先序遍历以及后序遍历的非递归算法给出。</p><p>下面是先序遍历的算法，其思路为：</p><ul><li>检测栈中是否为空</li><li>双亲结点出栈访问；</li><li>检测该结点有没有左右孩子，按照先右后左的顺序入栈；</li><li>回到第二步继续循环，直到栈空，算法结束</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//先序遍历——非递归算法</span><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BiTNode<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//类似的，m可以由读者自行决定，够大就可以</span>  BiTNode<span class="token operator">*</span> p<span class="token punctuation">;</span>  <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//b不空，开始遍历</span>    stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">//根结点入栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//当栈不空时，循环</span>      p <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//先将一个结点出栈（先序遍历的特点）</span>      top<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//p有右孩子</span>        top<span class="token operator">++</span><span class="token punctuation">;</span>        stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//p的右孩子先入栈</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//p有左孩子</span>        top<span class="token operator">++</span><span class="token punctuation">;</span>        stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment">//p的左孩子后入栈</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//当栈空时，所有的结点均被访问完毕</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个先序遍历算法有一点需要额外说明一下：在访问完当前结点，随后入栈当前结点的左右孩子时，为了保证程序能 <strong>先访问左孩子，再访问右孩子</strong> ，我们需要 <strong>先将右孩子入栈，随后再将左孩子入栈</strong> 。这是由栈的后进先出原则决定的。</p><p>最后是后序遍历，这是三种遍历中最难写的一种。</p><p>这玩意涉及到了一个重复访问的问题：即我们先找到左节点，随后返回其双亲结点，再访问双亲结点的子树，再返回双亲结点，这就产生了问题：<br>我们如何判断返回双亲结点时，这是从左子树返回过来的，还是从右子树返回过来的？</p><p>因此，很遗憾的，我们可能又需要写一个辅助栈，来额外设置一个标记位，便于我们判断返回情况。</p><p>还是先给出大体思路：</p><ul><li>沿着根结点一直向左下走，直到走到NULL，途中所有的结点入栈，同时辅助栈相应的位置添加标记0；</li><li>走到NULL后，检测当前栈顶结点，并将其对应标记位设置为1，开始访问其右子树；</li><li>右子树的访问规则与第一步相同；</li><li>当我们访问完右子树再次返回这个结点时（即总有一次我们检测栈顶元素，发现这个结点的标记位已经被我们之前置成1了），我们将其出栈，并打印。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//后序遍历——非递归写法</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BiTNode<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  BiTNode<span class="token operator">*</span> p <span class="token operator">=</span> b<span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token operator">*</span> sub <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//辅助栈</span>  <span class="token keyword">int</span> top<span class="token punctuation">;</span> <span class="token comment">//由于辅助栈的栈顶与主栈栈顶同步，因此只需要设置一个表示栈顶的变量即可</span>  <span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      top<span class="token operator">++</span><span class="token punctuation">;</span>      stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>      tag<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//第一次入栈时，将其标志位置为0</span>      p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//向左下一直找到NULL</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sub<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//如果当前栈顶元素的左右子树都被访问过了</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//出栈</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sub<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//当前栈顶元素的右子树还没被访问过</span>      p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//把p指向右子树，用于下一次的循环</span>      tag<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//将其标志位置成1</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">||</span> top<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//当p为NULL且栈空时才停止循环</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="按层次遍历的广度优先算法"><a href="#按层次遍历的广度优先算法" class="headerlink" title="按层次遍历的广度优先算法"></a>按层次遍历的广度优先算法</h4><p>相对于深度优先算法而言，广度优先的算法要显得友好许多。</p><p>我们采用队列这种数据结构来遍历这棵二叉树，其思路为：</p><ul><li>创建一个队列；</li><li>先将二叉树的根结点入队；</li><li>对任意一个队列中的结点，我们先将其出队并打印，同时将其左孩子和右孩子入队列。</li><li>依照上述过程循环，直到队列空为止</li></ul><p>读者可以依照上面给过的二叉树的例子试着手过一遍这种算法，写过一遍的理解总是要比直接看代码要清晰许多，下面我们给出代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//广度优先遍历</span><span class="token keyword">void</span> <span class="token function">TransLevel</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">Queue</span><span class="token punctuation">&#123;</span>    BiTree<span class="token operator">*</span> vec <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一个道理，m够大就行</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">//指示队列头尾的变量</span>  <span class="token punctuation">&#125;</span>q<span class="token punctuation">;</span>  BiTree<span class="token operator">*</span> temp<span class="token punctuation">;</span>  q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//树空，则直接返回</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token comment">//否则，树根入队</span>    q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>    q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>front<span class="token operator">!=</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//当队列不空时，循环</span>    temp <span class="token operator">=</span> q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span>front<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> temp<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//队头的元素出队并打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-></span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//出队的元素有左孩子</span>      q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token operator">-></span>lchild<span class="token punctuation">;</span>      q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-></span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//出队的元素有右孩子</span>      q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token operator">-></span>rchild<span class="token punctuation">;</span>      q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>好的，二叉树的遍历至此，就差不多讲完了。这部分难度不小，读者可以缓口气。</p><p>之所以这么重视这一部分，并且花费很大的篇幅来讲解，是为了下一个部分，二叉树的基础应用来做铺垫，没有二叉树的遍历，我们没法进入下一部分。</p><blockquote><p>注：如果深度遍历的非递归算法读者未能理解，可以暂时跳过，递归算法先用着嘛，不寒碜。</p></blockquote><h3 id="二叉树的基础应用"><a href="#二叉树的基础应用" class="headerlink" title="二叉树的基础应用"></a>二叉树的基础应用</h3><h4 id="统计叶子结点的个数"><a href="#统计叶子结点的个数" class="headerlink" title="统计叶子结点的个数"></a>统计叶子结点的个数</h4><p>这应用在咱说完遍历算法之后应该不算很难了，我们只需要在算法中加入一个计数器，再把打印那一步改成一个判断语句，即如果这个结点没有左右孩子，则计数器+1即可。</p><p>这里就不写代码了，读者照着上面的代码自行改一改就好。</p><h4 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h4><p>求深度这一算法类似于后序遍历，我们根据二叉树的定义，应该能看出来树的深度等于其左子树与右子树深度的最大值+1；因此，这算法用递归相当好写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> depthval<span class="token punctuation">,</span> depthleft<span class="token punctuation">,</span> depthright<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//树空，返回0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    depthleft <span class="token operator">=</span> <span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    depthright <span class="token operator">=</span> <span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    depthval <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>depthleft<span class="token operator">></span>depthright<span class="token operator">?</span>depthleft<span class="token operator">:</span>depthright<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> depthval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><blockquote><p>线索二叉树这玩意其实笔者没找到非常具体的应用场景，但是无可奈何这东西确实在数据结构的书上有，这里稍微提一嘴</p></blockquote><p><strong>线索二叉树</strong> 是为了提高遍历速度而建立的一种类似于链表的结构，因此也被称为线索链表，主要用于深度遍历，也分为以下三类：</p><ul><li>先序线索链表</li><li>中序线索链表</li><li>后序线索链表</li></ul><p>其与二叉树的具体区别在于，二叉树中的空节点就是空节点，但线索二叉树并不，它将所有的空结点连接上了它遍历时的前驱与后继。</p><p>但这里又产生了一个问题，即我们如何区分一个结点的左右指针指向的是孩子还是线索呢？<br>对喽，引入了两个标记位，它们一个用于标记左指针，另一个用于标记右指针，当标记位为0时，它正常指向左 &#x2F; 右孩子，但当标记位为1时，则代表着它指向相应遍历顺序中的前驱与后继。</p><p>这里举一例：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%20%E5%AE%9E%E4%BE%8B%E6%A0%91.png" alt="线索二叉树例图"></p><p>我们还是拿这棵树来举个例子，其中序遍历时的顺序为：</p><p>4, 2, 6, 5, 7, 1, 3</p><p>正常而言，6没有左右孩子，其两个指针都是NULL，但在线索二叉树中，6这个结点的两个标记位都为1，即其左右指针均指向其前驱与后继，在这里即6的左指针指向了2，右指针指向了5</p><p>线索链表的具体结点结构为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span><span class="token punctuation">&#123;</span>  TElemType data<span class="token punctuation">;</span>  BiThrNode<span class="token operator">*</span> lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token keyword">int</span> Ltag<span class="token punctuation">,</span> Rtag<span class="token punctuation">;</span> <span class="token comment">//新增加的左右标记位</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线索二叉树的相关内容我们就写这么些。</p><h2 id="树——回归"><a href="#树——回归" class="headerlink" title="树——回归"></a>树——回归</h2><blockquote><p>前面的二叉树是树的一种最基础的表现形式，现在让我们回到树，继续谈树的一些存储和应用。</p></blockquote><h3 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h3><p>与二叉树相似，树的表示方式也有很多种，但其复杂性在于一个结点可能有多个孩子。这里介绍几种常见的存储方式。</p><h4 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h4><p>我们可以把每一个结点的孩子结点排列起来，以单链表作为存储结构。这也就代表着，一棵树有n个结点，也就有n个孩子链表。</p><p>又由于这n个头指针又形成了一个线性表，因此我们可以采取线性存储结构。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%A0%91%20%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子链表表示法"></p><p>在这种表示方式中，显然我们需要定义两种结点类型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> child<span class="token punctuation">;</span> <span class="token comment">//表示这个孩子所在的下标</span>  CTNode<span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//指向下一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//孩子结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  CTNode<span class="token operator">*</span> firstchild<span class="token punctuation">;</span> <span class="token comment">//指向第一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//双亲结点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们希望在双亲结点中能够直接找到自己的双亲结点，我们只需要在PTNode中增加一个变量即可：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%B8%A6%E5%8F%8C%E4%BA%B2%E7%9A%84%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8.png" alt="带双亲的孩子链表"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  <span class="token keyword">int</span> parent<span class="token punctuation">;</span> <span class="token comment">//存储双亲结点的下标</span>  CTNode<span class="token operator">*</span> firstchild<span class="token punctuation">;</span> <span class="token comment">//指向第一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//双亲结点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="树的二叉链表表示法（孩子-兄弟表示法）"><a href="#树的二叉链表表示法（孩子-兄弟表示法）" class="headerlink" title="树的二叉链表表示法（孩子-兄弟表示法）"></a>树的二叉链表表示法（孩子-兄弟表示法）</h4><p>前面铺垫了半天二叉树，这里肯定得用一下子。</p><p>我们如果想将一棵多叉树转换成一棵二叉树，应该怎么做呢？</p><p>比较通用的做法是将二叉树的左指针指向自己的第一个孩子，右指针指向自己下一个兄弟。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  CSNode <span class="token operator">*</span>firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>nextsibling<span class="token punctuation">;</span> <span class="token comment">//分别存储自己的第一个孩子和下一个兄弟</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，上图的树，我们如果利用这种方式进行存储：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%A0%91%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8.png" alt="树的二叉树存储"></p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>类似于二叉树，树也有不同的遍历法：</p><ul><li>先根遍历（对应二叉树的先序遍历）：先访问根根结点，然后依次访问各棵子树</li><li>后根遍历（对应二叉树的中序遍历）：先依次访问各棵子树，再访问根结点</li><li>按层次遍历：类似于二叉树的广度优先遍历</li></ul><p>这里先根遍历与对应二叉树的先序遍历对应；但后根遍历是与其对应二叉树的中序遍历对应的，举个例子：</p><p>我们还是以上面这棵树为例：</p><p>后根遍历的顺序：<br>B G E F C D A</p><p>我们再用之前讲的中序遍历二叉树顺序对上面转化完的二叉树来一遍：<br>B G E F C D A</p><p>可以发现完全一致。</p><h3 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h3><h4 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h4><p>树的深度写起来其实跟求二叉树的深度那个算法差别不大，我们需要先将树转化为二叉树（即孩子-兄弟表示），此后对这个二叉树求深，但需要额外考虑到走兄弟这条道路时深度不变。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//求树的深度</span><span class="token keyword">int</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>CSTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> h1<span class="token punctuation">,</span> h2<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    树为空，则返回<span class="token number">0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    h1 <span class="token operator">=</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>firstchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//走左侧第一个孩子时，深度+1；</span>    h2 <span class="token operator">=</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>nextsibling<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//走右侧兄弟结点时，深度不变</span>    <span class="token keyword">return</span> h1<span class="token operator">></span>h2<span class="token operator">?</span>h1<span class="token operator">:</span>h2<span class="token punctuation">;</span> <span class="token comment">//返回其中最大的那个</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树是一种在查找时尽可能减少查找所用时间的优化树，其思路在于将查找频次最低的值放在最远端，将频次较高的值放在尽可能近的位置。</p><p>博主在这里实在谈不上很擅长，就不在这里详细叙述了。</p><hr><p>至此，树的相应章节应该算是基本结束了。</p><p><del>真费劲啊，我靠</del></p><p>博主的水平有限，文中的某些代码或文本难免会有些谬误，已经尽可能的加上了注释，希望能对读者的理解有所裨益。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-5</title>
      <link href="/posts/6435.html"/>
      <url>/posts/6435.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组与广义表"><a href="#数组与广义表" class="headerlink" title="数组与广义表"></a>数组与广义表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>C语言中，我们已经多次接触过 <strong>数组</strong> 这一概念，这里我们给出数组的具体概念。</p></blockquote><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>在数据结构中， <strong>数组</strong> 指有限个数据元素的集合，这些数据元素具有相同的特性，并都有与之相对应的下标来表征它们的位置。</p><p>一维数组，与我们在第一章中介绍的 <strong>线性表</strong> 几乎是同一个东西。但这里，我们数组的维数理论上可以无限延申。</p><p>但向外延伸的复杂度则也带来了些许不便，即数组的删改操作会变得极其复杂（尤其在维数过多的情况下），因此我们不妨一刀切掉，数据结构中定义的数组，除了初始化与销毁两种操作之外，只有两种运算：</p><ul><li>给定下标，存储相应的元素</li><li>给定下标，修改相应下标内元素的值</li></ul><blockquote><p>很多读者可能会想起C中的relloc操作，但relloc操作常见于一维数组，即线性表的范畴内，因此这里不再对数组的删改进行叙述。</p></blockquote><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><p>如上所述，数组仅仅包含以下几种操作：</p><ul><li>InitArray：初始化</li><li>DestroyArray：销毁</li><li>Value：取出数组的元素值</li><li>Assign：给数组赋值</li></ul><h3 id="数组的顺序表示"><a href="#数组的顺序表示" class="headerlink" title="数组的顺序表示"></a>数组的顺序表示</h3><blockquote><p>以二维数组为例</p></blockquote><p>数组既然是多维的，则必然存在存储顺序优先级的问题，由于普遍已经适应了 <strong>以行序为主序</strong> 的存储方法，因此本文中会采用行序主序的映像方式进行说明。</p><blockquote><p>上面的说法有点抽象，举个例子：<br>存在一个2*3的数组，如果使用行序主序的方式，则在计算机内存中的存储顺序即：0 0、0 1、0 2、1 0、1 1、1 2。<br>相反的，如果使用列序主序的方式，则在计算机内存中的存储顺序即：0 0、1 0、0 1、1 1、0 2、1 2</p></blockquote><p>因此，一个m行n列的数组采用行序主序的形式时，存储a<sub>ij</sub>的位置时，其位置即：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + (n*i + j) * L;</p><p>如果以列序为主序，则：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + (m*j + i) * L;</p><p>这里，LOC(0, 0)被称为基地址（即数组第一个元素所在的地址），L则是数组一个元素所占有的内存大小。</p><h3 id="矩阵相关"><a href="#矩阵相关" class="headerlink" title="矩阵相关"></a>矩阵相关</h3><p>了解过高等数学的读者可能看出来了，我们拿来举例子的二维数组，在数学上有个另外的名字，叫 <strong>矩阵</strong> 。</p><p>但我们又想了，这矩阵里面可能有很多 <strong>值相同的元素</strong> 或 <strong>0元素</strong> ，显然，它们用处不大，但是占据了很大一部分的存储空间，这就显得很浪费。因此，我们需要研究一下压缩存储的相关问题。</p><p>那首先，我们讨论一下压缩的基本规则：</p><ul><li>多个值相同的元素，我们只分配一个存储空间</li><li>0元素，我们不分配存储空间</li></ul><p>我们先看一些特殊的矩阵：</p><h4 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h4><p><strong>对称矩阵</strong> ，即 a<sub>ij</sub> &#x3D; a<sub>ji</sub> ，我们可以只为每对对称的元素分配一个存储空间，即我们可以只存储其下三角（包括对角线）中的元素。</p><blockquote><p>说的详细点，在内存中的下标存储方式：0 0、1 0、1 1、2 0、2 1、2 2、……、n-1 0、n-1 n-1。</p></blockquote><p>由这个规律，我们得出对称矩阵压缩存储时其下标计算公式：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + [i*(i+1)&#x2F;2 + j] * L;</p><blockquote><p>i*(i+1)&#x2F;2 是一个从1到i，公差为1的等差数列的求和公式，读者自己推一下即可。</p></blockquote><h4 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h4><p><strong>三角矩阵</strong> 即一个矩阵中只有其上（下）三角的位置有元素，其余部分为0元素或常数C。</p><p>因此，其实与对称矩阵非常类似，我们留出相应的三角矩阵的存储空间，而后增加一个存储常数C的存储空间即可</p><h3 id="稀疏矩阵相关"><a href="#稀疏矩阵相关" class="headerlink" title="稀疏矩阵相关"></a>稀疏矩阵相关</h3><p><strong>稀疏矩阵</strong> 即矩阵中零元素的出现没有规律的矩阵</p><p>在了解它如何压缩之前，我们先来了解一个概念—— <strong>稀疏因子</strong> 。<br>其定义为如果m行n列的矩阵中含有t个非零元素，我们称：</p><p>d &#x3D; t &#x2F; m*n</p><p>为稀疏因子，即数组中非零元素个数与非零元素个数的比。</p><p>如果这个稀疏因子的大小小于0.05，则我们称这个矩阵为稀疏矩阵。<br>这种稀疏矩阵造成了两种问题：</p><ul><li>零元素占据空间过大</li><li>进行运算时（除法 &#x2F; 取余），需要频繁的判断当前的除数是否为0</li></ul><p>这就代表着压缩存储的操作非常的必要</p><h4 id="三元组表示法"><a href="#三元组表示法" class="headerlink" title="三元组表示法"></a>三元组表示法</h4><p>这种压缩方法大概是最容易想到的了，即我们用一个线性表来表示稀疏矩阵，这个线性表中每个元素都是一个结构体，结构体里有三个元素，分别为非零元素的行下标、列下标、值。</p><p>相应的，习惯使然，我们在存储它时也已行下标优先的存储方法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment">//行、列下标</span>    Elemtype v<span class="token punctuation">;</span> <span class="token comment">//非0元素的值</span><span class="token punctuation">&#125;</span>Triple<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Triple data<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> num<span class="token punctuation">;</span> <span class="token comment">//矩阵的行数、列数、非零行个数</span><span class="token punctuation">&#125;</span>TSMatrix<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三元素表示法的加、减都挺简单，但一旦涉及到矩阵的 <strong>转置</strong> ，则事情就变得有些复杂。</p><hr><ul><li>三元组的转置——常规转置</li></ul><p>我们知道，常规矩阵的转置：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>line<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>col<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>放到三元组里面，我们可以采如下的转置方法：</p><ul><li>将矩阵的行、列值互相调换</li><li>将三元组存储行、列下标的变量互换</li><li>将三元组重新排成以行序为主序的顺序表</li></ul><p>这前两步非常简单，但第三步的实现需要琢磨一下，我们这里也给出两种方法：</p><ul><li>按照原先三元组列序的顺序查找（因为原先三元组的列序就是转置后三元组的行），而后按照顺序进行转置，转置后依次添加进一个新的三元组里面。</li><li>直接按照原先三元组中的顺序进行转置，此后将转置的每个元素置入与之对应的新位置里。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第一种方法</span><span class="token function">Trans</span><span class="token punctuation">(</span>TSMatrix M<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//M是需要被转置的矩阵，N是一个全新的矩阵</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//M非空</span>        N<span class="token punctuation">.</span>line <span class="token operator">=</span> M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>col <span class="token operator">=</span> M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>num <span class="token operator">=</span> M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> line <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//从M的第一列开始转置</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>                    <span class="token comment">//行列互换，值直接赋入新三元组</span>                    temp<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种方法非常清晰明了，但是显然效率不够，因为我们需要将三元组所有的元素都扫描很多遍，这显然不是很优雅。</p><p>这种转置方法存在循环的嵌套，因此其时间复杂度为：</p><p><strong>O(M.num * M.col);</strong></p><p>我们再想一想，我们如果能知道M中每一列的 <strong>第一个非零元</strong> 在N中应该存储的位置，那么我们在对M中的元素进行转置时，我们就可以直接将相应的元素放到N中合适的位置上，这就显得非常的理想。</p><p>问题来了，这法子需要怎么实现呢？</p><hr><ul><li>三元组的转置——快速转置</li></ul><p>我们想知道新矩阵每一行开始的位置，我们自然需要对原数组先进行一次遍历，通过这次遍历的结果得到我们想要的数据并进行储存。</p><p>因此，我们再设置两个数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">nums<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token comment">//表示原矩阵中第col列中含有多少个非零元素</span>cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token comment">//表示原矩阵中第col列的第一个非零元素在新矩阵中的起始位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：这里需要再啰嗦一嘴，原矩阵中的第col列其实就是新矩阵中的第col行，因此cpot[col]中的元素就是新矩阵里面第col行的起始下标。</p><p>我们可以通过以上的关系得到这个式子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cpot<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//第一行的第一个非零元的起始下标为1</span>cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> cpot<span class="token punctuation">[</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//第col行的第一个非零元的起始下标 = 上一行的起始下标 + 上一行的元素数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果将上述式子写成代码也非常简单，只需要用for循环遍历一遍，就能将nums数组中的所有元素得到，而后再通过nums遍历一遍得到cpot数组即可：</p><p>得到这个cpot数组后，转置的工作就很简单了，这里给出具体的转置代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第二种方法</span><span class="token function">Trans</span><span class="token punctuation">(</span>TSMatrix M<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//M非空</span>        N<span class="token punctuation">.</span>num <span class="token operator">=</span> M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>line <span class="token operator">=</span> M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>col <span class="token operator">=</span> M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> nums <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> copt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里之所以每个数组都多分配一个空间是因为想让下标从1开始，与三元组统一</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//初始化nums数组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//遍历M中每一个元素，该元素是哪一列，就把nums相应下标的值+1</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//nums数组赋值完成</span>        cpot<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cpot<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cpot<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//通过遍历得到cpot每一个值</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//cpot数组赋值完成</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>p<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> col <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>            <span class="token keyword">int</span> place_in_N <span class="token operator">=</span> cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">+</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>            <span class="token comment">//在新三元组N中的下标为：行起始下标+新矩阵中的列下标（也就是原矩阵中的行下标）</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>            <span class="token comment">//行，列下标互换，值不变</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述完整方法其实理解起来有一定难度，主要是因为需要定义以及捋清楚的变量非常多，如果读者暂时无法理解全部，也可以先放一放，或者跟着此前的梳理顺序再来一遍。</p><p>我们再来看这个算法的时间复杂度：</p><p>我们通过分别对M的列以及M的所有元素进行遍历，实现了这个算法，其时间复杂度为</p><p><strong>O(M.num + M.col);</strong></p><p>这个加式可比之前那个乘方式好看多了</p><hr><h4 id="行逻辑链接表示法"><a href="#行逻辑链接表示法" class="headerlink" title="行逻辑链接表示法"></a>行逻辑链接表示法</h4><p>三元组表示法的优点在于其内每个非零元素的行下标与列下标都非常清晰，可以直接提取出来，但是如果我们需要随机存取某一行中的非零元，则三元组需要从头开始遍历，不是非常的优雅。</p><p>我们参考三元组快速转置中的思路，直接将一个数组rpos添加到压缩后矩阵的结构体的定义中，其代表的就是每一行第一个非零元在三元组中的下标。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Triple data<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> num<span class="token punctuation">;</span> <span class="token comment">//矩阵的行数、列数、非零行个数</span>    <span class="token keyword">int</span><span class="token operator">*</span> rpos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>RLSMatrix<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话，我们如果给定一组下标(r, c)，我们就可以直接通过以下的算法进行取值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Elemtype <span class="token function">value</span><span class="token punctuation">(</span>RLSMatrix M<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//r:行数; c:列数</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> M<span class="token punctuation">.</span>rpos<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">==</span> r <span class="token operator">&amp;&amp;</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">&lt;</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">==</span> r <span class="token operator">&amp;&amp;</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="行-列链接存储表示法"><a href="#行-列链接存储表示法" class="headerlink" title="行 &#x2F; 列链接存储表示法"></a>行 &#x2F; 列链接存储表示法</h4><p>如果我们想用指针来对稀疏矩阵进行存储，思路也很简单：<br>我们可以以每行 &#x2F; 每列为单位，存储一个链表的头节点，在其后面存储每一个不为0的元素为一个节点。</p><p>这里以行链接表示法为例，给出具体定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">&#123;</span>    Elemtype v<span class="token punctuation">;</span>    <span class="token keyword">int</span> col <span class="token comment">// 每一个元素的列数</span>    LinkNode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CpMatrix</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> num<span class="token punctuation">,</span> line<span class="token punctuation">,</span> col<span class="token punctuation">;</span>    LinkNode<span class="token operator">*</span> Head<span class="token punctuation">;</span> <span class="token comment">//链表的头指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用图示表示一下：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.5/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A1%8C%E9%93%BE%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="行链接存储"></p><p>看到这里，有些读者可能就有些 <del>大胆的想法</del> ，哎？我如果行与列都加上一个链表来存储呢？当然可以，不过这种玩意维护起来就显得有亿点点麻烦了，有需求的读者可以自行尝试实现，这里权当抛砖引玉。让我们在读者的思想变得更危险之前进入下一个话题…</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><blockquote><p>广义表这个玩意其实目前用的已经很少了，因为它的定义方式决定着这玩意哪怕是用手画都很难理解，并且捋清楚层次，更别提用真正的计算机来实现它了，其实这玩意的思路跟后面要叙述的 <strong>多叉树</strong> 非常的接近，占用空间又比树大，所以嘛…</p></blockquote><p>说了这么多，毕竟这玩意也是数据结构的考点，还是在这里大体捋一下。</p><p><strong>广义表</strong> 是用递归形式定义的线性结构，是线性表的推广，它的元素可以是一个单元素，也可以是一个子表。</p><p>LS &#x3D; (α<sub>1</sub>, α<sub>2</sub>, α<sub>3</sub>, …, α<sub>n</sub>);</p><p>以上是它的书写形式，LS是其表名，而其中的α<sub>1</sub>, α<sub>2</sub> 等元素，可以是一个元素，也可以是又一个表 <del>（这不纯纯tm套娃吗）</del></p><p>上面的定义决定了广义表这玩意有以下性质：</p><ul><li>广义表里的元素是有顺序的</li><li>广义表的长度：最外层的表含有的元素个数</li><li>广义表的深度：广义表所含括弧的重数，即其最深的一枝能深到第几层</li><li>广义表可以是递归的</li></ul><h3 id="广义表的分解"><a href="#广义表的分解" class="headerlink" title="广义表的分解"></a>广义表的分解</h3><p>这里咱单开一块来说一说广义表分解这一茬事情，因为这玩意的定义方式使得分解很容易把人绕晕喽。</p><p>我们通常认为，任何一个广义表，都可以被分解成表头和表尾：</p><ul><li>表头是广义表的第一个元素</li><li>表尾是广义表的 <strong>剩余元素组成的新广义表</strong></li></ul><p>请希望学习这一部分的读者提高重视，表头是一个元素，而表尾必定是一个 <strong>广义表</strong> 。这个分解方式在学习时已经坑了笔者很多次了，希望读者能够不要像笔者一样踩这么多坑。</p><p>我们举个例子：<br>有个广义表：</p><p>D &#x3D; (E, F);<br>其中E &#x3D; (a, b, c); F &#x3D; z;</p><p>那么 <strong>D的表头</strong> 就是 <strong>E</strong> ，而 <strong>D的表尾</strong> 是 <strong>(F)</strong> 。<br>再写一个，加深一下印象：<strong>E的表头</strong> 是 <strong>a</strong> ，而 <strong>E的表尾</strong> 是 <strong>(b, c)</strong> 。</p><p>在读者能够清晰地分辨出表头和表尾的区别后，我们进入下面的章节。</p><h3 id="广义表的表示"><a href="#广义表的表示" class="headerlink" title="广义表的表示"></a>广义表的表示</h3><blockquote><p>由于广义表的定义过于复杂，拆解也很复杂，因此广义表的表示通常只能用链表这一结构来实现。</p></blockquote><p>我们首先明确一下，广义表中，存在两类节点：</p><ul><li>表节点（表示这里面是另一个表）</li><li>原子节点（表示这里面只有一个元素）</li></ul><p>这两类节点通过一个额外的表示符 <strong>tag</strong> 来区分。</p><p>我们这里只说一种表示方法</p><h4 id="表头、表尾分析法"><a href="#表头、表尾分析法" class="headerlink" title="表头、表尾分析法"></a>表头、表尾分析法</h4><p>这法子挺自然的，刚刚说了拆分方式嘛，所以我们干脆直接将节点中拆出两个玩意来，一个指向表头，一个指向表尾。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">GenNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//表节点</span>    GenNode<span class="token operator">*</span> ListHead<span class="token punctuation">,</span> ListTail<span class="token punctuation">;</span> <span class="token comment">//分别指向表头以及表尾</span><span class="token punctuation">&#125;</span>GenList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Atom</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//原子节点</span>    Elemtype value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里举一个相对复杂的例子来让读者再次理解这个分析的方法</p><p>A&#x3D;( ) ; B&#x3D;(e) ; C&#x3D;(a,(b,c,d)) ; D&#x3D;(A,B,C)</p><p>我们把D用这种方法来表示出来：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.5/%E5%B9%BF%E4%B9%89%E8%A1%A8%20%E8%A1%A8%E5%A4%B4%E8%A1%A8%E5%B0%BE%E5%88%86%E6%9E%90%E6%B3%95.png" alt="D 表头表尾分析法"></p><p>可以得见，这玩意真要表示需要耗费多少空间…</p><blockquote><p>其实这玩意还有另一种表示方式叫 <strong>子表分析法</strong> ，这种法子相对而言比较节省空间，但是把这玩意写出来的话想必读者会更混乱，这里有需求的读者可以自行查阅其他资料。</p></blockquote><h3 id="广义表的相关算法"><a href="#广义表的相关算法" class="headerlink" title="广义表的相关算法"></a>广义表的相关算法</h3><p>这里我们只写一个广义表求深度的算法，我们利用递归的思想来求一个广义表的深度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">GetDepth</span><span class="token punctuation">(</span>GenList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//L是空表，深度为1</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//L是原子节点，返回深度0</span>    <span class="token punctuation">&#125;</span>    GenNode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>L<span class="token punctuation">;</span>    <span class="token keyword">int</span> max<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>ListTail<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> dep <span class="token operator">=</span> <span class="token function">GetDepth</span><span class="token punctuation">(</span>p<span class="token operator">-></span>ListHead<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dep <span class="token operator">></span> max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//当前表头的深度比此前得到的深度更深</span>            max <span class="token operator">=</span> dep<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>至此，数组与广义表的内容就阐述的差不多了。</p><p>额外提一嘴，广义表的相关概念，考虑到日常生活中的应用概率较低，可以不必过于在意，但如果是因为数据结构考试的话，建议还是深入思考一下（苦笑</p><p>好啦，这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-4</title>
      <link href="/posts/55778.html"/>
      <url>/posts/55778.html</url>
      
        <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><blockquote><p>本章是 <strong>串</strong> 这种结构的大体梳理</p></blockquote><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p><strong>串</strong> 是由零个或多个字符组成的有限序列。</p><p>由于串实在过于常见，因此大多数语言都提供了一些基础的对串格式的支持，如C中的字符串拼接、复制、分割函数；C++中的string类，Java中的String类等。</p><p>很显然，不同的语言对串的支持程度不尽相同，因此这里仅仅提一个概念， <strong>串的最小操作子集</strong> ，即可以用这个集合里的函数实现任何想要对串进行的操作。</p><ul><li>串赋值（CharAssign）</li><li>串复制（Strcopy）</li><li>串比较（StrCompare）</li><li>求串长（StrLength）</li><li>串连接（Concat）</li><li>求子串（SubString）</li></ul><p>可以看出，其实串跟我们第一章所了解的 <strong>线性表</strong> 是很相似的，只不过，串存储的是一个个字符，同时串也常常以 <strong>一组字符</strong> 为单位进行增删改查，而不像线性表一样以 <strong>单个单元</strong> 为单位进行。</p><h2 id="串的存储"><a href="#串的存储" class="headerlink" title="串的存储"></a>串的存储</h2><h3 id="串的堆分配存储"><a href="#串的堆分配存储" class="headerlink" title="串的堆分配存储"></a>串的堆分配存储</h3><p>这种存储方式是串最常见的存储方式。其利用动态内存分配进行存储管理。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HString<span class="token punctuation">;</span><span class="token comment">//当需要进行内存分配时</span>ch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>length<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他存储方式"><a href="#其他存储方式" class="headerlink" title="其他存储方式"></a>其他存储方式</h3><p>读者读到这里可能会产生两个疑惑：</p><ul><li>直接用数组不行吗</li><li>想用链表存储</li></ul><p>用数组，即被称为 <strong>串的定长顺序存储</strong> ，其弊端在于无法改变串的长度，当进行操作时很容易产生长度过长的问题，这种情况下，数组存储只能进行截断操作，这导致了串内容的丢失。</p><p>用链表，即被称为 <strong>串的块链存储</strong> ，其可以通过链表对串进行连接，同时链表每个节点中需要存储多少字符也可以由个人决定，但是这种存储方式使原本十分简单的复制、连接等操作变得极为复杂，一般不会采取这种存储方式。</p><h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h2><p>通常，字串的定位操作被称为 <strong>串的模式匹配</strong> ，表示为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">INDEX</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其意义表示为：如果主串S中存在与字串T相同的串，则返回其在字串下标pos后第一次出现的位置。<br>这定义听着挺拗口的，读者不妨把它理解成字串查找即可。</p><p>我们现在想一想，如果要实现这个功能，该如何设计？</p><h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>这是我们大概第一眼就会想到的算法，主串从前往后循环，遇到与字串相同的字符则开始一个子循环流程，子循环能跑完，则代表着串匹配了，返回当前主串循环的下标。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">INDEX</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> S<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            i <span class="token operator">=</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//匹配失败，指针回退</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//说明子循环跑完了，有字串</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种算法固然清晰，但其时间复杂度为O(m*n)，即字串与主串的长度的乘积，这太长了。</p><h3 id="首尾匹配算法"><a href="#首尾匹配算法" class="headerlink" title="首尾匹配算法"></a>首尾匹配算法</h3><p>这种算法算得上一种折中，即每次比较时，优先比较首尾的元素，再比较中间的剩余元素，但由于这种算法并算不上真正降低了时间复杂度，这里不再详述。</p><h3 id="KMP算法（重点）"><a href="#KMP算法（重点）" class="headerlink" title="KMP算法（重点）"></a>KMP算法（重点）</h3><h4 id="KMP概述"><a href="#KMP概述" class="headerlink" title="KMP概述"></a>KMP概述</h4><p>我们再次甚至暴力求解的第一个算法，发现其实主要的重复计算时间来源，是主串中 <strong>每次字符失配时的指针回退</strong> 。如果我们能够达到一种主串中指针永远不回退的算法，那将大大降低我们的算法耗时。</p><p>我们这里举一个例子：</p><p>主串的内容：A B A B A B C</p><p>字串的内容：A B A B C</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-1.png" alt="初始情况"></p><p>如果按照暴力求解的算法，第一次匹配，字串匹配到了C，发现与主串的A不相同，则主串指针回退至B，字串指针回退至A，再次匹配。</p><p>但我们想的理想情况是将字串的A与主串中第三个A齐平，同时可以跳过重复的AB，直接从第三个字符开始比较。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-2.png" alt="理想情况"></p><p>要实现这个跳跃过程，我们需要借助一个数组，这个数组的作用是当字串与主串的字符发生失配现象了，下一次比较时主串需要与哪一个字串中的字符相比较。</p><p>我们用具体的程序来表达一下这个算法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">INDEX_KMP</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> S<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//当主串中的字符与字串的第一个字符失配，或者主串与字串还未失配时，继续向后比较</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//此时失配，则j回退至next[j]所指向的位置，i不变</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>那么现在的问题就从如何降低时间复杂度变为这个next数组该怎么求了。</p><p>这里原理不进行详细叙述，给出公式：<br>next[j] &#x3D; 此前已成功匹配的字串中最长的相同前后缀+1</p><p>前缀，即不包含最后一个字符的字串（从前往后看）<br>后缀，即不包含第一个字符的字串（从后往前看）</p><p>特殊的，next[1] &#x3D; 0</p><p>比如上例：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-3.png" alt="next"></p><ul><li>第一个字符A: next[1] &#x3D; 0</li><li>第二个字符B: 不存在相同的前后缀，next[2] &#x3D; 0+1 &#x3D; 1</li><li>第三个字符A: 不存在相同的前后缀，next[3] &#x3D; 0+1 &#x3D; 1</li><li>第四个字符B: 前缀”A”与后缀”A”相等，next[4] &#x3D; 1+1 &#x3D; 2</li><li>第五个字符C: 前缀”AB”与后缀”AB”相等，next[5] &#x3D; 2+1 &#x3D; 3</li></ul><h4 id="nextval数组"><a href="#nextval数组" class="headerlink" title="nextval数组"></a>nextval数组</h4><p>next数组已经可以达到主串指针不回溯的目的了，但是还有最后一点点小遗憾：</p><p>我们假设字串为：A A A A B</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-4.png" alt="next"></p><p>我们假设程序在比较时，恰巧在B这一点失配了。接下来我们应该干什么？</p><p>根据我们此前的讲述：程序会根据 <strong>next[5] &#x3D; 4</strong> 来将主串指针当前字符与字串的第四个字符A比较。</p><p>如果能够匹配还好，如果不匹配呢？</p><p>那就会出现，继续根据 <strong>next[4] &#x3D; 3</strong> 、 <strong>next[3] &#x3D; 2</strong> …等等语句，与字串的第三个字符A，第二个字符A，第一个字符A，比了三次，然后发现，哦，第一个都对不上，那主串的指针往后移动一位。</p><p>发现问题了吗？ 字串的前几位其实都一样，那么如果我跟第四个字符A比完之后，其实再跟第三个、第二个、第一个A比较的过程完全可以省去，因为一定会失配。</p><p>这就是为什么我们会再引入一个数组，叫nextval，这个数组就是为了防止上述问题的发生而出现的。<br>其具体方法为：如果 <strong>next[j] &#x3D;&#x3D; k</strong> ，同时字串中 <strong>T[j] &#x3D;&#x3D; T[k]</strong> ，那么我们就不用让主串S再跟字串中T[k]比较了，因为必定失配，我们让S当前位置的字符直接跟 <strong>T[next[k]]</strong> 进行比较。</p><p>nextval的具体求法是通过next数组来的：</p><ul><li>如果T[k] &#x3D;&#x3D; T[j] : 则nextval[j] &#x3D; nextval[k]</li><li>如果T[k] !&#x3D; T[j] : 则nextval[j] &#x3D; next[j]</li></ul><p>我们还是拿刚才那个例子来举例：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-5.png" alt="nextval"></p><ul><li>第一个元素A：照常，nextval[1] &#x3D; 0</li><li>第二个元素A：next[2] &#x3D; 1, 并且T[1] &#x3D;&#x3D; T[2] &#x3D;&#x3D; ‘A’, 因此nextval[2] &#x3D; nextval[1] &#x3D; 0</li><li>第三个元素A：next[3] &#x3D; 2, 并且T[2] &#x3D;&#x3D; T[3] &#x3D;&#x3D; ‘A’, 因此nextval[3] &#x3D; nextval[2] &#x3D; 0</li><li>第四个元素A：next[4] &#x3D; 3, 并且T[3] &#x3D;&#x3D; T[4] &#x3D;&#x3D; ‘A’, 因此nextval[4] &#x3D; nextval[3] &#x3D; 0</li><li>第五个元素B：next[5] &#x3D; 4, 但(T[4] &#x3D;&#x3D; ‘A’) !&#x3D; (T[5] &#x3D;&#x3D; ‘B’), 因此nextval[5] &#x3D; next[5] &#x3D; 4</li></ul><p>至此，nextval这个next的改进版数组也讲解完毕了，我们实现了一个线性时间复杂度的串模式比对算法。</p><hr><p>至此，串的各种事项大致梳理完毕，该部分的重点就是KMP算法的理解。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数电-Chap.1</title>
      <link href="/posts/33374.html"/>
      <url>/posts/33374.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：本课程会着重于半导体器件、逻辑代数以及逻辑门的学习，达到基本能够进行组合电路，时序电路以及运放（运算与放大）电路的识别、设计等操作。</p></blockquote><h1 id="数字逻辑基础"><a href="#数字逻辑基础" class="headerlink" title="数字逻辑基础"></a>数字逻辑基础</h1><h2 id="1-计数体制"><a href="#1-计数体制" class="headerlink" title="1. 计数体制"></a>1. 计数体制</h2><h3 id="1-1-数制"><a href="#1-1-数制" class="headerlink" title="1.1 数制"></a>1.1 数制</h3><p>我们将日常生活中由低位数向高位进位的规则称为 <strong>数制</strong> 。</p><p>在数字系统中，常用的数制包括：</p><ul><li>十进制（Decimal）</li><li>二进制（Binary）</li><li>八进制（Octal）</li><li>十六进制（Hexadecimal）</li></ul><p>它们分别表示逢几进一。</p><h3 id="1-2-进制的转换"><a href="#1-2-进制的转换" class="headerlink" title="1.2 进制的转换"></a>1.2 进制的转换</h3><h4 id="其他进制-十进制"><a href="#其他进制-十进制" class="headerlink" title="其他进制 -&gt; 十进制"></a>其他进制 -&gt; 十进制</h4><p>按权相加：将非十进制的各位权重乘以对应位的权重，再相加。<br>如：(10011.011)<sub>2</sub> -&gt; (?)<sub>10</sub><br>其计算过程为：1 * 2<sup>4</sup> + 1 * 2<sup>1</sup> + 1 * 2<sup>0</sup> + 1 * 2<sup>-2</sup> + 1 * 2<sup>-3</sup></p><h4 id="十进制-其他进制"><a href="#十进制-其他进制" class="headerlink" title="十进制 -&gt; 其他进制"></a>十进制 -&gt; 其他进制</h4><p>一般会将十进制的整数部分与小数部分分别转换并相加。<br>整数部分采用 <strong>除基取余法</strong> ，小数部分采用 <strong>乘基取整法</strong> 。<br>如：(25.25)<sub>10</sub> -&gt; (?)<sub>2</sub><br>整数25部分：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E9%99%A4%E5%9F%BA%E5%8F%96%E4%BD%99.png" alt="除基取余"></p><p>小数0.25部分：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E4%B9%98%E5%9F%BA%E5%8F%96%E6%95%B4.png" alt="乘基取整"></p><h4 id="其他进制之间的互相转换"><a href="#其他进制之间的互相转换" class="headerlink" title="其他进制之间的互相转换"></a>其他进制之间的互相转换</h4><ul><li><p>二进制 -&gt; 八进制 &#x2F; 十六进制：<br>通常可以采用三位 &#x2F; 四位二进制转为一位八进制 &#x2F; 十六进制的方法进行快速转化</p></li><li><p>八进制 &#x2F; 十六进制 -&gt; 二进制：<br>通常可以采用一位八进制 &#x2F; 十六进制转为三位 &#x2F; 四位二进制的方法进行快速转化</p></li></ul><p>注：上述方法运用时从小数点开始往左 &#x2F; 右进行转化，别忘记高位补0</p><h2 id="2-编码"><a href="#2-编码" class="headerlink" title="2. 编码"></a>2. 编码</h2><p>由于在计算机内，处理、存储、传输的都是二进制数据，因此将外界信息通过二进制进行表示这一过程就显得尤为重要，这一过程被称为 <strong>编码</strong></p><p>常见的编码有：</p><ul><li>BCD码</li><li>ASCⅡ</li></ul><h3 id="BCD编码"><a href="#BCD编码" class="headerlink" title="BCD编码"></a>BCD编码</h3><p>利用四位二进制数来表示一位十进制数的过程被称为 <strong>BCD编码</strong></p><p>常用的BCD编码有：</p><ul><li>8421码</li><li>余3码</li><li>2421码</li></ul><p>其中8421码尤为常用，其名称代表着各个位次上二进制数字的权值</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/BCD%E7%A0%81.png" alt="8421"></p><h3 id="ASCⅡ"><a href="#ASCⅡ" class="headerlink" title="ASCⅡ"></a>ASCⅡ</h3><p>ASCⅡ（American National Standard Code for Information Interchange）用于通过八位二进制数来表示生活中常用的数字与符号，其中低七位用于表示，最高一位用于奇偶校验。</p><p>具体图片烦请读者自行上网搜索。</p><h2 id="3-逻辑代数基础"><a href="#3-逻辑代数基础" class="headerlink" title="3. 逻辑代数基础"></a>3. 逻辑代数基础</h2><p>与现实中不尽相同，计算机由于采用二进制，因此其逻辑判断也仅有两种状态，即1（真）与0（假），在数字系统中，我们又常常将电位与真假相关联，即高电位（也称高电平）表示1，低电位（也称低电平）表示0。</p><h3 id="3-1-基本逻辑运算与基本逻辑门"><a href="#3-1-基本逻辑运算与基本逻辑门" class="headerlink" title="3.1 基本逻辑运算与基本逻辑门"></a>3.1 基本逻辑运算与基本逻辑门</h3><h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><p><strong>与运算</strong> 表示参与某一事件的全部条件都为真时，该事件才能发生。</p><h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><p><strong>或运算</strong> 表示参与某一事件的某一条件为真时，该事件就能发生。</p><h4 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h4><p><strong>非运算</strong> 表示将某一事件原本的真值倒置，1变0，0变1。</p><h4 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h4><p><strong>同或运算</strong> 表示参与某一事件的两个条件相同时，该事件才能发生。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%90%8C%E6%88%96%E8%BF%90%E7%AE%97.png" alt="同或运算真值表"></p><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p><strong>异或运算</strong> 表示参与某一事件的两个条件不同时，该事件才能发生。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.png" alt="异或运算真值表"></p><h3 id="3-2-常用化简公式"><a href="#3-2-常用化简公式" class="headerlink" title="3.2 常用化简公式"></a>3.2 常用化简公式</h3><p>数电中的化简方式繁多，这里给出一些常用的公式与定律，仅供参考<br><del>（有卡诺图谁用公式啊）</del></p><ul><li><strong>摩根定律</strong> ：$\overline{\text{A * B}}$ &#x3D; $\overline{\text{A}}$ + $\overline{\text{B}}$<br>注：该公式来源于 <strong>反演率</strong> ，即将公式中所有的乘加互换，01互换，原变量反变量互换，就可以得到原逻辑函数的反函数</li><li><strong>吸收率</strong> ：A * (A + B) &#x3D; A</li><li><strong>对偶规则</strong> ：若两个逻辑函数相等，则它们的对偶式也对应相等。（对偶式的写法与摩根定律反演率相同）</li></ul><h3 id="3-3-逻辑函数的表示"><a href="#3-3-逻辑函数的表示" class="headerlink" title="3.3 逻辑函数的表示"></a>3.3 逻辑函数的表示</h3><p>逻辑函数通常有以下五种表达方式：</p><ul><li>真值表</li><li>逻辑表达式</li><li>逻辑图</li><li>波形图</li><li>卡诺图</li></ul><p>这其中，在手动化简时，以卡诺图最为常用：<br>具体表示为一个表格，表格横坐标与纵坐标均表示一个或多个逻辑变量，在相应的最小项处标记0 &#x2F; 1表示假 &#x2F; 真，而后利用偶数对画圈法将所有的1都圈起来，根据圈写出逻辑表达式。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%9B%9B%E5%8F%98%E9%87%8F%E5%8D%A1%E8%AF%BA%E5%9B%BE.png" alt="四变量卡诺图"></p><p>这里举个例子：<br>假如m0, m1, m12, m13, m15, m14均为1，其他项均为0，则m0, m1为一组，表示为：$\overline{\text{A}}$ * $\overline{\text{B}}$ * $\overline{\text{C}}$ 。而剩余四个为一组，表示为： A * B<br>整体表达式为：<br>（$\overline{\text{A}}$ * $\overline{\text{B}}$ * $\overline{\text{C}}$ ）+ （A * B）</p><hr><p>这篇博文就到这里~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.4</title>
      <link href="/posts/35903.html"/>
      <url>/posts/35903.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><blockquote><p>上一篇博文中，我们大致对类及其特点进行了些许介绍，本文中将更进一步介绍一些常用的操作与注意事项</p></blockquote><h2 id="类方法中参数的传递"><a href="#类方法中参数的传递" class="headerlink" title="类方法中参数的传递"></a>类方法中参数的传递</h2><h2 id="类中的静态成员"><a href="#类中的静态成员" class="headerlink" title="类中的静态成员"></a>类中的静态成员</h2><p>试想一下，如果一个类中有这样的语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Text</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        number<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然，上述语句中count与number的性质并不同，count是一个静态变量，只能进行一次初始化，而number是一个普通变量，可以多次初始化。</p><p>正由于这种区别的存在，我们称如count这种的变量为静态变量，其生命周期与类相同，而number这样的变量的生命周期则与其对象相同。也可以说，静态变量属于类，而常规变量属于对象。</p><p>这样的变量很特殊，在java中，可以直接通过类名在外部访问这个变量，如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>类似的，如果static加在方法前，则称为 <strong>类的方法</strong> ，它也可以通过 类名.方法名 的形式进行外部访问。比如java中的math类，就有相关的特点。</p></blockquote><h2 id="单态设计模式-Singleton"><a href="#单态设计模式-Singleton" class="headerlink" title="单态设计模式(Singleton)"></a>单态设计模式(Singleton)</h2><p>在java中常见一种特殊的类，为了保障数据的一致性，这种类的实例，在一次编译过程中仅有一个，我们称之为 <strong>单例类</strong> ，构造一个单例类的过程我们称之为 <strong>单态设计模式</strong> 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Company</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Company</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Vehicle</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fleet<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Company</span> <span class="token function">getCompany</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种构造方法是私有的，保证了从外部无法访问相关的构造方法，此外其通过另一个静态函数getCompany来传入参数，间接进行唯一一个的Company的初始化。这样就保证了一个程序内只存在一个Company类。</p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final在java中用途繁多，主要有以下三种：</p><ul><li>final加在变量前，表示常量，只能进行一次赋值</li><li>final加在方法前，表示该方法无法被重写</li><li>final加在类前，表示该类是最终类，无法被继承（没有子类）</li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>类似于C，java中也存在枚举类型，其定义方法为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Red</span><span class="token punctuation">,</span> <span class="token class-name">Green</span><span class="token punctuation">,</span> <span class="token class-name">Blue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="抽象类-Abstract-class"><a href="#抽象类-Abstract-class" class="headerlink" title="抽象类(Abstract class)"></a>抽象类(Abstract class)</h2><p>java中涉及到一些类，它们没有具体的参数值，仅有一些方法，具体的参数需要在其子类下进行定义，我们称这种类型为 <strong>抽象类</strong> 。</p><p>这样的类定义需要加入 <strong>abstract</strong> 关键字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>抽象类常用于定义同一类型的对象的相似方法。</p><blockquote><p>其实，抽象类也可以没有抽象方法，如果这样的话，这种类就只能进行子类派生操作。</p></blockquote><h2 id="接口-Interfaces"><a href="#接口-Interfaces" class="headerlink" title="接口(Interfaces)"></a>接口(Interfaces)</h2><blockquote><p>上文中提到了利用抽象类来定义同一类型的实体的相似方法，但如果对象类型不同，就需要利用接口了</p></blockquote><p>接口用于定义不同对象的相同行为，其定义中仅有函数声明与静态常量，没有具体实现代码，需要在不同的类中重写。</p><p>接口的定义通常如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token generics"><span class="token punctuation">&lt;</span>interface_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> function1 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> function2 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可见，接口的定义与C中的函数声明很相似，仅声明出这个函数的存在，不给出具体方法。</p><p>而具体需要使用接口的函数时，需要这样写出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token generics"><span class="token punctuation">&lt;</span>interface_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token comment">//对接口函数进行重写</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h3><p>从jdk-8开始，接口中引入了默认方法，用default关键字修饰，这样的方法可以有具体的实现代码，这种特性使得接口在添加方法时不需要对所有应用接口的类进行重写，主要目的在于提高兼容性。</p><hr><p>关于面向对象的内容肯定不仅仅这么多，上述博文会在进一步了解java后继续完善。</p><p>目前，本篇博文就到这里～</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.3</title>
      <link href="/posts/20094.html"/>
      <url>/posts/20094.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-类与方法"><a href="#Java-类与方法" class="headerlink" title="Java 类与方法"></a>Java 类与方法</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类是什么"><a href="#类是什么" class="headerlink" title="类是什么"></a>类是什么</h3><p><strong>类</strong> 有些类似C中的结构体，不过Java中的类除了变量外，也可以包含函数，我们称之为 <strong>方法</strong> 。</p><blockquote><p>如果读者接触过C++，那么可以将类理解为一种 <strong>模板</strong> ，而每个实例都是对于模板的一种创建过程。</p></blockquote><h3 id="类的特点与必要性"><a href="#类的特点与必要性" class="headerlink" title="类的特点与必要性"></a>类的特点与必要性</h3><p>类的代码可重用，这极大程度上降低了代码语言的重复性，同时有效提高了便捷度。<br>通常而言，Java中的类具有以下三种特点：</p><ul><li>继承性</li><li>多态性</li><li>封装性</li></ul><p>这三种特点的具体表现将在以下详细阐述。</p><h3 id="类的定义-实例的声明"><a href="#类的定义-实例的声明" class="headerlink" title="类的定义 &amp; 实例的声明"></a>类的定义 &amp; 实例的声明</h3><p>Java是面向对象的编程语言，这就意味着类是Java中的基础构成部分，任何一个Java程序均离不开类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token keyword">public</span> <span class="token operator">/</span> <span class="token keyword">private</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">abstract</span> <span class="token operator">/</span> <span class="token keyword">final</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token punctuation">[</span><span class="token keyword">extends</span> class_name<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>property_type<span class="token punctuation">></span></span> var1<span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>property_type<span class="token punctuation">></span></span> var2<span class="token punctuation">;</span>        function1 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    function2 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//若在编写中需要使用这个类，则利用以下语句进行声明：</span><span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token generics"><span class="token punctuation">&lt;</span>var_name<span class="token punctuation">></span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句能够表示一个Java类的定义，其中public &#x2F; private 表示类的访问权限，abstract &#x2F; final表示类是否为抽象类 &#x2F; 是否能被继承，内部的var1 表示变量声明，而后的function表示方法（具体函数）。</p><p>如同我们此前讲过的那样，Java类中可以声明所有的数据类型，但在声明过后，如果不进行初始化，Java会使用 <strong>默认值自动对其进行初始化操作</strong> ，默认值如下：</p><ul><li>int: 0</li><li>double &#x2F; float: 0.0</li><li>char: “\u0000”</li><li>boolean: false</li><li>数组: NULL</li></ul><p>除此之外，Java中的类允许 <strong>方法</strong> 的定义，类似于C中的一个函数，可以进行这种类中可能涉及的操作，并返回相应的值。</p><p>与此同时，Java的类，类中的变量声明，类中的方法定义，均可以在前方添加 <strong>访问控制符</strong> 具体请看下文对于访问控制符的内容。</p><p>需要注意的是，类的名称通常使用大写字母开头，请尽可能养成这样的习惯，这有利于我们的程度可读性。</p><h3 id="类中的构造函数与this关键字"><a href="#类中的构造函数与this关键字" class="headerlink" title="类中的构造函数与this关键字"></a>类中的构造函数与this关键字</h3><p>在Java中的类中，常见用private对其内变量进行修饰，以此保证类的运行安全性。这种定义方式被称为 <strong>类的封装</strong> 。但这样做的后果是，无法从类的外部对类内部的变量直接进行更改，因此，Java的类提供了一种 <strong>构造函数</strong> 的方法，它与类同名，可以接受外部参数并以此根据其规则改变内部参量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看出，在这里，从外部传入的参数叫age，name，但对象内也有叫做同样名字的参量。因此，Java引出了 <strong>this</strong> 关键字，在变量名前方加入this. ，则表示指向 <strong>当前对象内的参数</strong> 。我们能通过这样的特性，对类内的私有参量进行赋值。</p><p>对类的封装能够使编译者或程序使用者在对类进行操作时更有条理，也避免了外部随意修改类内部代码的情况。</p><p>此外，在一个类中的一个方法需要利用其所在类内的另一个方法时，可以使用&lt;this.method_name&gt;来对其进行调用。</p><h3 id="类中方法的重载"><a href="#类中方法的重载" class="headerlink" title="类中方法的重载"></a>类中方法的重载</h3><p>Java中的类允许存在多个重名的方法，这被称为 <strong>重载(Overload)</strong> ，而重载的要求为两个同名函数的参数列表必须有区别。</p><h3 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h3><p>Java类中的方法允许传入多个同类型的参数，具体定义方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setnames</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> names<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用这样的定义，可以直接传入多个String。</p><p>这里提供另一种写法，其用途与上述定义相似，区别在于其基于数组传入参数，因此从外部调用时需要先行构造数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setnames</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>为了考虑一个文件，一个类在其他位置的访问权限，Java中提出了 <strong>访问控制修饰符</strong> 的概念。</p><p>Java有4类访问控制修饰符：</p><ul><li>private：仅仅允许同一个类中的方法来访问。</li><li>default：同一个包里文件都可以访问。</li><li>protected：不仅仅同一个包中，只要是它的子类，均可以访问。</li><li>public：完全公开。</li></ul><p>此外，Java中规定了，在一个源文件中（.java）， <strong>允许且仅允许</strong> 一个 <strong>public</strong> 类的存在，请在编写中注意这一点。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>当两个类具有相同的属性时，我们往往可以使用 <strong>继承</strong> 的方法进行定义。<br>这种情况下，有父类与子类之分，子类具有父类的全部属性和方法，同时也可以进行相应更具体属性、方法的添加。</p><p>这种方法常用 <strong>extends</strong> 关键字来进行操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Java中，所有后方没有进行extend的类，都会在编译时自动扩展为 <strong>extends Object</strong> ，这是因为Object类是java中所有类的父类，是个默认定义。因此，Java中除了Object类之外，严格来说其他的类均有父类。</p><p>当然，这其中也必然涉及到一些父类的属性我们不希望继承到子类中，或者希望在子类中对父类的方法进行覆盖，这就涉及到修饰符的问题了。</p><blockquote><p>额外提一句，其实C++中有继承的方法，并且允许多亲继承，即一个子类有多个父类，但这种方法在两个父类的方法名相同时会引起冲突。Java考虑到了这一点，并不允许多亲继承。</p></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们也会遇到，在子类中已经对父类的方法进行覆盖，但我们仍然希望调用父类中的特定方法的情况，我们常用 <strong>super</strong> 来进行操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> x <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"Manager"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h3><p>Java基于子类必须基于父类这一原则，声明了子类的构造方法必须首先调用父类的构造方法，这种构造可以是显性的，也可以是隐性的。</p><p>这就代表着子类的构造函数必定会对父类的构造函数进行引用，而这里也常常出现一个很不容易发现的问题：<br>如果父类中没有无参的构造方法，而子类中的构造方法内又没有明确声明要使用父类的哪种有参构造方法，则每次构造子类对象时，都会默认先调用父类的无参构造方法，这就导致了编译错误。</p><p>这段话听起来有点绕腾：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Preson</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上的代码是会报错的，因为其子类的构造方法在编译过程中会默认在最前方加一句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于先对父类的构造方法进行访问。而这里父类没有无参构造方法。</p><p>因此，请在父类中写出无参构造方法，或者在子类中申明一个构造方法，使用super关键字，对父类的含参构造方法进行调用。</p><h3 id="final-sealed-permits"><a href="#final-sealed-permits" class="headerlink" title="final &#x2F; sealed &amp; permits"></a>final &#x2F; sealed &amp; permits</h3><p>Java中，可以用final或sealed来对类进行修饰，分别表示 <strong>该类不允许进一步继承</strong> 以及 <strong>只允许指定类继承</strong> 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">permits</span> <span class="token class-name">Student</span><span class="token punctuation">,</span> <span class="token class-name">Teacher</span><span class="token punctuation">&#123;</span>    <span class="token comment">//表示Person类只允许Student以及Teacher类进行继承</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>    <span class="token comment">//表示Student类不允许再进一步被继承</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向上转型-Upcasting-向下转型-Downcasting-instanceof"><a href="#向上转型-Upcasting-向下转型-Downcasting-instanceof" class="headerlink" title="向上转型(Upcasting) &amp; 向下转型(Downcasting) &amp; instanceof"></a>向上转型(Upcasting) &amp; 向下转型(Downcasting) &amp; instanceof</h3><p>由于Java中子类具有父类的全部功能，因此在Java中定义一个父类对象，让其指向子类，这是 <strong>被允许的</strong> 。</p><p>比如，拿上文中的类举例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p <span class="token operator">=</span> s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是可以的。</p><p>但是，当我们想反过来的时候，这个操作就不一定能成了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> s3 <span class="token operator">=</span> s1<span class="token punctuation">;</span> <span class="token comment">//允许，因为s1实质上指向的是一个Student对象</span><span class="token class-name">Student</span> s4 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">//不允许，因为s2实质上指向的是一个Person对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此，为了确保向下转型不会出错，java提供了一种操作符叫 <strong>instanceof</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">s1 <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述语句可以判断s1对象指向的到底是不是Student，并返回相应的布尔变量。</p><p>从Java 14开始，可以直接在判断的类后面加名字，从而达成直接转型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>s1 <span class="token keyword">instanceof</span> <span class="token class-name">Student</span> stu1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，如果s1是Student，会直接转型为stu1，并执行输出语句。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="子类对父类方法的覆写-Override"><a href="#子类对父类方法的覆写-Override" class="headerlink" title="子类对父类方法的覆写(Override)"></a>子类对父类方法的覆写(Override)</h3><p>在子类中，如果希望对父类中的某个方法进行重写，可以进行 <strong>Override</strong> 操作。</p><p>具体方法为：在子类中定义一个与父类的某一个方法</p><ul><li>方法名相同</li><li>返回类型相同（也可以返回该类型的子类型）</li><li>参数列表相同</li></ul><p>的方法。</p><blockquote><p>子类中覆盖父类的方法，其访问限制必须要比父类的相应方法更宽泛。如：</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这种定义是不被允许的。</p></blockquote><h3 id="覆写与转型"><a href="#覆写与转型" class="headerlink" title="覆写与转型"></a>覆写与转型</h3><p>我们不妨设想这样一种情况：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stuent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不妨想一想这时候调用的是哪一个get_age方法？</p><p>事实证明，Java中调用方法是根据对象的实际类型来调用的，而非其声明类型。</p><p>这就引出了一个很重要的概念。</p><h3 id="多态是个啥"><a href="#多态是个啥" class="headerlink" title="多态是个啥"></a>多态是个啥</h3><p>上文中，我们知道了Java在调用方法时，会根据对象的实际类型决定调用什么方法。</p><p>这就是多态的重要特性， <strong>针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</strong> 。</p><p>这使得，如果我们定义某个函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_all_name</span><span class="token punctuation">(</span><span class="token class-name">Person</span> s1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s1<span class="token punctuation">.</span><span class="token function">get_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样的一个函数可以传入Person类，也同样可以传入Person的子类Student类，而在调用它们的get_name()方法时，Java会自动根据其实际类型来决定调用什么方法，这为我们省去了很多麻烦。</p><h3 id="异构集合体"><a href="#异构集合体" class="headerlink" title="异构集合体"></a>异构集合体</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">;</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Manager 是Employee的子类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种定义是合法的。</p><p>可以看出，这个集合中不仅仅存在Employee类型，还存在其子类Manager类型。<br>但当我们需要对其进行操作时，我们需要得知当前操作的对象到底是什么类型，此时，我们常用前文中的 <strong>instanceof</strong> 关键字来确定一个对象到底是否是某个类型。</p><hr><p>这篇博文写的比较仓促，可能会存在诸多不足之处，博主会在后续空闲时间尽力补足。</p><p>下一篇博文会涉及到更深入一些的面向对象的操作，这篇博文先到这里~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-3</title>
      <link href="/posts/7075.html"/>
      <url>/posts/7075.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈是什么"><a href="#栈是什么" class="headerlink" title="栈是什么"></a>栈是什么</h3><p><em><strong>栈</strong></em> 是另一种数据结构，其插入 &#x2F; 删除操作仅能在表的端点进行。</p><p>我们将允许进行插入 &#x2F; 删除操作的一端称为 <strong>栈顶</strong> ， 另一端称为 <strong>栈底</strong> 。<br>可以看出，栈的操作规则代表着其先进入的元素会被压在栈中，若想删除，则只能等到比其后进入的元素全部删除后才能进行。我们称这种规则为 <strong>后进先出</strong> 。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p>栈含有以下几种基本操作：</p><ul><li>InitStack：初始化</li><li>StackLength：求长</li><li>GetTop：获得栈顶元素</li><li>Push：入栈</li><li>StackTraverse：遍历</li><li>Pop：出栈</li><li>ClearStack：置空</li><li>StackEmpty：判空</li><li>DestoryStack：销毁</li></ul><h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>我们常用一组地址连续的存储单元来对栈进行存储，即C中的数组。<br>数组的上界（maxsize）用于表示栈的最大容量，而单独设置一个指针Top用来指向当前栈顶在数组中的位置。</p><p>需要注意的是，栈底的位置往往是固定的，但栈顶的位置会随着入栈 &#x2F; 出栈的操作而变化。</p><p>定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> Maxsize n<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Elemtype stack<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里同时也对栈的各类操作进行一些说明：</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>；<span class="token comment">//直接将栈顶的指针定为-1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">Push</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>top<span class="token operator">></span>Maxsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//此时栈满，即将上溢出</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        s<span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>s<span class="token punctuation">.</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出栈的操作与入栈相似，只需要考虑是否下溢出即可，这里不再详述。</p><h5 id="取顶"><a href="#取顶" class="headerlink" title="取顶"></a>取顶</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">GetTop</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> Elemtype <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>top<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//此时栈空</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        e <span class="token operator">=</span> s<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>s<span class="token punctuation">.</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其余操作在此不再详述。</p><h4 id="基于动态存储的栈管理"><a href="#基于动态存储的栈管理" class="headerlink" title="基于动态存储的栈管理"></a>基于动态存储的栈管理</h4><p>上文中基于数组的栈管理方法无法得心应手的进行栈扩容，而由此我们引出基于动态内存管理的方法。</p><p>它的定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">Stack_Int_Size</span> <span class="token expression"><span class="token number">100</span><span class="token punctuation">;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">Stack_Increment</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token operator">*</span>base<span class="token punctuation">;</span> <span class="token comment">//指向栈底</span>    Elemtype <span class="token operator">*</span>top<span class="token punctuation">;</span> <span class="token comment">//指向栈顶的下一个元素</span>    <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的管理方法使得每次当栈满时，我们可以进行realloc操作重新扩容栈：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base<span class="token operator">>=</span>S<span class="token punctuation">.</span>stacksize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//栈满，追加存储空间</span>    S<span class="token punctuation">.</span>base <span class="token operator">=</span> <span class="token punctuation">(</span>Elemtype<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>stacksize <span class="token operator">+</span> Stack_Incerment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elemtype<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span>top <span class="token operator">=</span> S<span class="token punctuation">.</span>base <span class="token operator">+</span> S<span class="token punctuation">.</span>stacksize<span class="token punctuation">;</span> <span class="token comment">//先将栈顶定出来</span>    S<span class="token punctuation">.</span>stacksize <span class="token operator">+=</span> Stack_Increment<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这种定义方法，判断栈满和栈空的语句分别为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">S<span class="token punctuation">.</span>top <span class="token operator">-</span> S<span class="token punctuation">.</span>base <span class="token operator">></span> S<span class="token punctuation">.</span>stacksize<span class="token punctuation">;</span> <span class="token comment">//栈满</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> S<span class="token punctuation">.</span>base <span class="token comment">//栈空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="多个栈共享空间"><a href="#多个栈共享空间" class="headerlink" title="多个栈共享空间"></a>多个栈共享空间</h4><p>在实际运用栈时，我们通常为了节省空间，防止空间浪费，会让多个栈同时使用一片存储空间，这通常表现为分配一个足够大的数组给多个栈，而后利用栈的动态存储特性，来对其进行存储空间的扩充。</p><p>以下，对两个栈的空间共享方法进行简要说明：</p><p>总体思路在于将两个栈的栈底至于 <strong>数组的两端</strong> ，而后在两个栈需要扩充空间时，将其栈顶向数组中间移动。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype stack<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top1<span class="token punctuation">,</span> top2<span class="token punctuation">;</span> <span class="token comment">//分别用于指向两个栈的栈顶位置</span><span class="token punctuation">&#125;</span> dustack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果用指针来表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token operator">*</span>m<span class="token punctuation">;</span> <span class="token comment">//整片区域的头指针</span>    Elemtype <span class="token operator">*</span>top1<span class="token punctuation">,</span> <span class="token operator">*</span>top2<span class="token punctuation">;</span>     <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span>  <span class="token comment">//整片区域的大小</span><span class="token punctuation">&#125;</span> dustack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种结构的栈，要判断是否上溢，则需要用到以下语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>top1 <span class="token operator">==</span> top2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//上溢</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里给出入栈的写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>top1 <span class="token operator">==</span> top2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"上溢"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        top1<span class="token operator">++</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>top1<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        top2<span class="token operator">--</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>top2<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="链式栈存储结构"><a href="#链式栈存储结构" class="headerlink" title="链式栈存储结构"></a>链式栈存储结构</h4><p>在栈的大小并不能确定时，采用链式存储结构能够更加轻松的扩栈，缩栈。</p><p>具体在C语言中，即链表的存储方式，但有所不同的是，此处链表的 <strong>头结点</strong> 指向的是栈的 <strong>栈顶</strong> ，因此每次对栈进行操作，相当于是对头结点的位置进行相关的改变。</p><p>链栈的定义方式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">snode</span><span class="token punctuation">&#123;</span>    Elemtype data<span class="token punctuation">;</span>    snode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> linkstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>链栈的进栈操作在这里给出：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>linkstack top<span class="token punctuation">,</span> Elemtype x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    snode<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>snode<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>snode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//内存满，栈上溢</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        t<span class="token operator">-></span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>        t<span class="token operator">-></span>next <span class="token operator">=</span> top<span class="token punctuation">;</span> <span class="token comment">//t的指针域指向原先的头节点</span>        top <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">//将头结点改成t的位置</span>        <span class="token keyword">return</span> OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，只要内存不爆满，链栈是不会有上溢这种错误出现的，这也是为什么链栈更加灵活的原因。</p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><blockquote><p>讲了一堆，现在该看看栈这种后进先出的玩意到底有什么用了</p></blockquote><h4 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h4><p>算法原理：</p><p><strong>N &#x3D; (N div d)×d + N mod d</strong></p><p>其中，d是进制数</p><p>举例：<br>（1348）<sub>10</sub> &#x3D; (2504) <sub>8</sub><br>具体计算为：  </p><ul><li>1348&#x2F;8 &#x3D; 168; 1348%8 &#x3D; 4;</li><li>168&#x2F;8 &#x3D; 21; 168%8 &#x3D; 0;</li><li>21&#x2F;8 &#x3D; 2； 21%8 &#x3D; 5；</li><li>2&#x2F;8 &#x3D; 0；2%8 &#x3D; 2；</li></ul><p>将每次取余计算的结果逆序链接，则能得到2504的结果</p><p>抽象为实现代码即：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">conversion</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化一个栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//N不得0时，持续循环</span>        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> N<span class="token operator">%</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        N <span class="token operator">=</span> N<span class="token operator">/</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//栈不空，则循环</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取出栈顶元素，存在e中</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，如果涉及到16进制的转换操作，需要对相应的字母与数字之间的关系进行建立，然后再进行算法的进一步优化，这里不再详述</p><h4 id="括号检验"><a href="#括号检验" class="headerlink" title="括号检验"></a>括号检验</h4><p>在表达式中，括号的对应是十分重要的一环，往往这种工作编译器会帮我们做完，如果需要我们自己进行编写，则需要借助栈这种结构。</p><p>如下的括号，都是符合书写格式的：<br>（ [ ] [ ] ）, ( ( [ ] ) )</p><p>但当出现如：<br>( [ ) ]<br>这一类的括号时，如何判断其是否符合要求，就是我们的任务。</p><p>总结一下，我们在检验括号时，出现的不匹配的现象，往往有三种可能：</p><ul><li>到来的右括号并不是 <strong>被期待的</strong></li><li>到来的是 <strong>不速之客</strong></li><li>直到最后，被 <strong>期待</strong> 的括弧也没到来。</li></ul><p>由此，我们可以设计出这样的算法：</p><p>从表达式左侧开始逐字符扫描，如果遇到左括弧，则入栈。<br>当遇到右括弧时：</p><ul><li>如果栈空：则右括弧必定多余，报错</li><li>如果栈非空，则将右括弧与栈顶元素比较：<br>  · 如果栈顶元素能与右括弧匹配，则栈顶元素出栈<br>  · 如果栈顶元素不匹配，则正常入栈</li></ul><p>当表达式扫描完成时，如果此时栈空，则表达式无误，若非空，则报错。</p><h4 id="行编辑程序问题"><a href="#行编辑程序问题" class="headerlink" title="行编辑程序问题"></a>行编辑程序问题</h4><p>如果让我们设计一个输入编辑器，我们应当如何设计？</p><p>一个最简单的设计思路是，用户输入一个字符，则存入一个字符。但这样显然是不合理的，如果用户输入错误，我们也应当给用户相应的挽回余地，对吧。</p><p>因此，至少需要有退格（backspace）的机制。<br>这里举一个例子，如果以“#”作为退格符号，用户输入的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">whli##ilr#e（s#*s)    putchar(*s&#x3D;#++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>则有效的输入内容为：</p><pre class="line-numbers language-none"><code class="language-none">while (*s)    putchar(*s++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此，这种方式十分符合栈的存储方式，思路为：<br>我们接收到一个字符，如果字符不是退格符，则压入栈顶；<br>如果字符是退格符，则令一个栈顶元素出栈。</p><blockquote><p>上述例子只是一个最简单的行编辑程序，更多的符号如回车（enter），上档（shift）等可以自行思考。</p></blockquote><h4 id="表达式求值问题"><a href="#表达式求值问题" class="headerlink" title="表达式求值问题"></a>表达式求值问题</h4><p>我们向程序中输入一个表达式，我们希望能够输出它的结果，这是如何被计算出来的？</p><p>要理解这个问题，我们首先应当介绍一下 <strong>算符优先法</strong> 。</p><p>我们先将一个表达式分成三部分：</p><ul><li>界限符：即左括号，右括号，表达式终止符等</li><li>运算符：即算术运算符，逻辑运算符，关系运算符等</li><li>操作数：常数，变量等</li></ul><p>本文中仅仅以简单算术表达式的例子做抛砖引玉作用。<del>（其实是博主水平不够）</del></p><p>要实现这个算法，我们需要设计两个栈，即：</p><ul><li>运算符栈：OPTR栈</li><li>操作数栈：OPND栈</li></ul><p>算法基本思想如下：</p><ul><li>我们首先将操作数栈为空栈，将起始符#入栈</li><li>依次读入字符，如果是操作数，则存入OPND栈，如果是运算符，我们就将当前读入的操作符与栈顶的操作符做优先级比较，并根据比较结果决定要不要进行相关的运算。直到我们的运算符栈里面只有两个#为止。</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Chap.3/%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p><blockquote><p>这里可以看出，相同的运算符，优先级默认是前者大于后者的，这点是为了使得“&#x3D;”这个优先级仅在括号的判断中出现，防止歧义。</p></blockquote><p>操作符之间的优先级很重要：</p><ul><li>如果读入的操作符优先级大于栈顶的操作符优先级：则该操作符入栈。</li><li>如果读入的操作符优先级等于栈顶的操作符优先级：则该操作符必定是括号。</li><li>如果读入的操作符优先级小于栈顶的操作符优先级：则直接取操作数栈的栈顶两个元素进行运算。</li></ul><p>这里给出一个运算式例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Chap.3/%E8%BF%90%E7%AE%97%E4%BE%8B%E5%AD%90.png" alt="例：3*(7-2)"></p><blockquote><p>更多的应用有迷宫求解，递归的实现，地图染色等等，这里不再详述。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>只允许在表的一端进行插入，在另一段进行删除的线性表<br>先进先出</p><h3 id="队列的基本操作："><a href="#队列的基本操作：" class="headerlink" title="队列的基本操作："></a>队列的基本操作：</h3><ul><li>EnQueue(&amp;Q, e) 入队</li><li>DeQueue(&amp;Q, &amp;e) 出队</li><li>InitQueue(&amp;Q) 初始化</li><li>QueueEmpty(Q) 判空</li><li>DestoryQueue(&amp;Q) 销毁</li><li>QueueLength(Q) 求长</li><li>ClearQueue(&amp;Q) 置空</li><li>GetHead(Q, &amp;e) 求头</li><li>QueueTraverse(Q, visit()) 遍历</li></ul><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>采用数组进行存储：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token function">queue</span><span class="token punctuation">(</span>maxsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">//front表示队头，rear表示队尾</span><span class="token punctuation">&#125;</span>queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>入队，改变队尾指针<br>出队，改变队头指针</p><p>队空：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">==</span> rear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>队满：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rear <span class="token operator">==</span> maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="顺序存储-改进"><a href="#顺序存储-改进" class="headerlink" title="顺序存储-改进"></a>顺序存储-改进</h3><p>显然，总有一个时刻，front指针与rear指针均指向数组的maxsize处的元素，但整个数组并没有被填满，反而前面空余了很多空间。这种情况被称为 <strong>假溢出</strong> 。</p><p>假溢出一般有两种解决方式：</p><ul><li>出队后，令整个队列左移。（涉及大量元素的移动）</li><li>将Queue[0]接到Queue[maxsize-1]的后方，形成队列环（参考上一章中循环链表的思想）</li></ul><p>入队时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rear <span class="token operator">=</span> <span class="token punctuation">(</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出队时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">=</span> <span class="token punctuation">(</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方法中，还有个问题，即队满和队空的判断语句均为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">==</span> rear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于这个问题，有两种解决方法：</p><ul><li><p>可以采用 <strong>设置标志位</strong> 的方法进行改进：<br>队空的情况只能由出队操作引起<br>队满的操作只能由入队操作引起<br>因此，加一个标志位 <strong>flag</strong> ，将其初始化为“delete”， 进行入队时，更改其为“enter”。由此判断队空还是队满。</p></li><li><p>可以少用一个存储空间<br>这时，队空则仍然由front &#x3D;&#x3D; rear来判断，队满则可使用front &#x3D;&#x3D; rear-1的方式来进行判断。</p></li></ul><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>顾名思义，使用链表对队列进行存储</p><p>当然，对于队列的链表而言，我们需要有队头与队尾两个指针来对整个队列进行维护</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    node<span class="token operator">*</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>链队列初始化时，只需要分配出头结点即可，此后利用rear &#x3D; front来进行初始化<br>销毁时，从队头开始遍历，分次释放所有的结点  </p><p>入队：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">node<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>本篇仅对栈和队列的基础定义与一些简单应用做出了阐述，后续有时间会补充更多的细节。</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.2</title>
      <link href="/posts/36543.html"/>
      <url>/posts/36543.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-程序设计基础"><a href="#Java-程序设计基础" class="headerlink" title="Java 程序设计基础"></a>Java 程序设计基础</h1><blockquote><p>本章将正式步入Java的内容，但说在前面，由于此前有C语言的基础章节，而Java的语法又跟C语言极其相似，因此在谈到某些具体语句时，博主将不再讲述的过于详细，请读者自行查找C语言章节中的内容。</p></blockquote><h2 id="有关引入包"><a href="#有关引入包" class="headerlink" title="有关引入包"></a>有关引入包</h2><p>上述语句中 <strong>import</strong> 语句相当于Java中的引入语句，它的作用是引入一个 <strong>包(Package)</strong> ，用于在本文件中使用。类比C语言，这类似于C中的引入头文件操作。</p><p>至于具体的包，我们将在后续的文章中具体提及。</p><h2 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h2><p>Java中有三种注释：</p><ul><li><p>单行注释：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 这是一条单行注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>多行注释</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*这是一个多行注释*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>文件注释</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**&#x2F;*这是一个文件注释&#x2F;*用于在文件头部对文件的具体功能进行说明*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="关于数据类型"><a href="#关于数据类型" class="headerlink" title="关于数据类型"></a>关于数据类型</h2><h3 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h3><p>类似于C语言，Java中也有多种数据类型：</p><ul><li>整数：<br>byte, short, int, long</li><li>浮点数：<br>float, double</li><li>字符型：<br>char</li><li>布尔型：<br>boolean</li></ul><p>在C中，对short，int， long的定义并不明确，只有笼统的：long&gt;int&gt;short （这里指的是内存占用大小），这就导致不同的编译器，不同的系统上可能会导致很严重的兼容性问题。<br>Java看到了这一点，为了兼容性，其对每个数据类型的大小进行了准确的定义。</p><ul><li>byte: 1</li><li>short: 2</li><li>int: 4</li><li>long: 8</li><li>float: 4</li><li>double: 8</li><li>char: 2</li><li>boolean: 4</li></ul><p>在这里，还需要进行三点说明：</p><ul><li>Java中不允许直接进行低精度类型赋予高精度类型的操作。这就代表着<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> x1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>是不被允许的。</li></ul><p>如果要强行赋值，请利用强制类型转化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>x1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Java中，byte类，short类在运行后所得到的类型， <em><strong>均为int型</strong></em> ，因此请注意这种类型的编译错误：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">byte</span> x3 <span class="token operator">=</span> x1 <span class="token operator">+</span> x2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>虽然x1, x2均为byte型，但其两者相加时，自动转为了int型，这时候将其值赋给x3，会发生溢出报错。</p><ul><li>在Java中定义float类型时，需要在值后方加一个f。</li></ul><h3 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h3><p>Java中定义常量时，需要在定义语句前加 <strong>final</strong> 语句。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">double</span> <span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="关于-var-关键字"><a href="#关于-var-关键字" class="headerlink" title="关于 var 关键字"></a>关于 var 关键字</h3><p><strong>var</strong> 关键字是一种用于偷懒的方法，当类型名过长时，可以在定义语句中使用var关键字来代替前方的类型名。</p><h3 id="关于数据类型的运算"><a href="#关于数据类型的运算" class="headerlink" title="关于数据类型的运算"></a>关于数据类型的运算</h3><h4 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h4><p>Java中的运算规则，与C大体上相同，在此前没有提过的有一种叫做 <strong>位移运算</strong> 的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 0111</span>n<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 1110</span>n<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 0011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述语句被称作位移运算，可以看出，这种运算方式是以整数的二进制表示方法为基础的。<br><strong>左移加倍，右移减半</strong></p><p>需要注意的是，右移操作并不会移动符号位，如果想要把符号位一并移动，请使用 <strong>&gt;&gt;&gt;</strong> 关键字</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>与位移运算相似的在数字二进制表达式上进行操作的还有一种，称为 <em><strong>位运算</strong></em> 。</p><p>其包括四种类型：</p><ul><li>位与运算符：&amp;<br>如果参与运算的两个数字的某一个二进制位同时取1，其结果该位上才为1，否则置0</li><li>位或运算符：｜<br>如果参与运算的两个数字的某一个二进制位同时取0，其结果上该位才取0，否则为1</li><li>位异或运算符：^<br>如果参与运算的两个数字的某一个二进制位不同，其结果上该位才取1，否则置0</li><li>位取反运算符：~<br>将一个数字的每一个二进制位上的数都取其相反数。</li></ul><h2 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h2><p><strong>字符串</strong> 是Java中的一种引用类，在Java中十分常用，因此在这里单独提一句：</p><p>字符串可以用 <strong>+</strong> 进行连接定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于多行字符串，可以使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> <span class="token string">""</span>" <span class="token class-name">Hello</span><span class="token punctuation">,</span><span class="token class-name">Java</span><span class="token class-name">Programming</span><span class="token class-name">World</span> <span class="token string">""</span>"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>来进行定义。</p><p>字符串还可以是一个空值，即：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要知道的是，字符串是不可以直接改变的，因为其是一种引用变量（关于引用，会在下文中提及），往往需要StringBuilder类进行修改。</p><h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p><strong>数组</strong> 同样是Java中的一种引用对象，其定义方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intarray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，Java中的数组与C语言中的数组并不是一回事，其意义为定义一个引用变量，这个引用变量会指向一个长度为26的数组变量.</p><p>相当于， <strong>intarray</strong> 只是一个变量，而这个数组是一个对象，用 <strong>new</strong> 关键字来创建，它被存在另一个位置，而intarray 仅仅是指向了它。</p><p>相似的，如果我定义了一个字符串数组，则事情更加复杂一些。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str_array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，str_array指向了一个长度为10的字符串数组，这个数组在另外一个位置，但由于字符串也是一种对象，在定义字符串时，也是通过引用的方式进行定义的，因此相当于这个长度为10的数组，里面是10个引用变量，这10个引用变量会各自指向一个字符串，它们也不一定存储在同一片区域。</p><p>这同样也代表着，一旦你创建了这个数组对象，你就不能更改这个对象的大小了。如果需要扩容，你只能重新创建一个更大的对象，然后把这个引用对象指向这个全新的对象。</p><p>这里，希望读者尽力理解，辅以网络上的其他资料对 <em><strong>引用</strong></em> 的机制进行了解。</p><p>了解后，我们可以在此引入另一个概念：</p><h2 id="关于多维数组"><a href="#关于多维数组" class="headerlink" title="关于多维数组"></a>关于多维数组</h2><p>在C中，我们定义二维数组必定是一个整齐的，如2＊5的，它每个次级数组的长度必须是一致的。</p><p>但由于Java中，数组是一种引用变量，我们其实可以定义不整齐的二维数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> two_dim_arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//代表定义了一个有四个子变量的数组</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//次级数组的长度可以不同，因为它们可以并不存储在同一片区域中，不需要考虑到对齐问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-2</title>
      <link href="/posts/56162.html"/>
      <url>/posts/56162.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-Chap-2-线性表"><a href="#数据结构-Chap-2-线性表" class="headerlink" title="数据结构 Chap.2 线性表"></a>数据结构 Chap.2 线性表</h1><h2 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h2><p>线性表是一种最简单的数据结构，其表现为一系列有顺序的元素集合。<br>自然，线性表需要满足如下标准：</p><ul><li>有 <strong>第一元素</strong> 与 <strong>最后元素</strong></li><li>除了第一元素之外，每个元素都有它的 <strong>后继</strong> ，除了最后元素之外，每个元素都有它的 <strong>前驱</strong> 。</li><li>同一线性表内的元素必定具有相同的特性。</li></ul><h2 id="线性表的相关操作"><a href="#线性表的相关操作" class="headerlink" title="线性表的相关操作"></a>线性表的相关操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>首先，我们来了解一些线性表的基本操作。<br>它们包括：</p><ul><li>初始化: InitList</li><li>销毁: DestoryList</li><li>判断是否为空: ListEmpty</li><li>求长度: ListLength</li><li>求指定元素的前驱: PriorElem</li><li>求指定元素的后继: NextElem</li><li>提取指定元素: GetElem</li><li>定位: LocateElem</li><li>遍历: ListTraverse</li><li>置空: ClearList</li><li>改变指定元素的值: PutElem</li><li>插入元素: ListInsert</li><li>删除元素: ListDelete</li></ul><p>这里对定位操作进行些许说明：<br>该操作的意义为在线性表中找到第一个符合某个条件的元素，并返回其位置。<br>一般而言，若未找到，则返回-1。</p><p>需要明确的是，上述表述仅仅关系了这些操作是 <strong>做什么的</strong> ，并没有深究应当如何实现这种操作，具体应当如何实现，应当依靠读者使用的语言，采用的具体结构而定。</p><p>上述基础运算也可以构成更进一步的应用，如线性表的有序合并，拆分，排序等。</p><h3 id="应用事例"><a href="#应用事例" class="headerlink" title="应用事例"></a>应用事例</h3><h4 id="两个线性表-LA-与-LB-的合并"><a href="#两个线性表-LA-与-LB-的合并" class="headerlink" title="两个线性表 LA 与 LB 的合并"></a>两个线性表 LA 与 LB 的合并</h4><p>该操作可以分为三步：</p><ul><li>从LB中依次取出每个元素</li><li>观察LB中取出的元素在LA中是否存在</li><li>若不存在，则存入LA中</li></ul><p>若写成代码块：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span>List <span class="token operator">&amp;</span>LA<span class="token punctuation">,</span> List LB<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LA_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LA<span class="token punctuation">)</span><span class="token punctuation">;</span>    LB_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LB_len <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">GetElem</span><span class="token punctuation">(</span>LB<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取第i个元素赋予e</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> e<span class="token punctuation">,</span> equal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">ListInsert</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> LA_len<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将e插入LA的最后</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处，给出了一个很基础的操作代码块，后续在无必要的情况下，将不会这样详细的给出具体步骤。</p><p>回归正题，这个算法需要在遍历LB内每个元素的同时也遍历LA中的每个元素来进行查重，因此我们可以计算出其时间复杂度：<br><em><strong>O(ListLength(LA) * ListLength(LB))</strong></em></p><h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><blockquote><p>前面讲的内容比较概括性，也相对抽象，以下将具体讲述线性表的表示方法。</p></blockquote><h3 id="什么是顺序表示"><a href="#什么是顺序表示" class="headerlink" title="什么是顺序表示"></a>什么是顺序表示</h3><p><em><strong>顺序表示</strong></em> 正如其名，线性表中的数据结构在内存中的表示也是有顺序的，具体表现为前一个元素紧挨着后一个元素。再简单一点，顺序表示可以通俗的理解为C中的 <strong>数组</strong> 。</p><h3 id="用C语言实现线性表的顺序存储"><a href="#用C语言实现线性表的顺序存储" class="headerlink" title="用C语言实现线性表的顺序存储"></a>用C语言实现线性表的顺序存储</h3><h4 id="线性表的初始化：InitList"><a href="#线性表的初始化：InitList" class="headerlink" title="线性表的初始化：InitList"></a>线性表的初始化：InitList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">L<span class="token punctuation">.</span>Elem <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> List_Elem_Size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的容量扩展：ExtendList"><a href="#线性表的容量扩展：ExtendList" class="headerlink" title="线性表的容量扩展：ExtendList"></a>线性表的容量扩展：ExtendList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">NewBase <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>List_Elem_Size <span class="token operator">+</span> Expand_Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的元素定位：LocateElem"><a href="#线性表的元素定位：LocateElem" class="headerlink" title="线性表的元素定位：LocateElem"></a>线性表的元素定位：LocateElem</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>statment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//定位到符合statment语句的元素</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="线性表的元素插入：ListInsert"><a href="#线性表的元素插入：ListInsert" class="headerlink" title="线性表的元素插入：ListInsert"></a>线性表的元素插入：ListInsert</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">>=</span>q<span class="token punctuation">;</span> p<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将插入位置后方的元素分别向后移动一位</span><span class="token operator">*</span>p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//插入元素e</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>线性表的删除操作与插入操作类似，在此不再详述。</p><h3 id="顺序存储线性表的优劣"><a href="#顺序存储线性表的优劣" class="headerlink" title="顺序存储线性表的优劣"></a>顺序存储线性表的优劣</h3><p>顺序存储的优点主要表现在以下两方面：</p><ul><li>存储时不需要为了表述元素之间的关系而额外花费内存空间</li><li>可以实现元素的随机读取</li></ul><p>顺序存储的缺点主要表现在以下两方面：</p><ul><li>必须分配连续存储空间给线性表，在内存连续片段较小时，有初始化失败的可能性</li><li>在插入 &#x2F; 删除元素时，需要大量移动元素，造成不便</li></ul><h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><h3 id="什么是链式表示"><a href="#什么是链式表示" class="headerlink" title="什么是链式表示"></a>什么是链式表示</h3><p><em><strong>链式表示</strong></em> ， 每个数据元素单独存储，它们在内存中可以是连续的，也可以是分散的，它们之间的关系通过每个数据元素附带的一个指针域进行连接。说的更具体化一些，即用结构体将指针于数据元素包装在一起，它们链式存储中的一个数据元素。在C语言中常常通过链表表示。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>这里需要对 <strong>链表</strong> 这一概念进行引入。<br>链表即指代如同上述表达中提及的，一个数据域附带一个指针域形成的结构。其主要分为以下几类：</p><ul><li>单链表</li><li>双链表</li><li>循环链表（单 &#x2F; 双）</li><li>静态链表</li></ul><p>让我们先从最基础的单链表讲起</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>顾名思义，单链表的连接方式是单向的，即我们只能通过前一个元素的指针域找到它的后继，而无法通过后一个元素找到其前驱。<br>其通常在C语言中以这样的方式进行结点定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    ElemType Elem<span class="token punctuation">;</span>    Node<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以得知，只要得知第一个结点，就可以通过每个结点指针域中的指针得知其下一个结点，从而实现链表的一系列操作，因此，我们一般称单链表的第一个结点为 <strong>头结点</strong> 。</p><p>注：有时为了方便，头结点的数据域中不进行存储。</p><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><h5 id="单链表的元素提取：List-GetElem"><a href="#单链表的元素提取：List-GetElem" class="headerlink" title="单链表的元素提取：List_GetElem"></a>单链表的元素提取：List_GetElem</h5><p>不同于顺序存储，链式存储在提取元素时必须通过头结点分部向后寻找指定位置的元素。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_GetElem</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    e <span class="token operator">=</span> p<span class="token operator">-></span>Elem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h5 id="单链表的元素插入：List-Insert"><a href="#单链表的元素插入：List-Insert" class="headerlink" title="单链表的元素插入：List_Insert"></a>单链表的元素插入：List_Insert</h5><p>同样，链式存储的元素插入与顺序存储差异极大。<br>我们需要先找到插入位置的前一个元素，这之后只需要改变这个元素与被插入元素的指针域即可。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_Insert</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//链表的每次插入都需要手动创建一个新结点</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_node<span class="token operator">-></span>ElemType <span class="token operator">=</span> e<span class="token punctuation">;</span>    new_node<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> new_node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>单链表的元素删除相比元素插入仅仅多了一个free（释放内存）的操作，即将删除的结点释放掉，这里不再详述。</p><h5 id="单链表的置空操作：ClearList"><a href="#单链表的置空操作：ClearList" class="headerlink" title="单链表的置空操作：ClearList"></a>单链表的置空操作：ClearList</h5><p>与删除操作类似。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ClearList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>        L<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="单链表的改进"><a href="#单链表的改进" class="headerlink" title="单链表的改进"></a>单链表的改进</h4><p>从上述应用中我们可以看出，单链表的运用很依赖于链表本身的一些特殊结点与位置，那我们不妨改进一下单链表，单独为它设置一个结构体，用于存储这些特殊的位置和个数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sruct List<span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> Head<span class="token punctuation">,</span> Tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种定义，我们可以清晰的明确一个链表的头、尾结点，以及其元素总个数。</p><h4 id="单链表：注意事项"><a href="#单链表：注意事项" class="headerlink" title="单链表：注意事项"></a>单链表：注意事项</h4><p>可以看到，在以上操作中，我们在函数内对单链表进行操作，往往不会直接使用其头结点，而是单独定义一个指针，再通过移动这个指针来操作链表内的元素。<br>这是因为，如果直接对头结点的Head指针进行移动，由于函数的参数是Head的地址，因此在函数中你对Head的每一次移动都是永久性的，函数结束后Head指针的地址并不会还原，你会丢失前面的元素。<br>因此，请务必注意这一点。</p><h3 id="其他形式的链表"><a href="#其他形式的链表" class="headerlink" title="其他形式的链表"></a>其他形式的链表</h3><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p><strong>双链表</strong> 是对单链表的改进，其相比于单链表，一个数据元素占用的内存更大，这是因为它不仅仅能通过一个元素找到它的后继，同时也能找到它的前驱。</p><p>我们常常这样定义一个双链表的结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">DuNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token comment">//数据域</span>    DuNode<span class="token operator">*</span> prior<span class="token punctuation">;</span>    DuNode<span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们通过prior来指向元素的前驱，通过next来指向元素的后继。</p><p>由于指针域的增加，对一个双向链表进行操作时的指针域更改会更加复杂一些，但道理总归相似，请读者自行类比即可。<br>需要特殊说明的是，双向链表在进行插入、删除操作时，需要更改其前驱的next指针，也需要更改其后继的prior指针。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表</strong> 是将链表最后一个元素指向了这个链表的头结点，从而实现了让这个链表首尾相接的效果。<br>此时，判断元素是否是最后一个元素的依据也不是其后继是不是 NULL ，而变成了是不是头结点。</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p><strong>静态链表</strong> 是在某些没有指针这个设定的高级语言中应用的，它通常这样定义一个结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">StaticNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述链表是通过数组来实现的，数组中的一个元素就是一个结点，同时其通过游标cur来表示其结点在链表中的位次。<br>这种链表通过游标来指示其下一个元素的位置，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这就是链表的第1个元素所在的下标位置</span>S<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这是链表第2个元素所在的下标位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>虽然这种链表仍然需要一个相对较大的存储空间，但其在插入 &#x2F; 删除元素时，仍然只需要改变指针，而不用移动元素，因此其仍然具备链式存储结构的主要优点。</p><p>这种链表的顺链查找通常会这样写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i <span class="token operator">=</span> S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span> <span class="token comment">//S[0]相当于头结点</span><span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i <span class="token operator">=</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链式存储的优劣"><a href="#链式存储的优劣" class="headerlink" title="链式存储的优劣"></a>链式存储的优劣</h3><p>链式存储的优势体现在：</p><ul><li>插入 &#x2F; 删除时，无需大量移动元素</li><li>不需要一大块连续的存储空间</li><li>扩充表的规模很容易</li></ul><p>链式存储的主要劣势：</p><ul><li>无法随机访问表内元素，访问时间长短与元素在表内的位置相关。</li></ul><p>至此，关于线性表的大致内容梳理完成。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.1</title>
      <link href="/posts/36863.html"/>
      <url>/posts/36863.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h1><blockquote><p>本文旨在让读者大致了解Java，并对其中的一些基本内容进行说明</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在学习Java之前，我们首先应当了解Java的一些细节</p></blockquote><h3 id="Java是什么？"><a href="#Java是什么？" class="headerlink" title="Java是什么？"></a>Java是什么？</h3><p>Java是由SUN公司开发的一种编程语言，如今已被Oracle收购。</p><p>但时至今日，Java已经不仅仅是一门编程语言，Java包含着许多方面：</p><ul><li>一类编程语言</li><li>一种开发环境</li><li>一种应用运行环境</li></ul><p>得益于Java本身强大的兼容性，其不仅仅在服务器端的应用中占据着一席之地，同样在PC，移动端应用开发上有广大的应用场景。</p><h3 id="Java迄今的地位"><a href="#Java迄今的地位" class="headerlink" title="Java迄今的地位"></a>Java迄今的地位</h3><p>迄今为止，Java在编程语言使用率上仍然占据着第四名的位置。这得益于其兼容性；易于理解的编译语言；内置的内存处理机制等等。</p><h3 id="Java的不同版本"><a href="#Java的不同版本" class="headerlink" title="Java的不同版本"></a>Java的不同版本</h3><p>SUN公司曾经为Java设定了三个版本，这种分类标准被沿用至今：</p><ul><li>Java SE (Standard Edition)</li><li>Java EE (Enterprise Edition)</li><li>Java ME (Micro Edition)</li></ul><p>三者之间的关系为：EE &gt; SE &gt; ME</p><h3 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h3><p><em><strong>JDK</strong></em> 是Java Development Kit 的简称。<br><em><strong>JRE</strong></em> 是Java Runtime Environment 的简称。<br><em><strong>JVM</strong></em> 是Java Virtual Machine 的简称。</p><p>Java在每台计算机上会内置一个虚拟机，即JVM。代码会先编译为Java字节码，而后放在JVM上运行，以此很好的保证了Java在各个平台上的兼容性。</p><p>JRE是Java运行的环境，而JDK比JRE更大一层，其中除了JRE外还内置了编译器、调试器等工具。</p><h2 id="编译入门"><a href="#编译入门" class="headerlink" title="编译入门"></a>编译入门</h2><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>与C不同，Java的配置过程稍显复杂，也需要更多的时间与步骤。</p><p>整体而言，分为 下载JDK -&gt; 配置环境变量 -&gt; 运行IDE 三个步骤。</p><p>本笔记的运行全程以JDK-20为环境，在VScode上进行java的编写。<br>博主在这个方面不做详细阐述，请自行上网搜索</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-1</title>
      <link href="/posts/55842.html"/>
      <url>/posts/55842.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在此前C语言的章节中，曾提到过一个十分有名的等式：算法 + 数据结构 &#x3D; 程序。本部分的博文会从C语言的角度来对数据结构进行相应的阐述，有利于理清思路，也可以以相似的想法套用至其它编译语言中。</p></blockquote><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="1-数据结构的概念"><a href="#1-数据结构的概念" class="headerlink" title="1. 数据结构的概念"></a>1. 数据结构的概念</h2><blockquote><p>何为数据结构？</p></blockquote><p>在编程的过程中，我们通常遇到的问题能够被分为两类：</p><ol><li>数值计算问题</li><li>非数值计算问题</li></ol><p>数值计算问题往往是能够通过明确的数学公式进行解决的，编译的过程需要思考的问题相对较少。而非数值计算问题则涉及的方面更多，也更考验编译者的抽象思维，这一过程中就涉及到选取正确的数据存储方式，以此使我们在计算机上能够更加便利地对数据进行操作，数据结构的概念由此产生。</p><p>我们定义数据结构时，往往通过三方面进行考虑。</p><ul><li>数据的逻辑结构：即信息的组织方式</li><li>数据的存储结构：即信息在计算机上的存储方式</li><li>数据的运算：即在计算机上应当如何处理这些数据</li></ul><p>以下举出两例，进行相关的说明：</p><ol><li><p>表：</p><p> 表的逻辑结构往往是线性的，这意味着其中的数据组与组之间关系并不十分强烈，因此可以采用在计算机中采用顺序（数组）或链式（链表）存储方式。运算也往往包含插、删、改、查四种方式。</p></li><li><p>图：</p><p> 图的逻辑结构体现在结点与结点之间，其组与组之间的关系更加复杂，因为任意两组数据之间均有可能产生联系。因此在存储时，既要考虑结点本身信息的存储，也要考虑结点之间的关系如何构建。运算相应添加了关键路径、最短路径的问题等。</p></li></ol><p>通过上述示例，我们能看出 <strong>数据结构往往解决的是非数值计算问题，它意在数据组织的基础上解决复杂程序的设计问题</strong>。</p><h2 id="2-数据的结构"><a href="#2-数据的结构" class="headerlink" title="2. 数据的结构"></a>2. 数据的结构</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是能够被输入到计算机中进行存储、操作的符号的总称。其衍生出的名词还有：</p><ul><li>数据元素：即数据中的一个个体</li><li>数据项：数据中的一个个体可能有多项数据，这其中每一项数据都能被称作数据项</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>数据元素之间存在某种关系，这种关系被称为逻辑结构。</p><p>常见的逻辑结构有：</p><ul><li>集合</li><li>线性结构</li><li>树形结构</li><li>图 &#x2F; 网状结构</li></ul><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>将数据结构在计算机中存储，表示的方式称为存储结构。它也可以理解为逻辑结构在计算机中的映像。（如二进制、顺序存储映像、链式存储映像等）</p><p>由于某些数据的逻辑结构极其相似，因此统一用一类存储结构对它们进行存储，这种特定的存储结构叫做 <strong>数据类型</strong> （如数组，链表等具体类型）</p><p>同时，对相应数据类型的操作有时也极其相似，因此对相应一类操作起个名，叫 <strong>抽象数据类型（Abstract Data Type）</strong> （不同的教材中叫法不同）<br>这与很多编译语言中的 <strong>类</strong> 的概念十分类似。</p><h3 id="Abstract-Data-Type（ADT）"><a href="#Abstract-Data-Type（ADT）" class="headerlink" title="Abstract Data Type（ADT）"></a>Abstract Data Type（ADT）</h3><h4 id="重要特征"><a href="#重要特征" class="headerlink" title="重要特征"></a>重要特征</h4><p>由于ADT本身的性质，其具有两个重要的特征：</p><ul><li>数据抽象：ADT强调数据本身的性质，而其中的操作是一致的，因此对于其本身与外部用户的接口具有严格的要求。</li><li>数据封装：其内部的实现细节往往对外部用户隐藏。</li></ul><h4 id="ADT的定义"><a href="#ADT的定义" class="headerlink" title="ADT的定义"></a>ADT的定义</h4><pre class="line-numbers language-none"><code class="language-none">ADT抽象数据类型名&#123;    数据对象：    数据关系：    &#x2F;&#x2F;以上两种定义利用伪码描述    基本操作：        基本操作名（参数表）        初始条件：        操作结果：&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本操作的参数表中含有两种参数：</p><ol><li>赋值参数：为操作提供输入值</li><li>引用参数（以&amp;开头）：可返回操作结果</li></ol><p>初始条件表明了该种操作需要满足的条件，可以为空。<br>操作结果表明了数据结构的变化状况，以及此操作后应当返回怎样的结果。</p><h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><p>算法，是对特定问题解决步骤的描述，根据时间、空间占用量的不同有优劣之分。</p><h3 id="算法的特点"><a href="#算法的特点" class="headerlink" title="算法的特点"></a>算法的特点</h3><p>首先，算法必须具有以下五条基本性质：</p><ul><li>有穷性</li><li>确定性（指令明确）</li><li>可行性（每条指令都可被执行）</li><li>有输入（0或多个）</li><li>有输出（0或多个）</li></ul><p>其次，要写出一个 <strong>好的算法</strong> ，则还应当有如下特点进行辅助：</p><ul><li>正确性</li><li>可读性</li><li>健壮性（程序不会轻易崩溃）</li><li>高效率 &amp; 低存储量</li></ul><blockquote><p>正确性、可读性、健壮性自然不必多言，下面从高效率与低存储量方面进行说明。</p></blockquote><h3 id="算法执行时间"><a href="#算法执行时间" class="headerlink" title="算法执行时间"></a>算法执行时间</h3><p>首先，明确一下与执行时间密切相关的因素：</p><ul><li>算法策略</li><li>问题规模</li><li>使用语言</li><li>机器代码质量</li><li>机器性能</li></ul><p>在我们的控制范围内的，主要是算法策略与使用语言。其中又以算法策略为重点优化对象。</p><p>这里我们继续细分， <em><strong>算法 &#x3D; 控制结构 + 原操作</strong></em><br>其中控制结构主要指程序的顺序、分支与循环，而原操作则指固有数据类型的操作。</p><p>形成习惯的是，算法中原操作的重复次数往往与算法的执行时间成正比，因此以 <strong>原操作在算法中重复执行的次数</strong> 作为算法执行时间的衡量准则，称为 <strong>时间复杂度</strong> ，以 <em><strong>O(n)</strong></em> 表示。<br>下面举几例常见的时间复杂度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token comment">//O(1) 常量阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n) 线性阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token operator">++</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n^2)  平方阶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里提出两个经典的问题供读者思考，有兴趣也可以自行搜索相应解答：</p><ul><li>折半查找的算法时间复杂度</li><li>汉诺塔问题递归解法的时间复杂度</li></ul><p>请务必注意，上文中的 <strong>原操作</strong> 指的是 <strong>ADT中的一次基本操作</strong> ，如对于折半查找来说，即进行一次折半操作，对于汉诺塔问题来说，则是挪一次盘子的操作。<br><strong>请务必不要将原操作理解为一条语句！</strong></p><h3 id="算法占用空间"><a href="#算法占用空间" class="headerlink" title="算法占用空间"></a>算法占用空间</h3><p>相对应的，算法本身的操作也需要相应的存储空间，这也就产生了 <strong>空间复杂度</strong> 的概念，不过博主至今并未了解相应的计算机制，烦请读者自行搜索。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好久不见</title>
      <link href="/posts/62537.html"/>
      <url>/posts/62537.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于此前的断更"><a href="#关于此前的断更" class="headerlink" title="关于此前的断更"></a>关于此前的断更</h2><p>距离上一次更新已经有半年之久，这期间主要是由于博主的学习与生活琐事所致，今后会尽力维持更新</p><h2 id="关于此后的内容"><a href="#关于此后的内容" class="headerlink" title="关于此后的内容"></a>关于此后的内容</h2><p>会有偏向性的转向C++与Java方面，另外，（如果博主能够学会相应的表述）可能会有一些数学方面的简记</p><p>好了，下篇博文见~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.8</title>
      <link href="/posts/34435.html"/>
      <url>/posts/34435.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote><p>在一个C语言程序中，除了自行编写程序之外，我们还想到应该如何对计算机内依然存在的文件进行操作，这就引出了本文的主题。</p></blockquote><h3 id="内存与外存"><a href="#内存与外存" class="headerlink" title="内存与外存"></a>内存与外存</h3><p>要描述文件，首先需要从内存，外存两个概念说起。</p><p>内存的概念，此前曾多次提及，是各类变量，算法储存的位置，并会在程序运行结束后及时释放。<br>内存中的数据会在关机后立刻消失。  </p><blockquote><p>如果对DIY有一定了解，则会常常听到“内存条”，就是这东西。</p></blockquote><p>外存则是永久存放各类文件，数据的地方，其中的数据在关机后不会消失。</p><blockquote><p>同样的，接触到的固态硬盘，机械硬盘，以及延伸至各类u盘，软盘，都属于外存的范畴。</p></blockquote><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p><strong>文件</strong> 是数据的集合，也是操作系统储存数据的基本方法。</p><p>文件有以下基本属性：</p><ol><li>文件名</li><li>占用空间</li><li>存储位置</li><li>文件类型</li><li>读写属性</li><li>创建，访问，修改时间</li><li>….</li></ol><p>操作系统为了使各种各样的文件有序的存储，衍生出了 <strong>目录</strong> 这一概念（即文件夹）</p><p>要通过程序操作文件，就必须要求相应的高级语言具有相应的文件操纵能力。</p><p>我们要达到的目的就是通过C语言程序访问文件，即对文件进行相关的输入（input），输出（output）操作。<br>为了简化书写，对输入输出，下文中简称为（I&#x2F;O）</p><h3 id="C语言中的文件形式"><a href="#C语言中的文件形式" class="headerlink" title="C语言中的文件形式"></a>C语言中的文件形式</h3><p>C语言将文件看成一个二进制流或字符流：</p><ol><li>二进制流（常用于二进制文件）：<br>相当于把文件看成很多0&#x2F;1序列，这种方式更有利于计算机的信息读取，保存，写入，但不利于阅读。</li><li>字符流（常用于文本文件）：<br>将文件看成很多字符序列的组合，每行后有一个换行符。这种形式很适合I&#x2F;O操作。</li></ol><p>与此同时，C语言在其标准库中加入了相应函数，包括：</p><ul><li>打开文件</li><li>关闭文件</li><li>读写文件</li></ul><h2 id="2-文件的打开与关闭"><a href="#2-文件的打开与关闭" class="headerlink" title="2. 文件的打开与关闭"></a>2. 文件的打开与关闭</h2><h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><p>在C语言中打开文件常用 <strong>fopen</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span>fp  <span class="token comment">//定义文件类型指针</span>fp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"这里写你的文件名（别忘加后缀）"</span><span class="token punctuation">,</span> <span class="token string">"这里写打开方式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里处理无法打开的情况</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>几个注意事项：</p><ol><li>如果打开文件成功，则返回一个FILE类型的指针地址，并且此后的文件操作都通过这个指针进行。<br>如果打开失败，则返回空指针。<br>因此利用C语言打开文件后一定要检查是否打开成功。</li><li>c语言有很多种文件打开方式：<ul><li>“r”: 打开文本文件，只读</li><li>“w”: 新建文本文件（或者删除原本的内容），只写</li><li>“a”: 打开文本文件，追加</li><li>“r+”: 打开文本文件，可以读+写</li><li>“w+”: 新建文本文件（删除原来的内容），可以读+写</li><li>“a+”: 打开文本文件，可以读+追加</li></ul></li><li>如果用二进制模式打开文件则在打开方式后加b，即：”rb”,”ab+”等。</li></ol><h3 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h3><p>在C语言中关闭文件常用 <strong>fclose</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几点注意事项：</p><ul><li>对于执行写入操作的文件，会将缓冲区内的内容写入文件中，然后关闭文件。</li><li>对于只读文件，会丢弃缓冲区内的内容，然后关闭文件</li><li>程序退出时，所有文件会自动关闭</li></ul><h3 id="三个标准文件指针"><a href="#三个标准文件指针" class="headerlink" title="三个标准文件指针"></a>三个标准文件指针</h3><p>C语言中，有三个自动生成的标准文件指针：</p><ul><li>stdin（标准输入流）</li><li>stdout（标准输出流）</li><li>stderr（标准错误流）</li></ul><p>stdin一般与键盘相连接，stdout一般与显示器相连接。</p><h2 id="3-文件的操作"><a href="#3-文件的操作" class="headerlink" title="3. 文件的操作"></a>3. 文件的操作</h2><blockquote><p>文件的读写涉及到多个函数，这其中还包括顺序读写与随机读写两种类型。</p></blockquote><h3 id="文件的顺序读写"><a href="#文件的顺序读写" class="headerlink" title="文件的顺序读写"></a>文件的顺序读写</h3><h4 id="字符读写函数：fgetc-fputc"><a href="#字符读写函数：fgetc-fputc" class="headerlink" title="字符读写函数：fgetc &amp; fputc"></a>字符读写函数：fgetc &amp; fputc</h4><p>首先对fgetc函数进行说明。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>pp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//通过只读模式打开一个文件</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从文件指针的位置读取一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgetc函数只能对以”r”（只读）, “r+”（只读写）的文件进行操作。</li><li>fgetc函数通过文件内部的位置指针进行读取。</li><li>每次读取一个字符，则文件指针fp向后移动一个位置。若读取失败（如读取到最后一个字符时），则返回EOF。<br>注：在应用时，可以利用这个特性进行循环读入：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过这种方式实现对文件的整体输出。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>此后是fputc函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token function">fputc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在p所指向的位置写入一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>被fput操作的文件只能是通过”w”, “w+”, “a”所打开的文件。</li><li>每写入一个字符，则字符指针fp向后移动一个位置。若写入失败，返回EOF。</li></ul><h4 id="字符串读写函数：fgets-fputs"><a href="#字符串读写函数：fgets-fputs" class="headerlink" title="字符串读写函数：fgets &amp; fputs"></a>字符串读写函数：fgets &amp; fputs</h4><p>先对fgets进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//这里权且为了说明写了n，正常情况下这种写法不合规</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开的过程</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在fp的位置读取n-1个字符，并将其放入str中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgets函数如果遇到了换行符或EOF，则自动结束读取。</li><li>fgets函数的返回值为字符数组的首地址。</li><li>若读取失败，则返回NULL。</li></ul><p>在对fputs进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">fputs</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在p的位置将str送入文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数执行成功则返回0，否则则返回EOF。</p><h4 id="格式化读写函数：fscanf-fprintf"><a href="#格式化读写函数：fscanf-fprintf" class="headerlink" title="格式化读写函数：fscanf &amp; fprintf"></a>格式化读写函数：fscanf &amp; fprintf</h4><p>从名字就能看出来，这两个函数与scanf以及printf的功能及其类似，区别在于这两个函数的操作对象是文件，而scanf，printf的操作对象为键盘。（标准输入设备）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开过程</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将文件中的数据读取并存储在变量中</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将变量中的数据写入到文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="数据块读写函数-fread-fwrite"><a href="#数据块读写函数-fread-fwrite" class="headerlink" title="数据块读写函数 fread &amp; fwrite"></a>数据块读写函数 fread &amp; fwrite</h4><p>fread与fwrite常用于二进制文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fread</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fp的位置开始每次读4个字节，读5次，并存入fa所在的地址中。（fa，fp均为指针）</span><span class="token function">fwrite</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fa的位置每次取4个字节，取5次，并放入fp所指向的文件中。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="文件定位函数：rewind-fseek"><a href="#文件定位函数：rewind-fseek" class="headerlink" title="文件定位函数：rewind &amp; fseek"></a>文件定位函数：rewind &amp; fseek</h4><p>先对rewind进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rewind</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将fp放置到文件开头</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在对fseek进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>fseek函数比较复杂：</p><ul><li>第一个参数fp为文件指针。</li><li>第二个参数为偏移量（一个long型变量）。</li><li>第三个参数为偏移起始点：<ul><li>SEEK_SET：代表文件开头（也可以用0代替）</li><li>SEEK_CUR：代表现在fp所在的位置（也可以用1代替）</li><li>SEEK_END：代表文件末尾（也可以用2代替）</li></ul></li></ul><h3 id="文件的检测"><a href="#文件的检测" class="headerlink" title="文件的检测"></a>文件的检测</h3><h4 id="错误检测：ferror"><a href="#错误检测：ferror" class="headerlink" title="错误检测：ferror"></a>错误检测：ferror</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ferror</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测被操作文件的当前状态，正常则返回0，错误则返回1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="清除出错：clearerr"><a href="#清除出错：clearerr" class="headerlink" title="清除出错：clearerr"></a>清除出错：clearerr</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">clearerr</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将所有文件错误标志与文件结束标志强制置0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上，是文件操作的所有函数。<br>确实很复杂，并且博主用的也确实很少 <del>（现在谁还用C语言编辑文档啊.jpg）</del><br>随用随取吧。</p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.7</title>
      <link href="/posts/33475.html"/>
      <url>/posts/33475.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态数据结构"><a href="#动态数据结构" class="headerlink" title="动态数据结构"></a>动态数据结构</h1><h2 id="1-动态存储管理"><a href="#1-动态存储管理" class="headerlink" title="1. 动态存储管理"></a>1. 动态存储管理</h2><h3 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h3><p>在此前的编程过程中，我们所声明的存储大小都是静态的，数组有大小，变量有类型。这固然已经能够满足很多需求，但相应的，有些数据大小未知的情形我们便无法很完美的解决。在此举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> student<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//这种先输入再创建的情况是不合规的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此前，我们的解决方法大多都是创建一个足够大的数组，从而能够达成目标，但这样做势必会浪费许多存储空间。</p><p>因此，引入我们的正题——动态存储分配。</p><h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>在C语言中，动态存储主要依赖于两个标准库以及四个函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//两个标准库：</span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>malloc<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token comment">//四个函数：</span>malloccallocreallocfree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来会一个个介绍</p><h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//分配一个大小为n个int的存储空间，并将其首地址赋给p，如果分配失败则返回空指针。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//如果p是空指针，则直接退出程序，返回值0。</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放程序中被分配的空间。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>malloc可以通过指针的形式来创建一个大小由用户自行输入的存储空间。</p><h4 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//务必注意calloc函数与malloc函数的写法区别。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>calloc函数可以通过指针的方式来创建一个大小由用户自行输入的存储空间 <font color=Aqua> <strong>并将其中的元素自动赋值为0</strong> </font></p><h4 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过以上的语句已经分配了一个空间</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//现在发现原先分配的空间不够，需要重新分配。</span>n<span class="token operator">=</span>n<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//将原先的n变为2倍。</span><span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//重新分配一个大小为n的存储区域，将首地址赋值给一个新的指针q；</span><span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    p<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//若分配失败，p仍然指向原来的存储区；若成功，p指向新存储区。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放原先p所指向的存储块。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="一点注意事项"><a href="#一点注意事项" class="headerlink" title="一点注意事项"></a>一点注意事项</h4><ol><li>请务必注意区分malloc, calloc, realloc的用法以及写法区别。</li><li>malloc, calloc, realloc三种函数通常情况下返回的都是通用指针，因此在给具体类型指针赋值时需要进行强制类型转换（具体原理见上一章：指针）</li></ol><h2 id="2-自定义类型"><a href="#2-自定义类型" class="headerlink" title="2. 自定义类型"></a>2. 自定义类型</h2><blockquote><p>此前提到过一种自定义类型——宏定义define，但宏定义只能做到简单的字符替换，从而在各种计算，定义中产生不可预知的后果，因此在这里给出更加通用的自定义类型。</p></blockquote><h3 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ULI<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>tppedef会用最后的一个词来代替前面的类型。<br>常用于简化程序书写。</p><p>但是typedef在程序书写时不仅仅是简单替换，这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IP</span> <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span> </span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token operator">*</span> P<span class="token punctuation">;</span><span class="token comment">//若之后想要定义两个指针</span>IP a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  <span class="token comment">//等价于int *a, b; 会发现b不是指针</span>P m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>  <span class="token comment">//这时候m, n都是指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-结构"><a href="#3-结构" class="headerlink" title="3. 结构"></a>3. 结构</h2><blockquote><p>C语言中虽然提供了很多变量类型，但是如果我们需要很多不同类型变量的结合体，则仅仅使用C语言提供的变量则显得效率低下。因此，产生了可以自定义的结构类型。</p></blockquote><h3 id="结构类型的定义"><a href="#结构类型的定义" class="headerlink" title="结构类型的定义"></a>结构类型的定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>  <span class="token comment">//这样就定义了一个名叫POINT的结构类型，之后可以直接使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在程序中常用的结构可以通过上述方式来进行定义，从而简化此后需要使用相应模型时的书写过程。</p><p>需要注意的是，结构定义时其成员可以包含其他结构，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    POINT center<span class="token punctuation">;</span>    <span class="token keyword">double</span> radius<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>CIRCLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，结构存在单位大小，但结构的单位大小并不是简简单单的将各个元素的大小加到一起，因此在计算结构大小时建议使用sizeof运算符。（这种状况的出现原因为结构体内的对齐问题，具体请自行搜索）</p><h3 id="结构类型的访问"><a href="#结构类型的访问" class="headerlink" title="结构类型的访问"></a>结构类型的访问</h3><p>在C语言中，结构的访问有其规则。</p><p>如果结构类型相同，则可以直接通过整体相等来赋值<br>如果需要对一个结构里的成员进行编辑，则使用 .<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT A<span class="token punctuation">,</span> B<span class="token punctuation">;</span>A<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>A<span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token number">3.2</span><span class="token punctuation">;</span>A<span class="token operator">=</span>B<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>相应的，结构既然是自定义的数据类型，同样也可以定义一个以自定义结构为元素的数组。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//相当于创建了一个由四个POINT组成的数组。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，与数组相似，结构数组也可以用指针表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>POINT <span class="token operator">*</span>P<span class="token punctuation">;</span>P<span class="token operator">=</span>PT<span class="token punctuation">;</span><span class="token comment">//这里P就与PT数组的首地址绑定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引出了通过指针如何访问结构内的成员，比如我要用指针访问上述数组中第二个点中的X坐标值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//这种表达过于繁琐，因此C语言提供了另一种方法</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-></span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//与上面的表达等价</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-补充</title>
      <link href="/posts/4308.html"/>
      <url>/posts/4308.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的目的在于对此前C语言的笔记进行相应的补充，同时整理一下博主遇到的一些有趣的函数。</p></blockquote><h2 id="1-知识点补充-编程疑难解决"><a href="#1-知识点补充-编程疑难解决" class="headerlink" title="1. 知识点补充 &amp; 编程疑难解决"></a>1. 知识点补充 &amp; 编程疑难解决</h2><h3 id="关于scanf"><a href="#关于scanf" class="headerlink" title="关于scanf"></a>关于scanf</h3><ol><li>在没有特殊说明的情况下，scanf遇到空格，回车等特殊字符会停止，因此在输入字符后需要回车时，不用在scanf后特地打出\n这样的转义字符。</li><li>用scanf时，字符与数字最好分开输入，不然很容易报错，具体原理貌似是%c与%d的输入规则不同。</li></ol><h3 id="关于程序运行时间成本的降低"><a href="#关于程序运行时间成本的降低" class="headerlink" title="关于程序运行时间成本的降低"></a>关于程序运行时间成本的降低</h3><p>运行程序时常常会出现运行时间过长，无法以一个理想的时间得出结果的情况。有以下几种解决办法：</p><ol><li>程序中是否出现了&lt;math.h&gt;中的pow函数，因为pow函数的运算方式为浮点运算，速度较慢，如果运算不需要用到浮点数，可以尝试自己写一个更简单的函数进行改进。</li><li>程序中是否有三层以上的循环，一般来说不会遇到这么复杂的循环，可以尝试改变算法。</li><li>程序中是否有各种递归算法，如果有，尝试改写成循环写法。</li></ol><h3 id="关于排序"><a href="#关于排序" class="headerlink" title="关于排序"></a>关于排序</h3><blockquote><p>在前面的章节中曾经讲过冒泡排序，这是C语言的一种最基础的排序算法，当我们遇到一些更加复杂 &#x2F; 数据更多的情况时，冒泡排序就显得过于简陋，效率也不够看了。</p></blockquote><h4 id="qsort函数（首选）"><a href="#qsort函数（首选）" class="headerlink" title="qsort函数（首选）"></a>qsort函数（首选）</h4><p>QSORT函数位于 &lt;stdlib.h&gt; 中，其原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span>  <span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> size<span class="token punctuation">,</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先别急着头疼，这里会一个个解释。</p><ol><li><p>void* base:<br><strong>base</strong> 是一个指针，该指针指向数组的首地址。(通常直接传入数组名即可)</p></li><li><p>nuemb:<br><strong>nuemb</strong> 是个 <strong>无符号整数类型</strong>，用size_t表示，这个值表示数组内元素个数。(通常可以直接使用 <em>sizeof(数组名)&#x2F;sizeof(数组单个元素大小)</em> 来计算得出)</p></li><li><p>size:<br><strong>size</strong> 表示数组内每个元素的大小。</p></li><li><p>*compar:<br>这一部分是qsort的核心部分，指向的是一个比较两个元素的值的函数，直接决定了排序的顺序。这玩意是要自己写的。这里详细论述：</p><p>首先说明这一函数如何决定排序顺序：<br>当这一函数返回值小于0，则将 p1 指向的元素放在 p2 之前；<br>大于0，将 p1 指向的元素放在 p2 之后；<br>等于0，顺序 <strong>不确定</strong> 。</p><p>再说明这个函数的一些注意事项： </p><ol><li>注意传入数据格式：<br>传入的是两个通用指针，因此在函数内使用时请务必转换成相应类型指针再进行计算。</li><li>务必注意这个函数返回值为0时，排序顺序是随机的！</li></ol></li></ol><h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><h4 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h4><p>字符串的输入有几种方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><del>一般而言，博主更常用gets_s。</del><br>tmd，经过紧接着几个月的拷打之后，还是fgets比较好使…</p><p>但需要注意，关于gets的三种输入函数都存在回车问题，即当这几个函数上面有scanf的时候，会出现函数读入回车导致跳过原本预期中字符串输入的过程，对此有两种解决方式：</p><ol><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于清空缓冲区内的数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于读入此前的回车进而防止其影响字符串输入。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>博主用第二种方法更多一些。</p><h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式不会补充回车</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式会自动补充回车，效果同printf("%s\n", str);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="读入不定个数个字符串"><a href="#读入不定个数个字符串" class="headerlink" title="读入不定个数个字符串"></a>读入不定个数个字符串</h4><p>常用gets_s的返回值进行操作。<br>这里进行说明：</p><p>gets_s是有返回值的，具体返回值为输入字符串的地址（相当于返回一个指针）。如果输入不成功则返回一个空指针。</p><p>因此常用这个性质：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//需要结束输入时则使用CTRL+Z进行结尾。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串的各种转化"><a href="#字符串的各种转化" class="headerlink" title="字符串的各种转化"></a>字符串的各种转化</h4><blockquote><p>假设一串字符串中存着一个5位的整数，我们想用这个值进行计算，这时候如果再用循环进行转化，就太慢，也不优雅（笑</p></blockquote><p>好在，C语言其实是有相应的命令的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为int</span><span class="token function">atol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为long</span><span class="token function">atof</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这一系列函数通通位于 &lt;stdlib.h&gt; 中，传入的参数都是字符串的首地址（可以直接写字符串名）<br>这三个函数可以极大程度上提高我们的效率。</p><h3 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h3><h4 id="指针的地址？-指针所指向的地址？"><a href="#指针的地址？-指针所指向的地址？" class="headerlink" title="指针的地址？ 指针所指向的地址？"></a>指针的地址？ 指针所指向的地址？</h4><p>这是两码事。</p><p>指针的地址可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><p>而指针所指向的地址则可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><h2 id="2-一些有趣的函数"><a href="#2-一些有趣的函数" class="headerlink" title="2. 一些有趣的函数"></a>2. 一些有趣的函数</h2><blockquote><p>这个条目仅仅用于记录博主遇到过的觉得有一定利用意义的函数。</p></blockquote><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>利用&lt;stdlib.h&gt;中的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数的功能为得到0~ RAND_MAX 之间的整数，不同系统的RAND_MAX不一样，反正够用</p><p>如果要得到一个范围内的数，比如3-10之间的数，可以用如下方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> random<span class="token punctuation">;</span>  random<span class="token operator">=</span><span class="token number">3</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">//前面的3为最小值，rand后面取余的数为区间宽度。</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> random<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述算法还有个问题，该函数生成的是伪随机数，如果种子不刷新，则生成的随机数是有规律的。<br>因此建议每次使用该函数之前，都多引用一个库，并在主函数中加一句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤的目的是在每次运行程序之前都刷新种子。（通过time(0)这个随时间变化的变量，而这个变量存储在 &lt;time.h&gt; 中。）</p><p>需要注意的是，这个语句请务必加在主函数中，而非是一个调用多次的子函数或迭代很快的循环中，由于time(0)是一个只统计到秒的变量，因此如果过快地多次重置，则会发现你生成的随机数都是同一个数。</p><h3 id="求素数"><a href="#求素数" class="headerlink" title="求素数"></a>求素数</h3><p>用空间换时间</p><p>具体算法：</p><ol><li>令n&#x3D;2，如果n是素数，则划掉序列中所有n的倍数。</li><li>令n等于下一个没有划掉的元素，回到步骤2。</li></ol><hr><p>本文会随着博主编程经历的增长持续更新。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.6</title>
      <link href="/posts/16898.html"/>
      <url>/posts/16898.html</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="1-指针概述"><a href="#1-指针概述" class="headerlink" title="1. 指针概述"></a>1. 指针概述</h2><p><strong>指针</strong> 在C语言中有着十分重要的作用，其特点体现在其极高的灵活性上，并且能够十分方便的在不同函数间传递。</p><p>要理解指针到底是个啥，需要从一个基础概念 <strong>地址</strong> 说起。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>此前的章节中，曾提到过编程时的各种变量以及算法是储存在 <strong>内存</strong> 中的，而内存在储存数据时对不同的数据都有一个编号，这个编号就被称为 <strong>地址</strong> 。</p><p>在编程过程中，系统会根据程序中的变量名对不同的数据进行存储，相应的，不同的变量占用的内存大小也不尽相同。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>    <span class="token comment">//4个字节</span><span class="token keyword">char</span>   <span class="token comment">//1个字节</span><span class="token keyword">float</span>  <span class="token comment">//4个字节</span><span class="token keyword">double</span> <span class="token comment">//8个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>有了地址这个概念，相应的，程序需要调用相应变量时，就会通过地址找到内存中对应的部分进行调用，这个过程被称为 <strong>寻址</strong> 。</p><p>寻址有两种方式：  </p><ol><li><p>直接寻址</p><p><strong>直接寻址</strong> 指的是直接按变量的地址存取变量的值<br>平时用的如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这些都属于直接寻址。</p></li><li><p>间接寻址</p><p>与直接寻址不同， <strong>间接寻址</strong> 是以地址跳转的方式来存取变量的值。</p><p>这就涉及到了本章的核心—— <strong>指针</strong> ，因为指针所存储的就是地址。</p></li></ol><h2 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2. 指针的使用"></a>2. 指针的使用</h2><h3 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3><p>同样的，指针变量也有不同的类型，以下给出几例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要提出的是，指针变量可以指向任何类型，不仅仅局限于常见的变量类型，还包括函数，结构体等等。</p><h3 id="指针的赋值"><a href="#指针的赋值" class="headerlink" title="指针的赋值"></a>指针的赋值</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//上面是一种赋值方式</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//这是另一种赋值方式</span><span class="token comment">//请格外注意，这种赋值方式是不合规的！</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针变量常用取地址符号 <strong>&amp;</strong> 进行一系列的赋值操作。<br>此外，只能赋给指针与其指针类型对应的变量的地址。（如：整形指针只能赋予其整形变量的地址）</p><h3 id="指针相关的运算符"><a href="#指针相关的运算符" class="headerlink" title="指针相关的运算符"></a>指针相关的运算符</h3><p>与指针相关的运算符有两个： <strong>&amp;</strong> 以及 * 。</p><p>&amp;的意义为取地址，可以将其后方的变量的地址提取出来。<br>*的意义为解引用，只能操作有指针意义的值。</p><p>这里给出*的使用例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//等价于a++;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//等价于printf("%d", a);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里还需要提一下指针的常用情景，此前曾经提过，由于形参的限制，在函数中直接交换另一个函数中的变量是不可取的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span>a<span class="token punctuation">;</span>    a<span class="token operator">=</span>b<span class="token punctuation">;</span>    b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“3 5”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但在这里，指针可以完成这个操作，因为指针直接指向相应变量的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span><span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a<span class="token operator">=</span><span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“5 3”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是为什么说指针很灵活的原因之一。</p><h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>C语言中提供了一个特殊的指针值，被称为空指针，表示该指针变量闲置。常见写法为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//也可以写成int *p=0; 但这种写法不常用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="通用指针"><a href="#通用指针" class="headerlink" title="通用指针"></a>通用指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上述语句可以定义一个通用指针，该指针可以被任何类型的变量地址赋值。<br>但需要注意的是，当使用该指针为其他非通用指针赋值时，需要做类型转换。下面给出一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，可以接受任何变量的地址。</span>pt<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，但pt为整形指针，因此赋值时需要进行强制类型转换。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在日常使用中，通用指针的作用并非进行各类计算，而是常用于动态内存分配函数malloc, calloc中，这点在本文靠后的位置中会提及。</p><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p>野指针：也叫悬空指针，即指针的地址是无效地址，或者未分配存储空间的地址。 <del>（指针指到别的地方去了）</del></p><h2 id="3-指针与数组"><a href="#3-指针与数组" class="headerlink" title="3. 指针与数组"></a>3. 指针与数组</h2><blockquote><p>在使用多次后，会逐渐发现数组和指针其实十分类似 <del>（就一个玩意）</del></p></blockquote><h3 id="数组的存储方式"><a href="#数组的存储方式" class="headerlink" title="数组的存储方式"></a>数组的存储方式</h3><p>在进入正题之前，咱们先来回顾一下数组如何在内存中进行存储。<br>在上一章，提到过数组名其实就是个地址，这里给出更具体的阐释：</p><p>数组名是一个 <strong>基类型为数组元素基类型</strong> 的地址常量。</p><p>解释一下，定义一个数组，其实就是在内存中开辟了一片区域，其每个单元大小都是一个数组元素的大小，然后给数组名关联上那片区域的起始位置的地址。</p><p>说到这里，是不是想到了什么？<br>指针也是个地址，因此用指针去访问数组中的元素是完全可行的。</p><h3 id="访问数组的指针"><a href="#访问数组的指针" class="headerlink" title="访问数组的指针"></a>访问数组的指针</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p， i<span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>  <span class="token comment">//这里也可以写成p=&amp;a[0]; 一个道理。</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//上述代码的输出结果为"1 1 1 1 1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述例子，可以发现我们通过将数组名与指针关联，进而实现了通过指针对数组中的元素进行访问。</p><p>需要注意的是：<br>当我们将数组的首地址赋值给指针时，指针就同样具有了 <strong>单位</strong> 这一概念，即其关联的数组的一个元素的大小。<br>因此，这时下列表达式便都存在意义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">;</span>p<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，现在数组元素的访问便有了两种方法：</p><ol><li>下标：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>指针：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>先回顾一下二维数组的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以理解为先创建了一个长度为5的数组，这个数组里每个单位又有五个整形元素。</p><p>因此，如果用指针操作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token comment">//也可以通过这种方式进行赋值</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出6，相当于tdarray[1][2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于*(*(p+i)+j)做出一些解释：</p><ol><li>p+i：相当于第i行的地址</li><li>*(p+i)：相当于第i行第1个元素的地址</li><li>*(p+i)+j：相当于第i行第j个元素的地址</li><li>*( *(p+i)+j)：相当于第i行第j个元素</li></ol><h3 id="一些额外说明"><a href="#一些额外说明" class="headerlink" title="一些额外说明"></a>一些额外说明</h3><p>需要明确的是，上面的阐述过程中一直将数组名与数组首地址画了等号，这其实并不十分准确，但因为这种阐述方法易于理解，因此采纳了这种方式。</p><p>实际上，大多数情况下，数组名都可以与数组首地址划等号，除了以下两种情况：</p><ol><li>使用sizeof运算符计算数组大小时<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结果为20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用&amp;取地址符号时</li></ol><h2 id="4-指针与字符串"><a href="#4-指针与字符串" class="headerlink" title="4. 指针与字符串"></a>4. 指针与字符串</h2><p>同样的道理，此前的字符数组定义为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显然，str作为字符串名也是一个地址，因此，我们也可以用指针来达成同样的效果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>str<span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是，指针所代表的字符串的起始位置是其地址，终止位置是第一个“\0”。</p><p>下面拿一道例题进行说明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ABCDE"</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> arr<span class="token punctuation">;</span> ptr <span class="token operator">&lt;</span> arr<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span> ptr<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//该程序运行结果为：</span><span class="token comment">//  ABCDE</span><span class="token comment">//  BCDE</span><span class="token comment">//  CDE</span><span class="token comment">//  DE</span><span class="token comment">//  E</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-指针数组"><a href="#5-指针数组" class="headerlink" title="5. 指针数组"></a>5. 指针数组</h2><blockquote><p>请务必区分指针数组与指针形式的二维数组</p></blockquote><p>如果我们想定义一个由指针元素构成的数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句的意义为定义了一个有四个元素的指针数组。</p><p><font color=red>注意：二维数组的定义方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></font><p>产生二者区别的根本原因在于[]的运算优先级高于*，因此前者代表着定义了一个由四个指针元素组成的数组，而后者则仅仅是一个指针，这个指针内对应的地址含有四个元素。</p><p>由于博主对于指针数组的应用实在过少，这里先暂且搁置，待后续补充。</p><h2 id="6-命令行参数"><a href="#6-命令行参数" class="headerlink" title="6. 命令行参数"></a>6. 命令行参数</h2><p>在每个程序的主函数中，都会有这样一个语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>事实上，main后面的括号里是可以填东西的。其完整形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里做出一点说明：</p><ol><li><p>argc是一个整形变量，由系统自动赋值，其值为后续*argv[]字符指针数组的个数。</p></li><li><p>*argv[]是一个字符指针数组，可以接受多个字符串。</p></li><li><p>至于这些字符串如何输入，是通过windows用户终端（cmd）里面执行相应程序的exe文件时需要输入的内容。</p><p>这里给出一例：<br>在终端中找到对应的exe文件（cd 对应文件地址），之后输入：</p><pre class="line-numbers language-none"><code class="language-none">你的文件名.exe Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的话，argv[0]便被赋值为”你的文件名.exe”，argv[1]被赋值为”Hello”, argc[2]被赋值为”World”。<br>argc则被赋值为3。</p><p>这些参数可以在C语言程序中使用。</p></li></ol><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.5</title>
      <link href="/posts/17218.html"/>
      <url>/posts/17218.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1. 数组概述"></a>1. 数组概述</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><p><strong>数组</strong> 是一种能够包含多个 <strong>同类型数据</strong> 的复合结构。</p><p>可以理解为一个连续的存储空间，被切分为了多个存储单元</p><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>数组的定义需要三个要素：  </p><ol><li>数组元素类型</li><li>数组名称</li><li>数组的大小</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">double</span> m<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：</p><ol><li>数组方括号内的只能是 <strong>字面量</strong> 或 <strong>枚举常量</strong>，不能是变量（已赋值的也不行） ；<br>如：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token keyword">int</span> m<span class="token punctuation">[</span>N<span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">enum</span><span class="token punctuation">&#123;</span>X<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//以上是合法的数组定义</span><span class="token comment">//以下是不合法的数组定义</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//注：该种定义方法在C99标准中被允许</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在常规编程中，数组的大小不宜太大（博主最高使用过长度为10000的数组），过大的数组可能会引起报错。<br>如真的需要使用一个很大的存储空间，请参考后一篇文章： <strong>指针</strong></li></ol><h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><h4 id="基本操作：元素访问"><a href="#基本操作：元素访问" class="headerlink" title="基本操作：元素访问"></a>基本操作：元素访问</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>值得一提的是，变量不能出现在数组定义的方括号中，但可以出现在使用数组时的方括号中。如：</p><h4 id="常用操作：批量赋值"><a href="#常用操作：批量赋值" class="headerlink" title="常用操作：批量赋值"></a>常用操作：批量赋值</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种用法是可行的。</p><p>注：<br>利用 <strong>for</strong> 循环对数组内的元素进行统一赋值是十分常见的用法，但这一过程中常常会出现 <strong>越界访问</strong> 问题。</p><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>三种方法：  </p><ol><li>直接初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>注：直接初始化不能使用除了常量之外的任何表达式。</li><li>部分初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会将未提到的元素自动赋值0。</li><li>直接写数组<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会在编译过程中自动给出数组的大小。</li></ol><h4 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h4><p>问题在于，C语言的参数传递是值传递，因此无法简单的在函数中使用数组。</p><p>解决方案：将数组在内存中存储的地址传递给函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的基本使用至此以叙述完毕，接下来会阐述一些常用的数组及其用法。</p><h2 id="2-一维数值型数组的应用"><a href="#2-一维数值型数组的应用" class="headerlink" title="2. 一维数值型数组的应用"></a>2. 一维数值型数组的应用</h2><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p><strong>排序</strong> 是十分常见的可以用数组解决的问题之一，在本篇博文中，仅仅展示出一个基本的方法—— <strong>冒泡排序</strong> 。</p><p><strong>冒泡排序</strong> 的基本思路是运用嵌套for循环对数组进行操作，每一轮循环都将最大的数挪到数组后方相应位置。</p><p>这里给出参考代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]是需要排序的数组，n是数组的大小</span>   <span class="token keyword">int</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span>n<span class="token operator">-</span>i1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">>=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> m<span class="token punctuation">;</span>  <span class="token comment">//m是个临时变量</span>            m<span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>m<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token comment">//如果前一个元素大于（等于）后一个元素，则将两个元素交换</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">//排序完成，如需输出：</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要标注的是，关于排序还有不少改进方法，如 <strong>选择排序</strong> ， <strong>插入排序</strong> 等，在后面的进阶训练篇章中会有提及。</p><h3 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h3><p><strong>查找</strong> 即在数组中寻找某个元素</p><h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><p>线性查找的思路是最简单的，即从头到尾全过一遍，找到相应元素便返回。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]为要进行查找的数组，n为数组大小，goal为要查找的元素</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>         count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> count<span class="token punctuation">;</span>   <span class="token comment">//数组中每个等于goal的元素下标均输出，并返回出现次数（count）</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，这种查找方法在数组已经排好序的情况下是效率较低的。这样就衍生出了另一种查找方法—— <strong>折半查找</strong> 。</p><p>同样的，在后续进阶文章中会提及。</p><h3 id="插入，删除问题"><a href="#插入，删除问题" class="headerlink" title="插入，删除问题"></a>插入，删除问题</h3><p>插入，删除的操作方法相比于查找就多了一步，因此此处不再详细阐述，给出思路。</p><p>插入：<br>找到插入位置-&gt;将后面的元素全部往后挪一位-&gt;将要插入的元素放进去</p><p>删除：<br>找到要删除的元素-&gt;将后面的元素往前挪一位</p><h2 id="3-字符数组-字符串"><a href="#3-字符数组-字符串" class="headerlink" title="3. 字符数组 &#x2F; 字符串"></a>3. 字符数组 &#x2F; 字符串</h2><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>顾名思义， <strong>字符串常量</strong> 即由一连串字符组成的常量。<br>在C语言中规定： <strong>\0</strong> 是字符串结尾的标志。<br>即：如果定义了一个内容为”C programming”的字符串，那它在存储空间内的存储方式为：”C programming\0”</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p><strong>字符数组</strong> 可以用来存储字符串。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>与其他数组定义方式相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> array<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：定义字符数组时需要考虑”\0”占据的一个大小。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化字符数组有多种方法。</p><ol><li><p>逐个字符赋值：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> task<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'p'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//其中未声明初始值的元素会自动赋值为 '\0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>直接定义字符串常量：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"That's a string"</span><span class="token punctuation">;</span><span class="token comment">//未定义初始大小的字符串常量会自动设定其大小为链长+1（用于存储 \0）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这种方法只能用于初始化，不能用于赋值。</p></li></ol><h4 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入&#x2F;输出"></a>输入&#x2F;输出</h4><p>C语言中的scanf（visual studio中为scanf_s）以及printf函数为字符串设定了单独的输入输出格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但很遗憾，由于scanf的限制，这样的输入不适用于列中带有空格的字符串。因为scanf遇到空格会中止。</p><p>因此，以下部分引入新的标准库&lt;string.h&gt;</p><h3 id="概述"><a href="#概述" class="headerlink" title="&lt;string.h&gt;概述"></a>&lt;string.h&gt;概述</h3><p>在C语言中，涉及到字符串，这个标准库几乎是逃不过去的，因为其中涉及到了许多很好用的操作字符串的函数。</p><h4 id="字符串输入函数-gets"><a href="#字符串输入函数-gets" class="headerlink" title="字符串输入函数 gets"></a>字符串输入函数 gets</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数遇到空格不会终止，当遇到回车时会中止输入，并自动在最后多赋值一个 \0</p><h4 id="字符串输出函数-puts"><a href="#字符串输出函数-puts" class="headerlink" title="字符串输出函数 puts"></a>字符串输出函数 puts</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会输出括号中的字符串，并在最后自动加上回车。</p><h4 id="字符串长度函数-strlen"><a href="#字符串长度函数-strlen" class="headerlink" title="字符串长度函数 strlen"></a>字符串长度函数 strlen</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"I'm editing a blog"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会自动计算括号内字符串的实际长度。（不含 \0）</p><h4 id="字符串复制函数-strcpy"><a href="#字符串复制函数-strcpy" class="headerlink" title="字符串复制函数 strcpy"></a>字符串复制函数 strcpy</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> <span class="token string">"blog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容复制到前面的字符串中。<br>需要注意的是前面的字符串需要够大来容纳后面的字符串。</p><h4 id="字符串比较函数-strcmp"><a href="#字符串比较函数-strcmp" class="headerlink" title="字符串比较函数 strcmp"></a>字符串比较函数 strcmp</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Shanghai"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出一个非0的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数会比较前后两字符串的值，相同则输出0，不相同则输出非0；</p><h4 id="字符串连接函数-strcat"><a href="#字符串连接函数-strcat" class="headerlink" title="字符串连接函数 strcat"></a>字符串连接函数 strcat</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Programming"</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"c language"</span><span class="token punctuation">;</span><span class="token function">strcat</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将str2的内容接到str后面</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容接到前面的字符串后面。</p><h3 id="一点补充"><a href="#一点补充" class="headerlink" title="一点补充"></a>一点补充</h3><p>字符串的操作方法十分繁杂，包括最简单的gets，puts函数的各种变体也有很多，在这里不过多赘述，在后面的文章中还会相应提及。</p><h2 id="4-二维数组"><a href="#4-二维数组" class="headerlink" title="4. 二维数组"></a>4. 二维数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述方式表示定义一个5*5的二维数组。</p><h3 id="赋值-使用"><a href="#赋值-使用" class="headerlink" title="赋值&#x2F;使用"></a>赋值&#x2F;使用</h3><p>二维数组的赋值常用两个for循环嵌套进行</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若二维数组作为函数参数使用，则需要使用如下格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//二维数组前面的一维长度不需要给出，但后面的二维长度必须给出</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上，关于数组的一些基本概念已经梳理完毕了。</p><p>下一章的指针，相对而言更加复杂，理解难度也更高，但归根结底与数组的原理极其相似，熟练应用后指针反而更加灵活。 <del>（虽然我现在还不能熟练应用）</del></p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.4</title>
      <link href="/posts/33667.html"/>
      <url>/posts/33667.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-函数概述"><a href="#1-函数概述" class="headerlink" title="1. 函数概述"></a>1. 函数概述</h2><p><strong>函数</strong> 是C语言中的基本单位，具体表现为一段代码，可重复使用从而实现某种功能。</p><p>在C语言的源文件中，仅能存在一个 <strong>main函数</strong> （程序入口）以及多个子函数（名称可自定）</p><p>注：C语言不允许函数的嵌套定义，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token function">function2</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此类函数定义方式是不被允许的。</p><h2 id="2-函数的定义，调用，声明"><a href="#2-函数的定义，调用，声明" class="headerlink" title="2. 函数的定义，调用，声明"></a>2. 函数的定义，调用，声明</h2><p>这里直接列举定义，调用以及声明的方法：</p><ol><li>定义：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">double</span> num<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>声明：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>调用：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> fact<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>几个要注意的点：</p><ol><li><p>函数的返回值类型必须与函数类型相同（第一个词写的啥返回啥）</p></li><li><p><strong>void</strong> 关键字可以指函数类型，此时函数无返回结果，也可用于描述参数，此时函数无参数。</p></li><li><p>关于实参与形参：<br>定义&#x2F;声明函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的a, b称为形参，函数执行完毕后即清除相应内存。</p><p>与此不同，调用函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> result<span class="token punctuation">;</span><span class="token keyword">double</span> n<span class="token operator">=</span><span class="token number">4.2</span><span class="token punctuation">;</span>result<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的m, n被称为实参。</p><p>在调用函数时，会将实参中的值自左向右传递给形参<br>（上例中即会先将m的值传给a，将n的值传给b）<br>此后再进行函数的下一步语句。</p><p>注意：实参传递给形参相应值是 <Font color=CornflowerBlue><em><strong>单向传递</strong></em> </Font></p></li><li><p>关于函数的结束：两种方法  </p><ol><li>执行完最后一条语句</li><li>遇到了return，返回了相应值</li></ol></li><li><p>一般而言，可以在主函数前定义相应函数并在主函数中进行调用，但如果想在主函数后定义相应函数，则需要在主函数前进行函数声明。</p></li><li><p>c语言中的函数允许多级调用（也叫嵌套调用）<br><strong>明确一点，只是允许多级调用，但不允许嵌套定义（在前面有提及）</strong></p></li></ol><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h2><p><strong>递归</strong> 指的是一个函数中存在调用自己本身这个函数的行为，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span>n<span class="token operator">+</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在fact函数中，若n!&#x3D;1，则会重复调用fact自身。</p><p><strong>一个特点：</strong><br> 递归可以转化为循环，但递归写法常常更加简洁，更加易读，相应的，递归的计算复杂度（不确定这个词是否准确）会更高，时间成本也会更高。<br>   举出一个比较合适的例子：斐波那契数列<br>   首先写出递归写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> result<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   然后再给出循环写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token keyword">long</span> f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> result<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span>f1<span class="token operator">+</span>f2<span class="token punctuation">;</span>      f1<span class="token operator">=</span>f2<span class="token punctuation">;</span>      f2<span class="token operator">=</span>result<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   明显看出，编辑时，循环写法涉及到的细节更多，包括for循环的数量问题，f1, f2, result等变量的重新赋值等，而递归写法编程难度要简单许多。</p><p>   但同时，也需要承认，在递归写法中，对许多量都需要进行重复运算，比如每算一次fibo(5)就要算一次fibo(4)和fibo(3)，但这时算fibo(4)则再次涉及到了fibo(3)的运算，这种运算量如果多次叠加，时间成本是很恐怖的。</p><p>综上，请在递归降低编程难度这一特点能够弥补上它自己本身的效率开销时，再进行递归算法的使用。</p><p>进一步的问题解决敬请期待C语言进阶训练篇章。 <del>（我直接挖坑）</del></p><h2 id="4-预编译"><a href="#4-预编译" class="headerlink" title="4. 预编译"></a>4. 预编译</h2><p>在本系列笔记的第二节中曾提及：预编译这一说法，这里给出详细说明。</p><p>预编译命令共三类：  </p><ol><li><p>文件引入</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一类编译命令还有一种写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"...（你自己的文件名）"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一种写法，是在系统头文件中寻找响应文件并引入，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>math<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二种写法，是现在编程文件所在目录下进行文件查找，若找不到，再到系统指定目录下寻找响应文件</p><p>无论如何，文件引入的根本目的是实现多文件编程，使得在这个编程文件中可以使用其他文件中所定义的函数。<br><Font color=cornflowerblue> <strong>其具体原理是用指定文件的内容代替相应的命令行</strong> </Font></p><p>这里存在一种简单易行的方法进行多文件编程，即将你的函数一并写到一个文件中，命名为&lt;file1.h&gt;，此后在需要使用函数的地方预编译： <strong>include &lt;file1.h&gt;</strong> 即可。</p><p>但当头文件有很多个时，会遇到另一个问题，参考如下例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件file1.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file2.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file3.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file4.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file5.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.3></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.4></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当出现必须要同时引用 file3 与 file4 时，会出现对 file1 与 file2 的重复引用（即引用了两次，会报错）<br>因此这里给出方法，在每个文件前都加上一行代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此代码代表本文件仅引用一次。</p></li><li><p>宏定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">name</span> <span class="token expression">maintext</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>宏定义的作用 <strong>maintext</strong> 来替换正文中出现的 <strong>name</strong><br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UD</span> <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">double</span></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>UD x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的UD x, y; 作用等同于unsigned double x, y;  </p><p>几个注意事项：</p><ol><li>宏定义后面没有引号，与文件引入相同。</li><li>宏定义是简单替换，会将maintext原封不动的替换到name的位置，容易造成计算方面的错误，因此不推荐频繁使用。</li></ol></li><li><p>条件编译</p><p>用于仅对c程序中的一部分进行编译，另一部分不编译。（通过if，else实现）<br>具体格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">expression1</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">expression2</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> </span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>局部&#x2F;全局变量</p><p><strong>局部变量</strong> 指的是在函数内定义的变量，仅仅能在函数内部生效。（包括主函数）<br>注意：在复合语句中定义的变量生效范围仅为该复合语句内部。</p><p><strong>全局变量</strong> 指的是在函数外定义的变量，作用范围从定义处到函数源文件结束。</p></li></ol><p>这里单开一块单独说明变量的问题。</p><h2 id="5-动态-静态储存变量"><a href="#5-动态-静态储存变量" class="headerlink" title="5. 动态&#x2F;静态储存变量"></a>5. 动态&#x2F;静态储存变量</h2><p>程序在内存的分布区域是有规划的，分为：</p><ol><li>程序区：存放用户代码</li><li>静态存储区：存放全局数据与静态数据（在程序执行完毕后再释放相应内存）</li><li>动态存储区：存放动态数据（在相应函数执行完毕后便释放对应内存区域）</li><li>寄存器（ <strong>CPU内</strong> ）：将某些用的很多的动态变量存入CPU相应的存储区域中，加快程序执行速度</li></ol><p>由此，可将变量按照存储方式分类：</p><ol><li><p>自动变量<br><strong>自动变量</strong> 存储在动态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">auto</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但由于auto关键字往往可省略，因此任何函数中的未加说明的变量定义均为自动变量。</p></li><li><p>静态变量<br><strong>静态变量</strong> 存储在静态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量在函数执行完毕后将不会被销毁，并会在后续对其进行操作时保留对其进行的改变。</p></li><li><p>寄存器变量<br><strong>寄存器变量</strong> 存储在寄存器中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">register</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几个要注意的要点：  </p><ol><li>只有动态变量可以作为寄存器变量</li><li>寄存器变量不能无限定义，因为寄存器数目有限</li></ol></li><li><p>全局变量<br><strong>全局变量</strong> 存储在静态存储区中，定义方式为在函数外部进行相应定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>extern可以通过在多文件编程中进行使用，但是在另一个文件中使用本文件的全局变量时需要加上extern前缀说明。<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件A的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//这是文件B的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>     <span class="token comment">//x存在，但是定义在别的地方</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>需要注意的是，全局变量、静态变量的使用会降低程序可读性，增加编程复杂度，故请适量使用。</p><p>此外，添加一点补充：  </p><ol><li><p>在嵌套作用域中出现同名变量名定义时，内层作用域的同名变量在这其中会遮盖外层变量。<br>这里浅举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">5</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很明显，在内部作用域中b被重新定义的b&#x3D;2覆盖，当执行完毕后b的值重新变回5。</p></li><li><p>需要注意，多个源文件中不能有重名的全局变量，否则在某一个文件中对全局变量进行引用时会出现链接问题</p></li><li><p>C语言中的常量定义：</p><ol><li>enum<br><strong>enum</strong> 代表枚举常量，仅能定义整数常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>N<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> M<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这样定义出的常量在函数编译过程中值不会改变</li><li>const<br><strong>const</strong> 代表常量，可以定义各种常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> m<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">long</span> r<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>同样，这样定义出的常量在函数编译过程中值不会改变</li></ol></li></ol><p>至此，函数以及各类预编译事项便具体说明完毕。</p><p>接下来就是一些比较复杂的数据处理了，如数组，指针等。</p><p>这篇博文先到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.3</title>
      <link href="/posts/16834.html"/>
      <url>/posts/16834.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><h2 id="1-三种基本结构"><a href="#1-三种基本结构" class="headerlink" title="1. 三种基本结构"></a>1. 三种基本结构</h2><ol><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ol><h2 id="2-关系，逻辑，条件的相关语句"><a href="#2-关系，逻辑，条件的相关语句" class="headerlink" title="2. 关系，逻辑，条件的相关语句"></a>2. 关系，逻辑，条件的相关语句</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>六个： <strong>&lt; &lt;&#x3D; &#x3D;&#x3D; &gt; &gt;&#x3D;</strong><br><strong>注：在C语言中，&#x3D;&#x3D;表示相等，&#x3D;表示赋值，勿混淆</strong></p><h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>在C语言中，用 <strong>1</strong> 表示表达式为真，用 <strong>0</strong> 表示表达式为假<br>如：  </p><ol><li>表达式： <strong>8&gt;4</strong> 为真，值为1</li><li>表达式： <strong>0&#x3D;&#x3D;1</strong> 为假，值为0</li></ol><p>这里引入一种语句： <strong>条件运算符</strong><br>写为：？：<br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述语句表示：<br>若a&gt;b，则x&#x3D;a，反之，则x&#x3D;b</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>三个： <strong>! &amp;&amp; ||</strong><br>分别表示：非，与，或</p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>对于 ! 表达式，会对该表达式求值，以该值的否定为结果<br>对于 &amp;&amp; 表达式，会对两侧表达式分别求值，只有两侧表达式值均为1时，整个表达式值才为1，否则均为0<br>对于 || 表达式，会对两侧表达式分别求值，只有两侧表达式值均为0时，整个表达式值才为0，否则均为1</p><h3 id="短路特性（重点关注）"><a href="#短路特性（重点关注）" class="headerlink" title="短路特性（重点关注）"></a>短路特性（重点关注）</h3><p>逻辑表达式求值时，只有系统判定必须计算下一个运算符才能得出表达式的值时，才会进行计算 <del>（多绕的慌啊）</del></p><p>举个例子：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">&amp;&amp;</span> b <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当上述例子输入时，第一个数值（即a的值）输入0时，则不会计算b &amp;&amp; c这一部分的值，而会直接将x的值赋值为0</p><h2 id="3-顺序结构程序设计"><a href="#3-顺序结构程序设计" class="headerlink" title="3. 顺序结构程序设计"></a>3. 顺序结构程序设计</h2><p><em><strong>自上而下，逐行运行</strong></em></p><p>主要由以下部分组成：</p><ol><li>赋值语句</li><li>复合语句</li><li>函数调用语句</li></ol><p><em>赋值，函数调用在前面的章节已经有过叙述，这里仅对复合语句做简要说明</em></p><p>复合语句指一组语句，可以由 <strong>{}</strong> 框在中间</p><h2 id="4-选择结构程序设计"><a href="#4-选择结构程序设计" class="headerlink" title="4. 选择结构程序设计"></a>4. 选择结构程序设计</h2><p>选择结构需要利用此前的关系，逻辑表达式来阐述条件</p><p>两种常用语句： <strong>if ; switch</strong></p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>有三种形式：  </p><ol><li>if：条件成立后执行</li><li>if-else：条件成立则执行if后的语句，反之则执行else后的语句</li><li>else-if：用于增加if-else中的条件个数</li></ol><p>最完备的一种情况：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">(</span>条件n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><em>用于实现多分支选择结构</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> E1<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> E2<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">default</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，通过对variable（即变量）的值进行判断从而决定要执行的语句<br>当variable&#x3D;&#x3D;E1时，执行case E1中的语句<br>后续同理<br>如果variable的值不等于其中的任意一个case，则执行default中的语句</p><p><strong>注</strong>：  </p><ol><li>执行语句时，只有遇到 <strong>break</strong> 或 <strong>}</strong> 才会终止，故这里推荐在每一个case后均加上break</li><li>default并不是必须的，如果不加default，则variable不符合要求时不会执行任何语句</li><li>variable不仅仅可以是数值，也可以是字符形式</li></ol><h2 id="5-循环程序结构设计"><a href="#5-循环程序结构设计" class="headerlink" title="5. 循环程序结构设计"></a>5. 循环程序结构设计</h2><p>与选择结构类似地，同样需要利用关系、逻辑表达式进行条件的阐述</p><p>常用语句： <strong>while ; for ; do-while</strong></p><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即：当condition为真（即condition非零）时，执行while内语句，执行完毕后重新判断condition，直至condition为假</p><p><strong>注</strong>：<br>当执行语句时遇到诸如 <strong>break ; return ; goto</strong> 之类的语句时，会跳出while循环</p><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>expr1 <span class="token punctuation">;</span> expr2 <span class="token punctuation">;</span> expr3<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要做出一点说明：  </p><ol><li><strong>expr1</strong> 表示初始条件</li><li><strong>expr2</strong> 表示需要满足的条件</li><li><strong>expr3</strong> 表示每次执行完一次语句后要做出的改变</li></ol><p>给出一例方便理解：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句表示：i 的初始值为0；每次执行完语句后 i 自增1，直到 i 大于五十时结束循环</p><p><strong>注</strong>：  </p><ol><li>for结构中每个表达式都可以省略，但分号不可省略</li><li>for结构和while结构可以互相转化，下属while语句与上述for语句等价<pre class="line-numbers language-c" data-language="c"><code class="language-c">expr1<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>expr2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> expr3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>特殊语句同样可以跳出for循环，如 <strong>break ; goto ; return</strong> 等</li></ol><h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与 while 的区别在于这种语句会先将语句执行一遍再判断</p><h3 id="循环中的常见问题"><a href="#循环中的常见问题" class="headerlink" title="循环中的常见问题"></a>循环中的常见问题</h3><ol><li>循环可以相互嵌套，但一般不超过三层（会极大降低运行效率）</li><li>一般不用浮点数对循环进行控制，原因是浮点数存在误差，容易增减循环次数</li></ol><p>以上</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈《阿凡达2：水之道》</title>
      <link href="/posts/54708.html"/>
      <url>/posts/54708.html</url>
      
        <content type="html"><![CDATA[<p><em>阅前提醒：本片博文是在博主仅仅对阿凡达1的剧情略知一二的情形下的观影体验，文章中的观点难免有失偏颇，仅代表个人看法</em></p><blockquote><p><strong>阿凡达2：一部“徒有其表”的科幻作品</strong></p></blockquote><h2 id="剧情梗概"><a href="#剧情梗概" class="headerlink" title="剧情梗概"></a>剧情梗概</h2><blockquote><p>博主的梗概极其简略，肯定无法将电影中的细节进行呈现，这里还请读者有兴趣的话自行观看</p></blockquote><p>阿凡达2采用了一个非常“合家欢”的剧本</p><p>几个基本设定：  </p><ol><li>故事发生的星球叫做：潘多拉星</li><li>该星球上存在着名为“纳美”的原始土著</li><li>纳美人与潘多拉星的自然环境有着一种天然的“联系”，能使他们免遭人类的追捕</li><li>人类通过将自己的记忆转移至阿凡达体内，可以防止自己被潘多拉星的自然环境所针对</li></ol><p>本作剧情：<br>男主在变为纳美族后，了解到人类要取自己性命，为了不拖累自己的森林部族，便主动禅让，并与其家人一同离开森林部族，前往海洋部族，寻求其庇护。<br>在海洋部族的时段，男主学习了海洋部族的各类技能，但仍旧无法逃过人类的追捕，自己的孩子以及海洋部族首领的孩子均被人类所绑架，以此要挟男主主动投降。<br>最终男主在海洋部族及自然的帮助下，击退了前来追杀自己的人类队伍。</p><p>对，在我的眼中这部电影中真正可以说是 <strong>剧情相关</strong> 的部分就这么多，但就是这些内容，居然能拍了长达 <strong>三小时</strong> ？！</p><h2 id="一些亮点"><a href="#一些亮点" class="headerlink" title="一些亮点"></a>一些亮点</h2><p>咱先谈谈这部电影哪里好</p><h3 id="画面，音乐，特效"><a href="#画面，音乐，特效" class="headerlink" title="画面，音乐，特效"></a>画面，音乐，特效</h3><p>可以承认的是，这部电影在这些基础层面，可以说的上是好好学生了，这一系列的基本功打的极其扎实。画面上，很干净，很透亮，对于一部“水战”的主题电影，这是一个很好的加分项；音乐上，至少头一次看，不会有很大的违和感，该起该落，情感把控都还算可以；特效上，阿凡达1就是凭这个打出名声的，不多赘述</p><h3 id="运镜！"><a href="#运镜！" class="headerlink" title="运镜！"></a>运镜！</h3><p>这点我一定得夸一下，这部电影的运镜节奏非常合适，它不会像某些科幻片一样让你感觉到一种“看不过来”的感觉，也不会显得过于拖沓，这带来的观影效果提升确实很明显</p><h2 id="吐槽-（正片开始）"><a href="#吐槽-（正片开始）" class="headerlink" title="吐槽 （正片开始）"></a>吐槽 <del>（正片开始）</del></h2><p>好了，该夸的夸完了，现在该骂一骂了</p><h3 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h3><p>首先从我认为最无法理解的地方说起<br>2022年的 <strong>“科幻巨制”</strong> ，却给我看出了一股子儿女情长，并肩加上一些环境保护的“陈词滥调”，我觉得多少有些无聊了吧</p><p>我可以接受电影以“家庭”，“环境”为主旨，但我不认可为了这所谓的主旨而把剧情的合理性抛之脑后的做法</p><p>我认为本作的不合理处包括并不限于：</p><ol><li>男主明知 <em>人类想要掠夺整个潘多拉星，他自己仅仅是个导火索</em> 的事实，却仍然选择逃窜到另一个部族</li><li>在人类已然找上门时，男主仍在坚守自己“忍一时风平浪静”的岁月静好思想</li><li>在男主终于打算前往一战时，海洋部族仅仅是开场露了个面，此后便在整场决战中 <strong>“销声匿迹”</strong> 了</li></ol><h3 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h3><p>其次，说说这个剧情带来的副作用——整个影片的剧情发展拖沓的令人发指</p><p>不同于此前所提及的“运镜”相关的节奏恰当，本片的剧情进展十分缓慢，依我看来，这部电影的主线完全可以在2小时内结束，能拖到3小时的原因在于影片中存在许多“不必要”的铺垫</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>很多细节上的处理完全为主线服务，而完全忽视了与背景的契合度</p><p>在此略举几例：<br>在太空时代，科技领先潘多拉星多少倍的人类，时至如今，其飞行器的前窗仍然能被纳美人一箭射穿。<br>以及科技如此发达的人类社会，在绑架男主几个孩子时，“固执”地使用 <strong>皮带</strong> 将几个孩子拷在船上，在男主初次成功救出部分人质后，仍然“执拗”地使用 <em><strong>皮带</strong></em> 将剩余人质拷在船上。 <del>（好家伙你搁这玩梅开二度呢？）</del></p><p>无力吐槽。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>阿凡达2的基础是好的，甚至可以说是杰出的，但抵不过剧情，细节上的硬伤带来的观感下降</p><p>如果奔着画面和特效所带来的震撼，可以尝试<br>如果奔着剧情去，大可不必了</p><p>本篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Movies </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.2</title>
      <link href="/posts/5828.html"/>
      <url>/posts/5828.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计初步"><a href="#程序设计初步" class="headerlink" title="程序设计初步"></a>程序设计初步</h1><h2 id="1-程序的基本结构"><a href="#1-程序的基本结构" class="headerlink" title="1.程序的基本结构"></a>1.程序的基本结构</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><Font color=CornflowerBlue> <em><strong>函数</strong></em> </Font> 是C语言程序的基本单位<br>函数以 <strong>{}</strong> 为开始&#x2F;结束标志<br>作为一个程序，必须有一个主函数，即 <strong>main</strong> 函数<br>每个函数由语句构成，每个语句以 <strong>；</strong> 结尾</p><h3 id="预编译命令"><a href="#预编译命令" class="headerlink" title="预编译命令"></a>预编译命令</h3><p>每个C语言程序都含有预编译命令<br>预编译命令有三类：  </p><ol><li>宏定义  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define PI 3.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>文件引入  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>条件编译 <del>（我没用过）</del><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释在程序的编译与运行中均不起作用，仅仅增加程序可读性<br>具体格式:  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;这是一条注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><h3 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h3><p>C语言源程序只能存在基本字符，否则无法通过编译<br>基本字符包括：  </p><ol><li>大小写字母</li><li>数字</li><li>其他的可显示字符</li><li>特殊字符</li></ol><p>注： <strong>程序中所有的字符（除了注释中的内容）必须是英文格式</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符用于标识程序中的名字，描述变量（其实就是你给函数或变量取的名）<br>分为三类：  </p><ol><li>用户自定义标识符</li><li>预定义标识符</li><li>关键字</li></ol><p>几个重要特征：</p><ol><li>标识符只能由 <strong>字母，数字及下划线</strong> 组成</li><li>标识符对大小写敏感</li></ol><p>关于关键字：<br>系统给其赋予了特定功能，不能用于其他目的<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intfloatdoublecharbreak...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><p>C语言中的数据区分类型</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>基本类型<ol><li>整形：int</li><li>字符型：char</li><li>浮点型：<ol><li>单精度浮点型：float</li><li>双精度浮点型：double</li></ol></li></ol></li><li>构造类型<ol><li>数组类型</li><li>结构体类型</li><li>共用体类型</li><li>枚举类型</li></ol></li><li>指针类型</li><li>空类型</li></ol><p><strong>限于章节原因，本处仅对基本类型进行说明</strong></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="整形（int）"><a href="#整形（int）" class="headerlink" title="整形（int）"></a>整形（int）</h4><p>用于描述整数<br>取值范围：$-2^{31}$~$2^{31}-1$</p><h4 id="浮点型（float，double）"><a href="#浮点型（float，double）" class="headerlink" title="浮点型（float，double）"></a>浮点型（float，double）</h4><p>用于描述实数<br>其中 <strong>float</strong> 与 <strong>double</strong> 的区别在于前者精度更低，占用内存也更小<br><em><strong>由于计算机以指数形式存储浮点型，因此存在误差</strong></em></p><h4 id="字符型（char）"><a href="#字符型（char）" class="headerlink" title="字符型（char）"></a>字符型（char）</h4><p>用于存储单个字符信息<br>存储的是对应字符的 <strong>ASCⅡ码</strong><br>在此举一例：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;%c&quot;, 63);printf(&quot;%c&quot;, ?);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两条语句的输出结果应当都是字符 ‘ <strong>？</strong>’</p><h3 id="基本数据类型的扩充"><a href="#基本数据类型的扩充" class="headerlink" title="基本数据类型的扩充"></a>基本数据类型的扩充</h3><h4 id="短整型（short-int-short）"><a href="#短整型（short-int-short）" class="headerlink" title="短整型（short int &#x2F; short）"></a>短整型（short int &#x2F; short）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围更小，占用内存也更小<br>取值范围：$-2^{15}$~$2^{15}-1$</p><h4 id="长整型（long-int-long）"><a href="#长整型（long-int-long）" class="headerlink" title="长整型（long int &#x2F; long）"></a>长整型（long int &#x2F; long）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围大于等于int的范围，主要用于处理一些比较大的整数问题</p><h4 id="无数据类型（unsigned）"><a href="#无数据类型（unsigned）" class="headerlink" title="无数据类型（unsigned）"></a>无数据类型（unsigned）</h4><p><strong>unsigned</strong> 可以加在 <strong>int, short, long, char</strong> 的前面，取消其二进制数第一位表示符号的限制，因此unsigned类型只能表示正数</p><h3 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量 &amp; 常量"></a>变量 &amp; 常量</h3><p><em>顾名思义，变量在函数编译过程中可变，而常量不可变</em></p><p>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">double x &#x3D; 2.3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一语句中，x是被定义出来的变量，2.3是个常量</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>系统在编译过程中会为变量分配相应的内存空间，不同类型的变量被分配的空间不同</p><p>变量的定义：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;char c;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>变量的赋值：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;i &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>分类：</p><ol><li>整形常量</li><li>实型常量</li><li>字符型常量</li><li>字符串常量</li><li>符号常量</li></ol><h5 id="关于字符型常量参与计算"><a href="#关于字符型常量参与计算" class="headerlink" title="关于字符型常量参与计算"></a>关于字符型常量参与计算</h5><p>由于字符型常量存储的是相应字符的 <strong>ASCⅡ码</strong>，因此可以将其作为整形进行相应计算<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char c &#x3D; &#39;a&#39;;c &#x3D; c - 32;printf(&quot;%c&quot;, c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的输出结果应该是 ‘A’</p><h5 id="关于转义字符"><a href="#关于转义字符" class="headerlink" title="关于转义字符"></a>关于转义字符</h5><p>用转义字符表示 <strong>ASCⅡ码</strong> 中不可打印的功能性字符<br>如：换行表示为‘ <em><strong>\n</strong></em> ’, 制表（tab）表示为‘ <em><strong>\t</strong></em> ’, …</p><h5 id="关于字符串常量"><a href="#关于字符串常量" class="headerlink" title="关于字符串常量"></a>关于字符串常量</h5><p>字符串常量利用双引号括起来，可表示多个字符的集合<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&quot;Hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-数据的输入与输出"><a href="#4-数据的输入与输出" class="headerlink" title="4. 数据的输入与输出"></a>4. 数据的输入与输出</h2><h3 id="输出函数printf"><a href="#输出函数printf" class="headerlink" title="输出函数printf"></a>输出函数printf</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;格式控制串&quot;, 输出表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式控制串决定输出的数据类型，分别表示为：</p><ol><li><strong>%d</strong> -&gt; <strong>int</strong></li><li><strong>%f</strong> -&gt; <strong>float&#x2F;double</strong></li><li><strong>%c</strong> -&gt; <strong>char</strong></li><li><strong>%ld</strong> -&gt; <strong>long</strong></li><li><strong>%s</strong> -&gt; <strong>字符串</strong></li></ol><h3 id="输入函数scanf（在Visual-Studio中为scanf-s）"><a href="#输入函数scanf（在Visual-Studio中为scanf-s）" class="headerlink" title="输入函数scanf（在Visual Studio中为scanf_s）"></a>输入函数scanf（在Visual Studio中为scanf_s）</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">scanf(&quot;格式控制串&quot;, 地址表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：<br>格式控制串与printf大抵相同，但是这里将 <strong>double</strong> 的格式控制串更改为了 <strong>%lf</strong><br>同时后面的地址表列为地址，故需要在变量前加上取地址符号 <strong>&amp;</strong></p><h3 id="字符型数据的输入与输出"><a href="#字符型数据的输入与输出" class="headerlink" title="字符型数据的输入与输出"></a>字符型数据的输入与输出</h3><p>C语言为字符型数据设定了新的输入方式（ <strong>getchar</strong> ）与新的输出方式（ <strong>putchar</strong> ）<br>格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-运算符与表达式"><a href="#5-运算符与表达式" class="headerlink" title="5.运算符与表达式"></a>5.运算符与表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是C语言中表示相应运算的特殊符号<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="运算符表"></p><p>关于运算符的运算顺序与层级，博主认为依靠个人的编程经验与计算习惯可以判断，故这里不再详述。</p><p>几点提示：  </p><ol><li>C语言中整形除以整形得出的数字还是整形，如：  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这个语句的输出应当是1</li><li><strong>size of</strong> 是个运算符，不是个函数，要记牢</li><li>自增（减）时，如果符号在前，就先加减，再运算，反之，若符号在后，就先运算，再加减</li><li>关于 <strong>+，*，%</strong> 与 <strong>&#x3D;</strong> 的连用： <pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>等价于：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>上述法则对于 *，%同样适用，不再赘述</li></ol><h2 id="6-数据类型的转换"><a href="#6-数据类型的转换" class="headerlink" title="6.数据类型的转换"></a>6.数据类型的转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>在运算时，如果程序识别到两个不同类型的数据进行运算，会以 <em><strong>向高看齐</strong></em> 的原则进行格式转换<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E5%90%91%E9%AB%98%E7%9C%8B%E9%BD%90.png" alt="向高看齐"></p><p>注意：此时可能会出现数值溢出的问题，通常警告为：</p><pre class="line-numbers language-none"><code class="language-none">warning: overflow in implicit constant conversion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在编程过程中，如果需要令一个变量以另一个数据类型参与运算，可以采用强制类型转换的方式，具体格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>i <span class="token operator">+</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，上述过程中对原本为整形的 i 进行了强制类型转换，将其转换为 double 类型参与运算</p><p>需要注意的是，强制类型转换后，被转换的变量类型是不变的，即 i 仍然是int型变量</p><h2 id="7-数学函数"><a href="#7-数学函数" class="headerlink" title="7.数学函数"></a>7.数学函数</h2><p>在C语言中有相应的对各种数学函数进行定义的库： <strong>&lt;math.h&gt;</strong><br>在需要使用时，在函数前进行相应的预编译即可</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/math.h.png" alt="math.h中的常用函数"></p><p>以上，是编程前需要了解的一些知识</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.1</title>
      <link href="/posts/32835.html"/>
      <url>/posts/32835.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计概述"><a href="#程序设计概述" class="headerlink" title="程序设计概述"></a>程序设计概述</h1><h2 id="1-程序设计语言"><a href="#1-程序设计语言" class="headerlink" title="1.程序设计语言"></a>1.程序设计语言</h2><p><em>计算机语言：计算机能够接受和处理的具有一定格式的语言</em>  </p><h3 id="发展历程："><a href="#发展历程：" class="headerlink" title="发展历程："></a>发展历程：</h3><ol><li>机器语言：二进制</li><li>汇编语言：少许助记符号</li><li>高级语言：  <ol><li>面向过程：Basic， C等</li><li>面向对象：Java， C++等</li></ol></li></ol><h2 id="2-程序设计基本概念"><a href="#2-程序设计基本概念" class="headerlink" title="2.程序设计基本概念"></a>2.程序设计基本概念</h2><h3 id="五部曲：（我自己起的）"><a href="#五部曲：（我自己起的）" class="headerlink" title="五部曲：（我自己起的）"></a>五部曲：<del>（我自己起的）</del></h3><ol><li>分析</li><li>确定算法</li><li>编程</li><li>调试</li><li>优化、改进</li></ol><h3 id="程序-数据结构-算法"><a href="#程序-数据结构-算法" class="headerlink" title=" 程序 &#x3D; 数据结构 + 算法 "></a><Font color=CornflowerBlue> <em><strong>程序 &#x3D; 数据结构 + 算法</strong></em> </Font></h3><h3 id="算法的特性："><a href="#算法的特性：" class="headerlink" title="算法的特性："></a>算法的特性：</h3><ol><li>有穷性：有终点</li><li>确定性：定义清晰</li><li>有零个或多个输入</li><li>至少有一个输出</li><li>可行性：每一步都得可行</li></ol><h3 id="如何描述算法？"><a href="#如何描述算法？" class="headerlink" title="如何描述算法？"></a>如何描述算法？</h3><ol><li><em><strong>流程图</strong></em> ：最常用的方法</li><li>结构流程图：<del>我没用过</del></li><li>伪代码：对相应代码块进行简写</li></ol><p>关于流程图的图例：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.1/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%9B%BE%E4%BE%8B.png" alt="流程图图例"></p><h2 id="3-结构化程序设计"><a href="#3-结构化程序设计" class="headerlink" title="3.结构化程序设计"></a>3.结构化程序设计</h2><p><em>顾名思义，将“程序设计”这个流程结构化，标准化</em></p><h3 id="三种基本结构"><a href="#三种基本结构" class="headerlink" title="三种基本结构"></a>三种基本结构</h3><ol><li>顺序：循序渐进</li><li>选择：涉及到判断，选择支线 <del>（不要介意这个游戏内常见的用语）</del></li><li>循环：涉及到判断，并是否返回执行</li></ol><h2 id="4-程序的实现环境"><a href="#4-程序的实现环境" class="headerlink" title="4.程序的实现环境"></a>4.程序的实现环境</h2><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><ol><li>输入设备</li><li>输出设备</li><li>外存&amp;内存</li><li>CPU：<ol><li>运算器</li><li>控制器</li></ol></li></ol><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><ol><li>操作系统</li><li>编辑程序</li><li>编译程序</li><li>连接程序</li></ol><h3 id="一些解释："><a href="#一些解释：" class="headerlink" title="一些解释："></a>一些解释：</h3><p>用高级语言编写出来的文件叫做 <strong>源程序</strong> ，不能直接执行<br>因此，需要先将其转换为可执行程序，这一过程称为 <strong>C程序的加工</strong><br>C程序的加工分为两步：  </p><ol><li>编译：具体表现为将 <em><strong>.c</strong></em> 程序转换为 <em><strong>.obj</strong></em> 程序</li><li>链接：将 <em><strong>.obj</strong></em> 程序与其他目标程序&#x2F;库装配，形成 <em><strong>.exe</strong></em>文件</li></ol><p>后续过程中如果涉及到编程，博主会以 <em><strong>Visual Studio 2022</strong></em> 为运行环境</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博第一篇</title>
      <link href="/posts/32455.html"/>
      <url>/posts/32455.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h2><p>这个博客来源于博主的一时兴起。</p><p>想发点啥但没有很系统的方法，之后发现了个人博客是个挺自在的地方，故就这样了。</p><h2 id="关于博客的内容"><a href="#关于博客的内容" class="headerlink" title="关于博客的内容"></a>关于博客的内容</h2><p>初步确定为进行个人学习笔记的整理，以及各种博主想说的（包括但不限于各种评价，各种想法…）</p><h2 id="后续更新计划"><a href="#后续更新计划" class="headerlink" title="后续更新计划"></a>后续更新计划</h2><p>· 博客的美化工作，会持续，长期进行</p><p>· 各类二级界面的创建与完善</p><p>· 后续内容的持续跟进…</p><p>目前就这些啦~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客的搭建流程</title>
      <link href="/posts/23043.html"/>
      <url>/posts/23043.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建流程概述"><a href="#搭建流程概述" class="headerlink" title="搭建流程概述"></a>搭建流程概述</h2><h3 id="Step-1：Nodejs的下载及配置"><a href="#Step-1：Nodejs的下载及配置" class="headerlink" title="Step 1：Nodejs的下载及配置"></a>Step 1：Nodejs的下载及配置</h3><p><em>本博客是以Hexo为基本框架，以Github Page为雏形的个人博客，而在Windows上装载Hexo的最佳方法是通过Git（一个应用，内置了Linux的些许命令）从Github上克隆相应仓库，同时Hexo的运行需要Nodejs所提供的环境</em></p><p>首先前往Nodejs官网：<strong>nodejs.org</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Nodejs.png" alt="Nodejs官网"></p><p>这边我选择的是左边的18.12.1版本，相对来说比较稳定<br>安装过程很简单，按照默认配置来就可以<del>（无脑下一步）</del></p><p>此后会涉及到两个环境变量的配置：<br>这里附上一篇博文，我觉得人家讲的比我清楚<del>（水平有限，见谅）</del>  </p><blockquote><p><a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>注：下载完后可以通过cmd（快捷键Ctrl+X，选中其中的 <strong>终端(管理员)</strong> ）检验一下Nodejs是否成功下载并运行了，一并检查一下npm是否成功安装（npm是一个在安装Nodejs后自动给你附带安装的东西，后面会用到）<br>具体命令：</p><pre class="line-numbers language-none"><code class="language-none">&#123;node -v  npm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错才对</p><h3 id="Step-2-将npm更改为国内镜像源提供的cnpm"><a href="#Step-2-将npm更改为国内镜像源提供的cnpm" class="headerlink" title="Step 2: 将npm更改为国内镜像源提供的cnpm"></a>Step 2: 将npm更改为国内镜像源提供的cnpm</h3><p><em>本步骤的目的在于更换npm组件，由于原版npm在后续流程中极其容易报错，因此本步骤至少在博主创建博客时是必要的</em></p><p>命令为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤需要等待一段时间（安装耗时）</p><p>等待其安装完成后，分别输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm  cnpm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错</p><p><strong>注：本步骤中博主遇到了报错情况，提示为：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm : 无法加载文件 D:\nodejs\node_global\cnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，可以通过命令解除限制：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Set-ExecutionPolicy RemoteSigned -Scope Process&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解除限制后再次输入cnpm相关命令即可</p><h3 id="Step-3-正式安装Hexo（主角登场）"><a href="#Step-3-正式安装Hexo（主角登场）" class="headerlink" title="Step 3: 正式安装Hexo（主角登场）"></a>Step 3: 正式安装Hexo<del>（主角登场）</del></h3><p><em>上文有提到，本博客以Hexo为基本框架</em></p><p>仍然是在cmd中，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install -g hexo-cli&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待其安装成功后，再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若没报错，说明安装成功</p><h3 id="Step-4-下载Git"><a href="#Step-4-下载Git" class="headerlink" title="Step 4: 下载Git"></a>Step 4: 下载Git</h3><p><em>上文有提到，通过Git可以有效装载运行Hexo，并与相关的Github仓库进行配套使用</em></p><p>前往Git官网：<strong><a href="https://git-scm.com/">https://git-scm.com/</a></strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Git.png" alt="Git官网"></p><p>博主采用的是2.39.0版本</p><p>同样的，下载，安装<del>（无脑下一步）</del></p><p>接下来仍然涉及到一个环境变量的设置：<br>把刚刚Git安装目录下的bin文件夹打开，复制相应的文件路径，将其添加到<strong>环境变量-系统变量-Path</strong>里面</p><h3 id="Step-5：新建一个用于操作你的博客的文件夹"><a href="#Step-5：新建一个用于操作你的博客的文件夹" class="headerlink" title="Step 5：新建一个用于操作你的博客的文件夹"></a>Step 5：新建一个用于操作你的博客的文件夹</h3><p><em>接下来就是正式的博客搭建环节</em></p><p>在你的电脑中随意一个位置（你得能记住奥）创建一个新文件夹，取名Blog<br>此后点进那个文件夹，右键空白处，点击<strong>Git Bash Here</strong><br>这时应该会出现一个黑框，像这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/gitbash.png" alt="Git控制台界面"></p><p>在其中输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo init&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里大概率会出现两个问题：<br>（1）显示经过多少多少毫秒之后连接错误<br>（2）显示无法成功安装，让你人工输入<em>npm install</em></p><p>如果是第一个错误，请你给git挂上代理（自行搜索）<br>如果是第二个错误，这时候之前做的就有用了，这时直接输入<em>npm install</em>大概率会报错，所以我们输入:</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果没有报错，就大概率成了，这时候看向你的Blog文件夹，如果有一个叫<em>node_modules</em>的文件夹，就可以放心进行下一步了</p><h3 id="Step-6-尝试第一次启动本地服务器"><a href="#Step-6-尝试第一次启动本地服务器" class="headerlink" title="Step 6: 尝试第一次启动本地服务器"></a>Step 6: 尝试第一次启动本地服务器</h3><p>在刚刚那个Git控制台中再次输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果显示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Hexo running at ______(这里是一个地址）_________, Press Ctrl+C to stop.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明成功了，现在在浏览器内打开那个地址，就可以看到一个初步的网页，上面有 <strong>Hexo</strong>标识</p><p>我们先Ctrl+C将其关闭</p><h3 id="Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接"><a href="#Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接" class="headerlink" title="Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接"></a>Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接</h3><p>这边需要你创建一个自己的Github账号<br>牢记你的注册邮箱以及用户名，密码</p><p>创建一个新的库（repository），将这个库的名字改为 <em><strong>你的账户名.github.io</strong></em>  (这一步很重要！)  </p><p>此后进行SSH与Github的绑定,这里还是给出链接  </p><blockquote><p><a href="https://blog.csdn.net/qq_35703954/article/details/87446876">https://blog.csdn.net/qq_35703954/article/details/87446876</a></p></blockquote><p>绑定成功后，需要对Blog文件夹中的一个文件进行些许更改<br>那个文件叫： <em><strong>_config.yml</strong></em></p><p>注：这个文件可以使用记事本打开，但是我强烈建议有需求的各位下载VScode打开这个文件，自行搜索就可以。</p><p>咱们继续：<br>打开后将文件翻到最后，有一个 <em><strong>deploy：…</strong></em> ，将deploy以下的部分全部删除，改为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;deploy:    type: git    repository: 你自己刚刚创建的GitHub的那个项目地址（下文会写如何查看）    branch: main&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>几个需要注意的点</strong></em><br>· 注意格式，deploy后面的内容是有缩进的，以及冒号后面的空格。<br>· 项目地址的查看方法：<br>前往你的GitHub相应项目中，右上角有一个 <em><strong>code</strong></em> 按钮，长这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code.png" alt="Code"><br>点击它，会出现这样的一个界面：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code-1.png" alt="点击Code之后的界面"><br>选中那个 <em><strong>HTTPS</strong></em>， 之后将底下的链接复制，粘贴至上面的 <em><strong>_config.yml</strong></em> 文件的repository后面</p><h3 id="Step-8-装载部署工具"><a href="#Step-8-装载部署工具" class="headerlink" title="Step 8: 装载部署工具"></a>Step 8: 装载部署工具</h3><p>还是 <em><strong>Blog</strong></em> 文件夹，还是右键 <strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install hexo-deployer-git --save&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待安装完成，之后输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待生成完成（不报错），之后再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这之后再输入你的库的名称（即 <em><strong>你的账户名.github.io</strong></em>）到浏览器地址栏中，应该就能看到刚刚那个有Hexo的界面了</p><h3 id="Step-9-编写博文"><a href="#Step-9-编写博文" class="headerlink" title="Step 9: 编写博文"></a>Step 9: 编写博文</h3><p><em><strong>Blog</strong></em>文件夹，右键，<strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo n 你想起的文章名&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后应该会出现一个提示，在你的 <em>source-_posts</em>文件夹内生成了一个markdown文件，这就是你撰写新博客的地方</p><p>注：这也是为什么我推荐安装vscode，因为vscode只需要安装两个插件就可以做到编写，预览Markdown文件，很方便（方法请自行搜索）</p><p>写完你的博文之后，保存，返回 <em><strong>blog</strong></em>文件夹，<strong>Git Bash Here</strong>，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo cl&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一套流程下来，你的博文就可以被成功上传到那个网页中</p><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><p>此次博客的搭建，从整体而言是相对繁琐的，同时中间掉了很多次坑，往往一个坑都得花费1-2个小时进行查询，修补，一套流程下来基本上花了有两天时间。</p><p>回过头来，再看这一整个流程，缺乏的就是一个整体框架，如果一股脑冲进去，会做着做着迷失了方向，就不知道该做什么了</p><p>故此，在这里整理下整套流程，供读者参考，更是供自己反思优化</p><p>关于美化，应该不会再整理步骤了，因为各种模板包里面都有详尽的使用说明，并且不同的模板操作方式不同，待读者自行探索了</p><p>这篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

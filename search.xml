<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库系统概论-Chap.1</title>
      <link href="/posts/51796.html"/>
      <url>/posts/51796.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-1-绪论"><a href="#Chap-1-绪论" class="headerlink" title="Chap.1 绪论"></a>Chap.1 绪论</h1><h2 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h2><h3 id="1-1-1-数据库的四个基本概念"><a href="#1-1-1-数据库的四个基本概念" class="headerlink" title="1.1.1 数据库的四个基本概念"></a>1.1.1 数据库的四个基本概念</h3><p>数据库中最基础的四个概念分别是:</p><ul><li>数据(Data)<ul><li>是数据库中存储的基本对象</li><li>定义为 <em>描述事物的符号记录</em></li><li>数据是 <strong>一个个数字</strong> , 而数据的具体含义叫做 <strong>数据的语义</strong></li><li>分为三类:<ul><li>结构化数据: 关系数据(表)</li><li>半结构化数据: 键值对, XML, JSON, 图, 向量等</li><li>非结构化数据: 文本文档, 电子邮件, 图像…</li></ul></li></ul></li><li>数据库(DataBase, DB)<ul><li>数据库是 <em>长期储存在计算机内的, 有组织, 可共享的大量数据集合</em></li><li>基本特征已经体现在定义中:<ul><li>数据按照一定格式来组织, 储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>易扩展</li></ul></li></ul></li><li>数据库管理系统(DBMS)<ul><li>是位于用于与操作系统之间的一层数据管理软件</li><li>负责组织 &#x2F; 存储数据, 同时在用户有需求时获取 &#x2F; 维护数据</li><li>主要功能包括两方面:<ul><li>对数据库本身的: 建立 &#x2F; 维护 &#x2F; 运行管理</li><li>对数据库内部数据的: 定义 &#x2F; 操纵 &#x2F; 存储 &#x2F; 组织 &#x2F; 管理</li></ul></li></ul></li><li>数据库系统(DBS)<ul><li>是对数据库及其相关内容的总称, 包括:<ul><li>数据库</li><li>数据库管理系统</li><li>应用程序</li><li>数据库管理员</li></ul></li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.png" alt="数据库系统"></p><h3 id="1-1-2-数据管理系统的产生和发展"><a href="#1-1-2-数据管理系统的产生和发展" class="headerlink" title="1.1.2 数据管理系统的产生和发展"></a>1.1.2 数据管理系统的产生和发展</h3><p>这一部分不是非常的重要, 一笔带过哈:</p><ul><li>第一阶段是人工管理阶段: 没有存储设备, 只能在纸带 &#x2F; 磁带上存储<ul><li>数据完全没有任何结构</li><li>冗余程度极高</li><li>通常 <strong>一个应用程序对应一个数据集</strong></li></ul></li><li>第二阶段是文件系统阶段: 建立在操作系统和文件系统产生之后.<ul><li>共享性差, 冗余度大</li><li>文件系统变成了中间介质, 对应方式变成了 <strong>多个应用程序-&gt;1个文件系统-&gt;多个数据集</strong></li></ul></li><li>第三阶段就是数据库系统阶段: 大容量磁盘, 存储阵列开始出现.<ul><li>存储数据, 查询等操作更规范化, 模式化.</li><li>极大幅度提高效率</li></ul></li></ul><h3 id="1-1-3-数据库系统的特点"><a href="#1-1-3-数据库系统的特点" class="headerlink" title="1.1.3 数据库系统的特点"></a>1.1.3 数据库系统的特点</h3><ul><li>数据结构化<ul><li>数据的结构用统一的数据模型来描述</li></ul></li><li>共享性高<ul><li>面向整个系统, 可以被多个用户, 多个应用使用</li></ul></li><li>独立性高<ul><li>包括 <strong>物理独立性</strong> 和 <strong>逻辑独立性</strong></li><li>物理独立性指应用程序与物理存储结构相互独立(物理存储结构变更不需要导致应用程序变更)</li><li>逻辑独立性指应用程序域逻辑结构相互独立(一样的, 逻辑结构变了, 应用程序不用变)</li></ul></li><li>数据通过DBMS统一管理或控制<ul><li>就像我们说的, 应用程序与数据库本身之间隔着一层DBMS, 它负责了一切, 包括<ul><li>完整性</li><li>安全性</li><li>并发控制</li><li>故障恢复</li></ul></li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%80%A7.png" alt="数据库的独立性"></p><h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h2><h3 id="1-2-1-数据建模"><a href="#1-2-1-数据建模" class="headerlink" title="1.2.1 数据建模"></a>1.2.1 数据建模</h3><p>数据模型是 <strong>对现实世界数据特征的抽象</strong> .<br>通常对于客观对象的抽象过程分两步:</p><ul><li>将客观对象抽象为概念模型<ul><li><strong>概念模型</strong> 还是用户的观点, 负责对现实进行抽象和建模</li></ul></li><li>将概念模型抽象为数据库支持的数据模型<ul><li><strong>逻辑模型</strong> 是一些DBMS实现了的模型, 比如网状模型 &#x2F; 层次模型 &#x2F; 关系模型等</li><li><strong>物理模型</strong> 是在物理磁盘上的存储模型</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1.png" alt="数据建模"></p><p>上图中信息世界的建模, 是我们应当着重关注的, 有一些基本的概念:</p><ul><li>实体(Entity): 客观存在的一个事物</li><li>属性(Attribute): 实体具有的某一特性</li><li>码(Key): 用于唯一标识实体的属性集</li><li>实体类型(Entity Type): 用实体名和属性名集合来标识的一类实体<ul><li>学生(学号, 姓名)</li></ul></li><li>实体集(Entity Set): 同一类型实体的集合</li><li>联系(Relationship): <ul><li>实体内部的联系: 各个属性之间的联系</li><li>实体之间的联系: 不同实体集之间的联系</li><li>一对一, 一对多, 多对多</li></ul></li></ul><p>在机器世界中, 有与其相对应的概念:</p><ul><li>记录(元组): 信息世界中的一个实体</li><li>字段(数据项): 信息世界中的属性</li><li>码(键): 信息世界中的码</li><li>文件: 信息世界中的实体集</li></ul><h3 id="1-2-2-概念模型"><a href="#1-2-2-概念模型" class="headerlink" title="1.2.2 概念模型"></a>1.2.2 概念模型</h3><p>我们关注的概念模型就是信息世界中建模的工具, 是现实世界和机器世界的一个中转站.</p><p>当前数据库主要是关系型数据库, 我们需要重点先关注实体集之间的关系:</p><ul><li>一对一: 比如一个班只能有一个班长, 同时一个班长只能在一个班任职</li><li>一对多: 比如一个班里可以有很多学生, 但一个学生只能在一个班里</li><li>多对多: 比如一个课程里可以有很多选修它的学生, 而一个学生也可以选修多门课程</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E5%AE%9E%E4%BD%93%E8%81%94%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%9E%8B.png" alt="实体联系的类型"></p><p>包括还有多个实体之间的联系(项目, 供应商, 零件), 单个实体型内部的联系(职工实体和领导关系).</p><p>这种描述不同实体之间联系的方式叫 <strong>ER(Entity Relationship)模型</strong> , 其内部三要素即:</p><ul><li>实体(矩形)</li><li>联系(菱形)</li><li>属性(椭圆)</li></ul><p>它们之间用线段连接.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/ER%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B.png" alt="ER模型实例"></p><h3 id="1-2-3-数据模型的组成要素"><a href="#1-2-3-数据模型的组成要素" class="headerlink" title="1.2.3 数据模型的组成要素"></a>1.2.3 数据模型的组成要素</h3><p>数据模型的组成要素有以下三点:</p><ul><li>数据结构<ul><li>对系统静态特征的描述</li><li>描述数据库的组成对象与联系</li></ul></li><li>数据操作<ul><li>对数据库内各种对象允许进行的操作的集合</li><li>增删改查等</li></ul></li><li>完整性约束<ul><li>就是一组规则, 对给出的数据结构的限定</li><li>需要保证数据正确 &#x2F; 有效 &#x2F; 相容</li></ul></li></ul><p>常用的数据模型包括:</p><ul><li>层次模型</li><li>网状模型</li><li>关系模型</li></ul><h3 id="1-2-4-层次模型"><a href="#1-2-4-层次模型" class="headerlink" title="1.2.4 层次模型"></a>1.2.4 层次模型</h3><p>层次模型用树形结构来表示各实体以及实体间的联系.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B.png" alt="层次模型"></p><p>因为是树形结构, 因此比较适合 <strong>一对多</strong> 的关系叙述, 对于多对多, 只能分解成两个一对多.</p><p>其完整性约束如下:</p><ul><li>无双亲则不能插入子女节点</li><li>删除双亲则必须一并删除子女节点</li></ul><p>其存储结构很像数据结构中 <strong>树</strong> 的存储结构, 可以用邻接法, 也可以用链接法(链表).</p><ul><li>查询效率高</li><li>对于插入和删除的限制多</li><li>必须通过双亲结点查询子女节点</li></ul><h3 id="1-2-5-网状模型"><a href="#1-2-5-网状模型" class="headerlink" title="1.2.5 网状模型"></a>1.2.5 网状模型</h3><p>网状模型通常采用经典的网状结构来描述实体间的联系. 其特点如下:</p><ul><li>允许一个以上的节点无双亲</li><li>一个节点可以有多于一个的双亲</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E7%BD%91%E7%8A%B6%E6%A8%A1%E5%9E%8B.png" alt="网状模型"></p><p>可以看出来, 实际上 <strong>层次模型是网状模型的一个特例</strong> .</p><p>网状模型通常直接使用链接法进行记录之间联系的构建. 并且, 可以构建多对多的联系(通过引入 <strong>联结记录</strong> )</p><blockquote><p><strong><font color =#2971ff>定义</font></strong><br>联结记录, 实际上就是引入一种新的实体.<br>比如对于学生与课程之间的多对多关系, 那就引入一种联结记录叫 <strong>选课</strong> .<br>学生与选课之间是一对多, 而课程与选课之间也是一对多.</p></blockquote><ul><li>网状模型的效率通常比较高, 性能还可以</li><li>结构随着数据库增大会变得非常复杂, 不利于管理</li></ul><h3 id="1-2-6-关系模型"><a href="#1-2-6-关系模型" class="headerlink" title="1.2.6 关系模型"></a>1.2.6 关系模型</h3><p>关系模型是当前数据库主要采取的数据组织方式. 它通过二维表来表示实体集, 用外键表示实体之间的联系.</p><p>关系模型中有一些名词, 其实跟我们之前说的比较像:</p><ul><li>关系(Relation): 通常指代一张表</li><li>元组(Tuple): 表中的一行即一个元组</li><li>属性(Attribute): 表中的一列就是一个属性</li><li>码(Key): 能够唯一标识元组的一个属性</li><li>域(Domain): 一组具有相同数据类型的值的集合(其实就是属性的取值范围)</li><li>分量: 元组中的一个属性值(表中的某一个具体格)</li><li>关系模式: 就是关系的表示方法: $ 学生(\underline{学号}, 姓名, 年龄, 性别, 系名, 年级) $ , 其中标下划线的是码(也叫主键)</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.png" alt="关系模型"></p><p>关系模型的操作就是我们熟悉的:</p><ul><li>增</li><li>删</li><li>改</li><li>查</li></ul><p>其完整性约束也比较完善:</p><ul><li>实体完整性: 实体的主键不能为NULL(针对主键本身)</li><li>参照完整性: 外键引用的主键必须在对应的主表中存在(针对实体的外键)</li><li>用户定义的完整性: 用户根据自己的需求对于属性进行的定义.(比如对于值域的定义, 对于枚举类的限制等)</li></ul><p>特点如下:</p><ul><li>数学概念严格</li><li>关系模式的存取对用户透明</li><li>查询效率通常低一些</li><li>为了性能问题需要优化查询, 提高了复杂度</li></ul><hr><p>除了上述三类之外, 近些年有一种叫做 <strong>面向数据关系类型</strong> , 相当于把编程中的面向对象的思想搬了过来.<br>它有其问题, 主要是它的理论基础并不扎实. 在语言以及查询优化方面都没有明显的优势.</p><p>由于关系型数据库发展至今已经十分完善, 因此并未掀起很大的波动.</p><h2 id="1-3-数据库系统的结构"><a href="#1-3-数据库系统的结构" class="headerlink" title="1.3 数据库系统的结构"></a>1.3 数据库系统的结构</h2><p>从应用开发人员的角度来讲(说白了就是从应用开发者的角度), 数据库通常是由三级模式结构区分的:</p><ul><li>外模式</li><li>模式</li><li>内模式</li></ul><h3 id="1-3-1-模式-实例"><a href="#1-3-1-模式-实例" class="headerlink" title="1.3.1 模式 &#x2F; 实例"></a>1.3.1 模式 &#x2F; 实例</h3><p>模式, 实际上就是数据库的结构定义. 以关系数据库为例, 像这样的ER图就可以作为我们数据库的模式:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/ER%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B.png" alt="ER模型实例"></p><p>当然, 我们也能通过这种图推导出如何构建这个表(通过SQL语言, 后文再讲), 这也叫模式.</p><p>而实例, 则是某组(某个)具体的数据集合(实体), 比如说一个学生表中的具体数据.</p><h3 id="1-3-2-三级模式结构"><a href="#1-3-2-三级模式结构" class="headerlink" title="1.3.2 三级模式结构"></a>1.3.2 三级模式结构</h3><p>我们刚刚说了, 三级模式结构:</p><ul><li>外模式(External Schema)</li><li>模式(Schema)</li><li>内模式(Internel Schema)</li></ul><p>现在一个个来说都是啥意思.</p><h3 id="1-3-3-模式-Schema"><a href="#1-3-3-模式-Schema" class="headerlink" title="1.3.3 模式(Schema)"></a>1.3.3 模式(Schema)</h3><p><strong>模式</strong> , 也叫 <strong>逻辑模式</strong> , 指的是数据库中所有数据的逻辑结构和特征的概述.<br>其实也就是我们具体怎么规划, 设计数据库的逻辑存储结构(就是上面的ER图).</p><p>显然, 它与数据的物理存储方式无关; 同时, 与具体的应用程序或者高级程序设计语言同样无关.</p><p>正如我们此前说的一样, 模式主要包含的就是:</p><ul><li>数据的逻辑结构(由什么变量构成)</li><li>数据之间的联系(表的结构)</li><li>数据有关的安全性 &#x2F; 完整性要求(参见1.2.6)</li></ul><blockquote><p><strong><font color =#ff3131>注意</font></strong><br>一个数据库只能有一个模式.</p></blockquote><h3 id="1-3-4-外模式-External-Schema"><a href="#1-3-4-外模式-External-Schema" class="headerlink" title="1.3.4 外模式(External Schema)"></a>1.3.4 外模式(External Schema)</h3><p><strong>外模式</strong> , 亦称 <strong>用户模式</strong> , 指的是数据库用户(应用设计者 &#x2F; 最终用户)使用的局部数据的逻辑结构和特征的叙述.</p><p>举个例子而言, 我们数据库的模式就是具体存储的一个个表. 而我们的外模式可以在后端一并取出一个表的某一些属性 &#x2F; 甚至几个表的属性我都拿出来呈现出来, 这种不同的呈现方式就是外模式的具体例子.</p><p>可以看出, 一个数据库虽然只能有一个模式, 但是它是可以有很多的外模式的对吧. 我怎么取出, 展示我的数据, 那可很自由了.<br>我们严谨一点给出外模式的特点:</p><ul><li><strong>外模式通常是模式的子集</strong></li><li><strong>一个数据库可以有多个外模式</strong></li><li>模式中同一个数据, 在外模式中的结构, 表现形式, 保密级别都可能不同.</li></ul><blockquote><p><strong><font color =#ff3131>注意</font></strong><br>这里提一嘴外模式根应用程序的关系.<br>外模式与应用程序是 <strong>一对多</strong> 的关系, 即一个外模式可以被很多个应用程序使用, 但是一个应用程序只对应一种外模式.</p></blockquote><h3 id="1-3-5-内模式-Internel-Schema"><a href="#1-3-5-内模式-Internel-Schema" class="headerlink" title="1.3.5 内模式(Internel Schema)"></a>1.3.5 内模式(Internel Schema)</h3><p><strong>内模式</strong> , 也叫 <strong>存储模式</strong> , 是数据库数据物理结构和存储方式的叙述.<br>比如:</p><ul><li>数据的物理存储策略(顺序, 链式, B树, …)</li><li>数据的组织方式</li><li>数据存储时是否压缩</li><li>数据存储时是否加密</li></ul><p>可以看出, 内模式就是我们的模式具体是怎么在我们的存储结构中物理实现的.<br>相对应的, <strong>一个数据库只能有一个内模式</strong> .</p><h3 id="1-3-6-数据库的二级映像功能与数据独立性"><a href="#1-3-6-数据库的二级映像功能与数据独立性" class="headerlink" title="1.3.6 数据库的二级映像功能与数据独立性"></a>1.3.6 数据库的二级映像功能与数据独立性</h3><p>数据库的 <strong>二级映像</strong> 正是针对这三个模式而言的.</p><ul><li>外模式 &#x2F; 模式映像</li><li>模式 &#x2F; 内模式映像</li></ul><p>这两层影响保证了数据库的数据具有较高的 <strong>逻辑独立性</strong> &#x2F; <strong>物理独立性</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84.png" alt="数据库系统的三级模式结构"></p><p>首先看 <strong>外模式 &#x2F; 模式映像</strong> , 它其实就是表达同一个模式是怎么被映射成不同样子的外模式的.<br>正因如此, 一个外模式通常就对应着一个外模式 &#x2F; 模式映像, 而它也一般被写在外模式的描述中.</p><p>它的作用不言自明, 当模式发生变化, 只需要更改外模式与模式的对应关系即可, 而无需更改应用程序的代码(因为应用程序只与外模式相关) . 这就是 <strong>数据的逻辑独立性</strong> .</p><p>再来看 <strong>模式 &#x2F; 内模式映像</strong> , 同理, 它表达了一个模式是怎么被存储在存储介质之中的.<br>因为对于同一个数据库, 只有一个模式 &#x2F; 内模式, 因此 <strong>模式 &#x2F; 内模式映像</strong> 是唯一的. 通常包含在模式的描述中.  </p><p>它的作用是什么?<br>当内模式(就是存储结构)发生变化, 只需要更改模式与内模式的映射即可, 无需做出其它更改, 这就叫 <strong>数据的物理独立性</strong> .</p><h2 id="1-4-数据库系统的组成"><a href="#1-4-数据库系统的组成" class="headerlink" title="1.4 数据库系统的组成"></a>1.4 数据库系统的组成</h2><p>一个数据库系统的组成通常包括:</p><ul><li>硬件平台及数据库<ul><li>足够大的内存</li><li>足够大的磁盘与磁盘阵列等设备</li><li>较高的通道能力</li></ul></li><li>软件<ul><li>操作系统</li><li>数据库管理系统</li><li>对接的高级语言编译系统</li><li>对应的应用开发工具</li><li>应用系统</li></ul></li><li>人员<ul><li>数据库管理员DBA</li><li>数据库设计人员</li><li>应用程序员</li><li>最终用户</li></ul></li></ul><h3 id="1-4-1-数据库管理系统DBMS"><a href="#1-4-1-数据库管理系统DBMS" class="headerlink" title="1.4.1 数据库管理系统DBMS"></a>1.4.1 数据库管理系统DBMS</h3><p>我们之前在这个图里面提过数据库管理系统:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.png" alt="数据库系统"></p><p>在了解了数据库的基本结构之后, 现在来详细的介绍一下它.</p><p>其功能主要有:</p><ul><li>数据库的定义功能<ul><li>定义三级模式以及二级映像</li><li>定义完整性 &#x2F; 安全性等约束</li></ul></li></ul><blockquote><p><strong><font color =#ff3131>注意</font></strong><br>DBMS中是怎么存储 <strong>三级模式定义</strong> 的?<br>实际上, DBMS同样使用数据库来定义三级模式.<br>这被称之为 <strong>数据字典(DD, Database Dictionary)</strong></p></blockquote><ul><li>数据库的操纵功能<ul><li>这不用说了, 增删改查, 之前提了很多回</li></ul></li><li>数据库的保护功能<ul><li>完整性 &#x2F; 安全性控制</li><li>数据库的恢复</li><li>数据库的并发控制</li></ul></li><li>数据库的存储管理<ul><li>就是把高级的插入语言转化成底层操作系统能看懂的文件系统命令</li></ul></li><li>数据库的维护功能<ul><li>数据装载</li><li>数据库备份</li><li>性能监控</li></ul></li></ul><p>读者把这五个方面都看一遍会发现, 我去, 数据库管理系统全包了, 把很复杂的工作简化成了对应的数据库语言.<br>这也就是为什么说 <strong>数据库管理系统是数据库系统的核心部分</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/Chap.1/%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="用户访问数据的过程"></p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统概论 </tag>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融数据安全-Chap.8</title>
      <link href="/posts/46611.html"/>
      <url>/posts/46611.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-8-网络支付安全问题"><a href="#Chap-8-网络支付安全问题" class="headerlink" title="Chap.8 网络支付安全问题"></a>Chap.8 网络支付安全问题</h1><h2 id="8-1-公钥基础设施PKI"><a href="#8-1-公钥基础设施PKI" class="headerlink" title="8.1 公钥基础设施PKI"></a>8.1 公钥基础设施PKI</h2><h3 id="8-1-1-PKI的基础概念"><a href="#8-1-1-PKI的基础概念" class="headerlink" title="8.1.1 PKI的基础概念"></a>8.1.1 PKI的基础概念</h3><p>公钥基础设施(PKI, Public Key Infrastructure)是用非对称密钥技术对网上服务等电子商务服务提供安全设施的机构.</p><p>PKI使用 <strong>证书</strong> 的形式来管理用户, 将用户的公钥与其其它身份信息通过证书关联起来.<br>狭义上的PKI只需要能够:</p><ul><li>创建</li><li>管理</li><li>存储</li><li>分配</li><li>撤销</li></ul><p>公钥证书即可.</p><p>但是随时代发展, PKI的功能已经不仅限于如上方面, 还包括对网络上所有的产品提供其余的安全设施.(比如密码学上的安全服务)</p><h3 id="8-1-2-PKI提供的功能"><a href="#8-1-2-PKI提供的功能" class="headerlink" title="8.1.2 PKI提供的功能"></a>8.1.2 PKI提供的功能</h3><p>PKI提供的功能如下:</p><ul><li>安全登录: 将一个成功登录的结果安全的分发到其他设备上.(减少多次登录的需求)</li><li>终端用户的透明性: 就是提供服务的技术细节不需要对终端用户公开</li><li>全面的安全性: 即我们说的与用户身份信息相关联的数字证书</li></ul><p>其优势在于:</p><ul><li>低成本</li><li>互操作性高</li><li>开放性广</li></ul><h3 id="8-1-3-PKI的组成"><a href="#8-1-3-PKI的组成" class="headerlink" title="8.1.3 PKI的组成"></a>8.1.3 PKI的组成</h3><p>PKI的组成部分包括以下几个方面:</p><ul><li>最终实体(EE)与数字证书(Cert): 数字证书不必多说, 最终实体分两类:<ul><li>证书主体(就是个人信息的标明用户)</li><li>证书依赖方(需要这些个人信息的第三方)</li></ul></li><li>认证中心(CA): 负责它最终实体身份的真实性</li><li>注册中心(RA): 负责最终用户的注册工作</li><li>证书库(Repo): 负责向所有用户公布数字证书与证书注销列表</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/PKI%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png" alt="PKI组成结构"></p><h3 id="8-1-4-PKI的功能-2"><a href="#8-1-4-PKI的功能-2" class="headerlink" title="8.1.4 PKI的功能(2)"></a>8.1.4 PKI的功能(2)</h3><p>根据上述PKI的组成, 我们可以更加细化一些PKI的功能:</p><ul><li>安全服务功能<ul><li>数字签名: 签名生成与签名验证</li><li>认证服务: 通常流程如下<ul><li>用户用私钥对自己的某些信息进行签名</li><li>验证方通过证书中的公钥来对这些信息进行验签</li></ul></li><li>时间戳服务: 证明一组数据在某个时间是否存在</li><li>安全公证服务: 即记录 &#x2F; 确认某个元素在某个时间点, 或者本身是否存在(通过签名来进行)</li><li>不可否认服务: 保证双方确实参与了某个具体行为</li></ul></li><li>系统服务功能<ul><li>证书的申请和审批: 用户必须先提供信息, PKI才能进行证书审批</li><li>密钥的生成和分发: 可以为用户产生并分发密钥</li><li>证书的颁发: 签发数字证书并存到证书库中</li><li>证书的撤销: 将过期的(或其它的原因而失效的)证书放入证书撤销列表中(CRL, Certificate Revocation List)</li><li>证书和目录查询: 提供为外界查询证书的接口</li><li>密钥的备份和恢复: 最终用户的密钥信息丢失时, 通过在线交换协议来完成这个过程</li><li>密钥的更新</li><li>密钥的历史档案: 由旧证书和历史密钥等旧信息组成</li><li>交叉认证: 一个CA给另一个CA认证证书, 这意味着两个CA域内部的用户可以进行安全通信</li></ul></li></ul><h2 id="8-2-信任模型"><a href="#8-2-信任模型" class="headerlink" title="8.2 信任模型"></a>8.2 信任模型</h2><h3 id="8-2-1-信任模型的基本概念"><a href="#8-2-1-信任模型的基本概念" class="headerlink" title="8.2.1 信任模型的基本概念"></a>8.2.1 信任模型的基本概念</h3><p>信任模型包含以下几种概念:</p><ul><li><strong>信任</strong> : 一个实体假定另一个实体会像它期望的那样表现, 则称这个实体信任它.</li><li><strong>信任域</strong> : 即一群实体都遵循同样的规则, 则它们处于同一个信任域中.</li><li><strong>信任锚</strong> : 意思是必须有一个足够有说服力的实体为你做担保, 别人才能信任你, 这个担保人就叫信任锚.</li><li><strong>信任关系</strong> : 经过一条条信任锚传递出去的信任链条被称为信任关系, 在验证实体身份时, 可以通过这种信任关系是否存在来进行.</li></ul><p>当前的信任模型主要关注三个问题:</p><ul><li>PKI颁发的证书是怎样被确定的?</li><li>信任是怎样建立的?</li><li>一定的环境下, 这种信任如何被控制?</li></ul><h3 id="8-2-2-信任模型的分类"><a href="#8-2-2-信任模型的分类" class="headerlink" title="8.2.2 信任模型的分类"></a>8.2.2 信任模型的分类</h3><p>当前PKI信任模型主要分以下四种:</p><ul><li>认证中心的严格层次结构模型</li><li>分布式信任结构模型</li><li>Web模型</li><li>以用户为中心的信任模型</li></ul><h3 id="8-2-3-认证中心的严格层次结构模型"><a href="#8-2-3-认证中心的严格层次结构模型" class="headerlink" title="8.2.3 认证中心的严格层次结构模型"></a>8.2.3 认证中心的严格层次结构模型</h3><p>基本上读者看到层次都能猜出来了, 没错, 就是树形模型.<br>其中根节点是对每个节点都有特别意义的CA.<br>从根节点发散出来的所有 <strong>非叶子节点</strong> 都是子CA.<br>而叶子节点通常就是用户节点.</p><p>这种结构的特点是每一个节点(叶子节点)都会信任它与根节点的路径上的全部节点.(根节点自然就被所有节点所信任)</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/PKI%E4%B8%A5%E6%A0%BC%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B.png" alt="PKI严格层次模型"></p><h3 id="8-2-4-分布式信任结构模型"><a href="#8-2-4-分布式信任结构模型" class="headerlink" title="8.2.4 分布式信任结构模型"></a>8.2.4 分布式信任结构模型</h3><p>与上一种情况相反, 将信任分散在2个甚至更多的CA上.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/PKI%E5%88%86%E5%B8%83%E5%BC%8F%E4%BF%A1%E4%BB%BB%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.png" alt="分布式信任结构模型"></p><h3 id="8-2-5-Web信任模型"><a href="#8-2-5-Web信任模型" class="headerlink" title="8.2.5 Web信任模型"></a>8.2.5 Web信任模型</h3><p>这里, 根CA变成了浏览器这个软件本身.<br>哎, 啥意思呢, 就是浏览器预装了一些受信任的CA根证书, 用户默认即信任它们.</p><p>这个过程整体而言对于用户是透明的, 比较方便.<br>但坏处也很明显, 如果某个CA被攻破了, 代表着会引起一系列的安全问题.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/Web%E4%BF%A1%E4%BB%BB%E6%A8%A1%E5%9E%8B.png" alt="Web信任模型"></p><h3 id="8-2-6-以用户为中心的信任模型"><a href="#8-2-6-以用户为中心的信任模型" class="headerlink" title="8.2.6 以用户为中心的信任模型"></a>8.2.6 以用户为中心的信任模型</h3><p>与Web的模式相反, 这种情况是完全由用户自己决定信任哪个证书, 不信任哪个证书.<br>进而多个用户能够构建起一个很庞大的信任网络.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E4%BB%A5%E7%94%A8%E6%88%B7%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E4%BF%A1%E4%BB%BB%E6%A8%A1%E5%9E%8B.png" alt="以用户为中心的信任模型"></p><h2 id="8-3-证书"><a href="#8-3-证书" class="headerlink" title="8.3 证书"></a>8.3 证书</h2><p>PKI签发的就是这个玩意, 它是一种在互联网上用于验证身份的证明文件.</p><h3 id="8-3-1-证书格式"><a href="#8-3-1-证书格式" class="headerlink" title="8.3.1 证书格式"></a>8.3.1 证书格式</h3><p>以X. 509数字证书为例, 列举出证书的格式内容:</p><ul><li>版本号: 编码证书的版本</li><li>序列号: 唯一</li><li>签名算法标识: 即CA在证书上用了什么方法签名</li><li>颁发者: 在证书上签名的实体</li><li>有效期限</li><li>主题: 标识申请证书者</li><li>主题公开密钥信息: 即主题选择公开的公钥信息 &#x2F; 使用的非对称算法等</li><li>颁发者唯一标识符</li><li>主题唯一标识符</li><li>签名</li></ul><p>其实实质上就是公钥管理机构在 <strong>你的公钥</strong> 上用 <strong>它的私钥</strong> 签了个名, 证明你的身份.</p><p>当前X. 509 的主流版本是 v3 .</p><h3 id="8-3-2-证书的存储载体"><a href="#8-3-2-证书的存储载体" class="headerlink" title="8.3.2 证书的存储载体"></a>8.3.2 证书的存储载体</h3><p>证书的存储主要有两种种形式:</p><ul><li>磁盘方式: 成本低, 但是容易被毁坏 &#x2F; 盗用</li><li>USB Key: 可移动的USB计算设备</li></ul><h3 id="8-3-3-证书的申请-发放-维护以及撤销"><a href="#8-3-3-证书的申请-发放-维护以及撤销" class="headerlink" title="8.3.3 证书的申请 &#x2F; 发放 &#x2F; 维护以及撤销"></a>8.3.3 证书的申请 &#x2F; 发放 &#x2F; 维护以及撤销</h3><p>证书的申请需要个人向PKI进行申请, 而其实核心就在于PKI的认证中心(CA)组件.<br>认证中心是一个权威的, 可信的, 公正的第三方机构, 专门负责发放管理数字证书.</p><p>其中有一个关键环节是证书关于申请者信息的认证, 涉及到CA中的一个子组件叫 <strong>注册中心RA</strong> . 它负责对证书申请者进行资格审查并决定是否同意发放证书.</p><p>维护与撤销同样归CA进行管理, 它会在证书失效时在 <strong>证书撤销列表(CRL)</strong> 中添加对应的表项, 而这个证书撤销列表能够通过在线证书状态协议OCSP进行查询.</p><h2 id="8-4-TLS-SSL"><a href="#8-4-TLS-SSL" class="headerlink" title="8.4 TLS &#x2F; SSL"></a>8.4 TLS &#x2F; SSL</h2><p>SSL即安全套接字(Secure Socket Layer)的简写, 是Web浏览器与Web服务器之间安全交换信息的协议.<br>TLS是它的升级版本.</p><p>其工作原理通过三个子协议来进行:</p><ul><li>握手协议(Handshake)</li><li>记录协议(Record)</li><li>警报协议(Alert)</li></ul><h3 id="8-4-1-Handshake"><a href="#8-4-1-Handshake" class="headerlink" title="8.4.1 Handshake"></a>8.4.1 Handshake</h3><p>过程如下:</p><ul><li>$ client \to server $ : 客户端初始消息<ul><li>支持的TLS版本</li><li>支持的加密算法</li><li>随机数</li><li>支持的压缩方法</li></ul></li><li>$ server \to client $ : 服务器初始消息<ul><li>确定使用的TLS版本</li><li>选择的加密算法</li><li>服务器证书(含有公钥)</li><li>随机数</li></ul></li><li>$ server \to client $ : 服务器鉴别和密钥交换<ul><li>服务器的证书及证书链: 用于向客户端证明服务器的身份</li><li>服务器公钥</li><li>证书请求(即向客户端请求证书): 包含可以接收的证书列表.</li><li>握手完成</li></ul></li><li>$ client \to server $ : 客户端鉴别和密钥交换<ul><li>客户端的证书和证书链(可选项, 目的同上一步)\</li><li>客户端公钥</li><li>证书验证(证明自己用有证书的私钥)</li></ul></li><li>$ client \to server $ : 更改密码规格</li><li>$ server \to client $ : 更改密码规格</li></ul><h3 id="8-4-2-关于密钥交换以及不同密钥的说明"><a href="#8-4-2-关于密钥交换以及不同密钥的说明" class="headerlink" title="8.4.2 关于密钥交换以及不同密钥的说明"></a>8.4.2 关于密钥交换以及不同密钥的说明</h3><p>上面一整个过程中涉及到一次密钥交换以及两种密钥:</p><p>一次密钥交换是指第三步和第四步, 客户端和服务器端向对方发送了自己的公钥, 这实际上是通过Diffie-Hellman计算出了一个两方共享的密钥, 这个密钥我们称之为 <strong>预主密钥(Pre-Master Secret)</strong> .</p><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>Diffie-Hellman是非常常用的密钥交换协议, 不了解的读者可以去自行查阅看一下, 不是很难, 这里不费笔墨了.<br>如果不想查看, 也可以直接了解它的作用, 就是让双方得知了一个相同的密钥.</p></blockquote><p>现在双方都有一个相同的密钥了, 但是一直用这个密钥显然不符合安全标准, 因此还要通过这个 <strong>预主密钥</strong> 到腾出一个 <strong>主密钥(Master Secret)</strong> .<br>这时候, 在第一步和第二步发的随机数就起到作用了, 这个主密钥一般是:</p><p>$$ master \  secret &#x3D; PRF(pre \  master \  secret, “master \  secret”, client \  random + server \  random) $$</p><p>PRF是个伪随机函数, 通过如下三部分得到一个主密钥, 随后再通过这个主密钥来生成一些对称密钥即可.</p><h3 id="8-4-3-TLS记录协议"><a href="#8-4-3-TLS记录协议" class="headerlink" title="8.4.3 TLS记录协议"></a>8.4.3 TLS记录协议</h3><p>这个协议为高层协议提供一些基本功能支持, 比如:</p><ul><li>数据封装</li><li>加密</li><li>压缩</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 信息安全专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融数据安全 </tag>
            
            <tag> Financial data security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融数据安全-Chap.7</title>
      <link href="/posts/45651.html"/>
      <url>/posts/45651.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-7-隐私保护技术"><a href="#Chap-7-隐私保护技术" class="headerlink" title="Chap.7 隐私保护技术"></a>Chap.7 隐私保护技术</h1><h2 id="7-1-隐私-隐私保护"><a href="#7-1-隐私-隐私保护" class="headerlink" title="7.1 隐私 &#x2F; 隐私保护"></a>7.1 隐私 &#x2F; 隐私保护</h2><h3 id="7-1-1-隐私的范围"><a href="#7-1-1-隐私的范围" class="headerlink" title="7.1.1 隐私的范围"></a>7.1.1 隐私的范围</h3><p>个人隐私在定义中通常分以下两种:</p><ul><li>已经识别出来的数据: 指可以用来确认某个自然人的数据</li><li>可以识别出来的数据: 指那些与自然人间接相关, 通过分析推理能够确定某个自然人的数据</li></ul><p>通常会涉及到四个参与方:</p><ul><li>个人用户</li><li>数据采集 &#x2F; 发布者</li><li>数据使用者</li><li>攻击者</li></ul><p>因此, 隐私保护主要针对以下三方面:</p><ul><li>身份隐私: 降低从数据直接推断出特定用户的可能性</li><li>属性隐私: 对用户属性信息进行有针对性地处理</li><li>社交关系隐私: 节点对应的社交关系应当匿名处理</li></ul><h3 id="7-1-2-隐私保护技术"><a href="#7-1-2-隐私保护技术" class="headerlink" title="7.1.2 隐私保护技术"></a>7.1.2 隐私保护技术</h3><p>当前主要存在的隐私保护技术分以下两类:</p><ul><li>基于等价类的隐私保护<ul><li>通过对数据进行泛化 &#x2F; 抑制, 使得每条记录都与一定数量的记录不可区分.</li></ul></li><li>基于差分隐私的隐私保护<ul><li>在查询结果中加入噪声, 使攻击者无法确认某个记录是否存在</li></ul></li></ul><p>常见的手段包括:</p><ul><li>抑制: 数据置空</li><li>泛化: 降低数据精度</li><li>置换: 改变数据属主</li><li>扰动: 添加噪声</li><li>裁剪: 数据分散发布</li><li>密码学: 使用加密等手段</li></ul><h2 id="7-2-关系型数据隐私保护"><a href="#7-2-关系型数据隐私保护" class="headerlink" title="7.2 关系型数据隐私保护"></a>7.2 关系型数据隐私保护</h2><h3 id="7-2-1-链接攻击与身份匿名"><a href="#7-2-1-链接攻击与身份匿名" class="headerlink" title="7.2.1 链接攻击与身份匿名"></a>7.2.1 链接攻击与身份匿名</h3><p>最简单的方式是将数据库中能够唯一标识个人的信息去除(匿名化).<br>但这种方式意味着如果攻击者有背景知识(了解攻击目标的其他信息), 就仍然能够快速定位到某个具体的攻击目标.</p><h3 id="7-2-2-k匿名"><a href="#7-2-2-k匿名" class="headerlink" title="7.2.2 k匿名"></a>7.2.2 k匿名</h3><p>指的是对表内的某些属性进行 <strong>泛化</strong> 操作, 使得每一条经过泛化的查询记录在表内至少有k个对应表项.</p><p><strong>泛化</strong> 指的是对数据的模糊化:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E6%B3%9B%E5%8C%96.png" alt="泛化"></p><p>当你把表中的很多数据都泛化时, 就会发现符合条件的表项变多了, 那自然攻击者也无法精准的找到某一个具体的角色了.</p><p>这种方式能够做到:</p><ul><li>攻击者无法知道个人是否在公开的数据中</li><li>给定一个人, 攻击者无法确认他是否有其它的敏感属性</li><li>攻击者无法确认某一个具体表项指的是哪个人</li></ul><p>当然, 这种情况下本质上是将一个人的查询结果变成了一群人, 但攻击者还是可以通过一些手段得知这个人具体的信息的, 只不过难度会稍高一些.</p><ul><li>同质化攻击: 某一组内对应的敏感信息完全相同, 这时候就无所谓哪个是哪个了:</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%90%8C%E8%B4%A8%E5%8C%96%E6%94%BB%E5%87%BB.png" alt="同质化攻击"></p><ul><li>未排序攻击: 即公开的数据记录跟原始记录一致, 那也可以很简单的猜出匿名化的记录的属主</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%94%BB%E5%87%BB.png" alt="未排序攻击"></p><ul><li>补充数据攻击: 即表格的筛选项多种多样时, 可以通过不同的筛选策略一并对比得到一些条目</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E8%A1%A5%E5%85%85%E6%95%B0%E6%8D%AE%E6%94%BB%E5%87%BB.png" alt="补充数据攻击"></p><h2 id="7-3-差分隐私"><a href="#7-3-差分隐私" class="headerlink" title="7.3 差分隐私"></a>7.3 差分隐私</h2><h3 id="7-3-1-差分隐私的具体流程"><a href="#7-3-1-差分隐私的具体流程" class="headerlink" title="7.3.1 差分隐私的具体流程"></a>7.3.1 差分隐私的具体流程</h3><p>显然, 上面的k匿名能起到一定作用, 但在涉及到大量数据以及比较特殊的情况时, 我们会发现还是有个别的数据被泄露了.</p><p>因此差分隐私的思路被提出:<br>通过随机算法对发布的信息作随机扰动, 如果攻击者无法判别信息来自于哪个数据集, 则可以说明数据集内的角色隐私受到了保护.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%B7%AE%E5%88%86%E9%9A%90%E7%A7%81.png" alt="差分隐私"></p><p>本质上相当于是对统计数据增加了 <strong>噪声干扰</strong> , 而这个具体的噪声干扰大小, 是随机的.</p><hr><p>给出 <strong>敏感度</strong> 这一概念:<br><em>两个相邻数据集D, D’, 一个查询函数最大的变化范围.</em></p><p>啥意思呢, 就是要被保护的那个个体给这个数据集查询值带来的最大扰动.</p><p>公式为: $ \Delta f &#x3D;  max_{D, D’} | | f(D)-f(D’) | | &#x3D; \frac{personal \  max - personal \  min}{total \  count} $</p><p>举个例子, 比如统计你们公司的人均工资水平, 你们公司的总人数100人, 工资分布从 0 ~ 10000.</p><p>那 $ \Delta f &#x3D; \frac{10000 - 0}{100} &#x3D; 100 $</p><p>就是你能给你们公司统计值带来的最大变化量.</p><hr><p>然后这个噪声值Y, 我们就从这里面取, 具体取值是一个分布函数, 叫拉普拉斯随机噪声, 与一个参量值 $ \epsilon $ 相关, 这个参量越大, 噪声越小, 反之则越大.</p><p>$$ Y \sim L(0, \frac{\Delta f}{\epsilon}) $$</p><p>最后在统计数据里面加上这个噪声Y即可:</p><p>$$ M(D) &#x3D; f(D) + Y $$</p><hr><h3 id="7-3-2-两类差分隐私"><a href="#7-3-2-两类差分隐私" class="headerlink" title="7.3.2 两类差分隐私"></a>7.3.2 两类差分隐私</h3><p>差分隐私也分位置:</p><ul><li>中心化差分隐私: 认为第三方可信, 在服务器上集中差分隐私</li><li>本地化差分隐私: 认为第三方不可信, 直接在本地差分隐私完之后上传假数据</li></ul><h2 id="7-4-社会网络数据保护"><a href="#7-4-社会网络数据保护" class="headerlink" title="7.4 社会网络数据保护"></a>7.4 社会网络数据保护</h2><p>社会的网络数据通常以 <strong>图</strong> 的形式来展现, 因此, 图的节点自然有些特征, 有时攻击者能通过一些图的特征来确认节点的含义, 进一步对其发动隐私攻击.</p><p>图的节点最基本的特征是? <strong>度数</strong> .</p><h3 id="7-4-1-k度匿名"><a href="#7-4-1-k度匿名" class="headerlink" title="7.4.1 k度匿名"></a>7.4.1 k度匿名</h3><p>相当于不让图中产生度数唯一的节点, 每一个度数至少有k个节点.</p><p>那这有问题, 如果人就是很少, 度数就是唯一, 咋办呢?<br>有个算法叫 <strong>K-means聚类算法</strong></p><p>它的核心思路是这样:</p><ul><li>K是你要分成的组数. 设总节点数 N</li><li>在你的节点中找到两个作为收敛中心点</li><li>将全部节点根据距离左右两个中心点的距离来分组(比如有一个中心节点度数为1, 另一个中心节点度数为7, 那度数为6的节点就要归到7那一组).</li><li>将分组之后的节点重新计算中心节点度数, 重复上述过程, 直到最终度数稳定为止</li></ul><h3 id="7-4-2-子图攻击"><a href="#7-4-2-子图攻击" class="headerlink" title="7.4.2 子图攻击"></a>7.4.2 子图攻击</h3><p>子图攻击相当于针对某个特定信息的节点对全图进行子图搜索, 并找到一个符合预设结构的子图.</p><p>我们给出一个定义 <strong>d层子图</strong> :<br><em>在图G中, 由其中某个节点v以及与该节点距离不超过d的节点构成的子图</em></p><p>因此, 最好的方式是构造一个 <strong>d-k匿名社会网络</strong> : </p><p><em>保证对于任意一个节点, 至少有其余k-1个节点, 它们的d层子图同构</em></p><p>这样的话, 攻击者就只能找到k个子图结构, 但是不知道到底哪个是被攻击的目标.</p><p>这种算法的思路是:</p><ul><li>提取出所有节点的d层子图, 然后用迭代哈希对所有的子图进行映射编码.</li><li>最后将k个节点的子图匿名成同构结构.达到对于图的修正目的</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 信息安全专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融数据安全 </tag>
            
            <tag> Financial data security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融数据安全-Chap.6</title>
      <link href="/posts/29330.html"/>
      <url>/posts/29330.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-6-安全处理技术"><a href="#Chap-6-安全处理技术" class="headerlink" title="Chap.6 安全处理技术"></a>Chap.6 安全处理技术</h1><h2 id="6-1-安全处理技术的概念及必要性"><a href="#6-1-安全处理技术的概念及必要性" class="headerlink" title="6.1 安全处理技术的概念及必要性"></a>6.1 安全处理技术的概念及必要性</h2><h3 id="6-1-1-同态加密的概念"><a href="#6-1-1-同态加密的概念" class="headerlink" title="6.1.1 同态加密的概念"></a>6.1.1 同态加密的概念</h3><p>安全处理技术解决的情况是: 用户想让第三方帮自己处理数据, 但同时又不希望数据本身遭到泄露.</p><p>这种情况下, <strong>同态加密</strong> 就应运而生, 其大致分为三步:</p><ul><li>用户在客户端本地加密, 随后将数据发送给云</li><li>云端对加密过后的数据进行运算处理, 但本身由于数据加密无法得到有效信息</li><li>处理完成后用户拿回处理结果, 基于密钥对数据进行解密, 得到运算完毕后的数据.</li></ul><p>相信大伙都看出来了, 这东西想要达成的目的是: <strong>对密文数据进行计算, 解密后能得到与对明文数据直接计算相同的结果</strong> .</p><h3 id="6-1-2-同态加密的方案过程"><a href="#6-1-2-同态加密的方案过程" class="headerlink" title="6.1.2 同态加密的方案过程"></a>6.1.2 同态加密的方案过程</h3><p>同态加密通常有四个需要实现的过程:</p><ul><li>KeyGen: 生成公私钥(sk, pk)</li><li>Encrypt: 输入明文m, 加密得到密文 $ c &#x3D; Encrypt(pk, m) $</li><li>Decrypt: 输入私钥sk和密文c, 得到明文 $ m &#x3D; Decrypt(sk, c) $</li><li>Evaluate: 输入公钥pk和布尔电路C以及密文 $ \vec{c} $ , 得到 $ c^* &#x3D; Evaluate(pk, C, \vec{c}) $</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86.png" alt="同态加密"></p><p>需要给出三个定义, 供读者区分:</p><ul><li>一个方案的正确性: 即对于一个方案 $ \epsilon &#x3D; (KeyGen, Encrypt, Decrypt, Evaluate) $ 而言, 如果对于这个方案内给出的布尔电路, 加密完运算再解密的结果与直接运算的结果相同, 则说明这个方案是正确的.</li><li>同态加密: 即给出的加解密算法对于一类布尔电路 $ \mathbb{C} $ 是正确的</li><li>全同态加密(最严格的定义): 给出的加解密算法对于所有的布尔电路都是正确的</li></ul><h2 id="6-2-同态加密的基础-语义安全性"><a href="#6-2-同态加密的基础-语义安全性" class="headerlink" title="6.2 同态加密的基础: 语义安全性"></a>6.2 同态加密的基础: 语义安全性</h2><h3 id="6-2-1-可忽略函数"><a href="#6-2-1-可忽略函数" class="headerlink" title="6.2.1 可忽略函数"></a>6.2.1 可忽略函数</h3><p>我们首先需要引入一个概念叫 <strong>可忽略函数</strong> :</p><p>一个函数 $ f(n) $ 是可忽略的, 代表着对于任何正整数c, 都存在足够大的 $ n_0 $ 使得当 $ n &gt; n_0 $ 时都有:</p><p>$$ f(n) &lt; \frac{1}{n^c} $$</p><p>这代表着, $ f(n) $ 是随着安全参数n变大而变得非常小的函数, 小到比任何多项式的倒数都要小.<br>我们一般把一个可忽略函数记为 $ \mu(n) $ .</p><p>这玩意有啥用呢?<br>通常用它来衡量攻击者能够攻击成功的概率.</p><h3 id="6-2-2-挑战游戏与语义安全性"><a href="#6-2-2-挑战游戏与语义安全性" class="headerlink" title="6.2.2 挑战游戏与语义安全性"></a>6.2.2 挑战游戏与语义安全性</h3><p>通常语义安全性会与一个挑战游戏相关, 我们称之为 $ Game_{A, \epsilon}(\lambda) $ :  </p><ul><li>挑战者生成公私钥(pk, sk), 将公钥pk发给敌手A</li><li>敌手A得到pk, 生成两段等长的消息 $ m_0, m_1 $</li><li>挑战者选择第0条或者第1条消息加密发回给A, 选择记为 $ b $</li><li>A去猜测这个加密过后的消息是来自 $ m_0 $ 还是 $ m_1 $ 的, 输出 $ b’ $</li><li>如果猜对了, 则游戏成功, 否则游戏失败.</li></ul><hr><p>我们说的 <strong>语义安全性</strong> 意思是:</p><p>攻击者无法从我们给出的密文中得到非常显著的, 能有助于其猜到加密原文的助益. 即:</p><p>$$ | Pr[b’ &#x3D; b] - \frac{1}{2} | \leq \mu(n) $$</p><p>满足了语义安全性, 我们能确保计算方无法根据我们提交的密文得到我们的明文到底是什么.</p><h2 id="6-3-计算结果的正确性"><a href="#6-3-计算结果的正确性" class="headerlink" title="6.3 计算结果的正确性"></a>6.3 计算结果的正确性</h2><p>解决了机密性, 我们现在需要着眼于正确性, 对啊, 怎么能保证对面算出来的东西没错呢?<br>这个问题通常有几种方式:</p><ul><li>复制: 让多个服务器都干这个活, 取最多的相同结果</li><li>审计: 我自己算一部分, 对比结果</li><li>可验证计算: 基于密码学的方法</li></ul><h3 id="6-3-1-两方参与的可验证计算"><a href="#6-3-1-两方参与的可验证计算" class="headerlink" title="6.3.1 两方参与的可验证计算"></a>6.3.1 两方参与的可验证计算</h3><p>可验证计算的本质其实是将两方抽象化了:</p><ul><li>验证方: 计算能力弱, 但可信(客户端)</li><li>证明方: 计算能力强, 但不可信(服务器)</li></ul><p>实际上, 其思路就是: 我要让服务器给我一个简易的证明过程, 使得我能很方便的确认你给我的结果是没错的.<br>我们用数学语言写一下:</p><p>验证方给定输入 $ x $ 和函数(运算) $ f $ , 证明者期望产生一个输出 $ y $ 以及相应的证明 $ p $ , 证明内容就是 $ y &#x3D; f(x) $ . 验证者要用这个证明 $ p $ 来验证整个计算的正确性.</p><p>当然, 这里涉及到两个前提, 都很好理解:</p><ul><li>合理性条件: 就是说, 你产生的这个证明 $ p $ , 效率必须要高于我自己算一遍 $ f(x) $ . <del>(对啊, 要不然我为啥不自己算捏)</del></li><li>安全性条件: 就是说, 你为造一个 $ y^* , p^* $ , 使得用 $ p^* $ 来证明 $ y^* &#x3D; f(x) $ 是不可行的.(说白了就是你给我的这个证明必须是有效真实的, 要不然就没意义了)</li></ul><p>读者可能很好奇了, 哎, 这种玩意真存在吗?<br>还真有, 因为我们要搞的是证明工作, 因此可以用概率的知识.</p><p>有种玩意叫 <strong>概率检测证明(PCP, Probabilistically Checkable Proof)</strong> , 就是证明者为了验证某一结论的合法性而给出的一个串, 其性质是验证者只需要查看PCP的一个常数常量就可以检测PCP的合法性.</p><h3 id="6-3-2-比特承诺"><a href="#6-3-2-比特承诺" class="headerlink" title="6.3.2 比特承诺"></a>6.3.2 比特承诺</h3><p>比特承诺想干的事情比较简单:<br>A发送给B一个证明(承诺), 承诺的内容是一个比特:</p><ul><li>A在打开这个承诺之前, B无法得知里面是什么</li><li>A也不能篡改这个打开的承诺</li></ul><p>因此比特承诺也就自然的被分为了两个阶段:</p><ul><li>承诺阶段: A选择一个比特(0, 1), 并将能够代表这个比特的消息c发给B</li><li>打开阶段: A把打开这个承诺的方案d以及承诺文b交给B, B打开c, 并验证里面是不是b.</li></ul><p>需要满足的两个性质也比较好理解, 就是我们之前说的那两条:</p><ul><li>隐藏性: 在承诺阶段，接收方无法知道被承诺的值</li><li>绑定性: 承诺方在揭示时无法更改自己原本承诺的值</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%88%A9%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E6%AF%94%E7%89%B9%E6%89%BF%E8%AF%BA.png" alt="利用对称加密的比特承诺"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%9F%BA%E4%BA%8E%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E7%89%B9%E6%89%BF%E8%AF%BA.png" alt="基于单向散列函数的比特承诺"></p><p>上面这两种我们都比较熟悉(也许不熟悉? 请了解加密算法以及哈希后如闪电般归来!)<br>下面还有一种比较高级的, 它基于二次剩余.</p><hr><p>回顾一下二次剩余, 定义如下:<br>对于X, d, p, 如果存在:</p><p>$$ X^2 \equiv d \space mod \space p $$</p><p>则称d是模p的二次剩余.</p><p>比如1, 2, 4就是模7的二次剩余.</p><hr><p>现在我们来讲这个高级的法子奥:</p><p><strong>基于Goldwasser-Micali的比特承诺</strong></p><ul><li>承诺阶段: <ul><li>令 $ n &#x3D; pq $ , 其中 $ p, q $ 都是大素数. 选择模n的 <strong>非二次剩余m</strong> .</li><li>A随机选择 $ r \in Z_n^* , b \in \lbrace 0, 1 \rbrace $</li><li>计算 $ y &#x3D; f(r, b) &#x3D; m^b r^2 \space mod \space n $</li></ul></li><li>打开阶段:<ul><li>A只需要揭示b, r即可</li><li>B验证是否成立即可</li></ul></li></ul><h3 id="6-3-3-交互证明"><a href="#6-3-3-交互证明" class="headerlink" title="6.3.3 交互证明"></a>6.3.3 交互证明</h3><p>这个东西的本质是在用概率的方式来向他人证明我 <strong>有能力解决某个问题 &#x2F; 有某个知识</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E4%BA%A4%E4%BA%92%E8%AF%81%E6%98%8E.png" alt="交互证明"></p><p>这个例子很好的说明了交互证明的思想.<br>并能够引出我们之后想说的: <strong>零知识证明(Zero Knowledge Proof)</strong></p><h3 id="6-3-4-零知识证明"><a href="#6-3-4-零知识证明" class="headerlink" title="6.3.4 零知识证明"></a>6.3.4 零知识证明</h3><p>零知识证明想解决什么问题呢?<br>即A向B证明我能解决某个问题, 但是B只能得到A的证明过程, 而自己仍然无法解出这道难题.</p><p>其必须具有的性质如下:</p><ul><li>完备性: 证明者能够在多项式时间内提供证明过程</li><li>合法性: 验证者能够在多项式时间内跑完这个证明过程, 并确认其正确性</li><li>零知识特性: 证明过程不会暴露证明者所拥有的知识</li></ul><p>显然, 这个零知识其实很难做到, 毕竟我们需要提供证明方案对吧.</p><ul><li>完美零知识: 我提供的证明, 就算敌手的算力无穷无尽, 也无法通过我的这个证明得到任何有助于这个难题的信息</li><li>统计零知识: 我提供的证明, 确实与解决这个难题的方法微弱相关, 但是任何算力有限的敌手(多项式敌手)都无法通过这个证明来得到解题信息</li></ul><h2 id="6-4-安全多方计算"><a href="#6-4-安全多方计算" class="headerlink" title="6.4 安全多方计算"></a>6.4 安全多方计算</h2><p>解决的是多个数据所有者在互不信任的条件下进行的协同计算.</p><h3 id="6-4-1-Sharmir门限方案"><a href="#6-4-1-Sharmir门限方案" class="headerlink" title="6.4.1 Sharmir门限方案"></a>6.4.1 Sharmir门限方案</h3><p>秘密即构造一个k-1次多项式P(意味着只需要k个点就应该能够重现这个多项式), 而秘密通常被编码成这个多项式的一个点(截距, P(0))</p><p>$$ P(x) &#x3D; S + a_1 x + a_2 x^2 + \ldots + a_{k-1} x^{k-1} \pmod p $$</p><p>现在假设总共N个人, 需要至少凑齐k个人才能还原多项式, 得到秘密.</p><p>因此步骤如下:</p><ul><li>秘密分发:<ul><li>选择模数p</li><li>选择N个不大于p的数 $ x_1, x_2, …, x_{N} $ , 分别计算 $ P(x_1), P(x_2), …, P(x_{N}) $</li><li>分发给N个人 $ (x_i, P(x_i)) $</li></ul></li><li>秘密重构:<ul><li>相当于集齐k个人, 就可以求出这个多项式, 并得到秘密.</li></ul></li></ul><p>这里重构多项式可以用拉格朗日插值法直接得到P(0):</p><p>$$ P(x) &#x3D; \sum_{j&#x3D;1}^{k} y_j \prod_{m&#x3D;1, m \neq j}^{k} \frac{x - x_m}{x_j - x_m} \pmod p $$</p><p>当然, 如果多项式次数比较小, 也是可以直接解方程先解出多项式, 再求值.</p><h3 id="6-4-2-混淆电路"><a href="#6-4-2-混淆电路" class="headerlink" title="6.4.2 混淆电路"></a>6.4.2 混淆电路</h3><p>这个情景是 A B 希望一块计算一个函数(可以看作是一个逻辑门), 即 $ f(x, y) &#x3D; x \  AND \  y $</p><p>但是A不希望B知道我输入了什么, B也不希望A知道我输入了什么.</p><p>因此可以这样做:<br>这个过程中一定有一个 <strong>构造方</strong> , 假设是A :</p><ul><li>为自己的输入生成两个密钥 $ k_{0x}, k_{1x} $</li><li>为对方的输入生成两个密钥 $ k_{0y}, k_{1y} $</li><li>为输出生成两个密钥 $ k_{0z}, k_{1z} $</li></ul><p>然后构造一个混淆真值表: 就是把这个</p><p>$$<br>\begin{array}{c|c|c}<br>    A &amp; B &amp; A \land B \\<br>    \hline<br>    0 &amp; 0 &amp; 0 \\<br>    \hline<br>    0 &amp; 1 &amp; 0 \\<br>    \hline<br>    1 &amp; 0 &amp; 0 \\<br>    \hline<br>    1 &amp; 1 &amp; 1<br>\end{array}<br>$$</p><p>变成这个:</p><p>$$<br>\begin{align*}<br>    E_{k_{0x}}(E_{k_{0y}}(k_{0z})) \\<br>    E_{k_{1x}}(E_{k_{0y}}(k_{0z})) \\<br>    E_{k_{0x}}(E_{k_{1y}}(k_{0z})) \\<br>    E_{k_{1x}}(E_{k_{1y}}(k_{0z}))<br>\end{align*}<br>$$</p><p>随后:</p><ul><li>把这四条打乱顺序发给B</li><li>把自己的选择对应的密钥(自己选0就发 $ k_{0x} $ ) , 发给B</li><li>把B的两个密钥( $ k_{0y}, k_{1y} $ )都发过去</li></ul><p>B收到这些玩意, 拿A发过来的密钥以及自己的选择密钥来解密. 得到 $ k_{ _ z} $ , 再把这东西根据上面的翻译表得到结果, 把 <strong>结果(0 &#x2F; 1)</strong> 发回给A.</p><p>A这时候就能知道最终的结果, 但A也不知道B的选择是啥.</p><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>这个位置读者可能会很疑惑, 假如A选了1, 得到结果后不就自然能够得知B的选择了?<br>是的, 我们必须承认这种情况下A一定能够得到B的输出. 但还请读者注意, 这不是由于方案的问题, 这是函数的性质(因为我们选择的是一个简单的与门)<br>如果我们构造一个更加复杂的函数, (即通过我的选择和结果完全无法得知对方的选择时), 这种情况就不会发生.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 信息安全专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融数据安全 </tag>
            
            <tag> Financial data security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融数据安全-Chap.5</title>
      <link href="/posts/29650.html"/>
      <url>/posts/29650.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-5-安全检索技术"><a href="#Chap-5-安全检索技术" class="headerlink" title="Chap.5 安全检索技术"></a>Chap.5 安全检索技术</h1><h2 id="5-1-安全检索的概念以及必要性"><a href="#5-1-安全检索的概念以及必要性" class="headerlink" title="5.1 安全检索的概念以及必要性"></a>5.1 安全检索的概念以及必要性</h2><p>云存储使得数据的所有权和管理权相互分离, 因此如何保证云数据的安全性成为了问题.<br>通用的方法是用户首先使用安全的加密机制(各种加密算法)对数据进行加密后上传至云服务器. 随后需要本地取用则只需要将密文下载至本地即可.</p><p>这个过程有其问题, 因为它要求客户端需要有较大的存储空间和计算能力, 反而减弱了云存储的优势.</p><h3 id="5-1-1-密文检索"><a href="#5-1-1-密文检索" class="headerlink" title="5.1.1 密文检索"></a>5.1.1 密文检索</h3><p><strong>密文检索(Searchable Encryption, SE)</strong> 的概念是:</p><p><em>云存储系统在密文场景下对用户数据进行检索，然后将满足检索条件的密文数据返回给用户。</em></p><p>显然, 云服务器在这个过程中收到的是密文, 因此无法获得用户的敏感数据和查询条件. 这保护了数据机密性和查询机密性.<br>通常这个过程涉及到三种角色:</p><ul><li>数据所有者: 即敏感数据的拥有者, 上传密文数据并生成索引</li><li>数据检索者: 查询请求的发起者, 生成陷门并发送给服务器</li><li>服务器: 为二者提供服务, 由云服务提供商进行管理和维护, 通过内置定义好的匹配算法将来自检索者的陷门和所有者的索引相匹配, 并返回给检索者以密文数据.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%AF%86%E6%96%87%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B.png" alt="密文检索系统流程"></p><p>根据应用场景的不同, 可以分为两大类:</p><ul><li>对称密文检索(SSE): 只有数据所有者拥有密钥, 也只有数据所有者可以提交数据 &#x2F; 生成陷门. 这种情况下数据所有者和数据查询者是一个人.</li><li>非对称密文检索(ASE): 任何能够获取到数据检索者公钥的用户都能够提交数据, 但只有数据检索者能够生成陷门.</li></ul><p>同时根据数据类型的不同, 又可以将检索分为两类:</p><ul><li>关键词检索(主要搜索字符型数据)</li><li>区间检索(对数值型数据进行范围查询)</li></ul><h2 id="5-2-早期安全检索技术"><a href="#5-2-早期安全检索技术" class="headerlink" title="5.2 早期安全检索技术"></a>5.2 早期安全检索技术</h2><h3 id="5-2-1-PIR技术"><a href="#5-2-1-PIR技术" class="headerlink" title="5.2.1 PIR技术"></a>5.2.1 PIR技术</h3><p>PIR(Private Information Retrieval)主要针对公开数据库, 目标是允许用户不向服务器暴露意图的前提下得到自己需要的内容.</p><p>这个方案比较复杂, 我们用一个例子来解释:<br>我们假设有矩阵:</p><p>$$<br>\begin{pmatrix}<br>    1 &amp; 2 &amp; 3 &amp; 4 \\<br>    5 &amp; 6 &amp; 7 &amp; 8 \\<br>    9 &amp; 10 &amp; 11 &amp; 12 \\<br>    13 &amp; 14 &amp; 15 &amp; 16<br>\end{pmatrix}<br>$$</p><p>假设用户要查询一个 $ x_{3, 2} &#x3D; 10 $ .<br>正常的思路是我直接给服务器发, 说我要查 $ x_{3, 2} $ , 但很可惜, 这样我们的意图就被服务器看的一清二楚.</p><p>因此我们想了个法子, 把我们的意图隐藏一下:<br>先把我们要查的东西转成一串二进制数: $ x_{3, 2} \to x_{i_1, i_2} &#x3D; x_{0010, 0100} $ , 1在第几位就是坐标.<br>随后我们生成两个 <strong>随机数</strong> : $ \delta &#x3D; 1001, \tau &#x3D; 0010 $ .<br>我们要让随机数跟我们要查询的坐标有点联系, 所以我们计算: $ \delta_1 &#x3D; \delta \oplus i_1 &#x3D; 1011, \tau_1 &#x3D; \tau \oplus i_2 &#x3D; 0110 $</p><p>我们要向多个服务器发送请求(假设每个服务器存储的信息是相同的, 也就是上面的这个矩阵).<br>怎么发呢:</p><ul><li>向第一个服务器发送 $ \delta, \tau $</li><li>向第二个服务器发送 $ \delta, \tau_1 $</li><li>向第三个服务器发送 $ \delta_1, \tau $</li><li>向第四个服务器发送 $ \delta_1, \tau_1 $</li></ul><p>服务器收到这些请求之后会返回结果: $ \oplus_{\delta(j_1) &#x3D; 1, \tau(j_2) &#x3D; 1} x_{j_1, j_2} $ . 这是个贼抽象的式子, 啥意思呢: 就是把第一个数为1的地方当作横坐标, 第二个数为1的地方当作纵坐标, 组合一下之后全部异或, 再返回这个值.</p><p>举个例子, 比如我们向第一个服务器发的值是 $ \delta, \tau &#x3D; 1001, 0010 $ , 也就是取出 $ x_{1, 3} $ 和 $ x_{4, 3} $ 来异或, 返回这个结果: $ 3 \oplus 15 &#x3D; 12 $</p><p>我们照着这个规律得到全部的返回结果:</p><ul><li>第一个服务器返回12</li><li>第二个服务器返回0</li><li>第三个服务器返回7</li><li>第四个服务器返回1</li></ul><p>随后客户端把这四个数再做异或, 就能得到正确结果 $ 12 \oplus 0 \oplus 7 \oplus 1 &#x3D; 10 $</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/PIR%E6%96%B9%E6%A1%88.png" alt="PIR方案"></p><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>上述方案是一个典型的4服务器PIR方案, 实际上, PIR服务器数量并不是固定的, 信息论上来讲, PIR的服务器只需要 $ \geq 2 $ 即可.<br>对于查询数字(也就是发给服务器数字)的长度, 通常是 $ \sqrt{n} $ , 其中n是数据总量.</p></blockquote><h3 id="5-2-2-ORAM技术"><a href="#5-2-2-ORAM技术" class="headerlink" title="5.2.2 ORAM技术"></a>5.2.2 ORAM技术</h3><p>ORAM认为整个服务器的存储介质都是不安全的, 因此数据是加密的, 并且要向服务器隐藏读写两种操作.<br>ORAM实际上的思路是将一次操作转化为多次操作(其中可能混杂着不相关的操作), 这使得服务器完全不知道你的目的是什么, 即使它都知道你干了什么.</p><p>这种方式的技术实现难度要远高于PIR, 因此本博客中就不详细叙述了, 有兴趣的读者自行了解吧. <del>(我也不会.jpg)</del></p><h2 id="5-3-对称密文检索技术"><a href="#5-3-对称密文检索技术" class="headerlink" title="5.3 对称密文检索技术"></a>5.3 对称密文检索技术</h2><p>我们上文提过, 对称密文检索技术即 <strong>数据所有者与数据检索者</strong> 是同一方. 这适用于大部分第三方存储.</p><p>通常一个对称密文检索技术包含四部分算法:</p><ul><li>Setup: 数据所有者执行, 生成用于加密数据 &#x2F; 索引的密钥</li><li>BuildIndex: 数据所有者执行, 根据数据内容建立索引</li><li>GenTrapDoor: 数据检索者执行, 生成陷门(搜索凭证)</li><li>Search: 服务器执行, 将接收到的陷门和本地索引进行比对, 引入预设计算过程并返回密文结果.</li></ul><h3 id="5-3-1-基于全文扫描的方案"><a href="#5-3-1-基于全文扫描的方案" class="headerlink" title="5.3.1 基于全文扫描的方案"></a>5.3.1 基于全文扫描的方案</h3><p>该方案的核心思想是对明文进行分组加密, 并将加密后的结果与一个伪随机串异或得到索引.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%AF%B9%E7%A7%B0%E5%AF%86%E6%96%87%E6%A3%80%E7%B4%A2-%E5%9F%BA%E4%BA%8E%E5%85%A8%E6%96%87%E6%89%AB%E6%8F%8F%E7%9A%84%E6%96%B9%E6%A1%88.png" alt="对称密文检索-基于全文扫描的方案"></p><p>这种方案的缺点是可以看出来的, 它依靠对全文进行顺序扫描来进行检索, 因此最坏情况下(比如关键词在全文最后), 它需要检索完整篇文章才能够返回对应的密文, 效率较低.</p><h3 id="5-3-2-基于文档-关键词索引的方案"><a href="#5-3-2-基于文档-关键词索引的方案" class="headerlink" title="5.3.2 基于文档-关键词索引的方案"></a>5.3.2 基于文档-关键词索引的方案</h3><p>核心思路是为每篇文档建立单独的索引, 服务器搜索时遍历全部索引即可.</p><p>检索时间复杂度与文档数目成正比.</p><h3 id="5-3-3-基于布隆过滤器的密文关键词检索方案"><a href="#5-3-3-基于布隆过滤器的密文关键词检索方案" class="headerlink" title="5.3.3 基于布隆过滤器的密文关键词检索方案"></a>5.3.3 基于布隆过滤器的密文关键词检索方案</h3><p>首先了解一下布隆过滤器是什么, 这是一个用于快速判断某一个元素是否位于一个集合中的方法.</p><p>构造位数组BF, 长度为m.<br>设待检索集合 $ S &#x3D; [x_1, x_2, …, x_n] $<br>选取k个哈希函数 $ h_1, h_2, …, h_k $<br>分别对集合中的每个元素用这k个哈希函数进行运算, 并将运算出的哈希值记录下来, 将位数组对应位置的值记为1.</p><p>当需要判断y是否在S中时, 同样进行k次哈希运算, 如果得到的结果对应的位数组位置均为1, 则认为这个元素在S中.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%AF%B9%E7%A7%B0%E5%AF%86%E6%96%87%E6%A3%80%E7%B4%A2-%E5%9F%BA%E4%BA%8E%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E6%96%B9%E6%A1%88.png" alt="对称密文检索-基于布隆过滤器的方案"></p><h3 id="5-3-4-基于关键词-文档的方案"><a href="#5-3-4-基于关键词-文档的方案" class="headerlink" title="5.3.4 基于关键词-文档的方案"></a>5.3.4 基于关键词-文档的方案</h3><p>相当于倒过来, 原先都是为文档单独创建索引, 这里为某个关键词单独创建索引. 这使得查找效率大大提升.</p><p>这种方式实现起来实在复杂, 就不整理了.</p><h2 id="5-4-非对称密文检索技术"><a href="#5-4-非对称密文检索技术" class="headerlink" title="5.4 非对称密文检索技术"></a>5.4 非对称密文检索技术</h2><p>非对称密文我们在开始的时候也提及了, 是一个数据拥有者和检索者并非同一人的情形. 但其算法结构其实跟对称密文检索技术是相似的:</p><ul><li>Setup: 数据所有者执行, 生成用于加密数据 &#x2F; 索引的密钥</li><li>BuildIndex: 数据所有者执行, 根据数据内容建立索引</li><li>GenTrapDoor: 数据检索者执行, 生成陷门(搜索凭证)</li><li>Search: 服务器执行, 将接收到的陷门和本地索引进行比对, 引入预设计算过程并返回密文结果.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/BDOP-PKES.jpg" alt="BDOP-PKES"></p><h2 id="5-5-密文区间检索技术"><a href="#5-5-密文区间检索技术" class="headerlink" title="5.5 密文区间检索技术"></a>5.5 密文区间检索技术</h2><p>提过哈, 就是涉及到数值区间问题的时候.</p><h3 id="5-5-1-基于桶式索引的方法"><a href="#5-5-1-基于桶式索引的方法" class="headerlink" title="5.5.1 基于桶式索引的方法"></a>5.5.1 基于桶式索引的方法</h3><p>对属性值域进行分桶, 为各桶分配一个唯一的标识(也就是记录的索引).<br>查询时, 用户将与检索区间相交的标识集发给服务器, 服务器将这些分桶全部发回给客户端.</p><p>显然, 这种方式分桶完全是服务器的活, 因此返回的数据很可能包括大量的冗余数据.</p><h3 id="5-5-2-基于B-树的传统加密技术方案"><a href="#5-5-2-基于B-树的传统加密技术方案" class="headerlink" title="5.5.2 基于B+树的传统加密技术方案"></a>5.5.2 基于B+树的传统加密技术方案</h3><p>这种方案为数据构造B+树, 服务器会将密文节点返回给用户, 用户解密后自行判断, 并通知服务器下一个节点位置.</p><p>这种方案需要客户端与服务器多轮交互.</p><p>还有一种基于矩阵加密的方式, 比较复杂, 这里不提了.</p><h3 id="5-5-3-基于等值检索的方案"><a href="#5-5-3-基于等值检索的方案" class="headerlink" title="5.5.3 基于等值检索的方案"></a>5.5.3 基于等值检索的方案</h3><p>这种方案的想法是把区间检索转化为关键词检索. 将每个属性值当作一个关键词, 然后对区间内部的属性值进行枚举, 再对每个枚举结果进行关键词搜索即可.</p><p><strong>不适用于检索区间精度高或者检索区间较大的情况</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%9F%BA%E4%BA%8E%E7%AD%89%E5%80%BC%E6%A3%80%E7%B4%A2%E7%9A%84%E6%96%B9%E6%A1%88.png" alt="基于等值检索的方案"></p><p>比如我要查询 [1, 6], 那只需要枚举 [001, 01*, 10*, 110] 这四种方案即可.</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 信息安全专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融数据安全 </tag>
            
            <tag> Financial data security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融数据安全-Chap.4</title>
      <link href="/posts/45843.html"/>
      <url>/posts/45843.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-4-访问控制技术"><a href="#Chap-4-访问控制技术" class="headerlink" title="Chap.4 访问控制技术"></a>Chap.4 访问控制技术</h1><h2 id="4-1-数据分级分类"><a href="#4-1-数据分级分类" class="headerlink" title="4.1 数据分级分类"></a>4.1 数据分级分类</h2><p>在信息业发展过程中, 信息的地位逐渐从信息化资产转变为生产要素, 同时金融行业的影响范围逐渐从行业内扩大至行业之间. 因此, 根据相关法律法规规定, 需要对金融信息进行合理的分级分类, 进而加强对其的有序管理.</p><h3 id="4-1-1-数据安全定级"><a href="#4-1-1-数据安全定级" class="headerlink" title="4.1.1 数据安全定级"></a>4.1.1 数据安全定级</h3><p>数据安全定级旨在对数据资产进行全面梳理并确立适当的分级制度, 是建立统一完善的保护制度的基础工作.</p><p>定级原则如下:</p><ul><li>合法合规</li><li>可执行性: 定级不应当过于复杂</li><li>时效性: 有一定时效期限并及时调整</li><li>自主性: 金融业机构结合自身情况自主确定安全级别</li><li>差异性: 数据应当被离散的划分至不同的级别中</li><li>客观性: 通过数据自身的属性和定级规则应当可以判定数据的级别</li></ul><p>定级需要考虑的最重要的三个要素即:</p><ul><li>保密性</li><li>完整性</li><li>可用性</li></ul><p>就是信息安全的CIA三元组.</p><h3 id="4-1-2-金融数据安全定级"><a href="#4-1-2-金融数据安全定级" class="headerlink" title="4.1.2 金融数据安全定级"></a>4.1.2 金融数据安全定级</h3><p>金融数据安全被按照上述原则分为5级:</p><ul><li>5级: 重要数据, 被核心节点类业务使用, 破坏后会对国家安全造成影响.</li><li>4级: 重要数据, 被核心节点类业务使用, 破坏后对公众权益或个人隐私造成破坏, 但不影响国家安全.</li><li>3级: 用于金融业的关键机构和业务使用, 破坏后对个人隐私和企业利益造成一般影响, 不影响国家安全.</li><li>2级: 用于金融业一般业务使用, 破坏后对个人隐私和企业利益造成轻微影响, 不影响国家安全, 公众权益.</li><li>1级: 数据可公开, 可被公众获知, 使用. 破坏后几乎不造成影响.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%9A%E7%BA%A7%E8%A7%84%E5%88%99%EF%BC%881%EF%BC%89.jpg" alt="金融数据定级规则"></p><h2 id="4-2-早期访问控制技术"><a href="#4-2-早期访问控制技术" class="headerlink" title="4.2 早期访问控制技术"></a>4.2 早期访问控制技术</h2><h3 id="4-2-1-访问控制技术的基本概念"><a href="#4-2-1-访问控制技术的基本概念" class="headerlink" title="4.2.1 访问控制技术的基本概念"></a>4.2.1 访问控制技术的基本概念</h3><ul><li>主体: 能对资源发出访问请求的实体</li><li>客体: 能被访问的资源</li><li>操作: 主体对客体的访问方式, 读 &#x2F; 写 &#x2F; 执行等</li><li>访问权限: 客体与其对应操作形成的二元组, &lt;操作, 客体&gt;</li></ul><p>早期访问控制技术建立在 <strong>引用监控机(Reference Monitor, RM)</strong> 的基础上, 它就是系统中监控主体与客体访问关系的部件, 类似于一个 <strong>管理员</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%BC%95%E7%94%A8%E7%9B%91%E6%8E%A7%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="引用监控机模型"></p><h3 id="4-2-2-访问控制技术的分类"><a href="#4-2-2-访问控制技术的分类" class="headerlink" title="4.2.2 访问控制技术的分类"></a>4.2.2 访问控制技术的分类</h3><p>访问控制技术随发展产生了四类:</p><ul><li>自主访问控制模型</li><li>强制访问控制模型</li><li>基于角色的访问控制模型</li><li>基于属性的访问控制模型</li></ul><hr><p><strong>自主访问控制</strong> 的思路是让客体的归属者来决定别的主体对于它的访问权限. 其可以用一个 (S, O, A)三元组来表示, 即 &lt;主体, 客体, 访问权限&gt; .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%9F%A9%E9%98%B5.png" alt="访问控制矩阵"></p><p>在访问控制矩阵中, 行代表主体, 列代表客体, 对应的格内代表访问权限.<br>这样的问题是矩阵过于稀疏了, 因此出现了 <strong>访问控制表(ACL)</strong> 和 <strong>能力权证 &#x2F; 能力表(CL)</strong> , 它们分别将访问矩阵按照 行 &#x2F; 列分解, 形成一个类似于图论中 <strong>邻接表</strong> 的数据结构.</p><hr><p><strong>强制访问控制</strong> 基于分类的思想得来, 其将主体和客体均进行分级, 并根据其级别对应关系来决定主体能否访问客体.</p><p>对于安全级别(level), 通常分以下几类:</p><ul><li>公开(UC)</li><li>秘密(S)</li><li>机密(C)</li><li>绝密(TS)</li></ul><p>也可能简单的分为以下两类(三类):</p><ul><li>高(High)</li><li>低(Low)</li><li>中(Medium)</li></ul><p>这种访问控制有两个很经典的模型: <strong>BLP</strong> 和 <strong>Biba</strong></p><p><strong>BLP模型</strong> 是为了保障数据的机密性而得来的, 其核心原则是 <strong>不上读, 不下写</strong> . 下层人员无法读到更高密级的信息, 而上层人员无法把信息向低密级的资源中写入.<br><strong>Biba模型</strong> 是为了保障数据的完整性而得来, 核心原则是 <strong>不下读, 不上写</strong> . 这是为了保证高密级信息不会收到低密级信息的污染.</p><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>这里其实还涉及到一些数学上的关系.<br>除了我们的安全级别之外, 还有一个概念叫 <strong>范畴(category)</strong> , 它是一个类别信息构成的集合, 比如{中国, 军事, 科技}.<br>因此, 会给每一个可能标识一个安全标记二元组 &lt;安全级别(level), 范畴(category)&gt;, 比如 &lt;机密, {中国, 军事, 科技}&gt;<br>我们所说的不上读, 不下写这种含义, 从数学上严格来说是跟一种叫 <strong>支配关系(dom)</strong> 的概念相关的.</p><p>对于两个安全标记 A &lt;L1, C1&gt; , B &lt;L2, C2&gt; , 只有L1 &gt; L2 且 C1 $ \supseteq $ C2时, 才能说 A dom B.<br>有点抽象, 啥意思呢, 就是A的信息范围比B广, 并且A的密级比B高, 才能说A支配B.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E6%94%AF%E9%85%8D%E5%81%8F%E5%BA%8F%E5%9B%BE.png" alt="支配偏序图"></p><p>在强制访问控制中, 会为每个主体和客体都分配这样一个安全标记(也就是上面的这个二元组).</p><p>对于BLP, 我们说的不上读不下写, 保证机密性, 可以翻译为:</p><ul><li>仅当 (label S) dom (label O)时, 主体S才能读O(不上读)</li><li>仅当 (label O) dom (label S)时, 主体S才能写O(不下写)</li></ul><p>对于Biba, 我们说的不下读不上写, 保证完整性, 可以翻译为:</p><ul><li>仅当 (label O) dom (label S)时, 主体S才能读O(不下读)</li><li>仅当 (label S) dom (label O)时, 主体S才能写O(不上写)</li></ul><h3 id="4-2-3-基于角色的访问控制"><a href="#4-2-3-基于角色的访问控制" class="headerlink" title="4.2.3 基于角色的访问控制"></a>4.2.3 基于角色的访问控制</h3><p>基于角色的访问控制希望通过一个个预设好的角色对主体的访问权限进行划分. 它按照功能的完善与否分为了四个类别:</p><ul><li>$ RBAC_0 $ : 用户通过一个个角色间接的获取访问权限</li><li>$ RBAC_1 $ : 引入 <strong>角色继承</strong> 的概念, 有点类似于Java &#x2F; Cpp 中的子类</li><li>$ RBAC_2 $ : 增加了角色之间的约束条件, 比如互斥 &#x2F; 角色最大数量等</li><li>$ RBAC_3 $ : 是1和2的结合(角色继承 + 约束条件)</li></ul><h3 id="4-2-4-基于属性的访问控制"><a href="#4-2-4-基于属性的访问控制" class="headerlink" title="4.2.4 基于属性的访问控制"></a>4.2.4 基于属性的访问控制</h3><p>基于属性的访问控制像是RBAC的进一步细分. 它将用户的一个个属性单独拆出来, 并作为一个个的衡量标准.</p><p>对于每个客体, 都有一套专门的访问策略(即所需要满足的属性要求), 当系统收到访问请求时, 会根据其属性情况进行策略判别, 只有访问主体满足对应的访问策略, 才能获取到对应的访问权限.</p><p>这种访问控制策略通常是最灵活的, 因为它将一个个子属性拆了出来, 但是与之相对的, 对属性的标识也是一个十分繁重的工作, 它的维护成本也是最高的.</p><h2 id="4-3-基于数据分析的访问控制技术"><a href="#4-3-基于数据分析的访问控制技术" class="headerlink" title="4.3 基于数据分析的访问控制技术"></a>4.3 基于数据分析的访问控制技术</h2><p>此前的访问控制技术, 如果用的好, 自然是很完善的模型, 但是它们太过于依赖安全管理员对于系统的筹划. 而在当代这个信息爆炸的年代, 安全管理员有时已经无法胜任如此繁重的工作.</p><p>因此, 新的模型被提出. 希望采用数据挖掘技术 <strong>从系统的访问控制信息中获取角色的定义</strong> , 这个过程也被称为 <strong>角色挖掘(Role Mining)</strong> . 当前的角色挖掘主要分以下两类:</p><ul><li>基于层次聚类的角色挖掘方法</li><li>生成式角色挖掘方法</li></ul><h3 id="4-3-1-基于层次聚类的角色挖掘"><a href="#4-3-1-基于层次聚类的角色挖掘" class="headerlink" title="4.3.1 基于层次聚类的角色挖掘"></a>4.3.1 基于层次聚类的角色挖掘</h3><p>这种情形下, 系统已经有一些 <strong>样本</strong> , 代表着已经存在了一个基础的访问控制矩阵. 我们需要从这些样本中挖掘出角色的定义.</p><p>我们先从一个二维平面上的点来搞明白层次聚类的基础思路: 假设平面上有5个点:</p><p>$$<br>A(2, 2) \\<br>B(3, 3) \\<br>C(6, 6) \\<br>D(8, 8) \\<br>E(3, 4)<br>$$</p><p>我们需要进行 <strong>聚类</strong> 的操作, 其实就是把相近的点分成一类, 合并它们, 随后继续这一过程.<br>考虑初始距离矩阵:</p><p>$$ d(i, j) &#x3D; \sqrt{(x_i-x_j)^2 + (y_i - y_j)^2} $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB-%E5%88%9D%E5%A7%8B%E8%B7%9D%E7%A6%BB%E7%9F%A9%E9%98%B5.png" alt="层次聚类-初始距离矩阵"></p><p>找到矩阵中最小的数字?<br>d(B, E)对吧. 合并.<br>更新这个矩阵.</p><p>这里会碰到一个问题, {B, E}是一个点簇, 怎么判定别的点跟它们的距离呢?<br>符合直觉, 距离这个点簇中哪个点最近就用哪个.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB-%E6%9B%B4%E6%96%B0%E8%B7%9D%E7%A6%BB%E7%9F%A9%E9%98%B5.png" alt="层次聚类-更新距离矩阵(1)"></p><p>随后重复这个过程, 我们就直接上图了, 不再重复叙述了哈~</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB-%E6%9B%B4%E6%96%B0%E8%B7%9D%E7%A6%BB%E7%9F%A9%E9%98%B5%282%29.png" alt="层次聚类-更新距离矩阵(2)"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB-%E6%9B%B4%E6%96%B0%E8%B7%9D%E7%A6%BB%E7%9F%A9%E9%98%B5%283%29.png" alt="层次聚类-更新距离矩阵(3)"></p><p>最终我们合并仅剩的两个点簇, 得到层次聚类的结果:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB-%E6%9C%80%E7%BB%88%E5%88%86%E7%B1%BB%E7%BB%93%E6%9E%9C.png" alt="层次聚类-最终分类结果"></p><p>上面这一整个过程叫做 <strong>凝聚式层次聚类</strong> .<br>现在的问题就简单了, 只需要将不同实体之间的差别抽象成距离即可.<br>在具体实操中, 这个距离由:</p><ul><li>它们之间的共同用户数量</li><li>它们所包含的共同权限数量</li></ul><p>来决定.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%87%9D%E8%81%9A%E5%BC%8F%E8%A7%92%E8%89%B2%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95.jpg" alt="凝聚式角色挖掘算法"></p><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>除了凝聚式, 还有一种叫 <strong>分裂式层次聚类</strong> , 它是自顶向下分配的, 这里就不详细叙述了.</p></blockquote><hr><p>层次聚类的方式基本上介绍完了, 但其还有几个缺点:</p><ul><li>聚类分析过程中会产生较多噪声.</li><li>凝聚式会产生很多包含很多权限的超级类簇, 分裂式则会产生很多很小的权限集合.</li><li>挖掘结果质量往往比较依赖已有权限分配的质量.</li></ul><h3 id="4-3-2-生成式角色挖掘"><a href="#4-3-2-生成式角色挖掘" class="headerlink" title="4.3.2 生成式角色挖掘"></a>4.3.2 生成式角色挖掘</h3><p>这种方式换了一种思路, 将 <strong>角色的挖掘问题映射为文本分析问题</strong> . 它从权限使用的历史数据来获得用户的权限使用模式, 进而产生角色.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E7%94%9F%E6%88%90%E5%BC%8F%E8%A7%92%E8%89%B2%E6%8C%96%E6%8E%98.png" alt="生成式角色挖掘"></p><h2 id="4-4-基于风险量化的访问控制"><a href="#4-4-基于风险量化的访问控制" class="headerlink" title="4.4 基于风险量化的访问控制"></a>4.4 基于风险量化的访问控制</h2><p>这种访问控制显得更加高端一点, 它直接面向结果.<br>它尝试量化用户做出对应访问控制行为的风险值, 随后划定某个阈值, 风险值超过此阈值则映射为拒绝访问, 否则允许访问.</p><p>其中, 风险量化有如下两种方式:</p><ul><li>基于概率论: $ Quantified \space Risk &#x3D; (Probability \space of \space Damage)×(Value \space of \space Damage) $ , 即 风险量化值 &#x3D; 危害发生可能性 * 危害值</li><li>基于协同过滤: 利用系统中用户的历史访问来构建正常的用户画像, 随后对本次访问构建偏差值, 如果偏差值越大, 则风险量化值越大.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%9F%BA%E4%BA%8E%E9%A3%8E%E9%99%A9%E9%87%8F%E5%8C%96%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.png" alt="基于风险量化的访问控制"></p><p>这种访问控制方法通常会与传统访问控制一并使用.</p><h2 id="4-5-基于密码学的访问控制技术"><a href="#4-5-基于密码学的访问控制技术" class="headerlink" title="4.5 基于密码学的访问控制技术"></a>4.5 基于密码学的访问控制技术</h2><p>这种访问控制技术使用了些比较高级的密码学原理内容. 当前分两种:</p><ul><li>基于密钥管理的访问控制技术<ul><li>基于单发送者广播加密的访问控制</li><li>基于公钥广播加密的访问控制</li></ul></li><li>基于属性加密的访问控制技术</li></ul><h3 id="4-5-1-基于密钥管理的访问控制技术"><a href="#4-5-1-基于密钥管理的访问控制技术" class="headerlink" title="4.5.1 基于密钥管理的访问控制技术"></a>4.5.1 基于密钥管理的访问控制技术</h3><p>首先是 <strong>单发送者广播加密</strong> , 啥意思呢, 这东西跟 <strong>密钥树</strong> 有关.<br>数据所有者通常知道一整棵密钥树, 而树的每个叶子节点都是一个用户, 用有自己的对应的子密钥.</p><p>只有拥有者通过对应的 <strong>子密钥或者其父节点密钥</strong> 对信息进行加密时, 子密钥对应的用户才能成功解密这个信息.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%9F%BA%E4%BA%8E%E5%8D%95%E5%8F%91%E9%80%81%E8%80%85%E5%B9%BF%E6%92%AD%E5%8A%A0%E5%AF%86%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6.png" alt="基于单发送者广播加密的访问控制"></p><p>假如数据所有者利用红色节点的三个密钥来加密并广播这条消息, 那么U7就无法解密这条消息, 也就是说U7是未授权用户.</p><hr><p>随后是 <strong>基于公钥广播加密</strong> , 它的想法跟非对称加密是一脉相承的, 即数据所有者广播的信息是用授权用户公钥来加密过的信息, 这意味着非授权用户没有这个私钥, 也自然无法得到这条消息的具体内容.</p><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>这里可以有一个公钥服务器来专门负责给用户分组, 让多个用户公用同一组公私钥.<br>这能提高发送效率(不用每个消息都加密很多很多次了)</p></blockquote><h3 id="4-5-2-基于属性加密的访问控制"><a href="#4-5-2-基于属性加密的访问控制" class="headerlink" title="4.5.2 基于属性加密的访问控制"></a>4.5.2 基于属性加密的访问控制</h3><p>这里的想法更像对称加密, 数据发送者以 <strong>属性集合</strong> 作为密钥对消息进行加密. 只有满足对应属性集合的用户才能解密数据.</p><p>本质上是 <strong>基于属性的访问控制</strong> 的进一步延申.</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 信息安全专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融数据安全 </tag>
            
            <tag> Financial data security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融数据安全-Chap.3</title>
      <link href="/posts/29010.html"/>
      <url>/posts/29010.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-3-加密防护的密码学基础"><a href="#Chap-3-加密防护的密码学基础" class="headerlink" title="Chap.3 加密防护的密码学基础"></a>Chap.3 加密防护的密码学基础</h1><blockquote><p>第二章的内容不是很重要, 被博主浓缩到了概述的1.3.0部分中, 这里我们直接进第三章.</p></blockquote><h2 id="3-1-密码学基本概念"><a href="#3-1-密码学基本概念" class="headerlink" title="3.1 密码学基本概念"></a>3.1 密码学基本概念</h2><h3 id="3-1-1-密码体系五元组"><a href="#3-1-1-密码体系五元组" class="headerlink" title="3.1.1 密码体系五元组"></a>3.1.1 密码体系五元组</h3><p>这一部分其实对密码学有一些了解的读者会很熟悉, 我们简单过一下概念:</p><ul><li>明文(plaintext): 通常用 $ M $ 标识明文空间, $ m \in M $ 表示其中一条明文</li><li>加密函数(encryption function): 通常用 $ E $ 表示, 以明文和密钥为输入, 密文为输出</li><li>密钥(key): 通常用 $ K $ 表示密钥空间, $ k \in K $ 表示其中一个密钥</li><li>密文(ciphertext): 通常用 $ C $ 表示密文空间, $ c \in C $ 表示其中一条密文</li><li>解密函数(decryption function): 通常用 $ D $ 表示, 以密文和解密密钥为输入, 明文为输出.</li></ul><p>这就是密码系统中的五元组: &lt;M, C, E, K, D&gt; , 一般会满足以下要求:</p><ul><li>系统是计算安全的(理论可破解, 实际破解花费时间过长, 无意义)</li><li>系统的保密性仅仅依赖于密钥(密码体制是公开的, 而使用者仅仅通过密钥保证安全, Kerckhoff原则)</li><li>便于实现 &#x2F; 使用</li></ul><p>密码系统遭受到的攻击一般分两类:</p><ul><li>被动攻击: 对传输进行监听和监测.(窃听信道 &#x2F; 流量分析)</li><li>主动攻击: 对信道中的数据进行篡改 &#x2F; 伪造.(伪装, 重放, 篡改, 拒绝服务)</li></ul><h3 id="3-1-2-加密体制"><a href="#3-1-2-加密体制" class="headerlink" title="3.1.2 加密体制"></a>3.1.2 加密体制</h3><p>当前的加密体制分以下两类:</p><ul><li>对称加密: 加密和解密使用同一组密钥</li><li>非对称加密: 加密使用对方的公钥, 解密使用自己的私钥.</li></ul><h2 id="3-2-对称加密"><a href="#3-2-对称加密" class="headerlink" title="3.2 对称加密"></a>3.2 对称加密</h2><h3 id="3-2-1-对称加密的典型算法"><a href="#3-2-1-对称加密的典型算法" class="headerlink" title="3.2.1 对称加密的典型算法"></a>3.2.1 对称加密的典型算法</h3><p>DES(Data Encryption Standard): 是典型的分组加密算法. 所谓分组加密, 指的是将明文分为固定长度的一个分组, 随后对每个分组分别进行加密.</p><ul><li>明文分组长度64比特(8字节), 密钥分组长度56比特(8字节, 每字节最低位是奇偶校验位), 输出为64比特(8字节).</li><li>有3DES的升级版本, 有两密钥 &#x2F; 三密钥的加密方式.<ul><li>两密钥加密方式原理如下: $ C &#x3D; E_{k1}(D_{k2}(E_{k1}(M))) $ , 是一个 <strong>加密-解密-加密</strong> 的模式, 实际密钥区间为112位.</li><li>三密钥加密方式原理如下: $ C &#x3D; E_{k3}(D_{k2}(E_{k1}(M))) $ , 同样是 <strong>加密-解密-加密</strong> 的模式, 实际密钥区间为168位.</li></ul></li></ul><h3 id="3-2-2-对称加密模式"><a href="#3-2-2-对称加密模式" class="headerlink" title="3.2.2 对称加密模式"></a>3.2.2 对称加密模式</h3><p>对称加密通常运用分组, 但怎么分组的加密方式有区别:</p><ul><li>电码本模式(ECB)</li><li>密文分组链接模式(CBC)</li><li>填充密码块链接模式(PCBC)</li><li>密文反馈模式(CFB)</li><li>输出反馈模式(OFB)</li><li>计数器模式(CRT)</li></ul><hr><p>电码本模式(ECB)是最简单的分组加密方式, 其直接将明文进行按照分组大小进行分组, 随后对每一组使用预先确认好的相同的密钥进行加密即可.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E7%94%B5%E7%A0%81%E6%9C%AC%20%E5%8A%A0%E5%AF%86.png" alt="电码本-加密"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E7%94%B5%E7%A0%81%E6%9C%AC-%E8%A7%A3%E5%AF%86.png" alt="电码本-解密"></p><ul><li>优势<ul><li>简单, 各段数据之间互不影响, 利于 <strong>并行计算</strong></li><li>密文块损坏时仅对应的明文损坏.</li></ul></li><li>劣势<ul><li>相同的明文块会得到相同的密文块, 不利于隐藏模式信息</li><li>加密消息块相互独立反而称为弱点(单独重放某一个密文块)</li></ul></li></ul><hr><p>密文分组链接模式(CBC)尝试让后面的加密与前面建立联系, 会让每个明文块与前面的密文块异或之后再进行加密.(第一个明文块与初始向量 $ IV(Initialization \space Vector) $ 进行异或)</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%AF%86%E6%96%87%E5%88%86%E7%BB%84%E9%93%BE%E6%8E%A5-%E5%8A%A0%E5%AF%86.png" alt="密文分组链接-加密"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%AF%86%E6%96%87%E5%88%86%E7%BB%84%E9%93%BE%E6%8E%A5-%E8%A7%A3%E5%AF%86.png" alt="密文分组链接-解密"></p><ul><li>每一个分组都受到前面所有分组的影响</li><li>必须选择初始向量</li><li>不容易主动攻击(安全性比ECB强), 当密文块损坏(不管是由于攻击还是数据传输问题), 都会导致后续全部的密文无法正确解密.</li><li>串行加密, 无法并行化</li></ul><hr><p>填充密码块链接模式(PCBC)尝试让前一个明文块和密文块都参与后续分组的加密, 每个分组加密前会异或上其前面那个分组 <strong>明文和密文的异或</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E5%9D%97%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E5%8A%A0%E5%AF%86.png" alt="填充密码块链接模式-加密"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%A1%AB%E5%85%85%E5%AF%86%E7%A0%81%E5%9D%97%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E5%AF%86.png" alt="填充密码块链接模式-解密"></p><ul><li>密文中的微小更改会导致明文出现大部分错误</li><li><strong>互换两个相邻的密文分组不会对后续的解密产生影响</strong> .</li></ul><hr><p>密文反馈模式(CFB)换了一种思路, 我不加密明文了, 我加密前面那个密文分组, 然后再跟明文异或以下得到当前分组的密文.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%AF%86%E6%96%87%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8F-%E5%8A%A0%E5%AF%86.png" alt="密文反馈模式-加密"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E5%AF%86%E6%96%87%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E5%AF%86.png" alt="密文反馈模式-解密"></p><ul><li>每一个区块的加密结果受之前所有区块内容的影响</li><li>明文的改变会影响后续的密文, 因此 <strong>加密不能并行化</strong> , 但是 <strong>解密可以并行化</strong></li></ul><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>注意看解密的图, 这个模式下全程不涉及到Decryption函数.</p></blockquote><hr><p>输出反馈模式(OFB)先用块加密器得到密钥流(Keystream), 随后再将密钥流跟明文异或得到密文.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E8%BE%93%E5%87%BA%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8F-%E5%8A%A0%E5%AF%86.png" alt="输出反馈模式-加密"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E8%BE%93%E5%87%BA%E5%8F%8D%E9%A6%88%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E5%AF%86.png" alt="输出反馈模式-解密"></p><ul><li>加密可并行(因为可以提前对IV进行加密操作)</li><li>没有错误扩散, 密文中单个比特错误只会导致明文中单个比特错误</li></ul><blockquote><p><strong><font color =#ff4444>注意</font></strong><br>这种方式与前一种密文反馈模式的区别在于它直接拿加密完的密文去参与下一个分组的加密过程了, 因此, 下一个分组的加密与前一个分组的明文就完全无关了.<br>同样要注意整个过程不涉及到Decryption函数.</p></blockquote><hr><p>计数器模式(CTR)通过递增一个加密计数器产生连续的密钥流. 随后其余过程与OFB类似.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%8A%A0%E5%AF%86.png" alt="计数器模式-加密"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E5%AF%86.png" alt="计数器模式-解密"></p><ul><li>可并行, 可预处理, 高效</li><li>可以随意加密 &#x2F; 解密任意一个分组</li></ul><h3 id="3-2-3-分组密码的填充"><a href="#3-2-3-分组密码的填充" class="headerlink" title="3.2.3 分组密码的填充"></a>3.2.3 分组密码的填充</h3><p>在分组密码中, 常见数据长度不够长的情况, 此时会进行填充. 有如下填充策略, 读者感兴趣请自行了解, 这里不费笔墨了:</p><ul><li>ANSI X9.23</li><li>ISO 10126</li><li>ISO&#x2F;IEC 7816-4</li></ul><h2 id="3-3-非对称加密"><a href="#3-3-非对称加密" class="headerlink" title="3.3 非对称加密"></a>3.3 非对称加密</h2><p>非对称加密指的是创建一对密钥, &lt;公钥, 私钥&gt;(&lt;PK, SK&gt;), 加密时用对方的公钥加密, 对方收到后用自己的私钥解密.</p><h3 id="3-3-1-RSA算法"><a href="#3-3-1-RSA算法" class="headerlink" title="3.3.1 RSA算法"></a>3.3.1 RSA算法</h3><p>该算法的数学基础在于数论:</p><p>寻求两个大素数比较简单, 但是将它们的乘积进行分解(即逆向求得这两个大素数)却异常困难. 这就是RSA的 <strong>陷门函数</strong> .</p><p>RSA的算法过程如下:</p><ul><li>选取两个不同的大素数 $ p, q $</li><li>计算 $ n &#x3D; pq $ (公开), $ \phi(n) &#x3D; (p-1)(q-1) $ (保密)</li><li>随机选取整数 $ e $ , 使得 $ gcd(\phi(n), e) &#x3D; 1 $ (公开)</li><li>计算d, 满足 $ ed \equiv 1(mod \space \phi(n)) $ (保密)</li></ul><p>将整数e作为公钥, 整数d作为私钥.</p><p>加密过程: $ C &#x3D; M^e \space mod \space n $<br>解密过程: $ P &#x3D; C^d \space mod \space n $</p><p>这其中涉及到一些数论的内容, 读者感兴趣可以去自行了解一下, 也可以看本博客的信安数学基础总结章.</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 信息安全专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融数据安全 </tag>
            
            <tag> Financial data security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融数据安全-Chap.1</title>
      <link href="/posts/45267.html"/>
      <url>/posts/45267.html</url>
      
        <content type="html"><![CDATA[<h1 id="Chap-1-金融数据安全概述"><a href="#Chap-1-金融数据安全概述" class="headerlink" title="Chap.1 金融数据安全概述"></a>Chap.1 金融数据安全概述</h1><h2 id="1-1-大数据"><a href="#1-1-大数据" class="headerlink" title="1.1 大数据"></a>1.1 大数据</h2><h3 id="1-1-1-定义与特点"><a href="#1-1-1-定义与特点" class="headerlink" title="1.1.1 定义与特点"></a>1.1.1 定义与特点</h3><p>大数据的定义为:</p><p><em>高速 (Velocity) 涌现的大量 (Volume) 的多样化 (Variety) 数据.</em></p><p>体现在三个方面:</p><ul><li>数据量大(Volume)</li><li>高速接收 &#x2F; 处理(Velocity)</li><li>数据多样化(Variety)</li></ul><p>大数据带来了三个结果:</p><ul><li>数据量的急剧增加导致分析数据时可以 <strong>不再依赖随机采样</strong></li><li>研究数据的急剧增多导致 <strong>不再热衷于追求精确度</strong></li><li><strong>不再热衷于寻找因果关系</strong></li></ul><h3 id="1-1-2-数据的流通特征"><a href="#1-1-2-数据的流通特征" class="headerlink" title="1.1.2 数据的流通特征"></a>1.1.2 数据的流通特征</h3><p>数据的本质是隐藏于其背后的信息和知识.</p><ul><li>数据是一种无形, 能够反复交易的物品. <strong>其交易的边际成本接近0</strong></li><li>数据价值具有相对性. <strong>对某些人非常有用, 对其他人用处不大</strong></li><li>数据的知识发现是数据交易的核心任务. <strong>必须能够得到数据背后的知识才有用</strong></li><li>数据涉及隐私性. <strong>大部分有价值的数据都与用户的隐私有紧密关联</strong></li></ul><p>因此数据安全是当前时代很基础, 很重要的安全问题.</p><h2 id="1-2-数据安全"><a href="#1-2-数据安全" class="headerlink" title="1.2 数据安全"></a>1.2 数据安全</h2><h3 id="1-2-1-定义"><a href="#1-2-1-定义" class="headerlink" title="1.2.1 定义"></a>1.2.1 定义</h3><p>数据安全的定义如下:</p><p><em>通过采取必要措施, 确保数据处于有效保护和合法利用的状态, 以及具备保障持续安全状态的能力.</em></p><h3 id="1-2-2-DSMM成熟度模型"><a href="#1-2-2-DSMM成熟度模型" class="headerlink" title="1.2.2 DSMM成熟度模型"></a>1.2.2 DSMM成熟度模型</h3><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E9%87%91%E8%9E%8D%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/DSMM%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B.png" alt="DSMM成熟度模型"></p><p>安全能力维度, 明确的是组织在数据安全领域应该具备的能力:</p><ul><li>组织建设: 设立, 职责分配应当清晰</li><li>人员能力: 对于组织内人员应当有明确的培训</li><li>制度流程: 制度和流程执行</li><li>技术工具: 有对应的技术手段和产品工具落实安全要求</li></ul><p>数据生命周期维度, 囊括数据全周期安全过程:</p><ul><li>采集: 对数据进行 <strong>分类分级</strong></li><li>传输: 采用适当的 <strong>加密措施</strong></li><li>存储: 技术管控, 定期备份</li><li>处理: <strong>处理环境要安全</strong> , 对敏感数据进行脱敏</li><li>交换: 保证数据 <strong>共享后的安全风险控制</strong></li><li>销毁: <strong>彻底删除</strong> , 无法恢复</li></ul><p>成熟度维度, 代表对当前组织数据安全领域的评估结果:</p><ul><li>非正式执行</li><li>计划跟踪</li><li>妥善定义</li><li>量化控制</li><li>持续改进</li></ul><h2 id="1-3-金融"><a href="#1-3-金融" class="headerlink" title="1.3 金融"></a>1.3 金融</h2><h3 id="1-3-0-金融的电子化系统发展"><a href="#1-3-0-金融的电子化系统发展" class="headerlink" title="1.3.0 金融的电子化系统发展"></a>1.3.0 金融的电子化系统发展</h3><p>本部分原先应当是第二章的内容, 但不很重要, 放在这里了.</p><p>金融的核心在于 <strong>货币</strong> . 它有如下优势:</p><ul><li>消除了物物交换的双重巧合问题, 提升了交易效率</li><li>提供了统一的价值衡量标准</li><li>允许人们将购买力存储至未来</li><li>支持复杂金融合约的履行</li></ul><p>早期的金融技术中, 就引入了货币这一概念, 同时有 <strong>票号 &#x2F; 水印技术</strong> 等概念的参与.<br>随后电报 &#x2F; 电话的出现推动了远程汇款这一操作.<br>在计算机出现后, ATM机作为提高交易效率的机器开始普及.</p><p>金融本身是 <strong>数据性</strong> 的产业, 本身就具有 <strong>数据量大, 数据多维</strong> 的特点.<br>在互联网技术普及后, 这一点更加明显:</p><ul><li>互联网银行(网上银行)的普及</li><li>证券 &#x2F; 保险 &#x2F; 网络支付等</li></ul><p>随后人工智能的出现进一步拓宽了人们对于金融行业的想象, 其在:</p><ul><li>收集信息</li><li>处理数据</li><li>评测风险</li></ul><p>方面均有显著的效率提升.</p><p>但人工智能参与金融行业也有其显著问题:<br>(1)人工智能多是 <strong>黑箱算法</strong> , 因此导致了数据不透明<br>(2)人工智能接收到的信息十分广泛, 可能出现各式各样的道德问题(歧视某些用户等)</p><h3 id="1-3-1-金融数据的重要性"><a href="#1-3-1-金融数据的重要性" class="headerlink" title="1.3.1 金融数据的重要性"></a>1.3.1 金融数据的重要性</h3><p>金融数据跟一般的数据相比更加重要.<br>涉及用户的财产安全和隐私, 是对数据安全和隐私保护等级最高的产业之一.</p><p>金融跟大数据相结合是必然结果:</p><ul><li>金融融合大数据有优势: 金融行业数据量大, 且预算充足, 能够给大数据人才提供良好的就业前景.</li><li>大数据领域的成熟</li><li>提升金融服务水平以及提高金融机构的管理效率的必然趋势</li></ul><p>金融数据安全的定义与数据安全基本一致, 只不过多限定了一个领域.</p><h3 id="1-3-2-金融安全的原则"><a href="#1-3-2-金融安全的原则" class="headerlink" title="1.3.2 金融安全的原则"></a>1.3.2 金融安全的原则</h3><ul><li>合法正当: 目的需要合法合规</li><li>目的明确: 每个周期需要达成的目标需要明确</li><li>选择同意: 采取的措施应当向数据所有者说明并征得同意</li><li>最小够用: 获得的数据应是业务所必需的最小金融数据</li><li>全程可控</li><li>动态控制</li><li>权责一致</li></ul><p>金融数据被分为共5级:</p><ul><li>1级是公开数据, 原则上无保密要求</li><li>2~5级应当平衡安全与业务两个不同方面:<ul><li>2级: 优先考虑业务</li><li>4级: 优先考虑安全</li><li>5级: 按照法律法规要求执行</li></ul></li></ul><h3 id="1-3-3-金融数据的生命周期及挑战"><a href="#1-3-3-金融数据的生命周期及挑战" class="headerlink" title="1.3.3 金融数据的生命周期及挑战"></a>1.3.3 金融数据的生命周期及挑战</h3><ul><li>数据采集:<ul><li>数据泄露 &#x2F; 数据源伪造 &#x2F; 数据被滥用 &#x2F; 篡改…</li><li>安全多方计算 &#x2F; 本地差分隐私</li></ul></li><li>数据传输:<ul><li>传输过程中泄露 &#x2F; 被篡改</li><li>当前的主流通讯加密协议</li></ul></li><li>数据存储:<ul><li>数据泄露 &#x2F; 篡改 &#x2F; 丢失 &#x2F; 不可用(可能来自机构内部人员的问题)</li><li>是组织 &#x2F; 管理策略 &#x2F; 数据信息具体存储的多方面考量</li></ul></li><li>分析与使用:<ul><li>防止数据使用者刻意挖掘导致用户不希望暴露的信息被得知.</li></ul></li><li>数据删除:<ul><li>去除数据, 使其处于不可访问的状态</li></ul></li><li>数据销毁:<ul><li>使用无意义信息反复写入原先存储数据的区域, 确保数据无法复原</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 信息安全专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 金融数据安全 </tag>
            
            <tag> Financial data security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-计网-Chap.4</title>
      <link href="/posts/27107.html"/>
      <url>/posts/27107.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Chap-4-网络层"><a href="#计算机网络-Chap-4-网络层" class="headerlink" title="计算机网络 Chap.4 网络层"></a>计算机网络 Chap.4 网络层</h1><blockquote><p>本系列计算机网络博文基于Bilibili王道的免费考研课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机组成原理的相关内容.</p></blockquote><h2 id="4-1-网络层的功能"><a href="#4-1-网络层的功能" class="headerlink" title="4.1 网络层的功能"></a>4.1 网络层的功能</h2><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="计算机网络的分层结构"></p><p>老图了, 每章开始都得拿出来哈.</p><p>网络层, 其为 <strong>传输层</strong> 提供服务, 将传输层的数据封装为 <strong>IP数据报(也叫分组)</strong> , 网络中的路由器根据数据报首部中的源和目的IP地址来进行 <strong>分组转发</strong> . 其能够实现 <strong>主机到主机的传输</strong> .</p><p>网络层需要实现的功能主要分以下三个部分:</p><ul><li>异构网络互联<ul><li>异构网络: 不同网络展现出来的拓扑结构不同, 主机类型也不相同. 这种不同的网络被称为异构网络.</li><li>路由器(在TCP &#x2F; IP体系中也叫 <strong>网关</strong> )是其中的重要部分.</li></ul></li><li>路由与转发<ul><li>路由: 各个路由器相互配合, 规划一个IP数据报的最佳转发路径(通过 <strong>路由表</strong> 进行)</li><li>转发: 根据自己的 <strong>转发表</strong> 来将收到的IP数据报通过合适的接口转发出去</li></ul></li><li>拥塞控制<ul><li>拥塞: 网络上的分组过多, 超负荷导致的网络性能下降</li><li>拥塞控制的方法通常分两种: <ul><li>开环控制: 提前设计, 网络开启后不再更改</li><li>闭环控制: 动态监视拥塞状况, 将拥塞状况及时防窥给路由器, 路由器实时调整路由表</li></ul></li></ul></li></ul><h2 id="4-2-IP协议"><a href="#4-2-IP协议" class="headerlink" title="4.2 IP协议"></a>4.2 IP协议</h2><p>IP是网络层中某个主机的标识符, 网络层需要实现主机到主机的传播, 其首先必然需要明确收发地对吧, IP地址就是干这个事情的.</p><h3 id="4-2-1-IPv4及其分组"><a href="#4-2-1-IPv4及其分组" class="headerlink" title="4.2.1 IPv4及其分组"></a>4.2.1 IPv4及其分组</h3><p>Ipv4的地址是一个32位的比特串, 人们为了方便记忆, 将其每八位看作为一组, 共四组.<br>因此我们通常IP是用三个点分隔开来的, 同时每个字部分的取值范围是 $ 0 \sim 2^{8}-1 $</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/Ipv4%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F.png" alt="Ipv4分组"></p><p>我们得把这玩意拆开来看看:</p><ul><li>首部<ul><li>固定首部(一定会有这20B)<ul><li>版本: 使用的协议版本, 当前只有v4和v6</li><li>首部长度: 首部的总长度, 以 4B 为单位</li><li>区分服务: 不重要, 跳过它</li><li>总长度: 整个IP数据报的长度, 以1B为单位</li><li>分片相关的三个字段:<ul><li>分片: 当一个Ipv4帧超过了下一段链路能承载的最大帧长(MTU, Maximum Transfer Unit)限制时, 就会进行分片.</li><li>标识: 通常由发送方源主机生成, 是一个自增序列, 用于让接收方区分收到的不同分片来自于哪个源主机的哪个IP数据报</li><li>标志: 共3bit<ul><li>最低位MF(More Fragment): 本分片后是否还有更多分片</li><li>居中位DF(Don’t Fragment): 本数据报不允许分片</li><li>最高位不管, 没用</li></ul></li><li>片偏移: 在分片前, 本分片的数据部分在原IP数据报中的位置, 以8B为单位</li></ul></li><li>生存时间(TTL, Time to Live): 一个IP数据报能在网络上经过的最大节点数目</li><li>协议: 标识上层传输层使用的协议</li><li>首部校验和: 只校验首部是否正确, 数据部分我不管(如果这一部分全零则代表首部都不用校验)</li><li>源地址 &#x2F; 目的地址: 不用再赘述了哈</li></ul></li><li>可变部分<ul><li>可选字段</li><li>填充(为了保证首部长度是4B的整数倍, 与首部长度字段对应)</li></ul></li></ul></li><li>数据部分(从上层传输层过来的报文)</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/Ipv4%E7%9A%84%E5%88%86%E7%89%87%E9%97%AE%E9%A2%98.png" alt="Ipv4的分片问题"></p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>通过对分片的理解, 我们得知了, 分片这个动作时能够在源主机 &#x2F; 路由器中任何一个节点进行的, 但重组这个动作只能在目的主机中进行.</p><p>同时, 除了最后一个分片外, 其余分片数据部分的大小也必定是8B的整数倍.</p></blockquote><h2 id="4-3-IP地址及其分组"><a href="#4-3-IP地址及其分组" class="headerlink" title="4.3 IP地址及其分组"></a>4.3 IP地址及其分组</h2><p>这一节会涉及到IPv4地址的分组以及其发展历程, 这二者是息息相关的.</p><h3 id="4-3-1-最初的IP地址设计-ABCDE"><a href="#4-3-1-最初的IP地址设计-ABCDE" class="headerlink" title="4.3.1 最初的IP地址设计: ABCDE"></a>4.3.1 最初的IP地址设计: ABCDE</h3><p>我们先看一下IPv4地址的容量, 我们此前说过Ipv4地址共32bit, 换算成十进制即:<br>$ 2^{32} \approx 42亿 $  </p><p>这就出问题了, 如果按照最初设计的设想(1981年), 为每个电子设备以及每个路由器的接口都分配一个唯一的ip, 那显然, 42亿有点太少了. 但在那个年代来看, 这个容量应该是绝对够用的.</p><p>当时的IP地址总分配管理者为 <strong>ICANN(互联网名字和数字分配机构)</strong> . 它们将IP分为了五类:</p><ul><li>A: 1 ~ 126</li><li>B: 128 ~ 191</li><li>C: 192 ~ 223</li><li>D: 224 ~ 239</li><li>E: 240 ~ 255</li></ul><p>其中, ABC为单播地址, D为多播地址, E类保留至今后使用.<br>这里划分的规则用二进制来看还是很明确的, A类地址以0开头, B以10开头, C以110开头, D以1110开头, E以1111开头.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%9C%80%E5%88%9DIPv4%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E6%96%B9%E6%A1%88.png" alt="最初IPv4地址的分类方案"></p><blockquote><p><strong><font color = #3490de>概念: 多播地址</font></strong><br>相当于通过一个IPv4地址映射多个单播地址.(类似于一个群组号, 向这个群组中发送消息, 则群组内的所有主机都能收到这条消息)</p></blockquote><p>需要注意的是, IPv4地址在当时定了个规则, 即 &lt;网络号&gt; + &lt;主机号&gt; 的双重结构. 网络号通常意味着 <strong>一个子网</strong> , 主机号则负责标注该子网下的某一台特定主机.</p><hr><p>我们通过一张图引入几个概念, 并向读者理清楚IP分组到底是怎么发送到指定的另一个主机的:</p><ol><li>IP转发表: 是每一个路由器均有的一张表, 它负责在路由器接收到IP数据报时进行从上至下的筛选, 直到筛选到符合的表项后向指定端口进行转发(简单而言就是判断这个IP该往我的哪个端口转发)</li><li>ARP协议: 是一种通过目的IP以及特定查询报文来确定其IP所对应的MAC地址的协议, 它只能在同一子网内生效.</li></ol><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91%E4%BE%8B.png" alt="IP分组转发例"></p><ol><li>首先, 一台计算机进入接入互联网中的某一个子网, 一定会被分配到该子网下属的一个主机号, 并被告知一个默认的网关(即需要跨子网通信时必定要经过的一个路由器, 也就是该子网的边缘路由器)</li><li>随后, 该主机希望向自己子网外的某个子网发送数据, 则先将目的IP与自己的本机IP填入分组中, 传递给下层数据链路层.</li><li>接下来进行组帧, 重点是目的MAC地址的填写, 也涉及到了第一次分类, 是关于目的IP相对自己的位置而言的:<ol><li>如果目的IP与自己处于同一个子网, 则直接通过ARP协议找到其MAC地址并填入.</li><li>如果目的IP与自己不在同一个子网, 则通过ARP协议先找到自己默认网关的MAC地址并填入</li></ol></li><li>接下来就是接收方的分类:<ol><li>同一子网的主机直接收到了该数据报, 传输结束.(都不用走路由转发)</li><li>网关路由器收到该帧, 拆帧并向上传输给网络层后, 网络层会检测目的IP地址与哪一个接口相匹配(通过IP转发表), 并在下一次组帧时将目的MAC地址更改为其传送目标路由器的MAC地址(同样通过ARP协议).</li></ol></li><li>到了下一个结点, 重复这一过程(3~4), 直到该数据报转发到了目标主机为止.</li></ol><p>这整个过程其实不是非常难理解, 但是涉及到了两个问题:</p><ul><li>ARP协议怎么拿到MAC的?</li><li>IP转发表怎么形成的?</li></ul><p>但在这里, 我们暂且按下不表, 还请读者带着这两个问题读下去.</p><hr><p>除了上述的分类之外, 最初的IP设计还给出了几个特殊地址:<br>我们假设 IP地址: &lt;网络号Y&gt; + &lt;主机号X&gt;</p><ul><li>X全0代表着子网本身, 不能被分配给网络内的任何一个主机, 也不能作为目的地址以及源地址.(比如上图中的166.1.0.0)</li><li>X全1代表着给这个子网 <strong>广播</strong> 该分组, 只能作为目的地址使用</li><li>Y全0代表着 <strong>本子网中的指定主机</strong> , 只能作为源地址使用</li><li>Y, X均全0代表着 <strong>本子网上的本主机</strong> , 在DHCP协议中有应用, 只能作为源地址来使用</li><li>Y, X均全1代表着 <strong>向本子网中的全部主机广播该分组</strong> , 只能作为目的地址使用</li><li>Y &#x3D; 127: 环回自检地址, 代表自己这台主机本身, 用于本地软件的测试.(不信读者回去看看地址分类是不是没有127)</li></ul><p>第四条和第五条通常在一个主机刚刚接入网络, 还没有被分配IP地址时使用. 其会发送一条DHCP报文, 源地址为 0.0.0.0(全0), 目的地址为 255.255.255.255(全1), 用于向本子网中的DHCP服务器获取IP地址. 具体的内容会在DHCP协议中详细叙述.</p><h3 id="4-3-2-子网划分和子网掩码"><a href="#4-3-2-子网划分和子网掩码" class="headerlink" title="4.3.2 子网划分和子网掩码"></a>4.3.2 子网划分和子网掩码</h3><p>看到了前面一小节ICANN的划分方式, 相信很多读者已经有点想法了, 哎, 我又没有那么多机子, 我能不能再把ip地址进一步划分呢?<br>那答案当然是可以的.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E4%B8%8E%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="子网验码与子网划分"></p><p>上图中, 以B类地址为例, 一个学校将原本分配给它的一个B类地址划分成了更细的两个子网: 166.1.0.x ~ 166.1.127.x 以及 166.1.128.x ~ 166.1.255.x, 其实本质上, 就是将后面原本16个主机字段, 单独分出来一个来额外标识子网号.</p><p>通过上述例子, 我们能知道, 引入了子网后, IP地址的结构发生了一点点变化:<br>&lt;网络号&gt; + &lt;子网号&gt; + &lt;主机号&gt;</p><p>哎这好像很简单啊? 还有啥能说的?<br>读者千万不要忘了, 我们上一节说过的IP数据报传输过程.</p><hr><p>我们知道, IP数据报传输需要首先判断目的IP到底在不在我的这个子网中, 如果在我的子网中, 我就不用走路由, 直接填它的MAC转发过去即可对不对.</p><p>那现在子网划分技术出现了, 从好的方面讲, 这使得某个机构或公司能够细化子网的划分, 提高IP利用率.<br>但从麻烦的角度来说, 网络号+子网号这俩玩意 <strong>长度不固定</strong> , 导致主机无法仅仅通过IP来确认对方是不是在我这个子网里.</p><p>那咋整呢, 聪明的前辈们搞出了一个叫 <strong>子网掩码</strong> 的东西.</p><hr><p>子网掩码的目的很简单, 就是让计算机得知我的 网络号 + 子网号 到底多长的. 它也采用了 <strong>32bit的二进制串</strong> , 与IP地址一一对应, 如果其所对应的那一位是 网络号 &#x2F; 子网号, 则对应的子网掩码为1, 否则为0.</p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>为啥使用32bit的二进制串?<br>答案是为了方便计算机更快速的确认两个IP在不在同一个子网中.<br>只需要将两个IP分别与子网掩码做逐位与运算(相当于只保留了网络号 + 子网号, 而没有保留主机号), 再对比结果是否一致即可</p></blockquote><hr><p>我们还需要额外提一下关于上一小节说的 <strong>IP转发表</strong> 这个玩意.<br>这个玩意是从上向下逐条对比的, 那有没有想过如果一条都没对上怎么办?</p><p>事实上, 不会出现这种问题, 因为可以在最下侧默认设置一条表项, 其IP地址与子网掩码全部为0, 这就意味着任何IP地址与它做与运算一定全0, 一定能与这个IP对上.<br>这就是所谓的 <strong>默认转发路径</strong> .<br>了解即可.</p><h3 id="4-3-3-无分类编址CIDR"><a href="#4-3-3-无分类编址CIDR" class="headerlink" title="4.3.3 无分类编址CIDR"></a>4.3.3 无分类编址CIDR</h3><p>这个概念诞生于1993年, 当时互联网技术勃勃生机, 主机数目越来越多, 导致了一个问题, 即定长的网络分类技术的局限性愈发明显.</p><p>啥意思呢, 假如一个单位有2000台主机, 我们考虑一下它应该怎么申请IP?</p><ul><li>一个A类地址下属 $ 2^{24} &#x3D; 16777216 $ 个IP</li><li>一个B类地址下属 $ 2^{16} &#x3D; 65536 $ 个IP</li><li>一个C类地址下属 $ 2^{8} &#x3D; 256 $ 个IP</li></ul><p>这就很尴尬, 2000不多不少, 比C类多太多, 比B类少太少对吧.<br>因此, 由于这种很可能造成的IP地址浪费, CIDR(无分类编址)应运而生.</p><hr><p>CIDR重定义了地址定义方式, 将IPv4的地址简单的分为了两部分: &lt;网络前缀&gt; + &lt;主机号&gt; .<br>说白了, 这个网络前缀就是我们之前说的: &lt;网络号&gt;.</p><p>这样做能够极大的提高IP划分的灵活性, 同时也能够兼容之前的子网掩码记法.<br>在CIDR中, 可以将一个IP地址记作: $ 128.14.32.0&#x2F;21 $ , 斜杠后面跟着的就是子网掩码1的位数, 这也被叫做 <strong>CIDR记法</strong> .</p><p>相似的, 子网的划分也有这个问题, 因此CIDR还提出, 对于一个单位内划分的子网, 也可以采取 子网号长度不同 的方式.</p><p>这样做的好处是很明显的, 我们能够根据一个子网的具体主机数来灵活的变更其子网长度, 进而更加灵活的分配我们的IP地址.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/%E6%97%A0%E9%99%90%E5%88%B6CIDR%E4%B8%8E%E5%8F%98%E9%95%BF%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.png" alt="CIDR与变长子网划分"></p><hr><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>按照CIDR的分配法, 即便是最小的点对点子网, 也应当至少保留2bit的主机号空间, 这是因为我们此前说过的, 主机号全0和主机号全1的情况是不能被分配给任何子网内主机的, 它们有特殊的含义.</p></blockquote><h3 id="4-3-4-路由聚合"><a href="#4-3-4-路由聚合" class="headerlink" title="4.3.4 路由聚合"></a>4.3.4 路由聚合</h3><p>路由聚合是与CIDR一并使用的, 它的根本目的在于缩小路由器IP转发表的表项数目, 同时也提高检索效率. 其定义如下:<br>对于一个路由转发表, 如果几条路由表项的转发接口相同, 部分网络前缀也相同, 那么可以将这几条路由表项聚合成一条表项.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88.png" alt="路由聚合"></p><hr><p>除此之外, 还有一个比较重要的原则叫 <strong>最长前缀匹配原则</strong> , 它的意思跟它的名字一样, 即路由器转发的时候, 一定会选择那个与目的IP地址匹配长度最长的表项所映射的端口来转发.</p><p>用一个例子来说, 我们把路由器比作一个邮局, 现在有一条专线能够从邮局直达你们家里, 还有一种方法是邮局通过将新建先给到你们街道, 你们街道再给到你们小区保安室, 保安室再给到你.<br>从效率而言, 当然是从邮局直接把信件发到你们家更精确一些对吧.</p><p>最长前缀匹配就是为了最精确的将IP数据报转发到指定的主机. 如果同时有好几条前缀都能够匹配, 这通常说明有好几条路径都能转发到这个IP地址.<br>那还能怎么办, 肯定选最精确的那一条啊(也就是尽可能快的缩小主机地址的范围, 换言之, 就是最长前缀匹配喽)</p><h3 id="4-3-5-网络地址转换-NAT"><a href="#4-3-5-网络地址转换-NAT" class="headerlink" title="4.3.5 网络地址转换 NAT"></a>4.3.5 网络地址转换 NAT</h3><p>我们说CIDR是用于提高IP地址利用率的, 它出现的原因是因为IPv4地址太少了.<br>但很显然, 这种方式治标不治本, 总有一天这32位的地址会被全部填满, 那不就完蛋了?</p><p>因此, 紧接着CIDR出现的第二年, 即1994年, 网络地址转换(NAT)技术就出现了.</p><hr><p><strong>前置知识: 端口号</strong></p><p>端口号其实是再上一层(也就是下一章), 传输层的一个概念, 它本质上代表着一个个在主机上运行的进程, 进程会通过一个主机上的不同端口号来收发信息. 其大小占16bit, 即可以有 $ 2^{16} \approx 65500 $ 个端口.</p><p>在传输层中, 则需要负责将对应报文的源端口号和目的端口号标明, 从而能够使得收发双方都正确地接收到传输的信息(否则你微信的消息发qq去了你不炸缸了嘛)</p><hr><p>我们回到刚刚的问题, IP不够用了, 咋办呢?<br>我们会发现一个IP有这么多个端口, 所以NAT的想法就是, 把一个局域网内的多台主机分配到同一个IP地址上, 当他们需要与公网通信时, 只需要分别通过网关的那个公有IP的某一个端口向外通信即可.</p><p>这是个好方法, 它相当于将一个局域网内的所有主机当成了同一个主机, 或者也可以说是放进了同一个 <strong>子网</strong> 中. 现在的问题是:<br>那内部的节点怎么进行标识呢?</p><p>NAT的指定考虑到了这一点, 并通过划定了一部分 <strong>私有IP地址</strong> 来保证上述占用同一个公网IP的节点的唯一标识:</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>可见给我们分配的私网IP还是很多的哈.</p><hr><p>最后, 考虑一个内网中的一个进程如果要与外网通信, 路由器该怎么映射这个进程到一个公网IP的一个端口上?</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="NAT地址转换"></p><p>其实没啥复杂的, 路由器有这么一个NAT表, 当它收到向外的报文, 会主动记录下这个报文的 &lt;内网IP + 端口&gt; , 并主动创建一个 &lt;外网IP + 端口&gt; 项目与之映射. 当收到回应时, 再将回应中的目的IP和端口号映射回内网IP与端口号, 随后继续放到内网中转发即可.</p><p>当前, 几乎全部的路由器都支持NAT功能. (废话, 要不然IPv4早爆了)</p><h3 id="4-3-6-地址解析协议-ARP"><a href="#4-3-6-地址解析协议-ARP" class="headerlink" title="4.3.6 地址解析协议 ARP"></a>4.3.6 地址解析协议 ARP</h3><p>按理来说, IP地址这一大块我们倒腾的差不多了. 现在就是一些前面没有涉及到的细节. 先从这个最关键的细节开始, <strong>怎么通过IP地址找MAC地址?</strong></p><p>这个事情跟我们之前提过一嘴的 <strong>ARP协议</strong> 有关系. 它单独于IP协议, 设定了另一种报文格式, 专门用于干这个与数据链路层对接的活.</p><p>具体而言, ARP定义了这么些东西:</p><ul><li>ARP表:<ul><li>每台主机 &#x2F; 路由器都有自己的ARP表, 它会记录自己已经得知的 &lt;IP地址, MAC地址&gt; 的对应关系.</li><li>会定期更新</li></ul></li><li>ARP分组(与IP分组是同等地位)<ul><li>ARP请求分组:<ul><li>我是谁: 标注自己的IP, 以及MAC地址</li><li>我要找谁: 标注自己想找的IP地址</li><li>将其封装进MAC帧, 目的地址设为全1(广播帧), 源地址填自己的MAC</li></ul></li><li>ARP响应分组:<ul><li>我是你想找的IP, 我的MAC地址是这个</li><li>封装进MAC帧, 目的地址设为请求分组的MAC, 源地址填自己的MAC</li></ul></li></ul></li></ul><p>当一台主机收到一个响应分组后, 就会更新自己的ARP表, 随后此后再要给对方发消息的时候就不用再问一遍了.<br>除此之外, 如果过程中有别的节点收到了别人的请求分组, 也会顺手将其在自己的ARP表中记下来. 这很好理解, 顺手的事对吧.</p><h3 id="4-3-7-动态主机配置协议-DHCP"><a href="#4-3-7-动态主机配置协议-DHCP" class="headerlink" title="4.3.7 动态主机配置协议 DHCP"></a>4.3.7 动态主机配置协议 DHCP</h3><p>好的, 最后一个细节: IP地址怎么分配?<br>当然有一种方法是手动来干, 每个设备(局域网)分配一个IP, 这很好, 但不够灵活, 也不够高效.(你的设备接入网络的时候需要你手动配置IP嘛?)</p><p>因此, DHCP出现了, 它的目的就是 <strong>给刚接入网络的主机分配IP地址, 配置默认网关以及子网掩码</strong> .</p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>DHCP实际上是一个应用层的协议, 但是由于其服务对象主要是网络层的内容, 因此我们把它拿到网络层来做解释.</p></blockquote><hr><p>通常每个需要涉及到IP分配的情景都会涉及到DHCP服务器. 因此我们将一个分配IP的过程用一个 C-S(Client - Server) 的过程模拟一下:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/DHCP%E5%8D%8F%E8%AE%AE%E6%B5%81%E7%A8%8B.png" alt="DHCP协议流程"></p><ul><li>Discover(DHCP 发现报文)<ul><li>源IP为全0(在前面IP地址的含义部分有讲), 目的IP为全1(广播)</li><li>源MAC为自己的MAC, 目的MAC为全1(广播)</li><li>意思为: 我初来乍到, 先报上我的MAC地址.</li></ul></li><li>Offer(DHCP 提供报文)<ul><li>源IP为自己的IP, 目的IP为全1(广播)</li><li>源MAC为自己的MAC, 目的MAC为发现报文中的源MAC</li><li>会在应用层(即网络最上层)的报文段中写如下信息:<ul><li>给你提供的IP地址</li><li>有效期</li><li>子网掩码</li><li>默认网关</li></ul></li></ul></li><li>Request(DHCP 请求报文)<ul><li>源IP为全0, 目的IP为全1(广播)</li><li>源MAC为自己的MAC, 目的MAC为全1(广播)</li><li>会在应用层写这些东西:<ul><li>我的MAC是…</li><li>我接受你刚刚给我分配的IP(xxx.xx.xx.xx)</li></ul></li></ul></li><li>Acknowledge(DHCP 确认报文)<ul><li>源IP为自己的IP, 目的IP为全1(广播)</li><li>源MAC为自己的MAC, 目的MAC为请求报文中的源MAC</li><li>应用层内写的东西跟Offer里面一样</li></ul></li></ul><p>随后, 这个新主机就有了自己的IP.</p><h2 id="4-4-Ipv6报文"><a href="#4-4-Ipv6报文" class="headerlink" title="4.4 Ipv6报文"></a>4.4 Ipv6报文</h2><p>我们Ipv4倒腾了好久, 有一大部分原因就是因为IPv4的地址空间 <strong>实在太小了!</strong> . 所以搞出了CIDR, NAT等等技术, 但这些都是修修补补, 有没有一种方式从根本上解决这个地址不够用的问题?</p><p>简单, 拓宽位数不就完了.<br>因此, Ipv6应运而生.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/IPv6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="Ipv6报文格式"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/Ipv6%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%282%29.png" alt="Ipv6报文格式(2)"></p><p>我们把首部拆开来聊聊:</p><ul><li>版本: 指明该数据报使用的Ip协议版本</li><li>优先级: 数据报的类别以及是否需要优先处理(不是很重要)</li><li>流标签: 从某一个主机A发送到主机B的全部数据拥有同样的流标签. 有点类似于Ipv4中的 <strong>标识</strong></li><li>有效载荷长度: 扩展首部 + 数据部分的总大小</li><li>下一个首部: 指向有效载荷中的第一个扩展首部(随后继续向扩展首部2, 扩展首部3, …指, 类似链表)</li><li>跳数限制: 相当于Ipv4的TTL</li><li>源地址 &#x2F; 目的地址: 顾名思义</li></ul><p>一看就明白了, Ipv6的地址是 <strong>128位</strong> , 容纳空间比Ipv4大多了!</p><p>除此之外, 我们会发现Ipv4中的分片相关的字段全没了. 对的, Ipv6将分片功能去掉了, 这意味着一个报文段只能在源主机处定好大小, 不能继续细分.</p><hr><p>这里还需要提一下, 这个 <strong>扩展首部</strong> 是个什么东西?</p><p>扩展首部是Ipv6的一个特别的部分, 如果需要进行更进一步的功能实现, 就再有效载荷部分添加对应的扩展首部(有点类似于买游戏的时候你要整上的DLC). 这能有效提高首部的灵活性.</p><hr><p>随后来了解一下IPv6的记法, 我们显然不能再使用点分十进制了, 太大了.<br>所以采用了一种比较好看的方式: <strong>冒号16进制记法</strong></p><p>每四个16进制一组, 总共8组, 这就是IPv6的表示形式, 感兴趣的读者还是可以继续查一下自己电脑上的Ipv6地址哈.</p><p>此外, Ipv6还涉及到一些压缩的记法, 这里就不涉及了, 不是很重要.</p><hr><p>最后, 是Ipv4与Ipv6的适配问题.<br>显然, 这俩的头部差的实在是有点多, 指望这俩报文在路由器处互相转换有点太难了.</p><p>咋整? 不换了, 假如现在有个Ipv6的数据报传到了一个只支持Ipv4的路由器处, 就直接把整个Ipv6数据报作为另一个Ipv4数据报的 <strong>数据部分</strong> , 相当于在外面套一层娃. 后面再把外面的Ipv4首部拆掉即可.<br>这被称为 <strong>隧道技术</strong> .</p><p>Ipv6的内容就到这里.</p><h2 id="4-5-路由选择协议"><a href="#4-5-路由选择协议" class="headerlink" title="4.5 路由选择协议"></a>4.5 路由选择协议</h2><p>我们之前说网络层的功能主要是 <strong>路由和转发</strong> , 转发我们倒腾的差不多了, 就是路由器将分组转发到其另一个接口的过程.<br>现在的问题是: <strong>路由</strong> 怎么实现?</p><p>首先, 路由的含义是, 在已知当前节点和目的IP节点后, 如何选择一个最优的路径来将该分组转发过去?<br>其实说的简单一些, 就是该 <strong>走哪个口</strong> ?</p><p>路由选择协议大体分以下几个部分:</p><ul><li>内部网关协议: <ul><li>一个AS内使用</li><li>RIP: 距离向量</li><li>OSPF: 链路状态</li></ul></li><li>外部网关协议: <ul><li>AS之间使用</li><li>BGP</li></ul></li></ul><blockquote><p><strong><font color = #3490de>概念: 多播地址</font></strong><br>自治系统（AS）是互联网中由一个或多个实体管理，并遵循统一路由策略的IP网络和路由器集合.</p></blockquote><p>读者大概只看这一行不会很明白AS到底是个啥, 别急, 我们往下慢慢聊.</p><h3 id="4-5-1-RIP协议与距离向量算法"><a href="#4-5-1-RIP协议与距离向量算法" class="headerlink" title="4.5.1 RIP协议与距离向量算法"></a>4.5.1 RIP协议与距离向量算法</h3><p>RIP协议适用于相对较小的AS, 基于 <strong>距离向量</strong> 算法.<br>它的核心思想是网络中的每一个路由器都维护一个从它自己到别的网络的最佳距离记录, 长这样:</p><p>$$<br>\begin{array}{c|c|c}<br>  目的网络 &amp; 距离 &amp; 下一跳路由器 \\<br>  \hline<br>  Net2 &amp; 1 &amp; 直接交付 \\<br>  \hline<br>  Net1 &amp; 2 &amp; R1 \\<br>  \hline<br>  Net4 &amp; 2 &amp; R3<br>\end{array}<br>$$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/RIP%E5%8D%8F%E8%AE%AE%E4%BE%8B.png" alt="RIP协议例"></p><p>有了这个图, 我们大致就能明白RIP是在干什么, 以及其要记录的信息是什么意思了.<br>但, 这些信息怎么来的呢?</p><hr><p>RIP制定的规则是: <strong>每个路由器只和与自己相邻的路由器交换信息, 每次将自己当前的路由表告知邻居路由器.</strong><br>而每次路由器收到相邻路由器的一条信息, 都要对自己的路由表进行一个更新:</p><p>这说起来有点抽象, 啥意思呢.<br>比如说我是路由器1, 现在已知一条到子网3的路径距离为10.<br>现在跟我相邻的路由器2把它的路由表告诉我了, 而恰巧它表内有一条表项, 说它到达子网3的距离为5.<br>那我就应该将这个距离为10的玩意更新掉, 然后填上我到路由器2+路由器2到子网3的距离 &#x3D; 6, 因为显然它更短. 同时将下一跳改为路由器2</p><p>其实本质上就是一个最短路算法, 如果读者有了解过数据结构中 <strong>图</strong> 部分的内容, 会发现这就是贝尔曼-福特（Bellman-Ford）算法.</p><p>我们系统的总结一下RIP协议中路由器收到相邻路由器的报文消息后该干啥:</p><ul><li>修改相邻路由器X发来RIP报文中的所有表项:<ul><li>把 <strong>下一跳路由器</strong> 改为X</li><li>把距离+1</li></ul></li><li>对修改后的RIP报文进行如下判断:<ul><li>如果本路由器表内没有对应条目到达的子网, 则将该条目填入本路由器表中</li><li>如果本路由器表内有对应条目到达的子网<ul><li>若下一跳为X, 则用收到的表项直接更新当前表项(说明这个邻居路由的路径发生更新了, 那我这边也得更新)</li><li>如果下一跳不是X, 则比较原表项和新表项距离的大小, 填入小的那个(比较一下新路径跟源路径那个近, 走近的那个)</li></ul></li></ul></li><li>如果超过180秒没有收到路由器的信息, 则将对应的距离更新为16</li></ul><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>RIP协议设计的最长跳数是15, 如果距离为16, 则认为该位置不可达</p></blockquote><p>这种传输方式会带来一种很严重的问题, 即 <strong>坏消息传得慢</strong> 的问题.<br>读者可以自行假设一下, 上面的路由表中, 有一个路由器突然断掉了, 会发生什么?</p><p>这里我就不写全过程了, 笔上模拟一下能够得知, 这个坏消息不会立即被别人得知, 而是反复+1循环, 直到两方都循环至16后才能发现问题.</p><hr><p>最后, 明确一个事情, RIP也是 <strong>应用层</strong> 的一个协议, 在传输层会使用UDP协议传输, 它之所以放到了网络层中讲解是因为它与网络层的功能息息相关.</p><h3 id="4-5-2-OSPF协议与链路状态算法"><a href="#4-5-2-OSPF协议与链路状态算法" class="headerlink" title="4.5.2 OSPF协议与链路状态算法"></a>4.5.2 OSPF协议与链路状态算法</h3><p>OSPF相比于RIP能够适用于更大的网络, 同时其本质上采取的算法是一个我们很熟悉的玩意 <strong>迪杰斯特拉最短路径算法</strong> .<br>OSPF的工作过程如下:</p><ul><li>用HELLO问候分组来发现它的邻居节点以及网络地址.</li><li>评估自己与邻居节点的链路成本度量</li><li>向相邻节点发送自己的全部链路状态的摘要信息.</li><li>相邻节点收到信息后, 通过迪杰斯特拉算法来更新自己的链路拓扑图以及最短路径转发表.</li><li>返回一个LSack确认分组</li><li>当链路发生变化时, 重复该过程.</li></ul><hr><p>还有两个点:</p><ul><li>OSPF每隔30分钟必须强制更新一次数据库中的链路状态.</li><li>相比于RIP, 更适用于规模较大的互连网</li></ul><h3 id="4-5-3-BGP-域间路由协议"><a href="#4-5-3-BGP-域间路由协议" class="headerlink" title="4.5.3 BGP: 域间路由协议"></a>4.5.3 BGP: 域间路由协议</h3><blockquote><p>这一部分博主就不按照王道的讲解来了, 当前王道的免费网课(2025)并未更新关于路由选择协议的内容, 而此前的版本讲的又着实过于简略, 因此还是以书为准.</p></blockquote><p>我们此前说的那俩都是运用在同一个AS内部的协议, 现在问题来了, 两个AS之间的通信怎么解决?<br>这个问题就是BGP尝试解决的玩意.</p><p>在互联网的当前设定中, 不同的AS会有一些 <strong>话事人(也叫网关路由器)</strong> , 它们负责着将本AS中的流量向别的AS之间转发的工作.<br>作为话事人, 它们必须要担当的职责主要有两方面:</p><ul><li>告知本AS中的服务器, 我能到哪些别的AS</li><li>告知外部AS中的服务器, 哪些服务器能从我这里借路到达</li></ul><p>这两方面的任务会通过 <strong>iBGP</strong> 与 <strong>eBGP</strong> 来进行解决, 我们一个个谈.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/eBGP%20%26%20iBGP.png" alt="eBGP &amp; iBGP"></p><hr><p><strong>eBGP</strong> : 向其它AS做出能够到达目的地的宣称与路径.</p><p>eBGP使用的通信信息通常被称为 <strong>路径通告</strong> . 通常包含两部分: (通过AS的路径, 目的地).<br>比如, 上图中, 假设以3d为目的地, 3a会向2c做出宣告: (AS3, 3d), 意义为: 能通过我这个AS3的话事人到达3d.<br>而经过iBGP(下面会讲)的通告后, 2a同样会做出如下宣告: (AS2, AS3, X), 意义为: 能通过我这个AS2的话事人, 我们AS2再把这个报文转给AS3, 进而到达3d.</p><hr><p><strong>iBGP</strong> : 向本AS内部的所有路由器告知我能到达的全部地点.</p><p>当本AS的话事人得到外部网关的宣称时, 它会将该宣称在本AS内部广而告之.<br>这样, 本AS内全部路由就都知道了我能通过这个网关把消息传出去.  </p><p>现在的问题就是怎么把消息传给这个网关?<br>那我们知道啊, 前面的OSPF和RIP干的就是这个事情.</p><hr><p>还有最后一个问题: 如果本AS内有多个网关都能到目的地, 选哪个?<br>本质上也就是要知道AS内部是通过什么策略来决定转发的网关的, 这玩意叫 <strong>Hot-Potato-Routing(热土豆路由)</strong> .<br>它的思路就是我要选择离我最近的网关, 赶紧把这个报文扔出我的AS. 至于AS之间的路径开销, 我不管.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%83%AD%E5%9C%9F%E8%B1%86.png" alt="热土豆路由"></p><p>举个例子, 上图中2d要给X传报文, 它会选择2a作为网关而不是2c, 因为它离2a更近.</p><p>最后, 明确BGP运行在应用层, 它通过传输层TCP协议来对接, 使用端口179.</p><h2 id="4-6-SDN控制平面"><a href="#4-6-SDN控制平面" class="headerlink" title="4.6 SDN控制平面"></a>4.6 SDN控制平面</h2><blockquote><p>这一部分也是王道没有的, 但是在计算机网络中占据的低位挺重要, 还是拿出来说一说.</p></blockquote><p>我们在4.5中倒腾了半天, 其实本质上都是在寻求一种方案, 怎么让路由器找到正确的转发路径.<br>有没有一种方法, 让这个过程变得更简单, 更高效?</p><p>有的兄弟, 有的. SDN控制平面来了.<br>SDN的思路非常非常简单, 我把上面做出的全部运算过程放在集中式服务器中先算完, 随后集中式服务器定期向下属路由器分发它们的转发表.<br>相当于路由器不用动脑子, 会照着集中式SDN服务器给的转发表干活就行.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.4%20%E7%BD%91%E7%BB%9C%E5%B1%82/SDN.png" alt="SDN控制平面"></p><p>SDN控制平面通常通过 <strong>OpenFlow协议</strong> 来进行数据沟通, 我们不需要对这个及其复杂的协议以及其过程有很深的了解, 只需要知道这两点:</p><ul><li>下层路由器负责报告链路状态, 传给SDN服务器</li><li>SDN服务器计算出每个路由器的转发表, 发回给下层路由器即可.</li></ul><p>相当于是将这个过程中心化了.</p><hr><p>网络层最核心的内容就介绍完了, 这一章写的其实挺艰难的, 因为王道的课在这一章着实称不上详细, 因此很多内容需要我们自己来扩展.</p><p>网络层还有些有趣的协议, 比如 SNMP(简单网络管理) 和 ICMP(互联网控制消息协议) , 它们至今在网络中也起到很重要的作用, 但是这里就不再过度展开了, 读者可以自行继续了解.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学-概率论与数理统计 Chap.3 多维随机变量及其分布</title>
      <link href="/posts/58202.html"/>
      <url>/posts/58202.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列概率论博文基于Bilibili宋浩老师发布的概率论教学视频整理而来, 仅用作复习参考. 在此感谢宋浩老师的开源工作.</p></blockquote><h1 id="概率论与数理统计-Chap-3-多维随机变量及其分布"><a href="#概率论与数理统计-Chap-3-多维随机变量及其分布" class="headerlink" title="概率论与数理统计 Chap.3 多维随机变量及其分布"></a>概率论与数理统计 Chap.3 多维随机变量及其分布</h1><h2 id="3-1-二维随机变量"><a href="#3-1-二维随机变量" class="headerlink" title="3.1 二维随机变量"></a>3.1 二维随机变量</h2><h3 id="3-1-1-二维随机变量的联合分布"><a href="#3-1-1-二维随机变量的联合分布" class="headerlink" title="3.1.1 二维随机变量的联合分布"></a>3.1.1 二维随机变量的联合分布</h3><p>第二章讲的是一维的, 第三章我们进入多个随机变量的问题.</p><p>首先仿照二维随机变量给出多维随机变量的定义:<br>有两个随机变量 X, Y.<br>给出它们两个的联合概率分布 $ F(x, y) &#x3D; P \lbrace X \leq x, Y \leq y \rbrace $</p><p>我们先明确一种建模方式, 即通过二维笛卡尔坐标系来表示随机变量的落点.<br>考虑 $ F(x, y) $ , 用二维坐标系来表示:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/F%28x%2C%20y%29.png" alt="F(x, y)"></p><h3 id="3-1-2-二维随机变量的性质"><a href="#3-1-2-二维随机变量的性质" class="headerlink" title="3.1.2 二维随机变量的性质"></a>3.1.2 二维随机变量的性质</h3><p>性质我们就直接给了, 因为这里的性质跟一维很类似:</p><ol><li>$ 0 \leq F(x, y) \leq 1 $</li><li>$ F(- \infty , y) &#x3D; F(x, - \infty) &#x3D; F(- \infty, - \infty) &#x3D; 0 $</li><li>$ F(+ \infty, + \infty) &#x3D; 1 $</li><li>F(x, y) 关于x不减, 关于y不减, 这意味着<ol><li>$ F(x_1, y) &lt; F(x_2, y), x_1 &lt; x_2 $</li><li>$ F(x, y_1) &lt; F(x, y_2), y_1 &lt; y_2 $</li></ol></li></ol><p>接下来还有几个公式, 读者大概画个图就能明白是啥意思哈:</p><ol><li>$ P \lbrace x_1 &lt; X \leq x_2, y_1 &lt; Y \leq y_2 \rbrace &#x3D; F(x_2, y_2) - F(x_1, y_2) - F(x_2, y_1) + F(x_1, y_1) $</li><li>$ P \lbrace x_1 &lt; X \leq X_2, Y \leq y \rbrace &#x3D; F(x_2, y) - F(x_1, y) $</li><li>$ P \lbrace X \leq x, y_1 &lt; Y \leq y_2 \rbrace &#x3D; F(x, y_2) - F(x, y_1) $</li></ol><h2 id="3-2-边缘分布"><a href="#3-2-边缘分布" class="headerlink" title="3.2 边缘分布"></a>3.2 边缘分布</h2><h3 id="3-2-1-边缘分布的定义"><a href="#3-2-1-边缘分布的定义" class="headerlink" title="3.2.1 边缘分布的定义"></a>3.2.1 边缘分布的定义</h3><p>边缘分布指的是 <strong>仅对其中一个随即变量进行限制的概率分布函数</strong> .<br>具体而言, 我们可以这么写:</p><p>$ F_X(x) &#x3D; P \lbrace X \leq x \rbrace &#x3D; P \lbrace X \leq x, Y &lt; + \infty \rbrace &#x3D; F(x, + \infty) &#x3D; lim_{y \to + \infty} F(x, y) $<br>$ F_Y(y) &#x3D; P \lbrace Y \leq y \rbrace &#x3D; P \lbrace X &lt; + \infty , Y \leq y \rbrace &#x3D; F(+ \infty, y) &#x3D; lim_{x \to + \infty} F(x, y) $</p><h3 id="3-2-2-二维离散型随机变量的边缘分布"><a href="#3-2-2-二维离散型随机变量的边缘分布" class="headerlink" title="3.2.2 二维离散型随机变量的边缘分布"></a>3.2.2 二维离散型随机变量的边缘分布</h3><p>离散型的是很好求的, 因为任何一点理论上都给出了:</p><p>$$<br>\begin{array}{c|c|c|c|c|c}<br>    X \backslash Y &amp; y_1 &amp; y_2 &amp; … &amp; y_n &amp; total \\<br>    x_1 &amp; … &amp; … &amp; … &amp; … &amp; sum_{X &#x3D; x_1} \\<br>    x_2 &amp; … &amp; … &amp; … &amp; … &amp; sum_{X &#x3D; x_2} \\<br>    … &amp; … &amp; … &amp; … &amp; … &amp; … \\<br>    x_n &amp; … &amp; … &amp; … &amp; … &amp; sum_{X &#x3D; x_n} \\<br>    total &amp; sum_{Y &#x3D; y_1} &amp; sum_{Y &#x3D; y_2} &amp; … &amp; sum_{Y &#x3D; y_n} &amp;  \\<br>\end{array}<br>$$</p><p>假如说我想求 $ F_X(x_{10}) $ ?<br>既然对Y没限制, 那就把所有满足要求的全加起来, 也就是: $ sum_{X &#x3D; x_1} + sum_{X &#x3D; x_2} + … + sum_{X &#x3D; x_{10}} $</p><h3 id="3-2-3-二维连续型随机变量的边缘分布"><a href="#3-2-3-二维连续型随机变量的边缘分布" class="headerlink" title="3.2.3 二维连续型随机变量的边缘分布"></a>3.2.3 二维连续型随机变量的边缘分布</h3><p>相比于离散型, 连续型要麻烦一些, 但本质上是一样的, <strong>都是求和!</strong></p><p>给定义:<br>对于二维随机变量的密度函数 $ f(x, y) $ ,<br>$ f_X(x) &#x3D; \int_{- \infty}^{+ \infty} f(x, y) dy $<br>$ f_Y(y) &#x3D; \int_{- \infty}^{+ \infty} f(x, y) dx $</p><p>我们首先要明白这给的是一个类似于 <strong>分布密度</strong> 的东西, 也就是上一章连续型随机变量的 <strong>概率密度函数</strong> , 相应的, 我们求出来的也是 <strong>边缘密度函数的密度函数</strong> , 也可以叫做 <strong>边缘密度</strong> .<br>那 $ f_X(x) $ 指的是什么? 就是X落在这一条线上的密度分布对吧, 那可不就是对这一条线上所有的y做积分(加和)嘛.</p><p>上面这段话有些绕, 还请读者尽可能理解, 因为这是求二维连续随机变量边缘分布的基本.</p><hr><p>接下来我们得给几个结论:</p><ol><li>在 <strong>长方形</strong> 区域上的二维均匀分布, 其关于X, Y的边缘分布仍然是均匀分布<ol><li>如果理解了上面的思路, 那这句话应该不难懂. 相当于一条线沿着x &#x2F; y轴扫过长方形, 那X &#x2F; Y落在这条线上的概率应该不会变, 因为这条线的长度始终没有变.</li></ol></li><li>如果X, Y服从二维正态分布(记作 $ (X, Y) \sim N(\mu_1, \mu_2, \sigma_1^2, \sigma_2^2, \rho) $ ) , 则它的边缘分布同样服从正态分布, 即 $ X \sim N(\mu_1, \sigma_1^2) , Y \sim N(\mu_2, \sigma_2^2) $<ol><li><strong>这个结论反过来并不成立</strong> .</li><li>如果反过来, 即 $ X \sim N(\mu_1, \sigma_1^2) , Y \sim N(\mu_2, \sigma_2^2) $ , 且 <strong>X, Y相互独立</strong> , 则有 $ (X, Y) \sim N(\mu_1, \mu_2, \sigma_1^2, \sigma_2^2, 0) $</li></ol></li></ol><p>这玩意证明起来实在是忒麻烦了, 笔者偷个懒, 就不证明了, 读者想请自行搜索吧, 这个结论尽量记住.</p><h2 id="3-3-条件分布"><a href="#3-3-条件分布" class="headerlink" title="3.3 条件分布"></a>3.3 条件分布</h2><p>条件分布, 都叫这个名了, 肯定跟条件概率脱不开干系对吧.</p><h3 id="3-3-1-二维离散型随机变量的条件分布"><a href="#3-3-1-二维离散型随机变量的条件分布" class="headerlink" title="3.3.1 二维离散型随机变量的条件分布"></a>3.3.1 二维离散型随机变量的条件分布</h3><p>同样的, 还是离散型简单一些, 我们还得搬出来这个表:</p><p>$$<br>\begin{array}{c|c|c|c|c|c}<br>    X \backslash Y &amp; y_1 &amp; y_2 &amp; … &amp; y_n &amp; total \\<br>    x_1 &amp; … &amp; … &amp; … &amp; … &amp; sum_{X &#x3D; x_1} \\<br>    x_2 &amp; … &amp; … &amp; … &amp; … &amp; sum_{X &#x3D; x_2} \\<br>    … &amp; … &amp; … &amp; … &amp; … &amp; … \\<br>    x_n &amp; … &amp; … &amp; … &amp; … &amp; sum_{X &#x3D; x_n} \\<br>    total &amp; sum_{Y &#x3D; y_1} &amp; sum_{Y &#x3D; y_2} &amp; … &amp; sum_{Y &#x3D; y_n} &amp;  \\<br>\end{array}<br>$$</p><p>我现在问:<br>$ P \lbrace X &#x3D; x_1 | Y &#x3D; y_7 \rbrace $ 的概率?<br>我们无论是按照上一章条件概率的公式, 还是单纯从理解这个事情来考虑, 都能得到一个很简单的式子:</p><p>$$ P \lbrace X &#x3D; x_1 | Y &#x3D; y_7 \rbrace &#x3D; \frac{P \lbrace X &#x3D; x_1, Y &#x3D; y_7 \rbrace }{ P \lbrace Y &#x3D; y_7 \rbrace } &#x3D; \frac{P \lbrace X &#x3D; x_1, Y &#x3D; y_7 \rbrace }{ sum_{Y &#x3D; y_7} } $$</p><p>好啦, 结束了, 这就是二维离散型的条件分布. 很简单哈~</p><h3 id="3-3-2-二维连续型随机变量的条件分布"><a href="#3-3-2-二维连续型随机变量的条件分布" class="headerlink" title="3.3.2 二维连续型随机变量的条件分布"></a>3.3.2 二维连续型随机变量的条件分布</h3><p>有了离散型的基础, 我们回过头来接着看连续型,  应该能好理解一些.</p><p>先看定义:<br>给定随机变量X, Y, 以及其边缘概率密度 $ f_X(x) ,f_Y(y) $ , 现在给定y, 在 $ f_Y(y) &gt; 0 $ 的前提下:<br>$ f_{X | Y}(x | y) &#x3D; \frac{f(x, y)}{f_Y(y)} $<br>同样的, 给定x, 在 $ f_X(x) &gt; 0 $ 的前提下:<br>$ f_{Y | X}(y | x) &#x3D; \frac{f(x, y)}{f_X(x)} $</p><p>读者理解这个式子的时候要重点观察密度函数的下标, 下标在后的说明其值是给定的.<br>在明确这是个密度函数, 以及其概念之后, 给出如下性质:</p><hr><ol><li>$ f_{X | Y}(x | y) \geq 0 $</li><li>$ \int_{- \infty}^{+ \infty} f_{X | Y}(x | y) dx &#x3D; 1 $<ol><li>在y给定的条件下对所有x取值的概率密度求积分(概率求和), 最终结果一定是1.</li></ol></li></ol><h2 id="3-4-二维随机变量相互独立的判定"><a href="#3-4-二维随机变量相互独立的判定" class="headerlink" title="3.4 二维随机变量相互独立的判定"></a>3.4 二维随机变量相互独立的判定</h2><p>我们老样子从离散型开始给</p><h3 id="3-4-1-离散型二维随机变量相互独立的判定"><a href="#3-4-1-离散型二维随机变量相互独立的判定" class="headerlink" title="3.4.1 离散型二维随机变量相互独立的判定"></a>3.4.1 离散型二维随机变量相互独立的判定</h3><p>离散型的公式最简单:<br>$ P \lbrace X &#x3D; x_i, Y &#x3D; y_j \rbrace &#x3D; P \lbrace X &#x3D; x_i \rbrace * P \lbrace Y &#x3D; y_j \rbrace $</p><p>还是从独立相互独立的那个概念来理解嘛, 就我落在哪跟你没关系, 你爱在哪在哪.<br>因此还有个性质, 即如果X, Y相互独立, 则其条件分布等于其边缘分布.<br>用数学语言解释是这样:<br>$ P \lbrace X &#x3D; x_i | Y &#x3D; y_i \rbrace &#x3D; \frac{ P \lbrace X &#x3D; x_i, Y &#x3D; y_i \rbrace }{ P \lbrace y &#x3D; y_i \rbrace } &#x3D; P \lbrace X &#x3D; x_i \rbrace $</p><p>看起来还蛮简单的哈.</p><h3 id="3-4-2-连续型二维随机变量互相独立的判定"><a href="#3-4-2-连续型二维随机变量互相独立的判定" class="headerlink" title="3.4.2 连续型二维随机变量互相独立的判定"></a>3.4.2 连续型二维随机变量互相独立的判定</h3><p>这个公式也挺简单:</p><p>$$ f(x, y) &#x3D; f_X(x) * f_Y(y) $$</p><p>就是二维概率密度函数等于两个边缘密度相乘.<br>这个式子说明啥呢?</p><ul><li>$ f(x, y) \to f_X(x), f_Y(y) $ , 这是我们知道一定可以求的(联合密度 -&gt; 边缘密度), 但通常 只知道边缘密度, 我们是求不出来联合密度的(即上面这个式子反过来没法推).<ul><li>但假如我们知道了二者相互独立, 则 $ f_X(x), f_Y(y) \to f(x, y) $ 是成立的.</li></ul></li><li>此外, 相互独立还代表着 $ f_{X | Y}(x | y) &#x3D; f_X(x), f_{Y | X}(y | x) &#x3D; f_Y(y) $ , 即条件密度等于边缘密度<ul><li>这好理解吧, 二者都没关系了, 自然条件密度就跟自己的边缘密度一样了.</li></ul></li></ul><hr><p>这里需要记住的主要是以下几个结论:</p><ul><li>如果X, Y服从二维正态分布(记作 $ (X, Y) \sim N(\mu_1, \mu_2, \sigma_1^2, \sigma_2^2, \rho) $ ) , 则它的边缘分布同样服从正态分布, 即 $ X \sim N(\mu_1, \sigma_1^2) , Y \sim N(\mu_2, \sigma_2^2) $<ol><li><strong>这个结论反过来并不成立</strong> .</li><li>如果反过来, 即 $ X \sim N(\mu_1, \sigma_1^2) , Y \sim N(\mu_2, \sigma_2^2) $ , 且 <strong>X, Y相互独立</strong> , 则有 $ (X, Y) \sim N(\mu_1, \mu_2, \sigma_1^2, \sigma_2^2, 0) $</li><li>我们后面会提, 这个二维正态分布后面这个0, 其实能够代表这两个变量的 <strong>相关程度</strong> . 这里暂且按下不表.</li></ol></li><li>如果 $ (X, Y) $ 在矩形 $ a \leq x \leq b, c \leq y \leq d $ 上服从均匀分布, 则X, Y相互独立.<ul><li>可以这样理解, 这俩变量在矩形上均匀, 代表着 X 在矩形区域取到哪一条线上的概率都是一致的, 跟 Y 一点关系没有.(这是肯定的, 因为矩形无论横着还是竖着切一刀那个线段都是一样长的嘛, 翻译成数学语言也就是概率密度 $ f_{X | Y}(x | y) &#x3D; f_{x}(x) $ ).</li><li>对应的, 这个条件对Y同样成立.</li></ul></li><li>如果 $ (X, Y) $ 在圆域上服从均匀分布, 则X, Y一定不相互独立.<ul><li>理解上面那个例子, 这个例子就好想了</li></ul></li><li>如果 X, Y 相互独立, 若构造关于X, Y的一元连续函数 $ g_1(X), g_2(Y) $ , 则 $ g_1(X) , g_2(Y) $ 之间也必定相互独立.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学-概率论与数理统计 Chap.2 随机变量及其分布</title>
      <link href="/posts/3956.html"/>
      <url>/posts/3956.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列概率论博文基于Bilibili宋浩老师发布的概率论教学视频整理而来, 仅用作复习参考. 在此感谢宋浩老师的开源工作.</p></blockquote><h1 id="概率论与数理统计-Chap-2-随机变量及其分布"><a href="#概率论与数理统计-Chap-2-随机变量及其分布" class="headerlink" title="概率论与数理统计 Chap.2 随机变量及其分布"></a>概率论与数理统计 Chap.2 随机变量及其分布</h1><h2 id="2-1-随机变量"><a href="#2-1-随机变量" class="headerlink" title="2.1 随机变量"></a>2.1 随机变量</h2><p>首先要引入一个非常核心的概念, 这个概念贯穿着我们此后概率论内容的始终.</p><blockquote><p><strong><font color = #3490de>概念: 随机变量</font></strong><br>对于一个样本空间 $ \Omega &#x3D; {\omega_i} $ , 我们对其中每一个样本点 $ \omega_i $ 设置一个不同的实数 $ X(\omega) $ , 此时我们记这个 $ X $ 为一个随机变量.<br>随机变量通常用一个大写字母来进行标识.</p></blockquote><p>需要读者理解这个定义, 这实质上是将一个 $ \geq 1 $ 维的样本空间, 转化到了一个 1维 的数轴上, 实际上代表了一种 <strong>映射关系</strong> .</p><p>那我们引入这玩意有啥用呢? 当然是要用它表示事件求概率啊!<br>我们通常可以用以下式子来表示一个事件及其概率:</p><p>$$ \lbrace X \leq x \rbrace , P \lbrace X \leq x \rbrace $$</p><p>这里还请各位读者理解这个表示方式, 它有点像微积分里面的 <strong>变上限积分函数</strong> . 这个 $ x $ 本身也是个变量, 但是在这个式子中, 它取到某一个特定的值时, 这个事件是能有一个准确的概率值的.</p><h2 id="2-2-离散型随机变量及其分布律"><a href="#2-2-离散型随机变量及其分布律" class="headerlink" title="2.2 离散型随机变量及其分布律"></a>2.2 离散型随机变量及其分布律</h2><p>刚刚说的随机变量既然是一种映射, 那它的取值自然分为 <strong>离散型</strong> 和 <strong>连续型</strong> . 这一节先从离散型开始.</p><h3 id="2-2-1-概率分布"><a href="#2-2-1-概率分布" class="headerlink" title="2.2.1 概率分布?"></a>2.2.1 概率分布?</h3><p>对于离散型而言, 其概率分布就是: $ P \lbrace X &#x3D; x_k \rbrace &#x3D; p_k , k &#x3D; 1, 2, … $ .<br>其实就是随机变量取到每一个离散值的概率是多少. 它也通常使用表格来表示:</p><p>$$<br>\begin{array}{c|c|c|c|c}<br>    X &amp; x_1 &amp; x_2 &amp; x_3 &amp; … \\<br>    \hline<br>    P &amp; p_1 &amp; p_2 &amp; p_3 &amp; …<br>\end{array}<br>$$</p><p>对于离散型的概率分布, 有这么几个要求:</p><ul><li>$ \lbrace X &#x3D; x_1 \rbrace, \lbrace X &#x3D; x_2 \rbrace, \lbrace X &#x3D; x_3 \rbrace, … $ 是一个完备事件组.<ul><li>就是所有样本点都包含在里面了</li></ul></li><li>$ p_k \geq 0 $<ul><li>概率基本性质, 不说了</li></ul></li><li>$ \Sigma_{k &#x3D; 1}^{\infty} &#x3D; 1 $<ul><li>就是所有样本点的概率加起来应该是1, 也就是不能有缺少的样本点.</li><li>也叫 <strong>归一性</strong></li></ul></li></ul><p>下面会写一些常见的离散型概率分布.</p><h3 id="2-2-2-0-1分布"><a href="#2-2-2-0-1分布" class="headerlink" title="2.2.2 0-1分布"></a>2.2.2 0-1分布</h3><p>这种是最好处理的, 本质上就是伯努利事件, 其样本空间仅有两个样本点, 因此我们将其抽象为 0, 1.<br>给出概率分布:</p><p>$$<br>\begin{array}{c|c|c}<br>    X &amp; 0 &amp; 1 \\<br>    \hline<br>    P &amp; 1-p &amp; p<br>\end{array}<br>$$</p><p>或者我们用一个表达式来写它:</p><p>$$ P \lbrace X &#x3D; k \rbrace &#x3D; p^k (1-p)^{1-k} , k &#x3D; 0, 1 $$</p><h3 id="2-2-3-二项分布"><a href="#2-2-3-二项分布" class="headerlink" title="2.2.3 二项分布"></a>2.2.3 二项分布</h3><p>二项分布实际上就是 <strong>n重伯努利实验</strong> , $ P(A) &#x3D; p $ , 我们引入随机变量X表示A发生的次数.</p><p>$$ P \lbrace X &#x3D; k \rbrace &#x3D; C_n^k p^k (1-p)^{n-k} , k &#x3D; 0, 1, 2, …, n $$</p><p>我们将其记作: $ X \sim B(n, p) $</p><ul><li>n: 伯努利实验总次数</li><li>p: 单次事件发生的概率</li></ul><p>其实读者能看出来, 二项分布中 $ n &#x3D; 1 $ 时, 就是 0-1分布 了.</p><p>这玩意也是肯定满足归一性的:<br>$ \Sigma_{k &#x3D; 0}^{\infty} C_n^k p^k (1-p)^{n-k} &#x3D; (p+(1-p))^n &#x3D; 1 $<br>这个式子读者如果有疑惑可以去搜索 <strong>二项式展开</strong> , 这里不费笔墨了.</p><h3 id="2-2-4-泊松分布"><a href="#2-2-4-泊松分布" class="headerlink" title="2.2.4 泊松分布"></a>2.2.4 泊松分布</h3><p>泊松分布有点复杂, 我们先给定义:</p><p>$$ X \sim P \lbrace X &#x3D; k \rbrace &#x3D; \frac{\lambda^k}{k!} e^{- \lambda} , k &#x3D; 0, 1, 2, … $$</p><p>我们记作 $ X \sim P(\lambda) $</p><p>这东西的归一性需要一个高数中比较重要的泰勒展开式: $ e^x &#x3D; \Sigma_{k &#x3D; 0}^{\infty} \frac{x^k}{k!} $<br>这个式子这里就不证明了, 读者忘记了可以自己搜一下.<br>有了这个式子, 我们推一下归一性:<br>$ \Sigma_{k &#x3D; 0}^{\infty} \frac{\lambda^k}{k!} e^{- \lambda} &#x3D; e^{- \lambda} \Sigma_{k &#x3D; 0}^{\infty} \frac{\lambda^k}{k!} &#x3D; e^{- \lambda} * e^{\lambda} &#x3D; 1 $</p><hr><p>泊松分布有一个非常重要的应用, 它能够用于近似实验量极大的二项分布:</p><p>设 $ X \sim B(n, p) , n \geq 100 , np \leq 10 $ , 则上述二项分布可以使用泊松分布 $ X \sim P(\lambda) , \lambda &#x3D; np $ 来近似.</p><p>这样近似的目的显而易见, 当二项分布的 n 过大时, 会涉及到超大指数的幂运算, 而泊松分布能够极大程度上简化这一计算过程.</p><h3 id="2-2-5-几何分布"><a href="#2-2-5-几何分布" class="headerlink" title="2.2.5 几何分布"></a>2.2.5 几何分布</h3><p>我们还是先给定义:</p><p>$$ P \lbrace X &#x3D; k \rbrace &#x3D; (1-p)^{k-1} p , k &#x3D; 1, 2, 3, … $$</p><p>我们记作 $ X \sim G(p) $</p><p>同样的, 我们推一下归一性:<br>$ \Sigma_{k &#x3D; 1}^{\infty} (1-p)^{k-1} p &#x3D; p \Sigma_{k &#x3D; 1}^{\infty} (1-p)^{k-1} &#x3D; p \frac{1}{1-(1-p)} &#x3D; 1 $</p><p>几何分布针对的场景是这样:<br>一个事件A, 其发生的概率是p, 一直独立的重复这个实验直到A发生为止. X描述的是A发生时的实验总次数.</p><h3 id="2-2-6-超几何分布"><a href="#2-2-6-超几何分布" class="headerlink" title="2.2.6 超几何分布"></a>2.2.6 超几何分布</h3><p>超几何分布针对的场景是这样:<br>两类共N个物体, 第一类 $ N_1 $ 个, 第二类 $ N_2 $ 个. 从中取出n个, 引入X表示从第一类中取出的物体个数.</p><p>$$ P \lbrace X &#x3D; k \rbrace &#x3D; \frac{ C_{N_1}^k C_{N_2}^{n-k} }{ C_N^n } , k &#x3D; 0, 1, …, min \lbrace n, N_1 \rbrace $$</p><p>这其实就对应着我们的 <strong>不放回抽取</strong> .</p><hr><p>当然, 我们也会碰到一种很难办的情况, 就是N特别大, 并且 N &gt;&gt; n , 这种情况我们通常使用二项分布 $ X \sim B(N, \frac{N_1}{N_1 + N_2}) $ 来对超几何分布进行近似.<br>本质上就是在总实验量过大的时候, 用放回抽取来近似不放回抽取.</p><p>至于二项分布在这种数据量极大的情况下怎么算?<br>请移步刚刚的泊松分布.</p><h2 id="2-3-随机变量的分布函数"><a href="#2-3-随机变量的分布函数" class="headerlink" title="2.3 随机变量的分布函数"></a>2.3 随机变量的分布函数</h2><h3 id="2-3-1-分布函数的定义"><a href="#2-3-1-分布函数的定义" class="headerlink" title="2.3.1 分布函数的定义"></a>2.3.1 分布函数的定义</h3><p>先给出定义:</p><p>$$ F(x) &#x3D; P \lbrace X \leq x \rbrace , x \in (- \infty, + \infty) $$</p><p>请读者明确两点:</p><ul><li>这个函数的自变量是 $ x $ , 即理解为一个随机变量的 <strong>取值限值</strong> .</li><li>这个函数的因变量是 <strong>一个概率</strong>  , 即 $ X $ 取到的值比 $ x $ 小这个事件的概率.</li></ul><p>它的含义与微积分中变上限积分函数的感觉非常相似. 还请读者尽可能理解.</p><h3 id="2-3-2-分布函数的性质"><a href="#2-3-2-分布函数的性质" class="headerlink" title="2.3.2 分布函数的性质"></a>2.3.2 分布函数的性质</h3><p>分布函数的性质还是比较重要的, 这里单拉出来开一小部分:</p><ul><li>$ 0 \leq F(x) \leq 1 $<ul><li>因为分布函数的函数值是个概率嘛</li></ul></li><li>$ F(- \infty) &#x3D; 0 , F(+ \infty) &#x3D; 1 $<ul><li>通过x取值范围得到的结论</li></ul></li><li>F(x)一定是一个 <strong>不减函数</strong> .<ul><li>理解上: x增加时, X能够取到的样本点一定是不减的, 那取到这些样本点的概率也一定是不减的.</li><li>证明上: $ F(x_2) - F(x_1) &#x3D; P \lbrace X \leq x_2 \rbrace - P \lbrace X \leq x_1 \rbrace &#x3D; P \lbrace x_1 &lt; X \leq x_2 \rbrace $ , 显然这个值 $ \geq 0 $ , 得证.</li></ul></li><li>F(x)是一个 <strong>右连续函数</strong></li></ul><hr><p>理解这些性质之后, 有仨比较常用的公式, 做题常用, 也比较好理解, 这里提一下:</p><ul><li>$ P \lbrace a &lt; X \leq B \rbrace &#x3D; F(b) - F(a) $</li><li>$ P \lbrace X &gt; a \rbrace &#x3D; 1 - F(a) $</li><li>$ P \lbrace X &lt; a \rbrace &#x3D; F(a) - P \lbrace X &#x3D; a \rbrace $</li></ul><h2 id="2-4-连续型随机变量及其概率密度函数"><a href="#2-4-连续型随机变量及其概率密度函数" class="headerlink" title="2.4 连续型随机变量及其概率密度函数"></a>2.4 连续型随机变量及其概率密度函数</h2><p>连续型相比于离散型的区别在于其随机变量的取值, 它能取 <strong>一段区间内的全部实数</strong> . 因此不是很好理解.</p><h3 id="2-4-1-概率密度函数"><a href="#2-4-1-概率密度函数" class="headerlink" title="2.4.1 概率密度函数"></a>2.4.1 概率密度函数</h3><p>我们先来捯饬一下这个概率密度函数是个啥意思:</p><p>设X为随机变量, 存在一个非负可积的函数 $ f(x) , f(x) \geq 0 $<br>并且 $ \forall a &lt; b, P \lbrace a &lt; X \leq b \rbrace &#x3D; \int_a^b f(x) dx $</p><p>我们称这样的 $ f(x) $ 就是随机变量X的 <strong>概率密度函数</strong> .</p><hr><p>这玩意确实不好理解, 读者请先明确, 这玩意是将概率用一个 <strong>积分</strong> 的形式来给出的. 也可以粗略的理解成函数图像的线下面积.</p><p>这玩意有好几个性质:</p><ul><li>$ f(x) \geq 0 $<ul><li>如果这玩意能小于0, 那线下面积就是负的了, 概率显然不可能为负数.</li></ul></li><li>$ \int_{- \infty}^{+ \infty} f(x) dx &#x3D; 1 $<ul><li>随机变量X取遍整个实数域的概率显然是1</li></ul></li><li>取个别点的概率为0<ul><li>$ 0 \leq P \lbrace X &#x3D; x_0 \rbrace \leq P \lbrace x_0 - \Delta x \leq X \leq x_0 \rbrace &#x3D; \int_{x_0 - \Delta x}^{x_0} f(x) dx $</li><li>显然, 当 $ \Delta x \to 0 $ 时, 右式趋近于0. 因此得证.</li><li>也正是由于这个性质, <strong>在连续型随机变量求概率时</strong> , 这几个式子是没区别的: $ P \lbrace a \leq X \leq b \rbrace &#x3D; P \lbrace a &lt; X \leq b \rbrace &#x3D; P \lbrace a \leq X &lt; b \rbrace &#x3D; P \lbrace a &lt; X &lt; b \rbrace $</li></ul></li><li>$ F(x) &#x3D; P \lbrace - \infty &lt; X \leq x \rbrace &#x3D; \int_{- \infty}^x f(x)dx $<ul><li>根据密度函数的定义来的</li></ul></li><li>连续性随机变量的分布函数 $ F(x) &#x3D; \int_{- \infty}^x f(x) dx $ 一定是个连续函数.</li><li>对 $ F(x) $ 的连续点, 有 $ F’(x) &#x3D; f(x) $<ul><li>积分的逆过程就是求导嘛</li></ul></li></ul><hr><h3 id="2-4-2-概率密度函数-Vs-连续性随机变量的分布函数"><a href="#2-4-2-概率密度函数-Vs-连续性随机变量的分布函数" class="headerlink" title="2.4.2 概率密度函数 Vs 连续性随机变量的分布函数"></a>2.4.2 概率密度函数 Vs 连续性随机变量的分布函数</h3><p>我们直接给一个表, 展示一下这俩玩意的区别:</p><p>$$<br>\begin{array}{c|c}<br>    f(x) &amp; F(x) \\<br>    \hline<br>    0 \leq f(x) &amp; 0 \leq F(x) \leq 1 \\<br>    \hline<br>    \int_{- \infty}^{+ \infty} f(x) dx &#x3D; 1 &amp; F(x) &#x3D; \int_{- \infty}^x f(x) dx \\<br>    \hline<br>    可积, 不一定连续 &amp; 一定连续 \\<br>    \hline<br>    增减性无要求 &amp; 一定是不减函数 \\<br>\end{array}<br>$$</p><p>接下来我们给几个比较常见的连续型随机变量分布.</p><h3 id="2-4-3-均匀分布"><a href="#2-4-3-均匀分布" class="headerlink" title="2.4.3 均匀分布"></a>2.4.3 均匀分布</h3><p>算是连续型里面最简单的一个, 我们直接给概率密度函数:</p><p>$$<br>X \sim f(x) &#x3D; \begin{cases}<br>  \frac{1}{b-a} &amp; a \leq x \leq b \\<br>  0 &amp; else<br>\end{cases}<br>$$</p><p>我们将这种情况记作: $ X \sim U[a, b] $ , 它通常用于描述 <strong>概率在整个区间内均匀分布</strong> 的情况.</p><p>$$<br>F(x) &#x3D; \begin{cases}<br>  0 &amp; x&lt;a \\<br>  \frac{x-a}{b-a} &amp; a \leq x &lt; b \\<br>  1 &amp; b \leq x<br>\end{cases}<br>$$</p><p>读者如果像得到这个 $ F(x) $ 求个积分就可以了, 应该不算难.</p><h3 id="2-4-4-指数分布"><a href="#2-4-4-指数分布" class="headerlink" title="2.4.4 指数分布"></a>2.4.4 指数分布</h3><p>还是先给概率密度函数:</p><p>$$<br>X \sim f(x) &#x3D; \begin{cases}<br>  \lambda e^{- \lambda x} &amp; x&gt;0 \\<br>  0 &amp; x \leq 0<br>\end{cases}<br>$$</p><p>我们将这种情况记作 $ X \sim E(\lambda) $ , 常用来描述各种电子元件的使用寿命(越长概率越小).</p><p>$$<br>F(x) &#x3D; \begin{cases}<br>  0 &amp; x\leq 0 \\<br>  1 - e^{- \lambda x} &amp; x &gt; 0<br>\end{cases}<br>$$</p><hr><p>指数分布有个特别重要的性质, 在一些电子产品, 以至于信息行业中都广泛应用, 即它的 <strong>无记忆性</strong> .<br>给出公式是这样的:</p><p>$$<br>\begin{align*}<br>  \because &amp; X \sim E(\lambda) , s&gt;0, t&gt;0 \\<br>  \therefore &amp; P \lbrace X&gt;t \rbrace &#x3D; P \lbrace X&gt;s+t | X&gt;s \rbrace<br>\end{align*}<br>$$</p><p>这玩意是啥意思呢? 我们翻译一下:<br>你的电子产品的使用寿命如果严格服从指数分布, 那么: 你刚拿到它能用t天不损坏的概率, 与你过一段时间拿到它能够再用t天不损坏的概率是相等的!</p><h3 id="2-4-5-正态分布"><a href="#2-4-5-正态分布" class="headerlink" title="2.4.5 正态分布"></a>2.4.5 正态分布</h3><p>老样子, 先给概率密度函数:</p><p>$$<br>X \sim f(x) &#x3D; \frac{1}{\sqrt{2 \pi } \sigma} e^{- \frac{(x- \mu)^2}{2 \sigma^2}} , - \infty &lt; x &lt; + \infty<br>$$</p><p>我们将其记作 $ X \sim N(\mu, \sigma^2) $ , 这里的 $ \sigma &gt; 0 $</p><p>那这玩意的分布密度函数:</p><p>$$<br>F(x) &#x3D; \frac{1}{\sqrt{2 \pi } \sigma } \int_{- \infty}^x e^{- \frac{(x- \mu)^2}{2 \sigma^2}} dx, - \infty &lt; x &lt; + \infty<br>$$</p><hr><p>这玩意如果想证明归一性需要用到微积分中的一个公式:<br>$ \int_{- \infty}^{+ \infty} e^{x^2} dx &#x3D; \sqrt{\pi} $<br>这个公式读者想知道怎么证明应该可以上网搜, 挺多的.</p><p>有这个公式之后应该就好整了, 凑个微分就行, 在这就不详细说了.</p><hr><p>了解完这个, 我们来看一下正态分布的曲线, 这也是为啥它这么重要:<br>正态分布是一个以 $ x &#x3D; \mu $ 为对称轴的 <strong>钟形曲线</strong> .<br>长这样: ( $ \mu &#x3D; 12 , \sigma &#x3D; 3 $ )</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png" alt="正态分布"></p><p>这玩意着实比较有特点:</p><ul><li>$ x &lt; \mu $ , 函数增, $ x &gt; \mu $ , 函数减.</li><li>$ \mu $ 只能影响函数的对称轴(左右移动)</li><li>最大值 $ x &#x3D; \mu $ , $ y &#x3D; \frac{1}{\sqrt{2 \pi } \sigma } $</li><li>又由于这个函数的积分值(线下面积)恒为1, 因此:<ul><li>$ \sigma $ 越大, 最大值越小, 取值越分散, 曲线越胖</li><li>$ \sigma $ 越小, 最大值越大, 取值越集中, 曲线越瘦</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%8F%82%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D.png" alt="正态分布不同参数的影响"></p><h3 id="2-4-6-标准正态分布"><a href="#2-4-6-标准正态分布" class="headerlink" title="2.4.6 标准正态分布"></a>2.4.6 标准正态分布</h3><p>标准正态分布是正态分布的一种特殊情况:</p><p>$$<br>x \sim \phi(x) &#x3D; \frac{1}{\sqrt{2 \pi }} e^{- \frac{x^2}{2}} , - \infty &lt; x &lt; + \infty<br>$$</p><p>记作 $ X \sim N(0, 1) $ , 其分布函数记作 $ \Phi(x) $</p><p>根据我们上面的结论, 能得到:</p><ul><li>关于y轴对称 ( $ \phi(-x) &#x3D; \phi(x) $ )</li><li>$ \Phi(-x) &#x3D; 1 - \Phi(x) $<ul><li>$ \Phi(0) &#x3D; \frac{1}{2} $</li><li>$ P \lbrace | X | \leq x \rbrace &#x3D; \Phi(x) - \Phi(-x) &#x3D; 2 \Phi(x) - 1 $</li></ul></li></ul><p>上图中的红线其实就是 <strong>标准正态分布</strong> .</p><hr><p>有这么标准的一条曲线, 我们能不能把所有正态分布都放在这条曲线上进行操作?<br>当然是可以滴.</p><p>定理如下:<br>$ X \sim N(\mu, \sigma^2) , f(x), F(x) $<br>则:</p><ul><li>$ f(x) &#x3D; \frac{1}{\sigma} \phi(\frac{x- \mu }{\sigma}) $</li><li>$ F(x) &#x3D; \Phi(\frac{x- \mu }{\sigma}) $</li></ul><p>有了这俩玩意, 我们就能算任意正态分布的 $ f(x), F(x) $ 了(只要知道 $ \mu , \sigma $ )</p><p>这个公式还有个更快捷的方式:<br>定理2:<br>对于 $ X \sim N(\mu, \sigma^2) , f(x), F(x) $ , 令 $ Y &#x3D; \frac{x - \mu}{\sigma} $ , 则 $ Y \sim N(0, 1) $</p><p>因此:<br>$ P \lbrace a \leq X \leq b \rbrace &#x3D; P \lbrace \frac{a - \mu}{\sigma} \leq \frac{x - \mu}{\sigma} \leq \frac{b - \mu}{\sigma} \rbrace &#x3D; \Phi(\frac{b - \mu}{\sigma}) - \Phi(\frac{a - \mu}{\sigma}) $</p><p>这个玩意叫做 <strong>正态分布的标准化</strong> .</p><hr><p>除此之外, 还有个小结论, 读者想自己算一下也可以, 直接记住也行:<br>$ X \sim N(\mu, \sigma^2) $ ,<br>则:<br>X落在 $ | x - \mu | \leq \sigma $ 的范围内的概率为 0.6826;<br>X落在 $ | x - \mu | \leq 2 \sigma $ 的范围内的概率为 0.9544;<br>X落在 $ | x - \mu | \leq 3 \sigma $ 的范围内的概率为 0.9974;</p><p>可以通过这个结论记住这个 $ 3 \sigma $ 原则, 即正态分布几乎不会落在距离 $ \mu $ $ 3 \sigma $ 的范围外.</p><h2 id="2-5-随机变量函数的分布"><a href="#2-5-随机变量函数的分布" class="headerlink" title="2.5 随机变量函数的分布"></a>2.5 随机变量函数的分布</h2><p>这里的 <strong>随机变量函数</strong> 指的是通过我们上面学过的几种典型的随机变量 <strong>构造出的新随机变量</strong> .</p><h3 id="2-5-1-离散型随机变量函数"><a href="#2-5-1-离散型随机变量函数" class="headerlink" title="2.5.1 离散型随机变量函数"></a>2.5.1 离散型随机变量函数</h3><p>非常简单, 离散型只有几个取值点对吧, 只需要将对应的取值点按照给出的函数操作即可.<br>给个例子: $ Y &#x3D; 2X $</p><p>$$<br>\begin{array}{c|c|c|c}<br>  X &amp; 1 &amp; 2 &amp; 3 \\<br>  \hline<br>  Y &amp; 2 &amp; 4 &amp; 6 \\<br>  \hline<br>  P &amp; 0.3 &amp; 0.3 &amp; 0.4<br>\end{array}<br>$$</p><h3 id="2-5-2-连续型随机变量函数"><a href="#2-5-2-连续型随机变量函数" class="headerlink" title="2.5.2 连续型随机变量函数"></a>2.5.2 连续型随机变量函数</h3><p>这种情况是最麻烦的, 因为往往涉及到函数的转换操作.</p><p>通常有两种解法:</p><ul><li>通过 $ f(x) $ 求出分布函数 $ F_Y(y) $ , 随后 $ F_Y(y) $ 对 y 求导得到概率密度函数<ul><li>通过 $ Y &#x3D; G(X) $ 反解出 $ X &#x3D; G^{-1}(Y) $ , 从而把 $ P \lbrace Y \leq y \rbrace $ 转化为 $ P \lbrace X \leq G’(y) \rbrace $ , 再通过讨论y的范围进行积分计算.</li></ul></li><li>通过 $ f(x) $ 求出概率密度函数 $ f_Y(y) $ , 随后 $ f_Y(y) $ 对 y 积分得到分布函数<ul><li>同样的 , 将 $ P \lbrace Y \leq y \rbrace $ 转化为 $ P \lbrace X \leq G^{-1}(y) \rbrace $ , 也就是 $ F_Y(y) &#x3D; F_X(G^{-1}(y)) $</li><li>等式两侧同时对 $ y $ 求导, 得到 $ f_Y(y) &#x3D; f_X(G^{-1}(y)) * G^{-1}(y)’ $ , 得到Y的概率密度函数</li><li>积分即可.</li></ul></li></ul><hr><p>通过如上的步骤, 有这么两个结论要记一下:</p><p>对于均匀分布: $ X \sim U[a, b] , Y &#x3D; cX + d $ .<br>$ Y \sim U[ac + d, bc + d] $</p><p>对于正态分布: $ X \sim N(\mu, \sigma^2) , Y &#x3D; aX + b $<br>$ Y \sim N(a \mu + b, a^2 \sigma^2) $</p><p>当然, 上面只是非常简要的结论, 真正到比较复杂的函数变换时, 还是要照着此前的两种解法老老实实的干…</p><hr><p>本章的内容就到这里了, 主要是关于随机变量的一些概念上的明晰, 以及几种重要的概率分布需要读者了解.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学-概率论与数理统计 Chap.1 随机事件及其概率</title>
      <link href="/posts/30359.html"/>
      <url>/posts/30359.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列概率论博文基于Bilibili宋浩老师发布的概率论教学视频整理而来, 仅用作复习参考. 在此感谢宋浩老师的开源工作.</p></blockquote><h1 id="概率论与数理统计-Chap-1-随机事件及其概率"><a href="#概率论与数理统计-Chap-1-随机事件及其概率" class="headerlink" title="概率论与数理统计 Chap.1 随机事件及其概率"></a>概率论与数理统计 Chap.1 随机事件及其概率</h1><h2 id="1-0-预备知识"><a href="#1-0-预备知识" class="headerlink" title="1.0 预备知识"></a>1.0 预备知识</h2><h3 id="1-0-1-加法原理-乘法原理"><a href="#1-0-1-加法原理-乘法原理" class="headerlink" title="1.0.1 加法原理 &#x2F; 乘法原理"></a>1.0.1 加法原理 &#x2F; 乘法原理</h3><p>个人理解就是不同情况下计算可能性的方式. <strong>加法原理</strong> 通常用于在多种情况下选择 <strong>一种</strong> 的情况计算. <strong>乘法原理</strong> 则是 <strong>多步加法原理的组合</strong> , 比如一个事情需要分为多个步骤, 其总可能情况应当是每个步骤的可能情况的乘积.</p><h3 id="1-0-2-排列与组合"><a href="#1-0-2-排列与组合" class="headerlink" title="1.0.2 排列与组合"></a>1.0.2 排列与组合</h3><blockquote><p><strong><font color = #3490de>概念: 不可重复排列</font></strong><br>从 n 个不同的元素中任取 m 个不同的元素, 按 <strong>顺序</strong> 排成一列.<br>这意味着排列是要分顺序的, 这一点还请务必与之后的组合区分开.</p></blockquote><p>对于不可重复排列, 通常用 $ P_n^m $ , 或 $ A_n^m $ 来表示, 其计算方式为:</p><p>$$ P_n^m &#x3D; n(n-1)…(n-m+1) $$</p><blockquote><p><strong><font color = #3490de>概念: 可重复排列</font></strong><br>从 n 个不同的元素中 <strong>有放回的</strong> 取出 m 个不同的元素, 按 <strong>顺序</strong> 排成一列.<br>与上面的区别很明显了, 上面取出的m个玩意不能重复, 这个可以.</p></blockquote><p>对于可重复排列, 就没什么特别的记法了, 因为它的可能性直接是 $ n^m $ , 应该比较好理解.</p><blockquote><p><strong><font color = #3490de>概念: 组合</font></strong><br>从 n 个不同的元素中取出 m 个不同元素, <strong>不在意顺序</strong> 地拍成一列.<br>这就是组合跟排列的本质区别, 组合不需要考虑顺序的问题.</p></blockquote><p>对于组合, 我们通常用 $ C_n^m $ 进行表示, 其计算方式为:</p><p>$$ C_n^m &#x3D; \frac{P_n^m}{m!} &#x3D; \frac{n(n-1)…(n-m+1)}{m!} $$</p><hr><p>除了定义, 还有几个需要提前明确的事情:</p><ul><li>$ 0! &#x3D; 1 $ , 相当于从0个元素中选0个, 可不就是一种可能吗.</li><li>$ C_n^m &#x3D; C_n^{n-m} $ , 这俩其实是一个事情.</li><li>$ C_n^m &#x3D; C_{n-1}^{m-1} + C_{n-1}^{m} $ , 这个式子也是计算机中某些背包问题的本质思想, 对于一种组合而言, 针对某一个元素, 只有 <strong>选它 $ C_{n-1}^{m-1} $</strong> 和 <strong>不选它 $ C_{n-1}^m $</strong> 两种可能, 将这两种加起来就可以了.</li></ul><h2 id="1-1-随机试验与随机事件"><a href="#1-1-随机试验与随机事件" class="headerlink" title="1.1 随机试验与随机事件"></a>1.1 随机试验与随机事件</h2><h3 id="1-1-1-基础概念"><a href="#1-1-1-基础概念" class="headerlink" title="1.1.1 基础概念"></a>1.1.1 基础概念</h3><blockquote><p><strong><font color = #3490de>概念: 随机试验</font></strong><br>即一次可能产生多种结果的行为, 投硬币, 扔色子, 均在其列.<br>通常具有三个特性: 1) 可重复性; 2) 多结果性; 3) 不确定性;<br>通常用大写字母 $ E $ 表示.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 样本空间</font></strong><br>一次随机试验 $ E $ 所有可能的结果组成的集合, 称为这个随机试验的样本空间. 记作 $ \Omega $<br>其中每一种可能被叫做 <strong>样本点</strong> , 记作 $ \omega $ .</p></blockquote><p>根据上述两个定义, 把不同的事件进行了分类:</p><ul><li>必然事件: 就是必然发生的事件. 比如 <em>一个随机试验的结果落在样本空间内</em> .</li><li>基本事件: 不可再继续细分的事件, 即只包含一个样本点的事件.</li><li>随机事件: 有可能发生的事件, 即 $ \Omega $ 的 <strong>一个子集</strong> .</li><li>不可能事件: 不可能发生的事件, 即 <strong>不含任何样本点</strong> , 也记作 $ \phi $ .</li></ul><h3 id="1-1-2-集合表示"><a href="#1-1-2-集合表示" class="headerlink" title="1.1.2 集合表示"></a>1.1.2 集合表示</h3><p>可以发现我们经常把概率论中的内容当作集合来进行运算. 因此这里还要给一些集合关系在概率论中的含义:</p><ul><li>$ A \subset B $ : A发生必然导致B发生</li><li>$ A \cup B $ : A, B中至少有一个发生, 也写成 $ A + B $<ul><li>$ A \cup B \supset A $</li><li>$ A \cup A &#x3D; A $</li><li>$ A + \Omega &#x3D; \Omega $</li></ul></li><li>$ A \cap B $ : A, B必须同时发生, 也写成 $ AB $<ul><li>$ AB \subset A $</li><li>$ AA &#x3D; A $</li><li>$ A \cap \phi &#x3D; \phi $</li><li>$ A \Omega &#x3D; A $</li></ul></li><li>$ A - B $ : A发生, 而B不发生<ul><li>$ A - B &#x3D; A - AB &#x3D; A \overline{B} $ , 这个式子读者结合韦恩图来理解更简单.</li></ul></li></ul><p>还有几个特殊的关系需要给出来:</p><ul><li><strong>互斥</strong> : $ AB &#x3D; \phi $</li><li><strong>两两互不相容</strong> : 对于 $ A_1, A_2, … A_n $ 有 $ A_i A_j &#x3D; \phi, 1 \leq i &lt; j \leq n $</li><li><strong>对立</strong> : $ A+B &#x3D; \Omega, AB &#x3D; \phi $ , 这里把对立事件也这么写: $ B &#x3D; \overline{A} $</li></ul><p>这里也有一个老生常谈的结论了, <strong>对立一定互斥, 互斥不一定对立</strong> .</p><hr><p>最后是一种特殊情况: </p><blockquote><p><strong><font color = #3490de>概念: 完备事件组</font></strong><br>对于 $ A_1, A_2, …, A_n $ , 满足 $ \Sigma_{A_i} &#x3D; \Omega , A_i A_j &#x3D; \phi $ , 称这一组事件是一个完备事件组.<br>其实学过离散或者学过集合论就知道, 一个完备事件组就是 <strong>样本空间的一个划分</strong> .</p></blockquote><h3 id="1-1-3-事件运算律"><a href="#1-1-3-事件运算律" class="headerlink" title="1.1.3 事件运算律"></a>1.1.3 事件运算律</h3><p>这里笔者在离散数学中写过了, 并且写的应该比宋老师写的要全一些(无贬义, 离散集合论专门干这个的), 读者请移步 <a href="mug-chen.site/posts/44754.html#2-3-%E5%B8%B8%E7%94%A8%E7%9B%B8%E7%AD%89%E9%9B%86%E5%90%88">离散数学 Chap.2</a> 查看.</p><h2 id="1-2-频率与概率"><a href="#1-2-频率与概率" class="headerlink" title="1.2 频率与概率"></a>1.2 频率与概率</h2><h3 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h3><blockquote><p><strong><font color = #3490de>概念: 频率</font></strong><br>对于一个随机事件, 进行多次实验, 该随机事件发生的次数与总试验次数的比值, 被称作频率.</p></blockquote><p>通常频率具有稳定性, 即 <strong>试验次数越多, 其值越接近某个值(其实就是这个事件发生的概率)</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 概率</font></strong><br>对于实验E, 样本空间 $ \Omega $ , 事件A, 引申出一个实数, 记作 $ P(A) $ , 代表其发生概率.</p></blockquote><p>这个 $ P( \space ) $ 被称为 <strong>集合函数</strong> : </p><ul><li>非负性: $ P(A) \geq 0 $</li><li>规范性: $ P(\Omega) &#x3D; 1 $</li><li>互斥可加: 对于 <strong>两两互斥的</strong> $ A_1, A_2, …, A_n $ , $ P(\Sigma A_i) &#x3D; \Sigma P(A_i) $</li></ul><h3 id="1-2-2-性质"><a href="#1-2-2-性质" class="headerlink" title="1.2.2 性质"></a>1.2.2 性质</h3><p>概率有一些比较重要的性质, 还是写一下:</p><ul><li>$ P( \phi ) &#x3D; 0 $<ul><li>这条性质反过来是不成立的: 即如果 $ P(A) &#x3D; 0 $ , <strong>推不出</strong> $ A &#x3D; \phi $ . 这意味着 <strong>概率为0的事件也有可能发生!</strong></li></ul></li><li>如果A, B互斥, 能推出 $ P(A + B) &#x3D; P(A) + P(B) $<ul><li>同样, <strong>反之不成立</strong> . 这要用到底下的加法公式, 我们最后再说这个事.</li></ul></li><li>$ P(\overline{A}) &#x3D; 1 - P(A) $</li><li>$ P(A-B) &#x3D; P(A) - P(AB) $</li><li>$ P(A+B) &#x3D; P(A) + P(B) - P(AB) $<ul><li>推广: $$ \cup_{i &#x3D; 1}^{n} A_i &#x3D; \sum_{i &#x3D; 1}^{n} |A_i| - \sum_{1 \leq i \neq j \leq n} |A_i \cap A_j| + \sum_{1 \leq i \neq j \neq k \leq n} |A_i \cap A_j \cap A_k| - … + (-1)^{n+1} | \cap_{i&#x3D;1}^{n} A_i | $$</li><li>同样在离散数学那里写过了, 读者请移步.</li></ul></li></ul><hr><p>现在我们写一下为什么性质2反过来不成立:</p><p>$$<br>\begin{align*}<br>  \because \space &amp; P(A+B) &#x3D; P(A) + P(B) \\<br>  \because \space &amp; 加法律(5) \\<br>  \therefore \space &amp; P(AB) &#x3D; 0<br>\end{align*}<br>$$</p><p>我们貌似能推出 $ P(AB) &#x3D; 0 $ 对吧, 但是由于性质1反过来就不成立( <strong>概率为0的事件不一定是不可能事件</strong> ) , 因此我们不能推出 AB 是不可能事件, 也就无法证明 AB 互斥.</p><h2 id="1-3-古典概型与几何概型"><a href="#1-3-古典概型与几何概型" class="headerlink" title="1.3 古典概型与几何概型"></a>1.3 古典概型与几何概型</h2><h3 id="1-3-1-古典概型"><a href="#1-3-1-古典概型" class="headerlink" title="1.3.1 古典概型"></a>1.3.1 古典概型</h3><p>我们此前高中接触到的概率大部分均为古典概型, 因此我们要先把这一部分捯饬明白.<br>古典概型有以下两个特点:</p><ul><li>有限个样本点</li><li>等可能性</li></ul><p>这意味着, 我们只需要知道一个随机事件 A 中的样本点总数 m 以及样本空间中的总样本点 n, 就能直接得到这个随机事件发生的概率:</p><p>$$ P(A) &#x3D; \frac{n}{m} $$</p><hr><p>关于古典概型, 有一种很经典的抽签问题: 有n个有奖签, m个无奖签, 现在有q个人来进行抽签, 问 (1) 有放回的条件下, 这q个人中奖的概率分别是多少? (2) 无放回的条件下, 这q个人中奖的概率分别是多少?</p><p>读者感兴趣可以自己算一下, 最终的结果是一样的, 都是 $ \frac{n}{m+n} $ .</p><p>除此之外, 还有个很出名的生日悖论, 也可以搜一下, 这里就不展开了.</p><h3 id="1-3-2-几何概型"><a href="#1-3-2-几何概型" class="headerlink" title="1.3.2 几何概型"></a>1.3.2 几何概型</h3><p>几何概型相比于古典概型就多了一个 <strong>数学建模</strong> 的过程. 相当于将概率问题几何化后, 根据几何图形的特征进行求解. 因此, 在此就不过多的展开这一部分的知识了, 有兴趣的读者可以去了解一下等车问题与会面问题.</p><h2 id="1-4-条件概率-乘法公式"><a href="#1-4-条件概率-乘法公式" class="headerlink" title="1.4 条件概率 &#x2F; 乘法公式"></a>1.4 条件概率 &#x2F; 乘法公式</h2><h3 id="1-4-1-条件概率的定义"><a href="#1-4-1-条件概率的定义" class="headerlink" title="1.4.1 条件概率的定义"></a>1.4.1 条件概率的定义</h3><blockquote><p><strong><font color = #3490de>概念: 条件概率</font></strong><br>对于事件A, B, 且 $ P(A) &gt; 0 $ , 在A已经发生的条件下, B发生的概率, 即 B对A的条件概率, 记作 $ P(B | A) $</p></blockquote><p>读者需要理解, 条件概率最重要的特点是 <strong>样本空间</strong> 发生了变化, <strong>A已经发生</strong> 这句话本身意味着人工对样本空间做出了限定.</p><p>条件概率有一个比较常用的计算方法, 它同时也是乘法公式的来源:</p><p>$$ P(B | A) &#x3D; \frac{P(AB)}{P(A)} $$</p><p>随后有几个条件概率的性质可以提一嘴:</p><ul><li>$ 0 \leq P(B | A) \leq 1 $<ul><li>概率的基本性质, 不提了.</li></ul></li><li>在 $ B_1, B_2, … $ 两两互不相容的前提下, $ P(\Sigma_{i &#x3D; 1}^{\infty} B_i | A) &#x3D; P(B_1 | A) + P(B_2 | A) + … $<ul><li>这一条解释一下, 读者要理解上面提到的条件概率的特点, 即 <strong>改变了样本空间</strong> . 因此在新的样本空间中, 一堆互不相容(互斥)事件的概率还是可以直接相加的.</li></ul></li><li>$ P(\phi | A) &#x3D; 0 $<ul><li>空事件永远不可能发生, 不提了.</li></ul></li><li>$ P(B_1 \cup B_2 | A) &#x3D; P(B_1 | A) + P(B_2 | A) - P(B_1 B_2 | A) $<ul><li>注意, 这条跟性质2差在了互斥上, 因此还需要减掉一个重复的部分. 把它理解成样本空间在A上的事件并集就行.</li></ul></li><li>$ P(B | A) + P(\overline{B} | A) &#x3D; 1 $<ul><li>样本空间虽然改变了, 但是B发生和不发生加一块的概率肯定还是1.</li></ul></li></ul><h3 id="1-4-2-乘法公式"><a href="#1-4-2-乘法公式" class="headerlink" title="1.4.2 乘法公式"></a>1.4.2 乘法公式</h3><p>乘法公式就是根据条件概率的计算方法推过来的:</p><p>$$ P(AB) &#x3D; P(A) * P(B | A) $$</p><p>值得说一下的是一个推广:</p><p>$$ P(ABC) &#x3D; P(A) * P(B | A) * P(C | AB) $$</p><h2 id="1-5-全概率-贝叶斯"><a href="#1-5-全概率-贝叶斯" class="headerlink" title="1.5 全概率 &#x2F; 贝叶斯"></a>1.5 全概率 &#x2F; 贝叶斯</h2><h3 id="1-5-1-全概率公式"><a href="#1-5-1-全概率公式" class="headerlink" title="1.5.1 全概率公式"></a>1.5.1 全概率公式</h3><p>全概率公式跟我们之前说过的一个概念 <strong>完备事件组</strong> 有关, 读者忘记了可以再去看看, 其实就是个集合的划分.</p><p>给出定义:<br>假设 $ A_1, A_2, …, A_n $ 是一个完备事件组, 且 $ P(A_i) &gt; 0 $ . 同时有一事件B.<br>则 $ P(B) &#x3D; P(A_1) * P(B | A_1) + P(A_2) * P(B | A_2) + … P(A_n) * P(B | A_n) $</p><p>相当于将样本空间分为了多个子事件, 考虑事件B在每个子事件中发生的概率, 加和即可.</p><p>明确了全概公式的含义, 我们其实就能明白下面的推广是啥意思:<br>推广是这样的:</p><p>只要有 $ \Sigma_{i &#x3D; 1}^n A_i \supset B $ , 即使 $ A_i $ 不是完备事件组, 上式同样成立.</p><p>意思就是B没有涉及的子事件我不用管它了, 我只看B涉及到了哪些子事件即可.</p><h3 id="1-5-2-贝叶斯公式"><a href="#1-5-2-贝叶斯公式" class="headerlink" title="1.5.2 贝叶斯公式"></a>1.5.2 贝叶斯公式</h3><p>全概率公式是通过分割样本空间, 来求某个事件在整个样本空间中发生的总概率.<br>贝叶斯公式是要求某件事情发生的前提下, 其来源于样本空间中某一子事件的概率.</p><p>还请读者读明白上面这两句话, 再看贝叶斯的定义.</p><p>假设 $ A_1, A_2, …, A_n $ 是一个完备事件组, 且有一个事件B. $ P(A_i) &gt; 0 $ 且 $ P(B) &gt; 0 $<br>则 $ P(A_k | B) &#x3D; \frac{P(A_k B)}{P(B)} &#x3D; \frac{P(A_k) * P(B | A_k)}{P(A_1) * P(B | A_1) + P(A_2) * P(B | A_2) + … + P(A_n) * P(B | A_n)} $</p><p>这个玩意还有个名字, 叫 <strong>后验概率</strong> , 指的就是 <strong>当某件事情发生后, 其来源于不同子事件的概率大小</strong> .</p><p>我们用通俗一些的语言解释一下上面这个公式:<br>B发生的前提下, 是 $ A_k $ 导致B发生的概率 &#x3D; $ A_k $ 发生, 且 B 发生的概率 &#x2F; $ \Sigma $ ( $ A_i $ 发生, 且 B 发生的概率)</p><h2 id="1-6-事件的独立性-伯努利概型"><a href="#1-6-事件的独立性-伯努利概型" class="headerlink" title="1.6 事件的独立性 &#x2F; 伯努利概型"></a>1.6 事件的独立性 &#x2F; 伯努利概型</h2><h3 id="1-6-1-事件的独立性"><a href="#1-6-1-事件的独立性" class="headerlink" title="1.6.1 事件的独立性"></a>1.6.1 事件的独立性</h3><p>我们先给出定义:</p><p>对于事件A, B.<br>如果 $ P(B | A) &#x3D; P(B) $ , 称事件B对事件A独立.<br>反之, $ P(A | B) &#x3D; P(A) $ , 称事件A对事件B独立.<br>若上述两条都满足, 称事件A, B相互独立.</p><p>这定义的想法就是事件A是否发生对于事件B的概率没有影响的时候, 就称B对A独立, 其实还是挺好理解的.<br>但问题是, 这定义有点太不好用了, 要算俩条件概率, 费劲.</p><p>所以给改造了一下, 给出A, B相互独立的等价条件:</p><p>$$ P(AB) &#x3D; P(A) * P(B) $$</p><p>有兴趣的读者可以根据定义证明一下这个式子是不是相互独立的充要条件, 应该不算难, 笔者这里就不费笔墨了.</p><hr><p>通过上面这个定义, 能够非常轻松地推出几个结论:</p><ul><li>$ \phi $ 与任意事件A均相互独立, $ \Omega $ 与任意事件A均相互独立.<ul><li>这挺好理解的, 不管A怎么滴, $ \phi $ 总不发生, $ \Omega $ 总发生.</li></ul></li><li>A, B相互独立, 则 $ A, \overline{B} $ ; $ \overline{A}, B $ ; $ \overline{A}, \overline{B} $ 均相互独立.<ul><li>也简单, A B都相互独立了, 那你发生还是不发生跟我有什么关系.</li></ul></li><li>如果 $ P(A) &#x3D; 0 $ 或 $ P(A) &#x3D; 1 $ , 则事件A与其它任意事件均独立.<ul><li>对于 $ P(A) &#x3D; 0 $ 的情况: $ P(AB) \leq P(A) &#x3D; 0 &#x3D; P(A) * P(B) $</li><li>对于 $ P(A) &#x3D; 1 $ 的情况: $ P(\overline{A}) &#x3D; 0 $ , B一定与 $ \overline{A} $ 独立, 那么根据性质2, B也一定与A独立.</li></ul></li></ul><hr><p>有一个非常常用的 <strong>相互独立</strong> 的例子, 即 <strong>有放回的抽签</strong> , 这玩意经常在题目中考, 还请读者记牢它.</p><h3 id="1-6-2-互斥-独立"><a href="#1-6-2-互斥-独立" class="headerlink" title="1.6.2 互斥 &amp; 独立?"></a>1.6.2 互斥 &amp; 独立?</h3><p>这是俩很容易混淆的概念, 在这我们得明确一下.</p><p><strong>互斥</strong> 的定义是 $ AB &#x3D; \phi $<br><strong>相互独立</strong> 的定义是 $ P(AB) &#x3D; P(A) * P(B) $</p><p>这俩显然不太一样.</p><p>假如我们默认 A, B 的概率均不为零的话, 我们甚至能够有这样一个推论:<br>互斥则 <strong>一定不独立</strong> ; 独立则 <strong>一定不互斥</strong> .</p><h3 id="1-6-3-伯努利概型"><a href="#1-6-3-伯努利概型" class="headerlink" title="1.6.3 伯努利概型"></a>1.6.3 伯努利概型</h3><p>我们先明确一个概念 <strong>伯努利事件</strong>.</p><blockquote><p><strong><font color = #3490de>概念: 伯努利事件</font></strong><br>即样本空间有且仅有两种可能的事件.</p></blockquote><p>我们将一个伯努利事件 <strong>独立的</strong> 重复n次, 这被我们称为 <strong>n重伯努利实验</strong> .<br>给出定义:</p><p>如果有一个n重伯努利实验, 其中每一次伯努利事件A发生的概率为 $ P(A) &#x3D; p $ .<br>则在n次中, 该事件发生k次的概率为:</p><p>$$ C_n^k p^k (1-p)^{n-k} $$</p><p>这个式子我们通俗的解释一下:<br>从n次里面先选k次, 随后乘上一种选择方式的概率即可.</p><hr><p>至此, 概率论第一章的内容就结束了.</p><p>读者可以感觉到这一章主要是捡一捡高中的知识, 没太多新东西.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 概率论 </tag>
            
            <tag> Probability Theory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-离散数学-Chap.3</title>
      <link href="/posts/28179.html"/>
      <url>/posts/28179.html</url>
      
        <content type="html"><![CDATA[<h1 id="离散数学-Chap-3-整数-数论"><a href="#离散数学-Chap-3-整数-数论" class="headerlink" title="离散数学 Chap.3 整数, 数论"></a>离散数学 Chap.3 整数, 数论</h1><p>离散数学此后的内容会跟数论沾点边, 所以这部分我们把数论的内容捡一下.</p><h2 id="3-1-除法-整除"><a href="#3-1-除法-整除" class="headerlink" title="3.1 除法 &#x2F; 整除"></a>3.1 除法 &#x2F; 整除</h2><h3 id="3-1-1-整除及其性质"><a href="#3-1-1-整除及其性质" class="headerlink" title="3.1.1 整除及其性质"></a>3.1.1 整除及其性质</h3><p>首先是一个整除的标识:</p><blockquote><p><strong><font color = #3490de>概念: 整除</font></strong><br>两个整数 $ a, b $ , 如果存在一个整数 $ c $ 使得 $ b &#x3D; ac $ 成立, 则我们称之为 $ a $ 整除 $ b $ . 记为 $ a \mid b $ . 反之则 $ a \nmid b  $ .</p></blockquote><p>还有四个比较常用的性质:</p><p>$ \forall a, b, c \in Z $</p><ul><li>$ a \mid 0 \space (a \neq 0) $</li><li>$ (a \mid b \land a \mid c) \to a \mid (b+c) $</li><li>$ a \mid b \to a \mid bc $</li><li>$ (a \mid b \land b \mid c) \to a \mid c $</li></ul><h3 id="3-1-2-余数-取余"><a href="#3-1-2-余数-取余" class="headerlink" title="3.1.2 余数 &#x2F; 取余"></a>3.1.2 余数 &#x2F; 取余</h3><blockquote><p><strong><font color = #3490de>概念: 余数</font></strong><br>对任意被除整数 $ a $ 以及 除数 $ d $ , 存在唯一的两个整数 $ p, r $ , 使 $ a &#x3D; dp + r $ 成立, 其中 $ 0 \leq r \leq |d| $ . r被称为余数.</p></blockquote><p>我们为这种运算单独写个运算子叫 <strong>取余运算子</strong> . 按上面的定义来说:</p><p>$$ a \space mod \space d &#x3D; r $$</p><hr><p>余数是有限的, 而整数是无限的, 因此理论上所有整数可以根据余数来分类对不对, 我们引出 <strong>同余</strong> 的概念.</p><blockquote><p><strong><font color = #3490de>概念: 同余(Modular Congruence)</font></strong><br>对于除数 $ d $ , 整数 $ a, b $ 有相同的余数, 称 $ a, b $ 相对于 $ d $ 同余. 记作 $ a \equiv b \space (mod \space d) $<br>这同样代表着 $ d \mid (a-b) $ </p></blockquote><p>取余运算同样有些有用的性质:</p><p>$ \exists a, b, c, d \in Z, m \in Z^+, a \equiv b \space (mod \space m) , c \equiv d \space (mod \space m) $</p><ul><li>$ a + c \equiv b + d \space (mod \space m) $</li><li>$ a + b \equiv ((a \space mod \space m) + (b \space mod \space m)) \space (mod \space m) $</li><li>$ ac \equiv bd \space (mod \space m) $</li><li>$ ab \equiv ((a \space mod \space m)(b \space mod \space m)) \space (mod \space m) $</li></ul><p><del>(叽里咕噜说啥呢, 听不懂)</del> , 读者莫急, 这上面一大片, 其实本质意思就是 <strong>取余这个运算, 对加法, 减法, 乘法而言, 都是具有分配律的</strong> .</p><h3 id="3-1-3-质数-最大公因数"><a href="#3-1-3-质数-最大公因数" class="headerlink" title="3.1.3 质数 &#x2F; 最大公因数"></a>3.1.3 质数 &#x2F; 最大公因数</h3><p>质数是从整除这个概念衍生出来的一种蛮特殊的数字:</p><blockquote><p><strong><font color = #3490de>概念: 质数(Prime)</font></strong><br>对于整数 $ p, p \geq 2 \land p \in Z $ , 如果有且仅有 $ 1, p $ 两个数字能够整除 $ p $ , 则我们称 $ p $ 是质数.</p></blockquote><p>随后是两个任意整数的最大公因数和最小公倍数:</p><blockquote><p><strong><font color = #3490de>概念: 最大公因数(GCD)</font></strong><br>$ gcd(a, b) &#x3D; max \lbrace m: m \mid a \land m \mid b \rbrace $</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 最小公倍数(LCM)</font></strong><br>$ lcm(a, b) &#x3D; min \lbrace m: a \mid m \land b \mid m \rbrace $</p></blockquote><p>当两个数的最大公因数等于1时, 称两个数 <strong>互质(coprime)</strong> .</p><h2 id="3-2-进制转换"><a href="#3-2-进制转换" class="headerlink" title="3.2 进制转换"></a>3.2 进制转换</h2><p>这个部分其实写过很多次了, 读者容博主犯个懒, 这里可以自行搜索关于 <strong>不同进制互相转换</strong> 的内容.</p><h2 id="3-3-欧几里得算法-逆元"><a href="#3-3-欧几里得算法-逆元" class="headerlink" title="3.3 欧几里得算法 &#x2F; 逆元"></a>3.3 欧几里得算法 &#x2F; 逆元</h2><h3 id="3-3-1-算法概述"><a href="#3-3-1-算法概述" class="headerlink" title="3.3.1 算法概述"></a>3.3.1 算法概述</h3><blockquote><p><strong><font color=#fa4659>注意</font></strong><br>这一部分会写的非常简略, 因为在本博客中 <a href="https://mug-chen.site/posts/56920.html#Chap-2-%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%EF%BC%8C%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">信安数学基础_期末复习章</a> 这一节写的很清楚, 就把基础部分粘过来, 还请读者移步该章节.</p></blockquote><p>基本思路:</p><p>$$ (a, b) &#x3D; (qb+r, b) &#x3D; (r, b) $$</p><p>将大的数字换成小的数字的带余除法形式, 而后依据最大公因子性质2, 直接将乘积去掉.<br>这个方法也叫做 <strong>辗转相除法</strong> .<br>直到没有余数为止, 此时的数字被就是二者的最大公因子.</p><hr><p>这里可以稍微给个证明, 其实很简单:</p><p>$$<br>\begin{align*}<br>  Known: &amp; (c \mid a) \land (c \mid b) \land (a &#x3D; qb + r) \\<br>  Proof: &amp; c \mid r \\<br>  Solution: &amp; (a &#x3D; qb + r) \to (r &#x3D; a - qb) \\<br>  &amp; (c \mid a) \land (c \mid b) \to c \mid (a - qb) \to (c \mid r) \\<br>  Proof &amp; \space End<br>\end{align*}<br>$$</p><p>反过来是一样的:</p><p>$$<br>\begin{align*}<br>  Known: &amp; (c \mid r) \land (c \mid b) \land (a &#x3D; qb + r) \\<br>  Proof: &amp; c \mid a \\<br>  Solution: &amp; (c \mid r) \land (c \mid b) \to c \mid (qb + r) \to (c \mid a) \\<br>  Proof &amp; \space End<br>\end{align*}<br>$$</p><h3 id="3-3-2-Re-同余"><a href="#3-3-2-Re-同余" class="headerlink" title="3.3.2 Re: 同余"></a>3.3.2 Re: 同余</h3><p>我们在之前讲余数这个玩意的时候, 说了这东西面对 加 &#x2F; 减 &#x2F; 乘都能分开算, 那除法呢?<br>事实上, 除法也能算, 但是有一定特殊条件.</p><p><strong>同余除法消去律(Cancellation Rules)</strong> 如下:</p><p>$$<br>\begin{align*}<br>  known : &amp; m \in Z^+, a, b, c \in Z \\<br>  if : &amp; ac \equiv bc \space (mod \space m) \land gcd(m, c) &#x3D; 1 \\<br>  then: &amp; a \equiv b \space (mod \space m)<br>\end{align*}<br>$$</p><p>这个玩意的证明也好办, 在这里也写一下:</p><p>$$<br>\begin{align*}<br>  \because &amp; \space ac \equiv bc \space (mod \space m) \\<br>  \therefore &amp; \space m \mid (ac - bc) \\<br>  \therefore &amp; \space m \mid (a - b)c \\<br>  \because &amp; \space gcd(m, c) &#x3D; 1 \\<br>  \therefore &amp; \space m \mid (a-b)<br>\end{align*}<br>$$</p><h3 id="3-3-3-逆元"><a href="#3-3-3-逆元" class="headerlink" title="3.3.3 逆元"></a>3.3.3 逆元</h3><p>给出逆元的概念: 对于整数 $ a $ , 存在 $ b $ 使得 $ ab \equiv 1 \space (mod \space m) $ , 此时称 $ a, b $ 互为逆元.<br>还请各位读者明确, 逆元存在的前提是 $ gcd(a, m) &#x3D; 1 $ .</p><p>读者可能稍微有点疑惑, 为什么? 别急, 我们把逆元的求法写出来就清晰了.<br>由 $ gcd(a, m) &#x3D; 1 $ , 可以通过扩展欧几里得算法得到 $ sa + tm &#x3D; 1 $ .<br>等式两边同时对m取余: $ sa \equiv 1 \space (mod \space m) $<br>得到这个 $ s &#x3D; b $</p><p>看完这个求法, 我们所说前提的必要性就呼之欲出了:<br>没有 $ gcd(a, m) &#x3D; 1 $ , 这个式子 $ sa + tm &#x3D; 1 $ 就不成立, 那何谈逆元?</p><h3 id="3-3-4-中国剩余定理"><a href="#3-3-4-中国剩余定理" class="headerlink" title="3.3.4 中国剩余定理"></a>3.3.4 中国剩余定理</h3><p>同样的, 我们在<a href="https://mug-chen.site/posts/56920.html#4-3-%E4%B8%80%E6%AC%A1%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B%E7%BB%84">信安数学基础_期末复习章</a>中有提, 这里不详细解释了.</p><h2 id="3-4-费马小定理"><a href="#3-4-费马小定理" class="headerlink" title="3.4 费马小定理"></a>3.4 费马小定理</h2><p>这玩意其实我们写过:<br>假设 $ p $ 是素数, 则对于一切不能被 $ p $ 整除的 $ a $ :</p><p>$$ a^{p-1} \equiv 1 \space (mod \space p) $$</p><hr><p>这是一个有关素数性质的定理. 那我们怎么记住它呢?</p><p>考虑所有不能被 $ p $ 整除的整数, 对 $ p $ 取余后还剩几种可能?<br>$ 1, 2, …, p-1 $ 对吧.</p><p>费马小定理的前提是 $ a $ 不能被 $ p $ 整除, 即 $ gcd(a, p) &#x3D; 1 $ (这是因为p是素数, 因此 $ a, p $ 互素).<br>那我们考虑 $ 1, 2, …, p-1 $ 中任何一个数字乘 $ a $ , 结果相对于 $ p $ 而言, 应该还是互素的.</p><p>这个结论明确之后, 我们把上面所有的式子乘起来:</p><p>$$ (p-1)! \equiv a^{p-1} \times (p-1)! \space (mod \space p) $$</p><p>把等式两侧的 $ (p-1)! $ 全部去掉, 最终就是我们的费马小定理:</p><p>$$ a^{p-1} \equiv 1 \space (mod \space p) $$</p><p>希望这个说明过程能有助于读者记忆这个式子.</p><hr><p>从课程上来看, 其实就讲了这些比较理论的东西, 读者也可以参考借鉴着我们给的 <a href="https://mug-chen.site/posts/56920.html">信安数学基础_期末复习章</a> 来看. </p><p><del>(并且事实上国内的离散貌似也不是狠注重数论和整数这一部分, 这部分更多的应用领域是密码学就是了)</del></p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
            <tag> Discrete Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-离散数学-Chap.2</title>
      <link href="/posts/44754.html"/>
      <url>/posts/44754.html</url>
      
        <content type="html"><![CDATA[<h1 id="离散数学-Chap-2-集合-函数-数列-级数"><a href="#离散数学-Chap-2-集合-函数-数列-级数" class="headerlink" title="离散数学 Chap.2 集合, 函数, 数列, 级数"></a>离散数学 Chap.2 集合, 函数, 数列, 级数</h1><blockquote><p>本系列离散数学博文基于Youtube易志偉老师的免费课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机组成原理 &#x2F; 计算机网络的相关内容.</p></blockquote><h2 id="2-1-集合"><a href="#2-1-集合" class="headerlink" title="2.1 集合"></a>2.1 集合</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><p><strong>集合</strong> , 这是个我们从初中倒腾到现在的玩意.  </p><blockquote><p><strong><font color = #3490de>概念: 集合(Set)</font></strong><br>一个 <strong>无序且内容不重复</strong> 的物体集.<br>集合内的元素 <strong>属于</strong> 集合. 集合 <strong>包含</strong> 其内的每一个元素.</p></blockquote><p>通常被记作:</p><p>$$ a \in S &#x2F; a \notin S $$</p><p>那这东西为什么在这门大学的课程里还要拉出来call back一下? <del>(没错, 我们上一章的东西又来了)</del><br>我们先再给出一些基本的概念.</p><blockquote><p><strong><font color = #3490de>概念: 集合的相等</font></strong><br>两个集合 $ A, B $ , 当且仅当 $ \forall x (x \in A \leftrightarrow x \in B) $ 时, 我们称二者相等.<br>两个集合内的元素完全相同.</p></blockquote><hr><p>然后, 我们还有个定义来描述集合内元素的数目:</p><blockquote><p><strong><font color = #3490de>概念: 集合的基(Cardinality)</font></strong><br>一个集合的 <strong>基</strong> , 即 <strong>集合内元素的数量</strong> . 通常用 $ |A| $ 来表示.</p></blockquote><p>之后有个数, 就有数量大小之分对吧, 还有可能这集合里面有 <strong>无限多</strong> 的元素.<br>根据元素个数 <strong>有限 &#x2F; 无限</strong> , 我们称之为 <strong>有限集(Finite Set) &#x2F; 无限集(Infinite Set)</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 集合套集合?</font></strong><br>先看个集合: $ A &#x3D; \lbrace \lbrace a, b, c \rbrace, \lbrace x \rbrace, x, y \rbrace $ , 那显然, $ \lbrace a, b, c \rbrace \in A $ 这种表述是完全成立的.<br>之所以举这个例子, 是为了告知读者, 集合中又包含一个集合是完全有可能的事情.</p></blockquote><hr><p>随后我们还要定义一个 <strong>子集</strong> 的概念.</p><blockquote><p><strong><font color = #3490de>概念: 子集(Subset)</font></strong><br>两个集合 $ A, B $ , 当且仅当 $ \forall x (x \in B \to x \in A) $ , 则称 $ B $ 是 $ A $ 的子集.<br>应该还挺好理解的, 子集里面的元素一定也是集合里的元素嘛.<br>会记作 $ B \subseteq A $</p></blockquote><p>但是这个概念其实有点太宽泛了, 因为我们会发现, 一个集合自己也是自己的子集, 这有点不太符合常识, 因此我们整了个叫 <strong>真子集</strong> 的玩意.</p><blockquote><p><strong><font color = #3490de>概念: 真子集(Proper Subset)</font></strong><br>两个集合 $ A, B $ , 当且仅当 $ \forall x (x \in B \to x \in A) \land \exists x (x \notin B \land x \in A) $ , 则称 $ B $ 是 $ A $ 的真子集.<br>比之前那个定义严格, B不能包含A的所有元素.<br>会记作 $ B \subsetneq A $</p></blockquote><h2 id="2-2-集合中的运算符号"><a href="#2-2-集合中的运算符号" class="headerlink" title="2.2 集合中的运算符号"></a>2.2 集合中的运算符号</h2><h3 id="2-2-1-交集-并集"><a href="#2-2-1-交集-并集" class="headerlink" title="2.2.1 交集 &#x2F; 并集"></a>2.2.1 交集 &#x2F; 并集</h3><p>读者别发怵哈, 说是集合中的运算符, 但是其实很多符号跟第一章的逻辑是异曲同工的. 第一章看明白了, 其实第二章不会太难哈.</p><p>首先是俩我们很熟悉的玩意:</p><blockquote><p><strong><font color = #3490de>概念: 交集(Intersection)</font></strong><br>两个集合 $ A, B $ , 构建集合 $ C $ , $ \forall x ((x \in A \land x \in B) \to x \in C) $ , 则我们称 $ C $ 是 $ A, B $ 的交集.<br>记作 $ C &#x3D; A \cap B $</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 并集(Union)</font></strong><br>两个集合 $ A, B $ , 构建集合 $ C $ , $ \forall x ((x \in A \lor x \in B) \to x \in C) $ , 则我们称 $ C $ 是 $ A, B $ 的并集.<br>记作 $ C &#x3D; A \cup B $</p></blockquote><p>这里有个挺重要的公式, 需要理解记忆一下:</p><p>$$ |A \cup B| &#x3D; |A| + |B| - |A \cap B| $$</p><p>俩太没意思了, 我们进一步推演一下?</p><p>$$ |A \cup B \cup C| &#x3D; |A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap C| + |A \cap B \cap C| $$</p><p>n个呢?</p><p>$$<br>\begin{align*}<br>  |A_1 \cup A_2 \cup … \cup A_n | &#x3D; &amp;  |A_1| + |A_2| + … + |A_n| &amp; 这里是每个单个集合的数量 \\<br>  &amp; - |A_1 \cap A_2| - |A_1 \cap A_3| - … &amp; 这里是两个的组合  \\<br>  &amp; + |A_1 \cap A_2 \cap A_3| + |A_1 \cap A_2 \cap A_4| + … &amp; 这里是三个的组合 \\<br>  &amp; … \\<br>  &amp; + (-1)^{n+1} |A_1 \cap A_2 \cap … \cap A_n| &amp; 这里是所有的加起来 \\<br>\end{align*}<br>$$</p><p>上面这种写法是比较冗余的, 主要目的在于让读者能够理解这个玩意在写什么. 有一种更简单的写法:</p><p>$$ \cup_{i &#x3D; 1}^{n} A_i &#x3D; \sum_{i &#x3D; 1}^{n} |A_i| - \sum_{1 \leq i \neq j \leq n} |A_i \cap A_j| + \sum_{1 \leq i \neq j \neq k \leq n} |A_i \cap A_j \cap A_k| - … + (-1)^{n+1} | \cap_{i&#x3D;1}^{n} A_i | $$</p><hr><p>除了单纯的定义之外, 还有个专有名词需要明确一下, 叫 <strong>互斥</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 互斥(Disjoint)</font></strong><br>两个集合 $ A, B $ , 当 $ A \cap B &#x3D; \emptyset $ 时, 称之为 $ A $ 与 $ B $ 互斥.</p></blockquote><p>这个东西能进一步衍生出来一种关系, 叫 <strong>分割</strong> . </p><blockquote><p><strong><font color = #3490de>概念: 分割(Partition)</font></strong><br>全集 $ U $ , 如果有这么一组集合 $ A_1, A_2, … , A_n $ , 它们满足 $ U &#x3D; \cup_{i&#x3D;1}^n $ 并且两两互斥, 则称 $ A_1, A_2, … , A_n $ 为 $ U $ 的一组 <strong>分割</strong> .<br>相当于你将一个整体拿刀切开来, 那不可能将一个元素同时分给两个部分对不.<br>这个概念在后续还挺有用的, 还希望读者能留个印象.</p></blockquote><hr><h3 id="2-2-2-幂集"><a href="#2-2-2-幂集" class="headerlink" title="2.2.2 幂集"></a>2.2.2 幂集</h3><blockquote><p><strong><font color = #3490de>概念: 幂集(The Power Set)</font></strong><br>一个集合 $ A $ , 由 $ A $ 的所有子集组成的集合被称为 $ A $ 的幂集.<br>通常记为 $ P(A) $ 或 $ 2^A $ .</p></blockquote><blockquote><p><strong><font color = #1fab89>例子: 幂集</font></strong><br>$ A &#x3D; \lbrace 1, 2, 3 \rbrace $<br>$ 2^A &#x3D; \lbrace \emptyset, \lbrace 1 \rbrace, \lbrace 2 \rbrace, \lbrace 3 \rbrace, \lbrace 1, 2 \rbrace, \lbrace 1, 3 \rbrace, \lbrace 2, 3 \rbrace, \lbrace 1, 2, 3 \rbrace \rbrace $</p></blockquote><p>读者想问了, 为啥写成这德行 $ 2^A $ ?<br>数一数上面的例子里面 A 的幂集有几个元素? 是不是正好是 $ 2^{|A|} $ ?</p><p>那问题又来了, 为啥是这个数?<br>易老师给了一种非常简单的理解法:</p><p>写幂集的过程就是 <strong>对集合内的元素进行挑选</strong> 的过程.<br>每一个 <strong>幂集的元素</strong> 都是一种挑法. 那总共几种挑法?<br>每个元素都有挑 &#x2F; 不挑两种选择, 因此幂集中总共 $ 2^{|A|} $ 个元素.</p><h3 id="2-2-3-笛卡尔积"><a href="#2-2-3-笛卡尔积" class="headerlink" title="2.2.3 笛卡尔积"></a>2.2.3 笛卡尔积</h3><blockquote><p><strong><font color = #3490de>概念: 笛卡尔积(Cartesian Products)</font></strong><br>两个集合 $ A, B $ , 其二者的笛卡尔积记为 $ A \times B &#x3D; \lbrace(a, b) | a \in A \land b \in B \rbrace $ .<br>是由两个集合中所有元素组成的有序对的集合.</p></blockquote><p>笛卡尔积的元素个数也挺简单的:</p><p>$$ |A \times B| &#x3D; |A| \times |B| $$</p><p>两边分别各取一遍就行.</p><h3 id="2-2-4-差集"><a href="#2-2-4-差集" class="headerlink" title="2.2.4 差集"></a>2.2.4 差集</h3><blockquote><p><strong><font color = #3490de>概念: 差集</font></strong><br>两个集合 $ A, B $ , 二者的差集定义为 $ A-B &#x3D; \lbrace x | x \in A \land x \notin B \rbrace $<br>很类似, 用A中的元素其中属于B的元素.</p></blockquote><h3 id="2-2-5-补集"><a href="#2-2-5-补集" class="headerlink" title="2.2.5 补集"></a>2.2.5 补集</h3><blockquote><p><strong><font color = #3490de>概念: 补集</font></strong><br>全集 $ U $ 和集合 $ A $ , 定义 $ A $ 的补集 $ \overline{A} &#x3D; \lbrace x | x \in U \land x \notin A \rbrace $<br>就是不在A内的全部元素. 按照刚刚的差集来写的话也能写成 $ U-A $ .</p></blockquote><h2 id="2-3-常用相等集合"><a href="#2-3-常用相等集合" class="headerlink" title="2.3 常用相等集合"></a>2.3 常用相等集合</h2><p>对的, 还是逃不开这玩意. 我们又得回来看看集合之间的运算有没有些规律.<br>读者不用太害怕哈, 这里很多公式跟逻辑那里几乎是一样的.</p><p>有个前提得说一下哈, 这里我们用 $ U $ 统一代指全集.</p><h3 id="2-3-1-恒等律-Identity-Laws"><a href="#2-3-1-恒等律-Identity-Laws" class="headerlink" title="2.3.1 恒等律(Identity Laws)"></a>2.3.1 恒等律(Identity Laws)</h3><p>$$ A \cap U &#x3D; A $$</p><p>$$ A \cup \emptyset &#x3D; A $$</p><h3 id="2-3-2-支配律-Domination-Laws"><a href="#2-3-2-支配律-Domination-Laws" class="headerlink" title="2.3.2 支配律(Domination Laws)"></a>2.3.2 支配律(Domination Laws)</h3><p>$$ A \cup U &#x3D; U $$</p><p>$$ A \cap \emptyset &#x3D; \emptyset $$</p><h3 id="2-3-3-幂等律-Idempotent-Laws"><a href="#2-3-3-幂等律-Idempotent-Laws" class="headerlink" title="2.3.3 幂等律(Idempotent Laws)"></a>2.3.3 幂等律(Idempotent Laws)</h3><p>$$ A \cap A &#x3D; A $$</p><p>$$ A \cup A &#x3D; A $$</p><h3 id="2-3-4-双重否定-Double-Negation"><a href="#2-3-4-双重否定-Double-Negation" class="headerlink" title="2.3.4 双重否定(Double Negation)"></a>2.3.4 双重否定(Double Negation)</h3><p>$$ \overline {\overline A} &#x3D; A $$</p><h3 id="2-3-5-结合律-Associative-Laws"><a href="#2-3-5-结合律-Associative-Laws" class="headerlink" title="2.3.5 结合律(Associative Laws)"></a>2.3.5 结合律(Associative Laws)</h3><p>俩式子:</p><p>$$ (A \cap B) \cap C &#x3D; A \cap (B \cap C) $$</p><p>$$ (A \cup B) \cup C &#x3D; A \cup (B \cup C) $$</p><h3 id="2-3-6-交换律-Commutative-Laws"><a href="#2-3-6-交换律-Commutative-Laws" class="headerlink" title="2.3.6 交换律(Commutative Laws)"></a>2.3.6 交换律(Commutative Laws)</h3><p>俩式子:</p><p>$$ A \cap B &#x3D; B \cap A $$</p><p>$$ A \cup B &#x3D; B \cup A $$</p><h3 id="2-3-7-分配律-Distributive-Laws"><a href="#2-3-7-分配律-Distributive-Laws" class="headerlink" title="2.3.7 分配律(Distributive Laws)"></a>2.3.7 分配律(Distributive Laws)</h3><p>$$ A \cap (B \cup C) &#x3D; (A \cap B) \cup (A \cap C) $$</p><p>$$ A \cup (B \cap C) &#x3D; (A \cup B) \cap (A \cup C) $$</p><h3 id="2-3-8-德摩根律-De-Morgan-Laws"><a href="#2-3-8-德摩根律-De-Morgan-Laws" class="headerlink" title="2.3.8 德摩根律(De Morgan Laws)"></a>2.3.8 德摩根律(De Morgan Laws)</h3><p>德摩根律有两个式子:</p><p>$$ \overline{A \cup B} &#x3D; \overline A \cap \overline B $$</p><p>$$ \overline{A \cap B} &#x3D; \overline A \cup \overline B $$</p><h3 id="2-3-9-吸收率-Absorption-Laws"><a href="#2-3-9-吸收率-Absorption-Laws" class="headerlink" title="2.3.9 吸收率(Absorption Laws)"></a>2.3.9 吸收率(Absorption Laws)</h3><p>$$ A \cap (A \cup B) &#x3D; A $$</p><p>$$ A \cup (A \cap B) &#x3D; A $$</p><h3 id="2-3-10-永真律-矛盾律-Nogation-Laws"><a href="#2-3-10-永真律-矛盾律-Nogation-Laws" class="headerlink" title="2.3.10 永真律 &#x2F; 矛盾律(Nogation Laws)"></a>2.3.10 永真律 &#x2F; 矛盾律(Nogation Laws)</h3><p>$$ A \cap \overline A &#x3D; \emptyset $$</p><p>$$ A \cup \overline A &#x3D; U $$</p><hr><p>读者请详细对比 2.3 部分和 第一章中的 1.2.1 部分.<br>可以发现其实就是把 $ \land $ 换成了 $ \cap $ , 把 $ \lor $ 换成了 $ \cup $ , 把命题换成了集合.<br>进一步说, 其实 $ \cap $ 类似于运算中的乘法, $ \cup $ 类似于运算中的加法, $ \emptyset $ 相当于0, $ U $ 相当于运算中的1.</p><hr><p>现在问题来了, 式子, 我们有了, 证明, 怎么干?<br>既然说了这地方跟逻辑非常像, 我们自然需要给出一个像逻辑那边一样简单的证明方法.<br>是啥, 笔者个人比较喜欢将其称作 <strong>元素关系表</strong> , 英文名叫 <strong>Membership Table</strong> .<br>这种表格中会假设一个元素, 并用T &#x2F; F表示元素是否在某个集合内.</p><p>我们以证明集合的德摩根率为例.</p><p>$$ \overline{A \cup B} &#x3D; \overline A \cap \overline B $$</p><p>$$<br>\begin{array}{|c|c|c|c|c|c|c|}<br>\hline<br>A &amp; B &amp; A \cup B &amp; \overline{A \cup B} &amp; \overline{A} &amp; \overline{B} &amp; \overline{A} \cap \overline{B} \\<br>\hline<br>T &amp; T &amp; T &amp; F &amp; F &amp; F &amp; F \\<br>T &amp; F &amp; T &amp; F &amp; F &amp; T &amp; F \\<br>F &amp; T &amp; T &amp; F &amp; T &amp; F &amp; F \\<br>F &amp; F &amp; F &amp; T &amp; T &amp; T &amp; T \\<br>\hline<br>\end{array}<br>$$</p><p>同样的, 观察上表, 会发现 $ \overline{A \cup B} $ 和 $ \overline A \cap \overline B $ 的表项是完全一样的. 那么就能证明上式成立.</p><p>显然, 这个方法与逻辑中 <strong>真值表</strong> 相同, 只能用来处理小的问题. 至于大问题怎么解决? 咱给这些公式就是为了解决更大的问题的.</p><h2 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h2><blockquote><p><strong><font color = #3490de>概念: 函数(Function)</font></strong><br>函数, 是针对两个集合而言的.<br>假设有两个集合 $ A, B $ , 如果对于 $ A $ 中 <strong>每一个元素</strong> , $ B $ 中都有一个元素与之相对应, 称之为有一个 从 $ A $ 到 $ B $ 的函数.</p></blockquote><p>读者请明确, <strong>函数</strong> 有两个重要的点:</p><ul><li>A中的每个元素都能在B中找到一个元素与之对应.</li><li>A中的一个元素对应在B中的元素是唯一的.</li></ul><hr><p>接下来, 写一下函数有关的一些专有名词:</p><p>对于一个从 $ A $ 到 $ B $ 的函数. 我们通常记作: $ f: A \to B $ .<br>$ A $ 被称作该函数的 <strong>定义域(domain)</strong> , $ B $ 被称作该函数的 <strong>对应域 &#x2F; 值域(codomain)</strong> .<br>相对应的, 我们设 $ a \in A, b \in B $ , 如果 $ b $ 是 $ a $ 的对应值, 则记作: $ f(a) &#x3D; b $ .<br>这种情况下, $ b $ 是 $ a $ 的 <strong>值</strong> (也叫 <strong>像</strong> &#x2F; <strong>image</strong> ).<br>$ a $ 是 $ b $ 的 <strong>原像</strong> ( <strong>preimage</strong> ).</p><blockquote><p><strong><font color=#fa4659>注意: 像与原像的关系</font></strong><br>按照定义, 我们需要明确, 一个像可以有多个原像, 但一个原像只能对应一个像.</p></blockquote><hr><p>接下来给一个比较常见的函数, 叫 <strong>高斯函数</strong></p><p>$$ f(x) &#x3D; \lfloor x \rfloor $$</p><p>$$ f(x) &#x3D; \lceil x \rceil $$</p><p>这二者分别表示整数 <strong>向下 &#x2F; 向上</strong> 取整. 有 $ \lfloor x \rfloor \leq x \leq \lceil x \rceil $ .</p><blockquote><p><strong><font color = #1fab89>例子: 高斯函数相关的证明</font></strong><br>证明: $ \lfloor 2x \rfloor &#x3D; \lfloor x \rfloor + \lfloor x + \frac{1}{2} \rfloor $<br>提示: 用第一章提到过的枚举法.<br>将x设置为整数部分 $ n $ + 小数部分 $ r $ , 针对小数部分进行讨论即可.</p></blockquote><hr><p>好的, 还有几种比较特殊的函数, 我们这里介绍一下:</p><blockquote><p><strong><font color = #3490de>概念: 单射函数(Injection &#x2F; One to one)</font></strong><br>对于一个函数, 如果有 $ (f(a) &#x3D; f(b)) \to (a &#x3D; b) $ , 则称之为单射函数.<br>相当于每个函数的 <strong>像对应的原像也是唯一的</strong> .</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 满射函数(Surjection &#x2F; Onto)</font></strong><br>对于一个函数, 如果满足 $ \forall b \in B ( \exists a \in A, f(a) &#x3D; b) $ ,则称之为满射函数.<br>相当于对应域中的 <strong>每个像都能找到至少一个原像</strong>.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 双射函数(Bijection &#x2F; One to one &amp; Onto)</font></strong><br>对于一个函数, 如果它又是单射, 又是满射, 则它是双射函数<br>相当于是 <strong>严格一对一的函数</strong> .</p></blockquote><hr><p>随后, 是反函数相关的内容:</p><blockquote><p><strong><font color = #3490de>概念: 反函数(Inverse Function)</font></strong><br>对于一个 <strong>双射函数</strong> $ f:A \to B $ , 可以定义它的反函数 $ f^{-1}: B \to A $ , 当 $ f(a) &#x3D; b $ ,则有 $ f^{-1}(b) &#x3D; a $ .<br>反函数存在的前提是这个函数一定得是一个 <strong>双射函数</strong> . 读者可以拿高中阶段的一些函数理解一下, 必须是严格一对一的函数才存在反函数.</p></blockquote><h2 id="2-5-数列-求和"><a href="#2-5-数列-求和" class="headerlink" title="2.5 数列 &#x2F; 求和"></a>2.5 数列 &#x2F; 求和</h2><p>这里又把一个我们之前看过的玩意拉出来了, 咋回事呢?<br>因为数列这东西其实可以看成一种比较特殊的函数.</p><blockquote><p><strong><font color = #3490de>概念: 数列(Sequences) &#x2F; 级数(Summation)</font></strong><br>数列可以看作一种特殊的函数, 它的定义域一定是 <strong>整数的子集</strong> .<br>级数, 则代表着一个数列某些函数值的总加和. 通常, 如果从第 j 项加至第 k 项, 使用 $ \sum_{i&#x3D;j}^k a_i $ 进行表示.</p></blockquote><p>随后还是把两个最常见的数列写一下:</p><blockquote><p><strong><font color = #3490de>概念: 等差数列(Arithmetic Progression)</font></strong><br>数列项与项之间的差值始终相同. 通常管数列的第一个值 $ a_0 $ 叫 <strong>首项</strong> , 管数列项与项的差值 $ d $ 叫 <strong>公差</strong> .</p></blockquote><p>等差数列的级数:</p><p>$$<br>\begin{align*}<br>  S_n &amp; &#x3D; \sum_{i &#x3D; 0}^n (a + id) \\<br>  &amp; &#x3D; (a + (a + nd)) * (n+1) * (\frac{1}{2}) \\<br>\end{align*}<br>$$</p><blockquote><p><strong><font color = #3490de>概念: 等比数列(Geometric Progression)</font></strong><br>数列项与项之间的倍数差距始终相同. 通常管数列的第一个值 $ a_0 $ 叫 <strong>首项</strong> , 管数列项与项的倍数差 $ r $ 叫 <strong>公比</strong> .</p></blockquote><p>等比数列的级数:</p><p>$$<br>\begin{align*}<br>  S_n &amp; &#x3D; \sum_{i &#x3D; 0}^n ar^i \\<br>  &amp; &#x3D; \frac{a(r^{n+1}-1)}{r-1} \\<br>\end{align*}<br>$$</p><hr><p>这之后是在微积分里面提过的几个概念, 我们假设c是常数, $ f_n, g_n $ 是两个数列的通项公式:</p><p>常数可提:</p><p>$$ \sum_{n} cf_n &#x3D; c \sum_{n} f_n $$</p><p>加减可拆:</p><p>$$ \sum_{n} (f_n + g_n) &#x3D; \sum_{n} f_n + \sum_{n} g_n $$</p><p>下标可换:</p><p>$$ \sum_{n &#x3D; i}^j f_n &#x3D; \sum_{n &#x3D; i+k}^{j+k} f_{n-k} $$</p><p>计算可分:</p><p>$$ \sum_{n &#x3D; i}^k f_n &#x3D; \sum_{n &#x3D; i}^j f_n + \sum_{n &#x3D; j+1}^k f_n \space (if \space i \leq j &lt; k) $$</p><p>算序可变:</p><p>$$ \sum_{n&#x3D;0}^{2k} f_n &#x3D; \sum_{n&#x3D;0}^k f_{2n} + f_{2n+1} $$</p><hr><p>最后一些常用的级数公式:</p><p>$$<br>\begin{align*}<br>  \sum_{k&#x3D;1}^n k^2 &amp; &#x3D; \frac{n(n+1)(2n+1)}{6} &amp;  \\<br>  \sum_{k&#x3D;1}^n k^3 &amp; &#x3D; \frac{n^2 (n+1)^2}{4} &amp;  \\<br>  \sum_{k&#x3D;0}^{\infty} x^k &amp; &#x3D; \frac{1}{x-1} &amp; |x|&lt;1 \\<br>  \sum_{k&#x3D;1}^{\infty} kx^{k-1} &amp; &#x3D; \frac{1}{(x-1)^2} &amp; |x|&lt;1 \\<br>\end{align*}<br>$$</p><hr><h2 id="2-6-Re-集合的基数"><a href="#2-6-Re-集合的基数" class="headerlink" title="2.6 Re: 集合的基数"></a>2.6 Re: 集合的基数</h2><p>我们之前提过集合的基数:</p><blockquote><p><strong><font color = #3490de>概念: 集合的基(Cardinality)</font></strong><br>一个集合的 <strong>基</strong> , 即 <strong>集合内元素的数量</strong> . 通常用 $ |A| $ 来表示.</p></blockquote><p>现在有了 <strong>函数</strong> 这一概念, 我们应该回过头来, 重新给出一些更细致的定义.<br>为啥呢, 我们之前提过有些集合是 <strong>无限集</strong> , 但无限集和无限集之间的基数大小能否知道呢?</p><p>所以我们要给一个更明确的 <strong>基相等</strong> 的定义:</p><blockquote><p><strong><font color = #3490de>概念: 基数相等</font></strong><br>对于两个集合 $ A, B $ , 如果能构造一个双射函数(Bijection) $ f: A \to B $ , 则我们说这两个集合基数相等.</p></blockquote><p>进而衍生出了一个概念:</p><blockquote><p><strong><font color = #3490de>概念: 可数 &#x2F; 不可数(Countable &#x2F; Uncountable)</font></strong><br>对于一个集合 $ A $ , 如果能找到一个双射函数 $ f: A \to (subset \space of \space N) $ , 其中 $ N $ 为自然数集合. 则我们称这个集合可数.</p></blockquote><hr><p>第二章中大体的知识性内容就这些, 主要是对于集合运算的补充, 并补充了函数部分的内容.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
            <tag> Discrete Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-离散数学-Chap.1</title>
      <link href="/posts/44946.html"/>
      <url>/posts/44946.html</url>
      
        <content type="html"><![CDATA[<h1 id="离散数学-Chap-1-逻辑与证明"><a href="#离散数学-Chap-1-逻辑与证明" class="headerlink" title="离散数学 Chap.1 逻辑与证明"></a>离散数学 Chap.1 逻辑与证明</h1><blockquote><p>本系列离散数学博文基于Youtube易志偉老师的免费课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机组成原理 &#x2F; 计算机网络的相关内容.</p></blockquote><h2 id="引子-为什么要学离散"><a href="#引子-为什么要学离散" class="headerlink" title="引子, 为什么要学离散?"></a>引子, 为什么要学离散?</h2><p>在开始梳理前, 稿主认为有必要明确, <strong>离散数学在计算机体系中占据一个怎样的地位?</strong></p><p>尤其是, 离散数学甚至不在408的考试范围内, 为什么要学这门课?<br>以笔者的理解, 离散数学为计算机的很多结构建立了 <strong>基本模型</strong> , 并在其上提出了很多解决关于该模型问题的 <strong>通用方法</strong> . 在今后的学习中, 很多情况下我们离不开这些模型.</p><blockquote><p>本博文不太像知识的梳理, 更多的是博主根据课程内容与自己的理解进行的知识概述, 希望能对读者的学习过程有所帮助.</p></blockquote><h2 id="1-1-逻辑"><a href="#1-1-逻辑" class="headerlink" title="1.1 逻辑"></a>1.1 逻辑</h2><p>离散数学为什么要先讲逻辑呢? 因为计算机的很多功能脱不开逻辑, 如果脱离了逻辑, 那计算机就不能叫计算机了, 该叫计算器.</p><h3 id="1-1-1-命题"><a href="#1-1-1-命题" class="headerlink" title="1.1.1 命题"></a>1.1.1 命题</h3><p>首先, 需要明确几个概念:</p><blockquote><p><strong><font color = #3490de>概念: 命题(Propositions) &#x2F; 命题的真值(Truth Value)</font></strong><br><strong>命题</strong> 指一个可以 <strong>明确判别真假</strong> 的 <strong>陈述句</strong> .<br><strong>命题的真假</strong> 指这个命题到底 <strong>是真是假(True or False)</strong> .</p></blockquote><p>请读者注意, 命题一定要有两层意思在里面:</p><ul><li>它是有 <strong>对错之分的</strong> , 也就是说, 你一看到它就能觉得这东西有对错.</li><li>它是 <strong>能明确判别真假的</strong> .</li></ul><blockquote><p><strong><font color = #1fab89>例子: 命题 &#x2F; 非命题</font></strong><br>命题: $ 2+3 &#x3D; 5 $ ; $ 5+7&#x3D;10 $ ; 星期二的下一天是星期三.<br>非命题: $ x+3 &#x3D; 5 $ ; 你好! ; 我是学生, 请给我钱.</p></blockquote><hr><p>那问题来了, 上面的命题还挺短的, 如果命题贼长, 那每次都要写一遍也太费劲了, 所以给了个东西叫 <strong>命题变量(Propositional Variables)</strong></p><blockquote><p><strong><font color = #3490de>概念: 命题变量(Propositional Variables)</font></strong><br>指可以代表一个命题的一个变量.</p></blockquote><p>其实说白了就是把一个句子用一个字母指代一下.</p><blockquote><p><strong><font color = #fa4659>注意: 命题变量请务必用小写字母来表示</font></strong></p></blockquote><hr><p>所以, 命题被定义出来了, 就可以被组合起来计算了, 因此有个单独的模块叫 <strong>命题计算(Propositional Calculus)</strong> .</p><p>计算的话, 通常不会对单独一个命题进行计算, 那太简单了. 所以出现了 <strong>复合命题</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 复合命题(Compound Proposition) </font></strong><br>即被多个命题以及逻辑运算组合而成的新命题.</p></blockquote><blockquote><p><strong><font color = #1fab89>例子: 复合命题</font></strong><br>北京是中国的首都, 并且北京在中国的华北地带.</p><p>这就是两个命题的组合.</p></blockquote><p>这个概念不难, 但重要在其中有个要求, 就是必须用 <strong>逻辑运算(也叫逻辑算子 &#x2F; Logical Operators)</strong> 给它们串起来. <strong>那有哪些逻辑运算呢</strong> ?</p><h3 id="1-1-2-逻辑运算符"><a href="#1-1-2-逻辑运算符" class="headerlink" title="1.1.2 逻辑运算符"></a>1.1.2 逻辑运算符</h3><h4 id="1-1-2-1-非-Negation-Not"><a href="#1-1-2-1-非-Negation-Not" class="headerlink" title="1.1.2.1 非(Negation &#x2F; Not)"></a>1.1.2.1 非(Negation &#x2F; Not)</h4><blockquote><p><strong><font color = #3490de>概念: 非(Negation) </font></strong><br><strong>$ p $</strong> 是一个命题, 则通常用 <strong>$ \neg p $</strong> 或 <strong>$ \overline{p} $</strong> 来表示 <strong>非p</strong> . 即p的否定.</p></blockquote><p>说白了, 其表达的意思就是 p是错的(<em>Is not the state of p.</em>). 这意味着 $ p $ 与 $ \neg p $ 的 <strong>真值是相反的</strong> .</p><h4 id="1-1-2-2-且-Conjunction-And"><a href="#1-1-2-2-且-Conjunction-And" class="headerlink" title="1.1.2.2 且(Conjunction &#x2F; And)"></a>1.1.2.2 且(Conjunction &#x2F; And)</h4><blockquote><p><strong><font color = #3490de>概念: 且(Conjunction) </font></strong><br><strong>$ p, q $</strong> 是两个命题, 则通常用 <strong>$ p \land q $</strong> 来表示 <strong>p且q</strong> .</p></blockquote><p>意思是 <strong>只有p和q均为真, p且q才为真</strong> . 画个真值表:</p><p>$$<br>\begin{array}{|c|c|c|}<br>\hline<br>p &amp; q &amp; p \land q \\<br>\hline<br>T &amp; T &amp; T \\<br>T &amp; F &amp; F \\<br>F &amp; T &amp; F \\<br>F &amp; F &amp; F \\<br>\hline<br>\end{array}<br>$$</p><h4 id="1-1-2-3-或-Disjunction-Or"><a href="#1-1-2-3-或-Disjunction-Or" class="headerlink" title="1.1.2.3 或(Disjunction &#x2F; Or)"></a>1.1.2.3 或(Disjunction &#x2F; Or)</h4><blockquote><p><strong><font color = #3490de>概念: 或(Disjunction) </font></strong><br><strong>$ p, q $</strong> 是两个命题, 则通常用 <strong>$ p \lor q $</strong> 来表示 <strong>p或q</strong> .</p></blockquote><p>意思是 <strong>只有p和q均为假, p或q才为假</strong> . 画个真值表:</p><p>$$<br>\begin{array}{|c|c|c|}<br>\hline<br>p &amp; q &amp; p \lor q \\<br>\hline<br>T &amp; T &amp; T \\<br>T &amp; F &amp; T \\<br>F &amp; T &amp; T \\<br>F &amp; F &amp; F \\<br>\hline<br>\end{array}<br>$$</p><h4 id="1-1-2-4-异或-Exclusive-OR-XOR"><a href="#1-1-2-4-异或-Exclusive-OR-XOR" class="headerlink" title="1.1.2.4 异或(Exclusive OR &#x2F; XOR)"></a>1.1.2.4 异或(Exclusive OR &#x2F; XOR)</h4><p>我们先给真值表:</p><p>$$<br>\begin{array}{|c|c|c|}<br>\hline<br>p &amp; q &amp; p \oplus q \\<br>\hline<br>T &amp; T &amp; F \\<br>T &amp; F &amp; T \\<br>F &amp; T &amp; T \\<br>F &amp; F &amp; F \\<br>\hline<br>\end{array}<br>$$</p><blockquote><p><strong><font color = #3490de>概念: 异或(Exclusive OR) </font></strong><br><strong>$ p, q $</strong> 是两个命题, 则通常用 <strong>$ p \oplus q $</strong> 来表示 <strong>p异或q</strong> .</p></blockquote><p>意思是只有二者不同时, 异或才为真.</p><h4 id="1-1-2-5-条件运算符-Conditional-Operator-Only-if"><a href="#1-1-2-5-条件运算符-Conditional-Operator-Only-if" class="headerlink" title="1.1.2.5 条件运算符(Conditional Operator &#x2F; Only if)"></a>1.1.2.5 条件运算符(Conditional Operator &#x2F; Only if)</h4><blockquote><p><strong><font color = #3490de>概念: 条件运算符(Conditional Operator) </font></strong><br><strong>$ p, q $</strong> 是两个命题, 则通常用 <strong>$ p \to q $</strong> 来表示 <strong>若p则q</strong> .</p></blockquote><p>给出真值表:</p><p>$$<br>\begin{array}{|c|c|c|}<br>\hline<br>p &amp; q &amp; p \to q \\<br>\hline<br>T &amp; T &amp; T \\<br>T &amp; F &amp; F \\<br>F &amp; T &amp; T \\<br>F &amp; F &amp; T \\<br>\hline<br>\end{array}<br>$$</p><p>这里显然可能有些反常识, 因为 $ p $ 为假时, 该命题也为真. 这是因为当 $ p $ 前提都不满足, 则我们自然无法明确 $ p $ 与 $ q $ 的逻辑关系, 因此此时我们认为这种命题是对的.</p><p>用一种更广泛令人接收的说法: </p><p>若 <strong>$ p \to q $</strong> , 则 <strong>$ p $ 是 $ q $ 的充分条件</strong> , <strong>$ q $ 是 $ p $ 的必要条件</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 条件运算符的各种说法</font></strong><br>我去, 这玩意能说的方法可太多了, 什么if, unless, only if, … 读者就细品吧, 这东西挺 <em>多样</em> 的 :(</p></blockquote><hr><p>我们这里扩展一下, 多写一些东西:</p><p>$$<br>\begin{array}{|c|c|c|c|c|c|c|c|}<br>\hline<br>p &amp; q &amp; \neg p &amp; \neg q &amp; p \to q &amp; q \to p &amp; \neg p \to \neg q &amp; \neg q \to \neg p \\<br>\hline<br>T &amp; T &amp; F &amp; F &amp; T &amp; T &amp; T &amp; T \\<br>T &amp; F &amp; F &amp; T &amp; F &amp; T &amp; T &amp; F \\<br>F &amp; T &amp; T &amp; F &amp; T &amp; F &amp; F &amp; T \\<br>F &amp; F &amp; T &amp; T &amp; T &amp; T &amp; T &amp; T \\<br>\hline<br>\end{array}<br>$$</p><p>哎嘿, 这后面四列怎么有点相似呢是不是. 这种情况通常用一个三等于来表示:</p><p>$$ (p \to q) \equiv (\neg q \to \neg p) $$</p><p>$$ (q \to p) \equiv (\neg p \to \neg q) $$</p><p>这里就是提一下, 具体我们下一节再唠.</p><hr><h4 id="1-1-2-6-双条件运算符-Biconditional-Operator"><a href="#1-1-2-6-双条件运算符-Biconditional-Operator" class="headerlink" title="1.1.2.6 双条件运算符(Biconditional Operator)"></a>1.1.2.6 双条件运算符(Biconditional Operator)</h4><blockquote><p><strong><font color = #3490de>概念: 双条件运算符(Biconditional Operator) </font></strong><br><strong>$ p, q $</strong> 是两个命题, 则通常用 <strong>$ p \leftrightarrow q $</strong> 来表示 <strong>p q必须同时成立</strong> .</p></blockquote><p>事实上, 它有另一种表达方式:</p><p>$$ (p \leftrightarrow q) \equiv (p \to q) \land (q \to p) $$</p><p>那意思很简单, 就是前键跟后键必须相同, 这个式子才成立.</p><p>给个真值表:</p><p>$$<br>\begin{array}{|c|c|c|}<br>\hline<br>p &amp; q &amp; p \leftrightarrow q \\<br>\hline<br>T &amp; T &amp; T \\<br>T &amp; F &amp; F \\<br>F &amp; T &amp; F \\<br>F &amp; F &amp; T \\<br>\hline<br>\end{array}<br>$$</p><h4 id="1-1-2-7-运算符的优先权"><a href="#1-1-2-7-运算符的优先权" class="headerlink" title="1.1.2.7 运算符的优先权"></a>1.1.2.7 运算符的优先权</h4><p>直接给个表:</p><p>$$<br>\begin{array}{|c|c|}<br>\hline<br>operator &amp; priority \\<br>\hline<br>\neg &amp; 1 \\<br>\land &amp; 2 \\<br>\lor &amp; 3 \\<br>\to &amp; 4 \\<br>\leftrightarrow &amp; 5 \\<br>\hline<br>\end{array}<br>$$</p><p>给个记忆方式, 其实 $ \neg $ 类似于数学运算中的 $ - $ (负号) , $ \land $ 类似于 $ \times $ (乘) , $ \lor $ 类似于 $ + $ (加) , 剩下俩是逻辑运算, 在它们之后.</p><h2 id="1-2-逻辑等价"><a href="#1-2-逻辑等价" class="headerlink" title="1.2 逻辑等价"></a>1.2 逻辑等价</h2><p><strong>逻辑等价(Propositional Equivalences)</strong> , 即通过一些正确的关系, 来将一个复杂的逻辑表达式化简为比较简单的表达式的过程.</p><p>给两个定义:</p><blockquote><p><strong><font color = #3490de>概念: 永真式 &#x2F; 重言式(Tautology) </font></strong><br>一个复合逻辑命题, 它永远为真.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 矛盾式(Contradiction) </font></strong><br>一个复合逻辑命题, 它永远为假.</p></blockquote><blockquote><p><strong><font color = #1fab89>例子: 永真式 &#x2F; 重言式</font></strong></p></blockquote><p>$$<br>\begin{array}{|c|c|c|c|}<br>\hline<br>p &amp; \neg p &amp; p \land \neg p &amp; p \lor \neg p \\<br>\hline<br>T &amp; F &amp; F &amp; T \\<br>F &amp; T &amp; F &amp; T \\<br>\hline<br>\end{array}<br>$$</p><p>所以, 我们给出 <strong>逻辑等价</strong> 的定义:</p><blockquote><p><strong><font color = #3490de>概念: 逻辑等价(Propositional Equivalences) </font></strong><br><strong>$ p, q $</strong> 是两个命题, 如果 <strong>$ p \leftrightarrow q $</strong> 是一个永真式, 则称 $ p, q $ 逻辑等价, 记作: <strong>$ p \equiv q $</strong> .</p></blockquote><blockquote><p><strong><font color = #1fab89>例子: 逻辑等价</font></strong></p></blockquote><p>$$<br>\begin{array}{|c|c|c|c|c|c|c|c|}<br>\hline<br>p &amp; q &amp; \neg p &amp; \neg q &amp; p \to q &amp; q \to p &amp; \neg p \to \neg q &amp; \neg q \to \neg p \\<br>\hline<br>T &amp; T &amp; F &amp; F &amp; T &amp; T &amp; T &amp; T \\<br>T &amp; F &amp; F &amp; T &amp; F &amp; T &amp; T &amp; F \\<br>F &amp; T &amp; T &amp; F &amp; T &amp; F &amp; F &amp; T \\<br>F &amp; F &amp; T &amp; T &amp; T &amp; T &amp; T &amp; T \\<br>\hline<br>\end{array}<br>$$</p><p>$$ (p \to q) \equiv (\neg q \to \neg p) $$</p><p>$$ (q \to p) \equiv (\neg p \to \neg q) $$</p><h3 id="1-2-1-常用的逻辑等价关系"><a href="#1-2-1-常用的逻辑等价关系" class="headerlink" title="1.2.1 常用的逻辑等价关系"></a>1.2.1 常用的逻辑等价关系</h3><blockquote><p><strong><font color=#fa4659>注意: 逻辑等价的证明方法</font></strong><br>底下这一堆, 其实证明方式都是 <strong>画真值表</strong> . 容笔者犯个懒, 读者如果想证明就自己画一下就好.</p></blockquote><h4 id="1-2-1-1-恒等律-Identity-Laws"><a href="#1-2-1-1-恒等律-Identity-Laws" class="headerlink" title="1.2.1.1 恒等律(Identity Laws)"></a>1.2.1.1 恒等律(Identity Laws)</h4><p>$$ p \land True \equiv p $$</p><p>$$ p \lor False \equiv p $$</p><p>应该好理解, 上面是乘1, 下面是加0.</p><h4 id="1-2-1-2-支配律-Domination-Laws"><a href="#1-2-1-2-支配律-Domination-Laws" class="headerlink" title="1.2.1.2 支配律(Domination Laws)"></a>1.2.1.2 支配律(Domination Laws)</h4><p>$$ p \lor True \equiv True $$</p><p>$$ p \land False \equiv False $$</p><p>一个道理, 上面是加1, 下面是乘0.</p><h4 id="1-2-1-3-幂等律-Idempotent-Laws"><a href="#1-2-1-3-幂等律-Idempotent-Laws" class="headerlink" title="1.2.1.3 幂等律(Idempotent Laws)"></a>1.2.1.3 幂等律(Idempotent Laws)</h4><p>$$ p \land p \equiv p $$</p><p>$$ p \lor p \equiv p $$</p><p>自己乘自己和自己加自己.</p><h4 id="1-2-1-4-双重否定-Double-Negation"><a href="#1-2-1-4-双重否定-Double-Negation" class="headerlink" title="1.2.1.4 双重否定(Double Negation)"></a>1.2.1.4 双重否定(Double Negation)</h4><p>$$ \neg (\neg p) \equiv p $$</p><p>负负得正.</p><h4 id="1-2-1-5-结合律-Associative-Laws"><a href="#1-2-1-5-结合律-Associative-Laws" class="headerlink" title="1.2.1.5 结合律(Associative Laws)"></a>1.2.1.5 结合律(Associative Laws)</h4><p>俩式子:</p><p>$$ (p \land q) \land r \equiv p \land (q \land r) $$</p><p>$$ (p \lor q) \lor r \equiv p \lor (q \lor r) $$</p><h4 id="1-2-1-6-交换律-Commutative-Laws"><a href="#1-2-1-6-交换律-Commutative-Laws" class="headerlink" title="1.2.1.6 交换律(Commutative Laws)"></a>1.2.1.6 交换律(Commutative Laws)</h4><p>俩式子:</p><p>$$ p \land q \equiv q \land p $$</p><p>$$ p \lor q \equiv q \lor p $$</p><h4 id="1-2-1-7-分配律-Distributive-Laws"><a href="#1-2-1-7-分配律-Distributive-Laws" class="headerlink" title="1.2.1.7 分配律(Distributive Laws)"></a>1.2.1.7 分配律(Distributive Laws)</h4><p>$$ p \land (q \lor r) \equiv (p \land q) \lor (p \land r) $$</p><p>$$ p \lor (q \land r) \equiv (p \lor q) \land (p \lor r) $$</p><hr><p>还记得笔者说的记忆逻辑运算的方法吗, 把 $ \lor $ 记成加法, 把 $ \land $ 记成乘法.<br>加法和乘法是不是有交换律 &#x2F; 结合律 &#x2F; 分配律?<br>这里一个意思.</p><hr><h4 id="1-2-1-8-德摩根律-De-Morgan-Laws"><a href="#1-2-1-8-德摩根律-De-Morgan-Laws" class="headerlink" title="1.2.1.8 德摩根律(De Morgan Laws)"></a>1.2.1.8 德摩根律(De Morgan Laws)</h4><p>德摩根律有两个式子:</p><p>$$ \neg(p \lor q) \equiv \neg p \land \neg q $$</p><p>$$ \neg(p \land q) \equiv \neg p \lor \neg q $$</p><h4 id="1-2-1-9-吸收率-Absorption-Laws"><a href="#1-2-1-9-吸收率-Absorption-Laws" class="headerlink" title="1.2.1.9 吸收率(Absorption Laws)"></a>1.2.1.9 吸收率(Absorption Laws)</h4><p>$$ p \land (p \lor q) \equiv p $$</p><p>$$ p \lor (p \land q) \equiv p $$</p><h4 id="1-2-1-10-永真律-矛盾律-Nogation-Laws"><a href="#1-2-1-10-永真律-矛盾律-Nogation-Laws" class="headerlink" title="1.2.1.10 永真律 &#x2F; 矛盾律(Nogation Laws)"></a>1.2.1.10 永真律 &#x2F; 矛盾律(Nogation Laws)</h4><p>$$ p \land \neg p \equiv False $$</p><p>$$ p \lor \neg p \equiv True $$</p><h4 id="1-2-1-11-关于条件运算符"><a href="#1-2-1-11-关于条件运算符" class="headerlink" title="1.2.1.11 关于条件运算符"></a>1.2.1.11 关于条件运算符</h4><p>$$ p \to q \equiv \neg q \to \neg p $$</p><p>$$ p \to q \equiv \neg p \lor q $$</p><p>还有些过于复杂的玩意, 咱就不写了.</p><h4 id="1-2-1-12-关于双条件运算符"><a href="#1-2-1-12-关于双条件运算符" class="headerlink" title="1.2.1.12 关于双条件运算符"></a>1.2.1.12 关于双条件运算符</h4><p>$$ p \leftrightarrow q \equiv (p \to q) \land (q \to p) $$</p><p>$$ p \leftrightarrow q \equiv (p \land q) \lor (\neg p \land \neg q) $$</p><p>$$ p \leftrightarrow q \equiv \neg p \leftrightarrow \neg q $$</p><h3 id="1-2-2-逻辑运算"><a href="#1-2-2-逻辑运算" class="headerlink" title="1.2.2 逻辑运算"></a>1.2.2 逻辑运算</h3><p>上面一大堆, 但是实际上读者做熟练了会发现一个常用的原则.</p><p>一般而言, 最优先处理的永远是这俩玩意: <strong>$ \to $</strong> 或 <strong>$ \leftrightarrow $</strong> . 因为这俩玩意在式子里面搞得逻辑关系挺乱的. 那怎么处理?<br>$ p \to q \equiv \neg p \lor q $<br>$ p \leftrightarrow q \equiv (p \to q) \land (q \to p) $<br>$ p \leftrightarrow q \equiv (p \land q) \lor (\neg p \land \neg q) $</p><p>这种俩费劲的玩意倒腾完之后就可以直接套别的公式了.</p><p>本处实际上就是公式的运用, 实在没什么可以说的, 读者就自行找些题目练习一下就好.</p><h2 id="1-3-谓词逻辑"><a href="#1-3-谓词逻辑" class="headerlink" title="1.3 谓词逻辑"></a>1.3 谓词逻辑</h2><p><strong>谓词逻辑(Predicate Logic)</strong> , 相比于我们之前的内容更进一步, 能够更方便的表示一些很麻烦的玩意, 我们给个例子.</p><blockquote><p><strong><font color = #1fab89>例子: 谓词逻辑</font></strong><br>假如你现在要表示这么个意思, <strong>你们班上的所有人年龄都大于18岁</strong> .</p><p>我们只用我们之前学的, 会发现这东西太麻烦了, 我得一个个把人都列出来, 然后写出所有人的这个陈述: &lt;人名&gt;的年龄大于18岁 .<br>这太费劲了.</p></blockquote><p>因此, 可以引入一些如 <strong>$ P(x) $</strong> 的谓词以及两个量词 <strong>$ \forall, \exists $</strong> , 来表示上面这个意思.</p><p>啥是谓词?</p><blockquote><p><strong><font color = #3490de>概念: 谓词(Predicate) </font></strong><br>简单来说, 谓词就是一个陈述句模板, 它把原本陈述句中的名词(或判断对象)转变为了一个 <strong>变量</strong> .<br>这样的话就很好理解, 谓词本身是 <strong>没有对错的</strong> . (都有不确定变量了还怎么判断对错)<br>而经过填充后, 谓词才能形成一个命题, 进而被判断对错.</p></blockquote><p>那继续下一个问题, 我们怎么填充谓词? 先给出这俩量词的含义:</p><blockquote><p><strong><font color = #3490de>概念: 全称量词( $ \forall $ ) </font></strong><br>$ \forall P(x) $ 表示在指定的域中, 每一个元素x都使谓词P(x)为真.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 存在量词( $ \exists $ ) </font></strong><br>$ \exists P(x) $ 表示在指定的域中, 至少有一个元素x都使谓词P(x)为真.</p></blockquote><p>回到最开始的问题, 我可以这么设置:<br>$ P(x) $ : $ x $ 在你们班, 且年龄大于18岁.<br><strong>$ \forall x P(x) $</strong> .</p><p>读者品一下, 是不是就是最开始那个命题的意思?</p><hr><p><strong>关于两个量词的展开式</strong></p><p>其实两个量词更像一种简写, 它们是可以被展开的:</p><p>$$ \forall xP(x) \equiv P(x_1) \land P(x_2) \land … \land P(x_n) $$</p><p>$$ \exists xP(x) \equiv P(x_1) \lor P(x_2) \lor … \lor P(x_n) $$</p><p>那我们再想想, 是不是这个式子就成立(用德摩根律):</p><p>$$<br>\begin{align*}<br>  \neg (\forall xP(x)) &amp; \equiv \neg (P(x_1) \land P(x_2) \land … \land P(x_n)) \\<br>  &amp; \equiv \neg P(x_1) \lor \neg P(x_2) \lor … \lor \neg P(x_n) \\<br>  &amp; \equiv \exists (\neg P(x))<br>\end{align*}<br>$$</p><p>另一个也成立, 这里就不写了(懒):</p><p>$$ \neg (\exists xP(x)) \equiv \forall x (\neg P(x)) $$</p><p>这俩玩意我们用人话解释一下, 意思就是: </p><ul><li><strong>所有x都满足条件</strong> 的否定命题是 <strong>存在x不满足条件</strong> .</li><li><strong>存在x满足条件</strong> 的否定命题是 <strong>所有x都满足条件</strong> .</li></ul><p>是不是顺口多了 :)</p><hr><p>再往后, 我们还要明确一下这俩量词的优先级, 扩充一下表:</p><p>$$<br>\begin{array}{|c|c|}<br>\hline<br>operator &amp; priority \\<br>\hline<br>\forall, \exists &amp; 1 \\<br>\neg &amp; 2 \\<br>\land &amp; 3 \\<br>\lor &amp; 4 \\<br>\to &amp; 5 \\<br>\leftrightarrow &amp; 6 \\<br>\hline<br>\end{array}<br>$$</p><p>这俩玩意的优先级 <strong>非常非常高</strong> , 甚至比 $ \neg $ 还要更加优先一些.</p><hr><p>还有一些比较麻烦的事情, 我们在这里一并说一下, 我们假设 $ P(x, y) $ 意思是 <strong>x喜欢y</strong> , x, y的取值范围是班上的人, 请读者比较一下下面几个式子:</p><ul><li>$ \forall x \forall y P(x, y) $ : 班上所有同学都互相喜欢</li><li>$ \exists x \exists y P(x, y) $ : 班上存在一对同学, 其中一个喜欢另一个</li><li>$ \forall x \exists y P(x, y) $ : 班上所有的人都有另一个喜欢的人</li><li>$ \exists y \forall x P(x, y) $ : 班上有一个人被其它所有同学都喜欢着</li><li>$ \exists x \forall y P(x, y) $ : 班上有一个人喜欢其它所有人</li><li>$ \forall y \exists x P(x, y) $ : 对于班上的所有人, 都能找到另一个人喜欢自己</li></ul><p>希望通过这一堆例子, 能跟读者说明白, <strong>量词的顺序是很重要的!</strong> , 往往不同量词的顺序会产生截然不同的效果.</p><hr><p>另外一个需要注意的点, 即这种东西:</p><p>$$ \forall x (P(x) \to Q(x)) $$</p><p>只有加了 $ \forall x $ 后面那一层的括号之后, 才能代表x的作用范围是后面这一整条语句. 因此读者在书写或化简时, 请注意括号的使用, 不要漏掉它.</p><h2 id="1-4-推理与证明"><a href="#1-4-推理与证明" class="headerlink" title="1.4 推理与证明"></a>1.4 推理与证明</h2><h3 id="1-4-1-这是个啥"><a href="#1-4-1-这是个啥" class="headerlink" title="1.4.1 这是个啥?"></a>1.4.1 这是个啥?</h3><p>我们前面捣鼓了那么半天, 其实真正的目的就在这, 我们要尝试着根据我们知道的一些事情, 用我们学过的一些玩意, 推导出一些我们不知道, 或者需要证明的一些事情.</p><p>上面这个过程有两个更加正式的词语来定义它:</p><blockquote><p><strong><font color = #3490de>概念: 前提(Premises) </font></strong><br>从本质上来讲, 就是 <strong>若干个命题</strong> . 这些命题是我们已知的, 且真值一定为真.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 结论(Conclusion) </font></strong><br>其实也是一个或多个命题, 这个命题是我们需要证明的.</p></blockquote><p>所以我们其实可以把我们的目标写成这个样子, 假设前提为 <strong>$ p_1, p_2, …, p_n $</strong> , 结论为 <strong>$ q $</strong> , 我们希望证明:</p><p>$$ (p_1 \land p_2 \land … \land p_n) \to q $$</p><p>是个 <strong>永真式</strong> .</p><h3 id="1-4-2-我们怎么做"><a href="#1-4-2-我们怎么做" class="headerlink" title="1.4.2 我们怎么做?"></a>1.4.2 我们怎么做?</h3><p>首先需要肯定的是, 我们其实前面已经写了挺多的公式, 这已经为我们做推理造就了很好的条件. 但问题在于, 它们太 <strong>基础</strong> 了, 因此我们这里还得给一些更加常用的推理公式:</p><ul><li>肯定前键式: <strong>$ [p \land (p \to q)] \to q $</strong> , p为真, p能推出q, 那q一定为真.</li><li>否定后键式: <strong>$ [\neg q \land (p \to q)] \to \neg p $</strong> , q为假, p能推出q, 那p一定为假.</li><li>假言三段论: <strong>$ [(p \to q) \land (q \to r)] \to (p \to r) $</strong> , p能推出q, q能推出r, 那p一定能推出r.</li><li>选言三段论: <strong>$ [(p \lor q) \land \neg p] \to q $</strong> , p或q是真的, 但p是假的, 那q一定是真的.</li><li>加法规则: <strong>$ p \to (p \lor q) $</strong> , p是真的, 则p或上任何一个命题都一定是真的.</li><li>简化规则: <strong>$ (p \land q) \to p $</strong> , p和q是真的, 那p(q也一样)一定是真的.</li><li>合取规则: <strong>$ [(p) \land (q)] \to (p \land q) $</strong> , p是真的, q是真的, 那 p和q 也是真的.</li><li>归结规则: <strong>$ [(p \lor q) \land (\neg p \lor r)] \to (q \lor r) $</strong> , p或q是真的, 非p或r是真的, 那q和r一定有一个真的.</li></ul><p>希望读者能理解, 上面的式子笔者尽可能每一个都给出一个比较 <strong>通俗易懂</strong> 的解释, 但真要证明的话, 还是需要使用我们在 1.2 中唠叨完的式子来证明的. 笔者这里就不证明了 <del>(哥们, 用Markdown写完整证明, 真能把人写裂开)</del></p><hr><p>到此, 其实逻辑部分我们能讲的知识就差不多了, 其余的工作, 就是留给读者的 <strong>灵活运用</strong> , 那就不是笔者能做到的工作了对吧 :)</p><h3 id="1-4-3-额外补充-关于条件表达式的证明法"><a href="#1-4-3-额外补充-关于条件表达式的证明法" class="headerlink" title="1.4.3 额外补充, 关于条件表达式的证明法"></a>1.4.3 额外补充, 关于条件表达式的证明法</h3><p>很遗憾, 最后我们还是逃不开这个条件表达式, 这东西在逻辑里面实在是太常见了. <strong>$ p \to q $</strong> , 如果让我们得到这个结论, 我们该怎么整?<br>当然, 上述章节中我们提到的方法理论上一定可行对吧, 这叫做 <strong>直接证明(Direct Proof)</strong> , 我们假设p为真, 随后只要根据其它的前提得到q就可以.</p><p>但很现实的一点是, 有时候直接证明是很困难的一件事. 因此, 这里给出其余几种思路;</p><ul><li><strong>逆否证明(Proof by Contraposition)</strong> : 即证明结论的一个 <strong>等价命题</strong> , 在上例中, 我们也可以证明 <strong>$ \neg q \to \neg p $</strong> .</li><li><strong>反证法(Proof by Contradiction)</strong> : 即 <strong>假设结论是假的</strong> , 随后如果能推出与前提的矛盾, 则说明结论是真的. 上例中, 我们可以假设 <strong>$ p \land \neg q $</strong> 为真, 随后再尝试推出其与其它前提的矛盾即可.</li><li><strong>空泛证明 &#x2F; 平凡证明(Vacuous and Trivial Proof)</strong> : 这种情况专门针对结论的一部分进行证明. 在上例中, 假如我们能证明 <strong>$ p $ 永远是假的(矛盾式)</strong> 或者 <strong>$ q $ 永远是真的(重言式)</strong> . 那自然结论一定是真的.</li></ul><h3 id="1-4-4-枚举法"><a href="#1-4-4-枚举法" class="headerlink" title="1.4.4 枚举法"></a>1.4.4 枚举法</h3><p>这是最 <strong>简单粗暴</strong> 的一种方式. 我们要证明一个结论, 假如说, 我们能够得知结论中某些部分的值域(即所有的情况) , 那我们只需要将所有情况分类讨论, 并明确每种情况都符合我们的结论即可.</p><p>其实思路上有些像直接列真值表, 对吧.</p><hr><p>到这里, 就真的结束了.<br>对, 离散数学的第一章就讲了如何进行证明和逻辑推理.</p><p>这一定角度上是后面章节的基础.<br>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
            <tag> Discrete Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-计网-Chap.3</title>
      <link href="/posts/43938.html"/>
      <url>/posts/43938.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Chap-3-数据链路层"><a href="#计算机网络-Chap-3-数据链路层" class="headerlink" title="计算机网络 Chap.3 数据链路层"></a>计算机网络 Chap.3 数据链路层</h1><blockquote><p>本系列计算机网络博文基于Bilibili王道的免费考研课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机组成原理的相关内容.</p></blockquote><h2 id="3-0-写在前面"><a href="#3-0-写在前面" class="headerlink" title="3.0 写在前面"></a>3.0 写在前面</h2><p>本章的内容极其丰富, 因为王道考研的课程组织将很多后续章节中同样会涉及到的机制(流量控制, 差错控制, 可靠传输等)放到了数据链路层中一并讲解, 因此还请读者做好心理准备, 我们即将面对整个计网中最困难重重的一章(笑</p><p>不过也不必过于害怕, 啃完这一章, 后面的事情会轻松很多.</p><h2 id="3-1-数据链路层的功能"><a href="#3-1-数据链路层的功能" class="headerlink" title="3.1 数据链路层的功能"></a>3.1 数据链路层的功能</h2><p>我们还是得把老图搬过来, 倒腾一下数据链路层的位置:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="计算机网络的分层结构"></p><p>数据链路层上接网络层, 下接物理层. 因此其主要负责两件事:</p><ul><li>使用物理层提供的 <strong>比特传输</strong> 服务</li><li>为网络层提供服务, 将网络层的 <strong>IP数据报(也就是分组)</strong> 封装成 <strong>帧</strong> .</li></ul><p>因此, 数据链路实际上, 为底层的物理层提供了一层额外的封装(就是这个 <strong>帧</strong> ) , 它能够使得数据链路层在 <strong>物理链路</strong> 之上的 <strong>逻辑链路</strong> 上, 来进一步保证下层的数据传输的正确性.</p><hr><p>这之后, 我们来详细一些, 列举一下数据链路层的主要功能:</p><ul><li><strong>组帧 &#x2F; 拆帧</strong><ul><li>帧定界: 让接收方能够确认帧的界限, 对应 <strong>组帧</strong></li><li>透明传输: 接收方的链路层要能够根据对方发送信息的定界来恢复原始的数据报, 即数据链路层的 <strong>服务数据单元 (SDU &#x2F; Service Data Unit)</strong> , 并交付给其网络层. 对应 <strong>拆帧</strong></li></ul></li><li><strong>差错控制</strong><ul><li>需要能够发现一个帧内部的 <strong>位错误</strong></li><li>有 <strong>丢弃重传 &#x2F; 纠错改正</strong> 两种策略, 前者简单些, 后者复杂些</li></ul></li><li><strong>可靠传输</strong><ul><li>需要能够发现并解决 <strong>帧错误</strong></li><li>分为三种: <strong>帧丢失 &#x2F; 帧重复 &#x2F; 帧失序</strong></li></ul></li><li><strong>流量控制</strong><ul><li>匹配发送方和接收方的发送 &#x2F; 接收速率</li></ul></li><li><strong>介质访问控制</strong><ul><li>对于 <strong>广播信道(总线型拓扑)</strong> , 需要实现介质访问权的分配</li><li>对于 <strong>点对点信道</strong> , 则通常不需要提供该功能, 因为存在专属介质, 不需要依靠介质的分配和争抢</li></ul></li></ul><blockquote><p><strong><font color = #fa4659>注意: 差错控制 Vs 可靠传输</font></strong><br><strong>差错控制</strong> 通常针对的是 <strong>帧内部</strong> 的错误, 而 <strong>可靠传输</strong> 针对的是 <strong>帧之间</strong> 的错误.</p></blockquote><p>这之后的小节中, 我们会对数据链路层实现这一大堆功能的方法进行逐一说明.</p><h2 id="3-2-组帧"><a href="#3-2-组帧" class="headerlink" title="3.2 组帧"></a>3.2 组帧</h2><p><strong>组帧</strong> , 通常用于达成 <strong>帧定界</strong> 和 <strong>透明传输</strong> 的目的. 有四种常见的方案:</p><ul><li>字符计数法</li><li>字节填充法</li><li>零比特填充法</li><li>违规编码法</li></ul><h3 id="3-2-1-字符计数法"><a href="#3-2-1-字符计数法" class="headerlink" title="3.2.1 字符计数法"></a>3.2.1 字符计数法</h3><p><strong>字符计数法</strong> 的原理是在每个帧的开头加上一个单独的 <strong>定长计数段</strong> , 来表示每个帧的长度.</p><blockquote><p><strong><font color = #fa4659>注意: 帧长</font></strong><br>帧长, 指的是 计数字段长度和帧的数据部分长度的 <strong>总和</strong> .</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0%E6%B3%95.png" alt="字符计数法"></p><p>可知, 使用这种方法的帧的最大长度是有上限的, 其值为 <strong>$ 2^{计数字段长度}-1 $</strong> .</p><p>除此之外, 该方案的 <strong>最大缺陷</strong> 在于: <strong>任何一个计数字段出错, 都会导致后续全部的帧都无法正确定界</strong> .</p><h3 id="3-2-2-字节填充法"><a href="#3-2-2-字节填充法" class="headerlink" title="3.2.2 字节填充法"></a>3.2.2 字节填充法</h3><p><strong>字节填充法</strong> 的原理是用两个规定好的字符来 <strong>标志一个帧的开始与结尾</strong> . 它们分别叫 <strong>SOH(Start of Header)</strong> 和 <strong>EOT(End of Transmission)</strong> , 对应的16进制分别为 <strong>$ 01H $</strong> 和 <strong>$ 04H $</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="字节填充法"></p><p>这个方案也有问题, 因为当 <strong>数据内本身出现了SOH和EOT时</strong> , 会使接收方 <strong>误认为该内容是控制字符</strong> , 导致定界失败.</p><p>那咋办呢? 人们引入了一个新的字符叫 <strong>转义字符(ESC &#x2F; Escape Character)</strong> , 对应的16进制为 <strong>$ 1BH $</strong> .<br>如果发送方的数据中包含了 <strong>特殊字符(SOH, EOT, ESC)</strong> , 则需要在对应的字节之前插入一个转义字符, 同时接收方也会进行逆处理, 将数据中的转义字符删除, 并原封不动的保留其下一个字节的内容.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85%E6%B3%95%28%E5%B8%A6%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%29.png" alt="字节填充法(带转义字符)"></p><h3 id="3-2-3-零比特填充法"><a href="#3-2-3-零比特填充法" class="headerlink" title="3.2.3 零比特填充法"></a>3.2.3 零比特填充法</h3><p>这种方案的初心跟上一种类似, 只不过开头和结尾使用的定界符相同, 是 <strong>$ 7EH $</strong> , 对应的二进制是 <strong>$ 0111,1110 $</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95.png" alt="零比特填充法"></p><p>如果理解了上一种方法的问题, 则很容易发现这种方式也面临着同样的问题. 数据本身如果包含完全相同的字节, 就出问题了.</p><p>而这个方法中没有引入转移字符, 而是利用了 <strong>其规定定界符的特殊性</strong> :</p><ul><li>发送方对数据进行处理, 每当连续遇到5个1, 就 <strong>添加一个0</strong> .</li><li>接收方对数据进行逆处理, 每当连续遇到5个1, 就 <strong>删掉后面的0</strong> .</li></ul><p>经过这样的处理, 能够保证数据中一定不会出现跟定界符一样的 <strong>六个1连在一块</strong> 的情况.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85%E6%B3%95%28%E5%B8%A6%E5%A1%AB%E5%85%85%29.png" alt="零比特填充法(带填充)"></p><p>这种组帧方式极为常用, 因为它能够很快速的依赖硬件完成处理. 在当前数据链路层的两个主流协议( <strong>HDLC, PPP</strong> )中均有所采用.</p><h3 id="3-2-4-违规编码法"><a href="#3-2-4-违规编码法" class="headerlink" title="3.2.4 违规编码法"></a>3.2.4 违规编码法</h3><p>既然扯到 <strong>编码</strong> 了, 势必意味着这玩意需要物理层的配合. <del>(不知道读者还记不记得上一章物理层的东西, 笑)</del></p><p>我们以 <strong>曼彻斯特编码</strong> 为例, 其每一个码元中间是必须要进行一次 <strong>跳变</strong> 的.<br>那么, 只需要让物理层在每一帧的前面和后面, 分别插入一个时钟周期的 <strong>违规信号(比如中间不跳变)</strong> , 就可以很方便地让接收方知道帧的起始位置和结束位置.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E8%BF%9D%E8%A7%84%E7%BC%96%E7%A0%81%E6%B3%95.png" alt="违规编码法"></p><h2 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h2><p><strong>差错控制</strong> 的目标是 <strong>发现并解决一个帧内部的位错误</strong> . 解决方案通常有两种:</p><ul><li>发现错误后丢弃帧, 并通知发送方重传.<ul><li>只需要发现错误即可, <strong>检错编码</strong></li><li>奇偶校验码 &#x2F; CRC循环冗余校验码等</li></ul></li><li>发现错误并纠正比特错误<ul><li>需要能够确定是哪一位出了错, <strong>纠错编码</strong></li><li>海明校验码</li></ul></li></ul><h3 id="3-3-1-奇偶校验"><a href="#3-3-1-奇偶校验" class="headerlink" title="3.3.1 奇偶校验"></a>3.3.1 奇偶校验</h3><p><strong>奇偶校验</strong> 指的是通过一个单独的比特位来保证信息中 “1” 的个数为奇 &#x2F; 偶.</p><ul><li><strong>奇校验</strong> : 添加该校验位后, 该校验码中总共有奇数个1.</li><li><strong>偶校验</strong> : 添加该校验位后, 该校验码中总共有偶数个1.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81.png" alt="奇偶校验码"></p><p>通常而言, <strong>偶校验</strong> 要更加常用一些, 因为只需要通过模2加的情况就能简单的得到结果.</p><ul><li>发送方只需要将 <strong>数据的所有位</strong> 全部以 <strong>异或</strong> 的方式相加就能得到偶校验位.</li><li>接收方只需要将 <strong>校验码的所有位</strong> 全部 <strong>异或</strong> 起来, 结果为1说明数据出错, 结果为0说明通过.</li></ul><blockquote><p><strong><font color = #fa4659>注意: 异或?</font></strong><br>因为 <strong>异或</strong> 运算实际上相当于 <strong>模2加法</strong> , 因此结果为1就说明有奇数个1相加, 为0则反之.</p></blockquote><blockquote><p><strong><font color = #fa4659>注意: 奇偶校验的限制</font></strong><br>因为奇偶校验只能针对 “1” 数据位总数的奇偶性进行检测, 因此当 <strong>偶数个位发生错误时</strong> , 则此时奇偶校验码会失效.</p></blockquote><p>最后, 还请读者明确, <strong>奇偶校验码没有纠错功能, 只有检错功能</strong> .</p><h3 id="3-3-2-循环冗余校验"><a href="#3-3-2-循环冗余校验" class="headerlink" title="3.3.2 循环冗余校验"></a>3.3.2 循环冗余校验</h3><p><strong>循环冗余校验(CRC &#x2F; Cyclic Redundency Check)</strong> 的核心思路在于通信双方约定一个相同的 <strong>除数</strong> , 随后对信息本身运行二进制除法来确定最终的 <strong>余数</strong> .</p><p>其数据结构分如下两个部分:</p><ul><li><strong>信息位(K位)</strong> : 待校验的信息(也就是数据本身的位数)</li><li><strong>校验位(R位)</strong> : 位数与校验码本身有关, 校验码通常由 <strong>生成多项式</strong> 给出, 而校验码的位数就是 <strong>生成多项式最高次项的次数</strong></li></ul><hr><p>我们先捯饬明白一个问题: <strong>生成多项式是什么</strong> ?</p><p><strong>生成多项式</strong> 是通过一个一元多项式来生成一段二进制的校验码的一种方法. 通过将该多项式各个次数项的系数拼接而成. 我们给个例子</p><p>$$ G(x) &#x3D; x^3 + x^2 + 1 $$</p><p>则该多项式可以再写成: <strong>$ 1 \times x^3 + 1 \times x^2 + 0 \times x^1 + 1 \times x^0 $</strong> , 进而写成二进制的 <strong>$ 1101 $</strong> .</p><hr><p>现在的问题是, <strong>怎么除</strong> ?</p><p>在循环冗余校验中, 采用的是 <strong>模2除</strong> 的策略. 其算法为 <strong>仅通过最高位判断当前位的商</strong> , 后续低位则使用 <strong>异或</strong> 计算后顺延到下一次计算中.</p><p>我们给个例子, 假设信息位6位, 校验位3位(相当于最初直接将信息位左移3位):</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99-%E6%A8%A12%E9%99%A4.png" alt="循环冗余-模2除"></p><p>最终得到的三位余数就是最终的 <strong>校验位结果</strong> .</p><p>发送方计算得到这个校验码之后, 将 <strong>信息位 + 校验位</strong> 一并传输给接收方. 接收方收到后再次进行与发送方相同的运算, 并验证最终校验位是否为0即可.</p><blockquote><p><strong><font color = #fa4659>注意: 接收方验证是否为0?</font></strong><br>读者在这个位置可以类比一下除法的 <strong>余数</strong> , 发送方发送给接收方的数据是 <strong>信息位 + 校验位</strong> , 换句话说就是把发送方算出的余数加了上去, 再传给了接收方, 因此接收方在算相同的问题时, 只需要检验自己的运算结果是不是0即可.</p></blockquote><hr><p>这里需要额外提一嘴, 循环冗余校验 <strong>是具备纠错能力的</strong> , 但具备纠错的条件是校验码能够表示的状态数 ( $ 2^R $ ) 大于本身的数据位数 (K+R) . 因此在计算机网络中一般不常用它来纠错而已.</p><p>通常, 循环冗余校验码能够检测出所有:</p><ul><li>奇数位错误</li><li>双比特错误</li><li>小于等于校验位长度的错误</li></ul><h3 id="3-3-3-海明校验"><a href="#3-3-3-海明校验" class="headerlink" title="3.3.3 海明校验"></a>3.3.3 海明校验</h3><p><strong>海明校验</strong> 是对于偶校验的一种扩展. 他着眼于偶校验的校验码长度过短, 导致无法判断指定某位的错误.<br>那到底需要多少个校验位?</p><p>事实上上一节已经给出答案了, 如果校验位数为k, 则它总共能表示 $ 2^k $ 个状态, 这其中应当包括 n+<strong>k个信息位出错的情况</strong> 以及 <strong>正确的情况</strong> . 即:</p><p>$$ 2^k \geq n+k+1 $$</p><p>我们给个例子:  </p><p>4位信息位, 因此需要有3位校验码 ( <strong>$ 2^3 \geq 4+3+1 $</strong> ) .<br>随后是海明码的位置规定, 校验位 <strong>$ P_i $</strong> 应该放在数据位号为 <strong>$ 2^{i-1} $</strong> 的位置上. (即校验位的分布是 1, 2, 4, 8, 16, …)<br>再将数据位分别填入剩余别的位置上.</p><p>这之后进入分组, 我们将 <strong>$ P_i $ 与 位置序号第i位为1的数据位分为同一组</strong> .<br>对同一组的数据进行异或, 得到 $ P_i $ 的值(相当于进行 <strong>分组偶校验</strong> )<br>那怎么纠错呢, 就是验证对应分组的偶校验是否正确, 得到 $ S_1, S_2, S_3, … $ , 这个值标志着哪一位的数据出了错.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%B1%82%E8%A7%A3.png" alt="海明码求解"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%B5%B7%E6%98%8E%E7%A0%81%E7%BA%A0%E9%94%99.png" alt="海明码纠错"></p><p>请读者明确, 海明码具有 <strong>1位纠错</strong> 和 <strong>2位检错</strong> 的能力, 其中两位检错通常是通过前加全体偶校验提供的.</p><h2 id="3-4-可靠传输与流量控制-滑动窗口机制"><a href="#3-4-可靠传输与流量控制-滑动窗口机制" class="headerlink" title="3.4 可靠传输与流量控制 &#x2F; 滑动窗口机制"></a>3.4 可靠传输与流量控制 &#x2F; 滑动窗口机制</h2><p><strong>可靠传输</strong> 的目标是发现并解决 <strong>与帧整体相关的错误</strong> , 具体分为三类:</p><ul><li><strong>帧丢失</strong></li><li><strong>帧重复</strong></li><li><strong>帧失序</strong></li></ul><blockquote><p><strong><font color = #fa4659>注意: 差错控制中的丢弃重传</font></strong><br>在 <strong>差错控制</strong> 一节中, 我们提到过有些校验码只具有检错的功能, 而并不能纠错, 这意味着接收方只能丢弃该帧并进行重传. 这种情况下, 问题就回到了可靠传输的 <strong>帧丢失</strong> 这一类中.</p></blockquote><p><strong>流量控制</strong> 的目标是让发送方控制自己的数据传输速度以 <strong>能够与接收方的接受速度相匹配</strong> .</p><p>那为啥把这俩东西放一块唠呢?<br>因为这俩目标的实现都跟一个机制相关, 它叫 <strong>滑动窗口机制</strong> .</p><h3 id="3-4-1-滑动窗口机制"><a href="#3-4-1-滑动窗口机制" class="headerlink" title="3.4.1 滑动窗口机制"></a>3.4.1 滑动窗口机制</h3><p><strong>滑动窗口</strong> 是针对双方而言的, 它分为 <strong>发送窗口( $ W_t $ &#x2F; Transmit Window)</strong> 和 <strong>接收窗口( $ W_r $ &#x2F; Reveive Window)</strong> . 它们分别指 <strong>发送方当前允许发送的帧</strong> 和 <strong>接收方当前允许接收的帧</strong> .</p><blockquote><p><strong><font color = #fa4659>注意: 允许发送? 允许接收?</font></strong><br><strong>这一部分是笔者自己的理解, 如有错误还请读者谅解</strong><br>个人认为对于发送 &#x2F; 接收窗口的定义是有些模糊的, 从笔者的理解, 发送窗口包括了发送方当前 <strong>正在或准备传输但没能够接收到确认消息</strong> 的帧 , 而接收窗口包括了接收方当前 <strong>希望收到但还没有从发送方处收到的帧</strong> .</p></blockquote><p>因此, 发送方暂时不会发送在发送窗口外的帧, 而接收方也会拒绝接受在接收窗口外的帧.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE-1.png" alt="滑动窗口示意图-1"></p><p>那么, 窗口的 <strong>滑动</strong> 是如何体现的呢?</p><p>在 <strong>接收方收到滑动窗口内的帧时</strong> , 会主动先将自己的窗口向后移, 随后通过某种确认方式向发送方确认 <strong>我已经收到这个帧了</strong> , <strong>发送方收到该确认消息后</strong> , 也会主动将自己的发送窗口后移, 以达到同步的效果.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE-2.png" alt="滑动窗口示意图-2"></p><p>这样, 我们就大概明确了 <strong>滑动窗口</strong> 到底是个啥玩意.<br>随后我们要探讨的几个协议, 会在以下四个方面有所区别, 但请读者明确, <strong>它们的本质都是滑动窗口机制的延申</strong> .</p><ul><li>窗口大小</li><li>确认机制</li><li>重传机制</li><li>帧编号</li></ul><h3 id="3-4-2-停止等待协议"><a href="#3-4-2-停止等待协议" class="headerlink" title="3.4.2 停止等待协议"></a>3.4.2 停止等待协议</h3><p><strong>停止等待协议(SW &#x2F; Stop and Wait)</strong> , 是滑动窗口机制中最为简单的协议.</p><p>它的特点如下所示:</p><ul><li>窗口大小<ul><li>发送窗口 $ W_t &#x3D; 1 $</li><li>接收窗口 $ W_r &#x3D; 1 $</li></ul></li><li>确认机制<ul><li>接收方收到第i号帧, 且未检测出差错时, 发回给发送方一个确认消息 $ ACK_i $</li></ul></li><li>重传机制<ul><li>发送方若超时未收到 $ ACK_i $ , 则主动重传该帧</li></ul></li><li>帧编号<ul><li>仅需要1bit对帧进行编号</li></ul></li></ul><blockquote><p><strong><font color = #fa4659>注意: ACK?</font></strong><br><strong>ACK</strong> 是 <strong>Acknowledge</strong> 的缩写, 在此后的协议书写中会经常使用.</p></blockquote><hr><p>在这里我们单独对 <strong>帧编号</strong> 进行一个说明.</p><p>帧的编号需要满足一个条件, 即 <strong>窗口长度必须小于等于序号空间大小的一半</strong> .</p><p>$$ W_t &#x2F; W_r \leq 2^{n-1} $$</p><p>这个式子在随后的协议中也会看到, 而在停等协议中, n&#x3D;1就已能够满足该条件.</p><blockquote><p><strong><font color = #fa4659>注意: 窗口长度的限制</font></strong><br>这个位置王道的网课上给出的式子为 $ W_t + W_r \leq 2^n $ , 笔者认为这种写法不够严谨.<br>具体留给各位读者自行评判.</p></blockquote><hr><p>为了写清楚停等协议的具体步骤, 我们得画俩流程图 <del>(草, 这东西真费劲啊)</del></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE-%E5%8F%91%E9%80%81%E6%96%B9.iodraw.png" alt="停等协议-发送方"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE-%E6%8E%A5%E6%94%B6%E6%96%B9.iodraw.png" alt="停等协议-接收方"></p><p>我们对这种流程图进行一个说明:</p><ul><li>圈内指的是 <strong>当前实体的状态</strong></li><li>横线上是 <strong>当前实体收到的信息</strong></li><li>横线下是 <strong>当前实体会采取的措施</strong></li></ul><p>总结一下停等的总体思路:</p><ul><li>发送方发一个包, 等待接收方确认</li><li>接收方收到包, 发送确认消息, 等待发送方下一个包</li></ul><h3 id="3-4-3-后退N步协议"><a href="#3-4-3-后退N步协议" class="headerlink" title="3.4.3 后退N步协议"></a>3.4.3 后退N步协议</h3><p><strong>后退N步协议(GBN &#x2F; Go Back N)</strong> , 比停止等待协议要稍显复杂, 它的特点如下:</p><ul><li>窗口大小:<ul><li>发送窗口 $ W_t &gt; 1 $</li><li>接收窗口 $ W_r &#x3D; 1 $</li></ul></li><li>确认机制<ul><li>接收方收到第i号帧, 且未检测出差错时, 发回给发送方一个确认消息 $ ACK_i $</li></ul></li><li>重传机制<ul><li>发送方若超时未收到 $ ACK_i $ , 则主动重传该i号帧</li></ul></li><li>帧编号<ul><li>仅需要1bit对帧进行编号</li></ul></li><li><strong>特殊规则</strong><ul><li>接收方可以 <strong>累计确认</strong> . 即连续收到多个数据帧时, 只返回最后一个收到的帧的ACK</li><li>如果发送方超时未收到i号帧的ACK, 则重传 <strong>i号帧以及其之后的所有帧</strong></li></ul></li></ul><p>意义即接收方能够通过 <strong>$ ACK_i $</strong> 表示自己已经收到第i号帧以及其之前的所有帧.</p><p>我们同样通过两个流程图来分别说明发送方和接收方的事情:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/Go-Back-N-%E5%8F%91%E9%80%81%E6%96%B9.iodraw.png" alt="后退N步-发送方"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/Go-Back-N-%E6%8E%A5%E6%94%B6%E6%96%B9.iodraw.png" alt="后退N步-接收方"></p><p>后退N步的主要想法是让发送方能够 <strong>一次发送多个帧</strong> , 而不用发一个等一下这样循环, 提高信道利用率.<br>但可以预见的是, 如果 <strong>信道错误率很高</strong> , 或者 <strong>接收方接收速率很慢</strong> 的情况下, 发送方需要 <strong>频繁的后退</strong> , 这也会导致资源的浪费.</p><h3 id="3-4-4-选择重传协议"><a href="#3-4-4-选择重传协议" class="headerlink" title="3.4.4 选择重传协议"></a>3.4.4 选择重传协议</h3><p><strong>选择重传协议(SR &#x2F; Selective Repeat)</strong> , 尝试解决GBN的缺点. 它的特点如下:</p><ul><li>窗口大小:<ul><li>发送窗口 $ W_t &gt; 1 $</li><li>接收窗口 $ W_r &gt; 1 $</li></ul></li><li>确认机制<ul><li>接收方收到第i号帧, 且未检测出差错时, 发回给发送方一个确认消息 $ ACK_i $</li></ul></li><li>重传机制<ul><li>发送方若超时未收到 $ ACK_i $ , 则主动重传该i号帧</li></ul></li><li>帧编号<ul><li>仅需要1bit对帧进行编号</li></ul></li><li><strong>特殊规则</strong><ul><li><strong>接收窗口不能大于发送窗口</strong></li><li><strong>接收方逐个确认已收到的分组</strong></li><li><strong>发送方只重新发送没有收到ACK的分组</strong></li><li><strong>发送方对每个分组均有单独的计时器</strong></li></ul></li></ul><blockquote><p><strong><font color = #fa4659>注意: 选择重传的机制</font></strong><br>王道网课给出的选择重传机制与笔者教材(计算机网络: 自顶向下方法 &#x2F; Computer Networking: A Top-Down Approach)中的机制并不相同, 甚至可以说是差异明显. 笔者这里给出的是教材中的方法. 如果读者有兴趣, 可以前往 <a href="https://www.bilibili.com/video/BV19E411D78Q?spm_id_from=333.788.videopod.episodes&vd_source=4565edcb254cb6582d6382ac80011294&p=27">选择重传协议王道网课版</a> 进行王道版本的学习.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png" alt="选择重传-滑动窗口"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0-%E5%8F%8C%E6%96%B9%E7%AD%96%E7%95%A5.png" alt="选择重传-双方策略"></p><h3 id="3-4-5-三种协议的信道利用率"><a href="#3-4-5-三种协议的信道利用率" class="headerlink" title="3.4.5 三种协议的信道利用率"></a>3.4.5 三种协议的信道利用率</h3><p>三种协议唠叨完了, 我们看看它们的优劣, 那自然就要捯饬一下它们对于信道的利用程度对吧.</p><h4 id="3-4-5-1-停等协议的信道利用率"><a href="#3-4-5-1-停等协议的信道利用率" class="headerlink" title="3.4.5.1 停等协议的信道利用率"></a>3.4.5.1 停等协议的信道利用率</h4><p>我们先从最简单的 <strong>停等协议</strong> 开始.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%81%9C%E7%AD%89%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="停等协议的信道利用率"></p><p>可见, 停等协议的一个周期由三部分组成:</p><ul><li>数据帧传输时延 <strong>$ T_D $</strong></li><li>传播时延: <strong>$ RTT $</strong></li><li>确认帧传输时延 <strong>$ T_A $</strong></li></ul><p>因此我们能给出这么个式子:</p><p>$$ U &#x3D; \frac{T_D}{T_D + RTT + T_A} $$</p><blockquote><p><strong><font color = #fa4659>注意: 信道利用率的计算前提</font></strong><br>我们在本处计算信道利用率时的前提是 <strong>理想情况</strong> , 即信道不丢帧, 不产生比特差错的情况. 原因在于如果我们加上那些意外, 整个情况会显得非常复杂 <del>(那不乱套了嘛)</del></p></blockquote><blockquote><p><strong><font color = #fa4659>注意: RTT Vs 单向传播时延</font></strong><br>事实上, RTT &#x3D; 2 * 单向传播时延 , 请读者务必注意这个名称问题</p></blockquote><h4 id="3-4-5-2-GBN-SR-的信道利用率"><a href="#3-4-5-2-GBN-SR-的信道利用率" class="headerlink" title="3.4.5.2 GBN &#x2F; SR 的信道利用率"></a>3.4.5.2 GBN &#x2F; SR 的信道利用率</h4><p>接下来是复杂一些的 <strong>回退N步和选择重传协议</strong> , 之所以把他俩放在一块说, 是因为他俩的理想条件是几乎完全一致的, 即发送一帧后对方也能及时接收这一帧并返回ACK.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/GBN%2C%20SR%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png" alt="回退N步 / 选择重传的信道利用率"></p><p>我们只需要看单个周期内(即灰色框内部)的信道利用率, 其实组成是一致的, 只不过此时的情况在于, 发送方能一次发送多个帧对吧. 进而我们给出这个式子:</p><p>$$ U &#x3D; \frac{N * T_D}{T_D + RTT + T_A} $$</p><p>其中, <strong>N</strong> 是指 <strong>发送过程中能够连续发送的数据帧数目</strong> .</p><p>相信有些读者读到这已经有点想法了, 那如果我的发送数据的这 <strong>$ N * T_D $</strong> 比你的分子还大捏? 你这式子不炸缸了吗?</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/GBN%2C%20SR%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%28%E7%AD%89%E4%BA%8E1%29.png" alt="等于1的情况"></p><p>所以说嘛, 都叫信道利用率了, 还能比1大不成? 算出来大于1直接写1就完了.</p><h3 id="3-4-6-额外补充"><a href="#3-4-6-额外补充" class="headerlink" title="3.4.6 额外补充"></a>3.4.6 额外补充</h3><p>有三个名词需要读者了解:</p><ul><li>滑动窗口协议: 指GBN或SR</li><li>ARQ(Automatic Repeat Request &#x2F; 自动重传请求)协议: 指ST &#x2F; GBN &#x2F; SR</li><li>连续ARQ协议: 指GBN &#x2F; SR</li></ul><h2 id="3-5-信道划分与介质访问控制"><a href="#3-5-信道划分与介质访问控制" class="headerlink" title="3.5 信道划分与介质访问控制"></a>3.5 信道划分与介质访问控制</h2><p>首当其冲, <strong>什么是介质访问控制</strong> ?</p><blockquote><p><strong><font color = #3490de>概念: 介质访问控制</font></strong><br>为了应对多个节点共享信道时的 <strong>信号冲突</strong> , 对各个节点对传输介质的访问进行控制的过程.</p></blockquote><p>好嘞, 所以说白了就是该怎么应对介质访问冲突对吧, 那我们来慢慢寻思.</p><h3 id="3-5-1-信道划分"><a href="#3-5-1-信道划分" class="headerlink" title="3.5.1 信道划分"></a>3.5.1 信道划分</h3><p>我们先从最基础的, 单信道的访问控制聊起.</p><h4 id="3-5-1-1-时分复用"><a href="#3-5-1-1-时分复用" class="headerlink" title="3.5.1.1 时分复用"></a>3.5.1.1 时分复用</h4><blockquote><p><strong><font color = #3490de>概念: 时分复用(Time Division Multiplexing, TDM)</font></strong><br>将时间分为等长的 <strong>TDM帧</strong> , 同时每个TDM帧又被分为等长的 m 个 <strong>时隙</strong> . 将m个时隙分别分配给各个用户使用.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="时分复用"></p><p>时分复用非常公平, 有时候显得有些公平过头了.</p><ul><li>每个节点最多享受到信道传输速率的 $ \frac{1}{m} $</li><li>当有节点在它的时隙内不需要发送信息时, 该信道的资源会被浪费.</li></ul><h4 id="3-5-1-2-统计时分复用"><a href="#3-5-1-2-统计时分复用" class="headerlink" title="3.5.1.2 统计时分复用"></a>3.5.1.2 统计时分复用</h4><blockquote><p><strong><font color = #3490de>概念: 统计时分复用(Statistic Time Division Multiplexing, STDM)</font></strong><br>亦称 <strong>异步时分复用</strong> , 在TDM的基础上, 动态按需分配时隙.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%8A%A8%E6%80%81%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="统计时分复用"></p><h4 id="3-5-1-3-频分复用"><a href="#3-5-1-3-频分复用" class="headerlink" title="3.5.1.3 频分复用"></a>3.5.1.3 频分复用</h4><blockquote><p><strong><font color = #3490de>概念: 频分复用(Frequency Division Multiplexing, SDM)</font></strong><br>将信道的总频带划分为多个 <strong>子频带</strong> , 每个子频带都作为一个子信道. 每对用户使用其中一个子频带进行通信.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="频分复用"></p><p>上图中出现了两个陌生的玩意:</p><ul><li><strong>复用器</strong> : 将各个节点发出的信号 <strong>复合</strong> 后传输到共享信道上.</li><li><strong>分用器</strong> : 将各个子频带的信号 <strong>分离</strong> 出来.</li></ul><blockquote><p><strong><font color = #fa4659>注意: 隔离频带</font></strong><br>都分频了, 那自然要做一些隔离措施, 防止分用器将本不属于这个子频带的信号分到这个子频带上.<br>就像跑道之间还要有一条隔离线作为隔离区域对不</p></blockquote><p>FDM看起来非常好, 又公平, 还充分利用了信道带宽对吧. 但它有个非常重要的缺点:<br><strong>FDM技术只能用于模拟信号的传输</strong> , 因为一般而言, 只有模拟信号才有 <strong>频率</strong> 这个概念.</p><h4 id="3-5-1-4-波分复用"><a href="#3-5-1-4-波分复用" class="headerlink" title="3.5.1.4 波分复用"></a>3.5.1.4 波分复用</h4><blockquote><p><strong><font color = #3490de>概念: 波分复用(Wavelength Division Multiplexing, WDM)</font></strong><br>将信道按照传输光信号的 <strong>波长</strong> 来分组. 本质上与频分复用是一个思路.</p></blockquote><p>波分复用主要用于 <strong>光纤</strong> .</p><hr><p>上面我们提的方式挺完善 <strong>吗</strong> ?<br>要知道互联网不仅仅是一对一, 而经常涉及到一对多的通信. 上面这些方式, 如果要进行一对多的通信, 会显得非常繁琐不是吗?</p><p>因此, 码分复用出现了.</p><h4 id="3-5-1-5-码分复用"><a href="#3-5-1-5-码分复用" class="headerlink" title="3.5.1.5 码分复用"></a>3.5.1.5 码分复用</h4><blockquote><p><strong><font color = #3490de>概念: 码分复用(Code Division Multiplexing, CDM)</font></strong><br>各个节点预先获得自己的 <strong>码片序列</strong> , 并根据自己的码片序列向接收方传送数据, 接收方能够根据传送数据的特点判断出是属于哪个发送方的.</p></blockquote><p>哎, 这里有个玩意叫 <strong>码片序列</strong> , 读者可以把它考虑为一个 <strong>多维向量</strong> , 并且这个向量的每个分量都取<strong>1 &#x2F; -1</strong> .<br>举个例子, 下面就是几个码片序列:</p><p>$$ \vec{a} &#x3D; (1, 1, 1, 1) $$</p><p>$$ \vec{b} &#x3D; (1, -1, 1, -1) $$</p><p>通常而言, 发送方会发送 $ \vec{sender} $ 来表示1, 发送 $ - \vec{sender} $ 来表示0 .</p><blockquote><p><strong><font color = #fa4659>注意: 码片序列的正交性</font></strong><br>为了让接收方更好的区分不同的发送方, 通常而言, 码片序列之间被规定为 <strong>严格正交(即相乘得0)</strong> .</p></blockquote><p>好的, 我们现在搞明白了发送方怎么发数据, 那接收方怎么收数据?</p><p>这里涉及到一个数学方面的运算, 被称为 <strong>规格化内积</strong> .</p><p>假设发送方a发了个比特1, b发了个比特0.<br>接收方应当接收到这两个比特的加和, 即 $ \vec{a} + (- \vec{b}) $ .<br>此时发送方干这么一件事: 分别用 $ \frac{1}{向量维数} $ 以及 $ \vec{sender_i} $ , 乘上它拿到的这个叠加向量, 即:</p><p>$$<br>\begin{align*}<br>  \frac{1}{m} \space \vec{a} * (\vec{a} + (- \vec{b})) \\<br>  \frac{1}{m} \space \vec{b} * (\vec{a} + (- \vec{b})) \\<br>\end{align*}<br>$$</p><p>哎嘿, 挺神奇, 是不是上面得1, 下面得-1;<br>正好对应a发送1, b发送0.</p><p>通过这种方式, 能够使不同的发送方同时发送数据, 而接收方能够分辨出每一部分数据的来源. 但代价是数据包的大幅度膨胀.</p><h3 id="3-5-2-随机访问介质访问控制"><a href="#3-5-2-随机访问介质访问控制" class="headerlink" title="3.5.2 随机访问介质访问控制"></a>3.5.2 随机访问介质访问控制</h3><p>啥是 <strong>随机访问介质</strong> ? </p><blockquote><p><strong><font color = #3490de>概念: 随机访问介质</font></strong><br>意味着个个节点能够随机的去访问的信道介质. 是访问介质的一种全新控制思路.</p></blockquote><h4 id="3-5-2-1-纯ALOHA"><a href="#3-5-2-1-纯ALOHA" class="headerlink" title="3.5.2.1 纯ALOHA"></a>3.5.2.1 纯ALOHA</h4><p>ALOHA最开始是夏威夷的一帮人搞出来的, 为了联通整个夏威夷的网络. 但后续因为思路值得借鉴, 传下来了.</p><p>其发送思路非常简单粗暴, 直接上图:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%BA%AFALOHA.png" alt="纯ALOHA协议"></p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>ALOHA的重要特征如下:</p><ol><li>未收到ACK, 会 <strong>随机等待一段时间再重传</strong> .</li><li>可以在 <strong>任意时刻</strong> 将帧发送到信道上.</li></ol></blockquote><h4 id="3-5-2-2-时隙ALOHA"><a href="#3-5-2-2-时隙ALOHA" class="headerlink" title="3.5.2.2 时隙ALOHA"></a>3.5.2.2 时隙ALOHA</h4><p>相比于ALOHA增添了关于 <strong>帧上传的部分要求</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%B6%E9%9A%99ALOHA.png" alt="时隙ALOHA"></p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>时隙ALOHA的重要特征如下:</p><ol><li>同样在传输失败后 <strong>随机等待一段时间</strong></li><li>规定时隙, 每个节点只能在一个时隙开始的时间点将数据帧发送到信道上</li></ol></blockquote><h4 id="3-5-2-3-CSMA"><a href="#3-5-2-3-CSMA" class="headerlink" title="3.5.2.3 CSMA"></a>3.5.2.3 CSMA</h4><p>CSMA是 <strong>Carrier Sense Multiple Access</strong> 的缩写, 中文译名为 <strong>载波监听多路协议</strong> . 它首次引入了 <strong>监听</strong> 这一概念.<br>简而言之, 就是节点在发送数据前会先监听信道是否空闲, 只有满足空闲前提, 节点才会开始传输帧.</p><p>CSMA又有:</p><ul><li><strong>1-坚持</strong> : 一旦我想发送数据帧, 我就一直看着这个信道, 直到空闲为止</li><li><strong>非坚持</strong> : 如果信道现在有人, 我就先屯着不发, 过一段时间再来看看</li><li><strong>p坚持</strong> : 我会一直看着这个信道, 但是我 <strong>有概率</strong> 不立刻传送我这个数据帧</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/1-%E5%9D%9A%E6%8C%81CSMA.png" alt="1-坚持CSMA协议"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E9%9D%9E%E5%9D%9A%E6%8C%81CSMA.png" alt="非坚持CSMA协议"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/p%E5%9D%9A%E6%8C%81CSMA.png" alt="p坚持CSMA协议"></p><p>还望读者通过这三张图能够明确这仨协议的区别.</p><h4 id="3-5-2-4-CSMA-CD"><a href="#3-5-2-4-CSMA-CD" class="headerlink" title="3.5.2.4 CSMA&#x2F;CD"></a>3.5.2.4 CSMA&#x2F;CD</h4><p>这个协议用于早期的 <strong>有线以太网</strong> . 跟我们上面说的 <strong>1-坚持CSMA协议</strong> 比较类似.</p><p>CSMA的缩写我们上面提过了, 主要就是一个 <strong>监听</strong> . 这里后面的CD是 <strong>Collision Detection</strong> 的缩写, 即 <strong>冲突检测</strong> .<br>咸鱼给出了一段很简单的总结: <strong>先听后发, 边听边发, 冲突停发, 随机重发</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CSMA%20CD.png" alt="CSMA/CD发送方"></p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>CSMA&#x2F;CD的重要特征如下:</p><ol><li>与 <strong>1-坚持CSMA</strong> 类似, 会一直盯着信道的当前状态. 并在空闲时立刻上传手中的帧.</li><li>具备冲突检测功能, 当检测到冲突后(冲突次数为第k次), 会根据冲突次数做出抉择:<br>2.1) 当前冲突已经是第16次了, 直接放弃传输该帧, 这往往代表着网络过于忙碌<br>2.2) 当前冲突在15次即以内, 则挑选一个合适的随机时间进行数据帧的重新发送任务.</li></ol></blockquote><p>这个随机时间怎么挑选: 肯定是一个 <strong>争用期</strong> 的整数倍.</p><blockquote><p><strong><font color = #3490de>概念: 争用期</font></strong><br>两倍的最远单向传播时延, 即距离最远的两个节点的传播时延.</p></blockquote><ul><li>如果冲突次数在10次及以内: 挑选 $ random(0, 2^k-1) $ 倍的争用期</li><li>如果冲突次数在11~15次之间: 挑选 $ random(0, 2^{10}-1) $ 倍的争用期</li></ul><hr><p>这里我们对 <strong>争用期</strong> 这个概念作进一步说明.</p><p>由于争用期是两倍的最远单向传播时延, 为什么是两倍呢?<br>考虑以下这种情况, 信道最两端的两个节点 A, B需要传输帧, 此时A的帧比特马上就要到B的位置, 但B此时监听信道应当还是空闲的(因为A的数据还没到嘛).<br>恰好, B这时候准备好了一个帧, 直接发出去了.<br><strong>会发生什么</strong> ?</p><p>B一定很快就发现了数据冲突, 因为我们刚刚说A的数据马上就到了.<br><strong>但A呢</strong> ?<br>它需要再等到B的数据走过一个最远单向传播时延, 才能知道, 哦, 原来我费劲巴力传了这么久的一个玩意冲突了.</p><p>因此算上A的数据走到B处的一个最远单向传播时延, 这意味着A需要至少等一个争用期, 找不到冲突, 才代表着这个帧正确的发送完毕了.</p><p>我们刚刚说的是最极限的情况, 因此, 只要一个争用期内没有检测到冲突, 代表着 <strong>A的数据流已经占领了整个信道</strong> , 也就意味着不会再出现冲突了.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BA%89%E7%94%A8%E6%9C%9F.png" alt="争用期的具体说明"></p><p>考虑上图中 $ \delta \to 0 $ 的情况, 就是我们的描述.</p><hr><p>理解了 <strong>争用期</strong> 之后, 对于 <strong>最短帧长</strong> 这个东西应该就不难懂了.</p><p>CSMA&#x2F;CD规定, 节点发送的最短帧不得短于: <strong>2 * 最大单向传播时延 * 信道带宽</strong> . 也就是 <strong>一个争用期内能发送的最大数据量</strong> .</p><p>这很好理解, 如果发送的数据量小于这个值, 那考虑上面那个极端的冲突例子, B的数据到A时, A的帧已经传输完毕了, 就导致A <strong>以为自己已经传输完了而没有出现冲突</strong> , 导致通信的错误.</p><p>哦, 对了, 为了防止有些 老赖 构造一个超级长的帧来长期占用一整个信道, 还有一个 <strong>最长帧长</strong> 的限制.</p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>在以太网中, 最短帧长是64B, 最长是1518B.</p></blockquote><hr><p>再考虑一下 CSMA&#x2F;CD 的接收方干的活:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CSMA%20CD%E6%8E%A5%E6%94%B6%E6%96%B9.png" alt="CSMA/CD接收方"></p><p>至此, 这一个很麻烦但很常用的 CSMA&#x2F;CD协议, 我们就聊完了.</p><h4 id="3-5-2-5-CSMA-CA"><a href="#3-5-2-5-CSMA-CA" class="headerlink" title="3.5.2.5 CSMA&#x2F;CA"></a>3.5.2.5 CSMA&#x2F;CA</h4><p>我们说CSMA&#x2F;CD通常用于有线网, 那无线网呢? 这就是CSMA&#x2F;CA干的活了.<br>首先, 这个 <strong>CA</strong> 是 <strong>Collision Avoidance</strong> 的缩写, 用中文讲叫 <strong>冲突避免</strong> . 这意味着这个协议不是在发送数据的过程中监听冲突, 而是要在发送前尽可能想办法避免冲突的发生.</p><p>在正式进入这个协议的介绍之前, 我们得先补个概念: <strong>Access Point(接入点)</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 接入点</font></strong><br>接入点(AP)是一种网络硬件设备, 它允许启用无线通信的设备连接到有线网络. 是无线网与有线网之间的中心枢纽.<br>另外, 我们称呼在不同的AP之间切换这个动作叫做 <strong>数据漫游</strong> .</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E6%97%A0%E7%BA%BF%E7%BD%91AP.png" alt="无线网AP"></p><p>现在我们考虑为啥无线网不能用CSMA&#x2F;CD?<br>考虑A发送数据的同时D也要发送数据, 此时, 不同于有线网的定向传输, 无线网中的设备是要向四面八方(也就是一个球体)发送信号的.<br>这会导致一种问题, 即A处接收到D的信号强度会远远小于A自身发出的信号的强度, 进而使得 <strong>冲突检测</strong> 这种行为的难度大大增加.<br>因此, 难办, 那不办了! 我们不检测, 转向一个 <strong>预测</strong> 的方向.</p><hr><p>最简单的CSMA&#x2F;CA是这样的:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CSMA%20CA%E6%97%A0%E9%9A%90%E8%97%8F%E7%AB%99.png" alt="CSMA/CA 无隐藏站"></p><p>其发送策略如下:</p><ul><li>信道空闲<ul><li>发送方: <ul><li>准备好数据帧后检测信道, 如果信道此时空闲, 则等待一个 <strong>分布式协调IFS(DIFS)</strong> 的时间后发送整个数据帧.</li><li>等待接收方ACK<ul><li>等到了, 进入下一个帧的传输</li><li>等不到, 进行二进制指数随机退避, 随后尝试重传这个帧</li></ul></li></ul></li><li>接收方:<ul><li>收到帧后, 在接下来一个 <strong>短IFS(SIFS)</strong> 的时间内立刻进行差错检测<ul><li>无错, 则返回ACK</li><li>有错, 丢弃该帧</li></ul></li></ul></li></ul></li><li>信道忙碌<ul><li>发送方<ul><li>准备好数据帧后检测信道, 如果信道此时忙碌, 则立刻进行二进制指数随机退避, 等待指定之间后直接传输该帧</li><li>随后的事务与信道空闲情况下相同</li></ul></li><li>接收方<ul><li>与信道空闲情况下相同.</li></ul></li></ul></li></ul><p>上卖弄涉及到了两个东西读者可能有疑惑:</p><ul><li>帧间隔(Inter Frame Gap): 其实就是一段时间, 有长有短, 在IEEE 802.11标准中规定.<ul><li>DIFS: 长帧间隔</li><li>SIFS: 短帧间隔</li></ul></li><li>二进制指数退避算法: 跟CSMA&#x2F;CD的退避算法几乎一致, 读者可移步该小节进行复习.</li><li>这里的接收方相当于采取了 <strong>停等协议</strong> 的收发策略.</li></ul><hr><p>我们这里再对这个DIFS简单说一下, 为啥这东西要最长呢?<br>通常有这么个公式:</p><p>$$ DIFS \geq SIFS + 最长传输时延 $$</p><p>这也是为了防止冲突的产生.</p><p>还是上图, 我们会发现再每个 SIFS 的时间内, 信道其实都是空闲的, 假如我们这时有另一个节点D, 不等待DIFS, 直接传输帧, 会发生什么?<br>可能这个帧就跟ACK撞上了对吧.</p><p>但如果我们发送之前都等待DIFS, 就能够检测到由于SIFS导致的信道状态延迟, 并采用退避算法.<br>显然这种方式比直接发送要更加智能一点.</p><hr><p>读者可能注意到上面图片的名字叫 <strong>无隐藏站</strong> , 这个隐藏站是个啥?<br>我们发现, 上面这种最简单的CSMA&#x2F;CA全靠发送方来检测信道是否忙碌, 这可靠吗?  </p><p>要知道, 发送方可并不处于AP的位置, 因此显然有可能, 有些信号AP是能收到的, 但发送方收不到, 比如最开始那张图, 发送方A和发送方C很有可能互相收不到对方的消息. 这种情况被我们称之为 <strong>隐藏站</strong> .</p><p>很显然, 这种情况下需要AP的直接介入才能真正判断信道是否空闲对吧.</p><p>为了解决这个恼人的问题, 发明了个新的机制叫 <strong>预约机制</strong> .  </p><ul><li>发送方:<ul><li>准备好数据帧后, 等待DIFS时间段之后向AP发送 <strong>RTS控制帧(Request to Send)</strong> , 该帧内需要包含预计发送时常, 等待AP的 <strong>CTS控制帧</strong> .</li><li>收到 <strong>CTS</strong> 后, 等待SIFS时间段, 随后开始传输数据帧</li><li>如未收到 <strong>CTS</strong> , 立刻进行二进制指数退避, 并在此之后尝试重发 <strong>RTS</strong> .</li></ul></li><li>接收方:<ul><li>收到 <strong>RTS</strong> 后<ul><li>若当前无其它预约, 则群发 <strong>CTS控制帧(Clear to Send)</strong> , 该帧内需要包含预约方和预约时长, 向所有节点明确当前的预约状况.</li><li>若当前有预约, 则忽略该 <strong>RTS</strong> .</li></ul></li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CSMA%20CA%E4%BF%A1%E9%81%93%E9%A2%84%E7%BA%A6.png" alt="CSMA/CA 信道预约"></p><h3 id="3-5-3-轮询访问介质访问控制"><a href="#3-5-3-轮询访问介质访问控制" class="headerlink" title="3.5.3 轮询访问介质访问控制"></a>3.5.3 轮询访问介质访问控制</h3><p>接下来是比较简单的轮询访问, 这种方式我们只说一种最简单的: <strong>令牌传递协议</strong> .</p><p>由于令牌传递的技术背景是IBM公司研发出的令牌环网, 但由于以太网现在已经极度成熟, 令牌环网已经逐步退出历史舞台, 因此这一节其实不是很重要.</p><p>这种方式的构想即整个网络中存在一个 <strong>令牌帧</strong> , 而整个网络中只有持有这个令牌帧的节点才能够发送数据帧.<br>当这个数据帧发送完成并确定被成功接收后, 节点必须立刻放弃令牌帧的控制权并将其传输给下一个节点.<br>当然, 如果这个节点当前没有帧需要传输, 则立刻放弃令牌控制权.</p><p>通过这种传递方式, 使得整个网络不会出现数据冲突的情况.</p><p>还需要提一下, 令牌环网以及令牌传递协议需要一个叫 <strong>MAU(Multistation Access Units &#x2F; 多站接入单元)</strong> 的玩意进行控制. </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E4%BB%A4%E7%89%8C%E7%8E%AF%E7%BD%91%20MAU.png" alt="令牌环网"></p><h2 id="3-6-局域网"><a href="#3-6-局域网" class="headerlink" title="3.6 局域网"></a>3.6 局域网</h2><p>接下来我们了解的是当前世界上局域网的公认标准, 它是由IEEE这个组织的下属802工作组推行的.</p><h3 id="3-6-1-IEEE-802-与局域网"><a href="#3-6-1-IEEE-802-与局域网" class="headerlink" title="3.6.1 IEEE 802 与局域网"></a>3.6.1 IEEE 802 与局域网</h3><p>我们上面说了很多种技术, 其大部分是通过企业发明的, 而后只有后续得到广泛认可的协议才能被IEEE重视, 成立下属工作组并指定国际标准, 比较著名的工作组包括:</p><ul><li>802.8: 负责FDDI光线分布数字接口(已解散)</li><li>802.5: 负责令牌环网技术(已解散)</li><li>802.3: 负责以太网技术</li><li>802.11: 负责Wi-Fi技术</li></ul><p>事实上, IEEE的覆盖范围远不止于此, 但由于我们计网的课程的研究范围大致为局域网内, 因此以下我们仅对部分局域网的知识进行讨论.</p><h3 id="3-6-2-局域网的基本概念与体系结构"><a href="#3-6-2-局域网的基本概念与体系结构" class="headerlink" title="3.6.2 局域网的基本概念与体系结构"></a>3.6.2 局域网的基本概念与体系结构</h3><p>先给出局域网的基本特点:</p><ul><li>覆盖较小的地理范围</li><li>具有较低的时延和误码率</li><li>以 <strong>帧</strong> 为单位在各个节点之间进行传播</li><li>支持 <strong>单播, 广播, 多播</strong><ul><li>单播: 一对一发送帧</li><li>广播: 对全部网内节点进行发送帧</li><li>多播: 对某一部分指定节点进行发送帧</li></ul></li></ul><p>在IEEE的体系下, 当代局域网分为两个大类:</p><ul><li>有限局域网(LAN)<ul><li>令牌环网<ul><li>时期: 1984 ~ 2000</li><li>拓扑结构: 环形</li><li>物理介质: 同轴电缆 &#x2F; 双绞线</li><li>采用协议: 令牌传递协议</li></ul></li><li>以太网<ul><li>时期: 1980 至今</li><li>分类:<ul><li>同轴电缆以太网 (10Base5)<ul><li>拓扑结构: 总线型</li><li>物理介质: 同轴电缆</li><li>采用协议: CSMA&#x2F;CD</li></ul></li><li>光纤以太网 (10BaseF)<ul><li>拓扑结构: <strong>点对点</strong> (因为光纤通常用于连接中间节点, 而不直接接入终端节点)</li><li>物理介质: 光纤(两条, 全双工)</li><li>采用协议: NULL, 不需要协议配合(因为是点对点, 不存在介质争用)</li></ul></li><li>双绞线以太网 (10BaseT)<ul><li>物理介质: 双绞线</li><li>分类:<ul><li>集线器双绞线以太网<ul><li>拓扑结构: 物理上星型, 逻辑上总线型</li><li>使用协议: CSMA&#x2F;CD</li></ul></li><li>交换机双绞线以太网<ul><li>拓扑结构: 星型</li><li>使用协议: CSMA&#x2F;CD(半双工), 也可能是NULL(全双工)</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li>无线局域网(WLAN)<ul><li>Wifi 802.11<ul><li>拓扑结构: 星型(一台AP + N台移动设备)</li><li>物理介质: 无线(Wireless)</li><li>采用协议: CSMA&#x2F;CA</li></ul></li></ul></li></ul><p>ok, 这个表还是挺大的, 但是其实里面的知识我们之前都聊过.</p><hr><p>这之后, 我们来看看直接跟数据链路层相关的 <strong>网络适配器</strong> .</p><p>对于不同的链接方式(有限局域网 &#x2F; 无线局域网), 设备中会配备不同的网络适配器.<br>一个网络适配器中有至少有一个ROM芯片, 它负责存储一个全球唯一的地址(MAC) , 来保证在局域网内发送给你的帧能够正确的找到你而不是别人.<br>这个MAC地址总共48位, 前24位由IEEE分配, 而后24位归网卡的硬件厂商来分配.</p><p>除此之外, 还会存在一个RAM用于暂存收到的数据帧(作为缓冲区).</p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>读者务必注意, 有线局域网和无线局域网的网络适配器不能共用, 这意味着如果你的电脑能接网线, 也能连Wifi, 则它必定有两个网络适配器, 而这两个适配器的MAC也一定是不一样的.<br>感兴趣的读者可以上网搜一下如何查看自己的网络适配器MAC地址. 这里笔者不赘述了.</p></blockquote><hr><p>总结一下网络适配器的功能:</p><ul><li>把帧发送到局域网</li><li>从局域网接收帧</li><li>根据接入的局域网类型实现数据链路层和物理层的功能</li><li>支持帧缓冲机制</li><li>将IP数据报封装成帧 (有些是适配器干的, 有些是主机干的)</li></ul><h3 id="3-6-3-IEEE-802-3-有线局域网"><a href="#3-6-3-IEEE-802-3-有线局域网" class="headerlink" title="3.6.3 IEEE 802.3 有线局域网"></a>3.6.3 IEEE 802.3 有线局域网</h3><p>接下来, 我们来看看有线局域网的具体内容.  </p><p>IEEE 对于局域网主要探讨两部分的标准, 即物理层与数据链路层(MAC)的标准设定.<br>我们先看物理层. 直接上一张表:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/IEEE802.3%20%E6%A0%87%E5%87%86.png" alt="IEEE 802.3 物理层标准"></p><p>这里需要注意的是关于物理介质对于双工模式的支持:</p><ul><li>同轴电缆只能半双工</li><li>双绞线:<ul><li>速率 $ &lt; 2.5Gbps $ 一般同时支持半双工 &#x2F; 全双工</li><li>速率 $ \geq 2.5Gbps $ 仅支持全双工</li></ul></li><li>光纤只能全双工</li></ul><hr><p>接下来看看数据链路层, 这一层的标准制定主要集中在 <strong>帧的结构</strong> 这一部分上, 这一部分当前主要有两种规定:</p><ul><li>DIX Ethernet V2</li><li>IEEE 802.3</li></ul><p>这两种帧的格式几乎一致, 并且前者目前是主流.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/V2%E6%A0%87%E5%87%86MAC%E5%B8%A7.png" alt="DIX Ethernet V2 MAC帧"></p><ul><li>目的地址 &#x2F; 源地址: MAC地址, 48bit(6bytes)<ul><li>目的地址如果全1, 则代表这是一个 <strong>广播帧</strong> .</li></ul></li><li>类型: 指明网络层使用的协议类型</li><li>数据:<ul><li>就是网络层的IP数据报 &#x2F; ARP报文等玩意, 详见下一章.</li><li>长度在46 ~ 1500byte之间(这里需要读者回顾一下为什么需要划定最短和最长帧长)</li></ul></li><li>FCS: CRC校验码</li></ul><p>在物理层, 还会在一个MAC帧前插入俩玩意:</p><ul><li>前同步码: 打节奏, 告知对方准备开始传输</li><li>帧开始定界符: 告知对方帧起始位置</li></ul><p>这一部分读者可以回到Chap.2 进行回顾, 采用的是曼彻斯特编码(跳0反跳1, 中必变).</p><hr><p>关于 <strong>广播帧</strong> , 我们得稍微说一下.</p><p>对于一个广播帧, 交换机和集线器都会将其转发到自己连接的所有端口, 但 <strong>路由器不会</strong> .<br>因此, 一个最底层的路由器的一个端口能够组成一个 <strong>广播域</strong> , 广播帧只能传输给所在广播域的所有节点.</p><p>在这里, 还请读者进一步复习一下之前提到的 <strong>冲突域</strong> 的概念, 对这二者的区别做一个明确的认知.</p><h3 id="3-6-4-VLAN基本概念与原理"><a href="#3-6-4-VLAN基本概念与原理" class="headerlink" title="3.6.4 VLAN基本概念与原理"></a>3.6.4 VLAN基本概念与原理</h3><p>VLAN(Virtual LAN), 是IEEE 802.1Q 工作组提出的概念. 目的在于在一个过大的广播域内对节点进行分组, 增加安全性, 并防止广播风暴的发生.</p><p>其思路很简单, 就是在通过交换机连接的某一个广播域内, 为不同的终端机进行分组, 从而形成一个个更小的 <strong>虚拟局域网</strong> .<br>相应的, 一个虚拟局域网也对应着一个 <strong>VID</strong> .</p><hr><p>VLAN的划分方式主要有以下三种:</p><ul><li>基于接口的VLAN划分: 按照交换机的接口来创建VID与接口号的映射.</li><li>基于MAC地址的VLAN划分: 按照终端机的MAC地址来创建VID与地址的映射.</li><li>基于IP地址的VLAN划分: 按照终端机的IP地址来创建VID与地址的映射.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84VLAN%E5%88%92%E5%88%86%E6%96%B9%E5%BC%8F.png" alt="基于接口的VLAN划分方式"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%9F%BA%E4%BA%8EMAC%E5%9C%B0%E5%9D%80%E7%9A%84VLAN%E5%88%92%E5%88%86.png" alt="基于MAC地址的VLAN划分"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E5%9F%BA%E4%BA%8EIP%E5%9C%B0%E5%9D%80%E7%9A%84VLAN%E5%88%92%E5%88%86.png" alt="基于IP地址的VLAN划分"></p><p>值得额外提一下的是, 由于IP是网络层的概念, 这种划分方式需要网络层设备的支持.<br>也相应的, 这种划分也能让VLAN达到 <strong>跨越路由器</strong> 的效果.</p><hr><p>最后的问题是, 不同的交换机该怎么判断这个帧属于哪个VLAN呢? 我们之前说的标准以太网帧里面没有这东西.<br>那很简单, 没有就加上.<br>因此 <strong>802.1Q帧</strong> 诞生了, 它主要在不同的交换机之间进行通信.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/802.1Q%E5%B8%A7.png" alt="802.1Q帧"></p><p>相比于普通的以太网帧, 其单纯在帧内加了一个VLAN标签.</p><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>由于802.1Q帧加了信息, 因此其末尾的FCS(CRC校验码)的部分需要再次生成, 这里不再赘述.</p></blockquote><h3 id="3-6-5-IEEE-无线局域网"><a href="#3-6-5-IEEE-无线局域网" class="headerlink" title="3.6.5 IEEE 无线局域网"></a>3.6.5 IEEE 无线局域网</h3><p>这一部分主要了解一下无线局域网的部分内容.</p><p>首先, 无线局域网不仅仅只有Wifi奥, 按照官方的分类, 其分为以下两类:</p><ul><li>有固定设施的无线局域网(即 IEEE 802.11 无线局域网 Wifi)</li><li>无固定基础设施移动自组织网络(AipDrop, 各厂商的Share等…)</li></ul><p>由于第二种主要是各个厂商自行组织定义的, 因此我们的了解重点还是在第一种 802.11 上.</p><hr><p>我们首先了解一下802.11无线局域网的一些概念与结构:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/802.11%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91.png" alt="802.11无线局域网"></p><p>上面这个图有几个重要的概念, 它们是无线网能够建立的核心:</p><ul><li>Portal(门户): 相当于一个协议转换器, 能够将802.11的协议和802.3的协议互相转换, 使得无线网和有线网能够互通.</li><li>AP(接入点): 之间我们说过, 就是一个无线网接入的中心节点. (说人话就是你家的路由器)</li><li>基本服务集(BSS): 一个接入点以及通过它连接上网的所有终端节点. (说人话就是路由器 + 连接的所有手机电脑)<ul><li>服务集合表示(SSID): 无线局域网的名字(标识符) (说人话就是你家的Wifi名)</li><li>基本服务区(BSA): 一个基本服务集能够覆盖的地理范围 (说人话就是能搜到你家Wifi的范围)</li></ul></li><li>漫游: 一个移动站在不同的服务集之间切换, 能够保持通信 (说人话就是你换了个Wifi, 还能上网)</li></ul><hr><p>可以看到802.11无线网跟有线网差的还挺大, 那自然其帧也不太一样.<br>具体而言, 802.11 分三类帧:</p><ul><li>数据帧</li><li>控制帧: ACK, RTS, CTS(这里不熟悉返回至CSMA&#x2F;CA协议)</li><li>管理帧: <ul><li>探测请求帧: 发给AP用于探测有哪些接入点(能搜到哪些Wifi)</li><li>探测响应帧: AP发回给终端设备来表示自己可以接入(我这个Wifi可以被探测并连接)</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/802.11%E6%95%B0%E6%8D%AE%E5%B8%A7.png" alt="802.11数据帧"></p><p>我们对这个帧进行一些说明:</p><ul><li>类型: 管理 &#x2F; 数据 &#x2F; 控制</li><li>子类型: 每种帧下属的子类型</li><li>去往AP &#x2F; 来自AP: 用于标识这个帧的发送方向</li><li>地址1<ul><li>去往AP: AP</li><li>来自AP: 接收方</li></ul></li><li>地址2<ul><li>去往AP: 发送方</li><li>来自AP: AP</li></ul></li><li>地址3<ul><li>去往AP: 接收方</li><li>来自AP: 发送方</li></ul></li></ul><blockquote><p><strong><font color = #fa4659>注意</font></strong><br>在802.11中, 两个移动站不能直接通信, 必须通过AP进行转发通信.</p></blockquote><h2 id="3-7-以太网交换机"><a href="#3-7-以太网交换机" class="headerlink" title="3.7 以太网交换机"></a>3.7 以太网交换机</h2><p>交换机之前提了挺多次, 但我们一直不知道这玩意到底是怎么实现 <strong>转发帧</strong> 这个功能的.</p><h3 id="3-7-1-交换机的自学习功能-即插即用"><a href="#3-7-1-交换机的自学习功能-即插即用" class="headerlink" title="3.7.1 交换机的自学习功能(即插即用)"></a>3.7.1 交换机的自学习功能(即插即用)</h3><p>我们在说以太网帧的时候, 有这么一张图:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.3%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/V2%E6%A0%87%E5%87%86MAC%E5%B8%A7.png" alt="DIX Ethernet V2 MAC帧"></p><p>这张图上明确的有源地址和目的地址对吧.</p><p>交换机内部会自行维护一张表(MAC地址表), 其表项为 {MAC地址, 端口号} .<br>当其收到一个帧的时候, 干两件事:</p><ul><li>将源地址的MAC与进入的接口进行映射, 建立表项.</li><li>会先将目的地址与当前所有表项进行对比, 如果能够找到该MAC, 则仅向对应的端口进行转发, 否则向所有的端口转发该帧.</li></ul><p>现在就还有个问题, 因为MAC地址是跟接口绑定的, 那假如有节点换接口了咋整?<br>交换机里面的表项是有一个最长有效期的, 当超过这个有效期就会自动作废, 此时交换机就找不到这个表项了, 因此会再次向全部的端口转发这个帧.</p><h3 id="3-7-2-交换机的转发方式"><a href="#3-7-2-交换机的转发方式" class="headerlink" title="3.7.2 交换机的转发方式"></a>3.7.2 交换机的转发方式</h3><p>当前交换机有两种转发方式:</p><ul><li>直通交换<ul><li><strong>只接收帧的前6个字节(即目的地址)</strong> , 随后查表, 找不到就全部转发, 找到了就定点转发.</li><li>转发时延比较低</li><li>不支持协议转换, 速率匹配, 差错控制</li></ul></li><li>存储交换<ul><li>存储整个帧, 不仅匹配目的地址, 同时进行差错控制等工作.</li><li>可以进行速率匹配以及需要差错控制的线路, 可以协议转换</li><li>转发时延比较高</li></ul></li></ul><hr><p>至此, 第三章就完事了.</p><p>这一章的很多内容还是很重要的, 我们初步谈了谈一些很重要的协议, 并且给出了一些在之后的层次中也很重要的内容(差错控制, 可靠传输, 流控等)</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-计网-Chap.2</title>
      <link href="/posts/27491.html"/>
      <url>/posts/27491.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Chap-2-物理层"><a href="#计算机网络-Chap-2-物理层" class="headerlink" title="计算机网络 Chap.2 物理层"></a>计算机网络 Chap.2 物理层</h1><blockquote><p>本系列计算机网络博文基于Bilibili王道的免费考研课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机组成原理的相关内容.</p></blockquote><p>开篇明义, 物理层的主要目的: <strong>实现相邻节点之间比特(0 &#x2F; 1)的传输</strong> .</p><h2 id="2-1-通信基础概述"><a href="#2-1-通信基础概述" class="headerlink" title="2.1 通信基础概述"></a>2.1 通信基础概述</h2><h3 id="2-1-1-通信基础的基本概念"><a href="#2-1-1-通信基础的基本概念" class="headerlink" title="2.1.1 通信基础的基本概念"></a>2.1.1 通信基础的基本概念</h3><p>物理层涉及到跟硬件打打交道, 因此 <strong>通信基础</strong> 这门学科的一些名词, 我们需要了解一下.</p><blockquote><p><strong><font color = #3490de>概念: 信源, 信宿, 信号, 信道</font></strong><br><strong>信源</strong> : 信号的来源, 即数据发送方<br><strong>信宿</strong> : 信号的归宿, 即数据接收方<br><strong>信道</strong> : 信号发送经过的通道, 通常一条物理线路会包含两条信道, 即 <strong>发送信道</strong> 和 <strong>接收信道</strong> .<br><strong>信号</strong> : 数据的载体, 分 <strong>数字信号</strong> 和 <strong>模拟信号</strong> 两种, 前者的值是离散的, 后者的值是连续的.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%20Vs%20%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7.png" alt="数字信号 Vs 模拟信号"></p><p>不论是数字信号还是模拟信号, 其目的都在于传输信息对吧, 因此要引出一个非常重要的概念, <strong>码元</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 码元</font></strong><br>一个 <strong>信号周期</strong> 内, 可能出现的 <strong>信号状态</strong> .</p><p><strong>信号周期</strong> 也被称为 <strong>码元宽度</strong> .</p></blockquote><p>事实上, 一个信号的码元越多, 代表它能够在单位时间内传输的数据量越多.</p><p>举个例子:</p><blockquote><p><strong><font color = #1fab89>例子: 2码元 Vs 4码元</font></strong><br>前者只能在一个信号周期内表示一个二进制位 (0 &#x2F; 1)<br>后者则可以表示两个 (00 &#x2F; 01 &#x2F; 10 &#x2F; 11)</p><p>但提高码元种类的代价就是信号功率 &#x2F; 信道本身素质要达标.</p></blockquote><p>相应的, 我们对码元的总量有一个称呼, 叫 <strong>k进制码元</strong> .</p><p>2进制码元能表示一个二进制位;<br>4进制能表示2个;<br>8进制能表示3个;<br>…</p><p>总结一下:</p><p>$$ k进制码元 \to log_2k \space bit数据 $$</p><hr><p>有了码元, 描述信道传输速率的单位就有两种了:</p><ul><li><strong>波特率(Baud)</strong> : 每秒几个码元</li><li><strong>比特率(bit&#x2F;s)</strong> : 每秒几个比特</li></ul><p>这三者属于知2求1的关系, 就不详细展开了.</p><h3 id="2-1-2-信道的极限容量"><a href="#2-1-2-信道的极限容量" class="headerlink" title="2.1.2 信道的极限容量"></a>2.1.2 信道的极限容量</h3><p>了解了以上概念之后, 我们该寻思一下 <strong>信道</strong> 这个玩意了. 我们在第一章的时候提到了一个概念叫 <strong>带宽(bandwidth)</strong> . 它指某个信道所能传送的最高数据率.</p><p>当时我们还提了一嘴, 说带宽有两个单位, 一个是 <strong>bit&#x2F;s</strong> , 另一个是 <strong>Hz</strong> .</p><p>在本节中, 我们会通过 <strong>香农定理</strong> 和 <strong>奈奎斯特定理</strong> 来解释这俩单位的内在关联.</p><hr><p>首先, 我们得引出一个概念: <strong>噪声</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 噪声</font></strong><br>指对信道产生干扰的信号.<br>噪声会影响信道的数据传输速率</p></blockquote><p>而奈奎斯特定律给出了一个结论, 描述如下:</p><p><em>对于一个理想低通信道(没有噪声, 带宽为W的信道), 其极限波特率是2W波特(Baud).</em></p><blockquote><p><strong><font color = #fa4659>注意: W的单位</font></strong><br>这里的带宽W的单位为Hz.</p></blockquote><p>根据这个定律, 结合我们此前所说的 <strong>k进制码元</strong> , 可知, 对于一个k进制码元, 其在理想低通信道中的极限比特率为:</p><p>$$ 2W \times log_2k \space (bit&#x2F;s) $$</p><hr><p>那无噪声的说完了, 有噪声的呢? 这就是 <strong>香农定理</strong> 给出来的结论了. 其表述如下:</p><p><em>对于一个有噪声, 带宽为W的信道, 其极限比特率为 $ W \times log_2(1 + \frac{S}{N}) $ .</em></p><blockquote><p><strong><font color = #fa4659>注意: 香农定理的研究对象</font></strong><br>请务必注意, 香农定理和奈奎斯特定理不同, 它直接给出了 <strong>比特率(bit&#x2F;s)</strong> .</p></blockquote><p>哎? 这个 $ \frac{S}{N} $ 是个什么东西? 这玩意叫 <strong>信噪比</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 信噪比</font></strong><br>$ \frac{S}{N} $ 即 $ \frac{Signal}{Noise} $ , 信号的功率比上噪声的功率.<br>信噪比越高, 噪声对数据传输的影响越小.</p></blockquote><p>照这么来看, 信噪比应该只是个数才对, 但很遗憾, 这东西一般而言都是个天文数字, <strong>因为信号的功率通常要比噪声的功率高太多了</strong> . 那咋整呢?</p><p>哎, 有人研究出来这么个公式:</p><p>$$ 信噪比 &#x3D; 10log_{10} \frac{S}{N} $$</p><p>并给它加了个单位 <strong>分贝(dB)</strong> .</p><blockquote><p><strong><font color = #fa4659>注意: 香农定理中信噪比的转换</font></strong><br>别混了, 香农定理里面信噪比是没有单位的那个记法!</p></blockquote><h3 id="2-1-3-编码和调制"><a href="#2-1-3-编码和调制" class="headerlink" title="2.1.3 编码和调制"></a>2.1.3 编码和调制</h3><p>之前我们聊的是信道本身, 现在我们要聊一下信道前后的东西, 它们分别叫做 <strong>变换器</strong> 和 <strong>反变换器</strong> . </p><blockquote><p><strong><font color = #3490de>概念: 变换器 &#x2F; 调制 &#x2F; 编码</font></strong><br><strong>变换器</strong> 指的是用于将二进制数据转变为数字 &#x2F; 模拟信号的器具.<br>二进制数据转换为数字信号被称为 <strong>编码</strong> .<br>二进制数据转换为模拟信号被称为 <strong>调制</strong> .</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 反变换器 &#x2F; 解调 &#x2F; 解码</font></strong><br><strong>反变换器</strong> 指的是用于将数字 &#x2F; 模拟信号转变二进制数据的器具.<br>数字信号转换为二进制数据被称为 <strong>解码</strong> .<br>模拟信号转换为二进制数据被称为 <strong>解调</strong> .</p></blockquote><blockquote><p><strong><font color=#ff9a00>趣闻</font></strong><br>调制解调器的英文名为 <strong>Modem</strong> , 由于它的英文像中文的 “猫” , 另一端又连着 <strong>光纤</strong> , 因此在日常中常用 <strong>光猫</strong> 这个名字来称呼它.</p></blockquote><hr><p>我们先从编解码开始, 了解一些常用的编码方式:</p><ul><li><strong>不归零编码(NRZ &#x2F; Non-Return-to-Zero)</strong> : 低0高1, 中不变. 即用 <strong>低电平表示二进制的0, 高电平表示二进制的1</strong> , 且信号全程 <strong>不归零</strong> .<ul><li>无自同步能力</li><li>不浪费带宽</li><li>抗干扰能力弱</li></ul></li><li><strong>归零编码(RZ &#x2F; Return-to-Zero)</strong> : 低0高1, 中归零. 即用 <strong>低电平表示二进制的0, 高电平表示二进制的1</strong> , 但 <strong>信号周期的后半程总是要让信号归零</strong> . 好处在于能使这个归零的行为作为信号双方的时钟.<ul><li>有自同步能力</li><li>浪费带宽</li><li>抗干扰能力弱</li></ul></li><li><strong>反向非归零编码(NRZI &#x2F; None-Return-to-Zero Inverted)</strong> : 跳0不跳1, 中不变. 即使用 <strong>当前信号周期相对于上一个信号周期的电平是否跳变</strong> 来决定当前的信号是0还是1, 跳为0, 不跳为1.<ul><li>可以增加冗余位来支持自同步</li><li>浪费部分带宽</li><li>抗干扰能力弱</li></ul></li><li><strong>曼彻斯特编码</strong> : 跳0反跳1, 看中间, 中必变. 即通过 <strong>当前信号周期中间的跳变方向</strong> 决定当前的信号是0还是1, 上跳为0, 下跳为1.<ul><li>有自同步能力</li><li>浪费带宽</li><li>抗干扰能力强</li></ul></li><li><strong>差分曼彻斯特编码</strong> : 跳0不跳1, 看起点, 中必变. 通过 <strong>当前信号周期起点的跳变方向</strong> 决定当前的信号是0还是1, 跳为0, 不跳为1.<ul><li>有自同步能力</li><li>浪费带宽</li><li>抗干扰能力强</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B.png" alt="编码类型详解"></p><hr><p>接下来是调制和解调, 我们先得明确一个概念, 叫 <strong>基带信号</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 基带信号</font></strong><br>指的是来自信号源的数字信号, 需要经过调制后才能在信道上传输.</p></blockquote><p>哎, 问题来了, 编码挺好听完善的, 干嘛非得用模拟信号呢?<br>事实上, 某些特殊环境下(如真空)是只能使用模拟信号的. 同时 <strong>模拟信号抗干扰能力显著强于数字信号</strong> , 因此在长距离传输环境下也会优先将数字信号调制成模拟信号再传输.</p><p>好嘞, 我们开始捯饬几种常用的调制策略:</p><ul><li>调幅(AM): 即 <strong>调整振幅</strong> 的策略, 也叫 <strong>幅移键控(ASK)</strong><ul><li>表示0: <strong>$ 0 * sin2x $</strong></li><li>表示1: <strong>$ 1 * sin2x $</strong></li></ul></li><li>调频(FM): 即 <strong>调整频率</strong> 的策略, 也叫 <strong>频移键控(FSK)</strong><ul><li>表示0: <strong>$ sinx $</strong></li><li>表示1: <strong>$ sin2x $</strong></li></ul></li><li>调相(PM): 即 <strong>调整相位</strong> 的策略, 也叫 <strong>相移键控(PSK)</strong><ul><li>表示0: <strong>$ sin(x+0) $</strong></li><li>表示1: <strong>$ sin(x+\pi) $</strong></li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E8%B0%83%E5%88%B6%E7%B1%BB%E5%9E%8B.png" alt="调制类型详解"></p><blockquote><p><strong><font color = #fa4659>注意: 调制中多个比特的表示法</font></strong><br>相当于要调出多种码元对不对, 那针对上面的调幅, 调频, 调相, 只需要设计出更多的振幅, 频率, 相位, 就能使得一个码元携带多个比特位了.</p></blockquote><hr><p>相信各位已经有些大胆的想法了, 我能不能不仅仅调一个参数, 而是把多个参数混在一块调制?<br>嘿嘿, 当然可以.</p><ul><li>正交幅度调制(QAM): 同时结合了调幅和调相.<ul><li>若涉及m种振幅, n种相位, 则能够有 $ m * n $ 种不同的码元, 一个码元可以表示 $ log_2(m * n) $ 个比特位</li><li>通常使用 $ QAM-k $ 的方式表示调制出的总信号数, 后方的k就是信号数的意思.</li><li>常见的有 <strong>QAM-16, QAM-32, QAM-64, QAM-128</strong> 等等.</li></ul></li></ul><h2 id="2-2-传输介质"><a href="#2-2-传输介质" class="headerlink" title="2.2 传输介质"></a>2.2 传输介质</h2><p>这一节我们捯饬捯饬关于传输介质的玩意. 通常分两类:</p><ul><li><strong>导向型</strong> : 信号只能朝向固定方向传播, 如双绞线, 同轴电缆, 光纤等</li><li><strong>非导向型</strong> : 信号朝四面八方传播, 通常都是无线通信的介质</li></ul><h3 id="2-2-1-非导向型传输介质"><a href="#2-2-1-非导向型传输介质" class="headerlink" title="2.2.1 非导向型传输介质"></a>2.2.1 非导向型传输介质</h3><h4 id="2-2-1-1-双绞线-TP-Twisted-Pair"><a href="#2-2-1-1-双绞线-TP-Twisted-Pair" class="headerlink" title="2.2.1.1 双绞线(TP &#x2F; Twisted Pair)"></a>2.2.1.1 双绞线(TP &#x2F; Twisted Pair)</h4><p><strong>双绞线</strong> 名如其意, 通常是由两根导线相互 <strong>绞合</strong> 而成. 根据屏蔽层的有无又可以划分为 <strong>屏蔽双绞线(STP &#x2F; Shielded Twisted Pair)</strong> 和 <strong>非屏蔽双绞线(UTP &#x2F; UnShielded Twisted Pair)</strong> 两种.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E5%8F%8C%E7%BB%9E%E7%BA%BF.png" alt="双绞线"></p><blockquote><p><strong><font color = #fa4659>注意: 绞合?</font></strong><br>上面这个图并没有展现出 <strong>绞合</strong> 这一方法, 事实上, 绞合就相当于把两根绳子像拧麻花一样缠在一起. 目的在于提升抗噪声的能力.</p></blockquote><p>双绞线提升传输速率的手段主要在于 <strong>抗噪声的设计</strong> . 包括 <strong>提升绞合度</strong> 和 <strong>增加屏蔽层</strong> 等方式.</p><h4 id="2-2-1-2-同轴电缆"><a href="#2-2-1-2-同轴电缆" class="headerlink" title="2.2.1.2 同轴电缆"></a>2.2.1.2 同轴电缆</h4><p><strong>同轴电缆</strong> 主要由 <strong>内导体(传输信号)</strong> 和 <strong>外导体屏蔽层(抗电磁干扰)</strong> 构成. 通常内导体使用铜线, 而铜线越粗, 电阻越低.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86.png" alt="同轴电缆"></p><h4 id="2-2-1-3-光纤"><a href="#2-2-1-3-光纤" class="headerlink" title="2.2.1.3 光纤"></a>2.2.1.3 光纤</h4><p><strong>光纤</strong> 主要由 <strong>纤芯</strong> 和 <strong>包层</strong> 组成. 它利用了 <strong>光的全反射特性</strong> , 在纤芯内传输光脉冲信号. 目前最常用, 因为光脉冲信号对电磁干扰不敏感, <strong>抗干扰性极强</strong> , 同时 <strong>传输损耗也小</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E5%85%89%E7%BA%A4.png" alt="光纤"></p><p>通常分为 <strong>单模光纤(SMF &#x2F; Single-Mode Fiber)</strong> 和 <strong>多模光纤(MMF &#x2F; Multi-Mode Fiber)</strong> .</p><ul><li>单模光纤<ul><li>纤芯非常细, 直径小于一个波长, 只能传输一条光线</li><li>传输损耗低</li><li>适合远距离传输</li></ul></li><li>多模光纤<ul><li>纤芯更粗, 可同时传输多条光线</li><li>传输损耗较高</li><li>适合短距离传输</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E5%8D%95%E6%A8%A1%E5%85%89%E7%BA%A4.png" alt="单模光纤"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.2%20%E7%89%A9%E7%90%86%E5%B1%82/%E5%A4%9A%E6%A8%A1%E5%85%89%E7%BA%A4.png" alt="多模光纤"></p><hr><p>三种介质说完了, 现在要明确在以太网中这三种介质的命名, 它们统一的格式为:</p><p>$$ 速度 \space Base \space 介质信息 $$</p><ul><li>速度: 通常是一个数字, 单位为 <strong>Mbps</strong></li><li>Base: Baseband的缩写, 即传输数字信号.</li><li>介质信息:<ul><li>一个单独的数字: 指同轴电缆, 数字是同轴电缆的 <strong>最远传输距离</strong> , 单位一般是 <strong>百米</strong></li><li>F开头: 指光纤, 后面可以继续接其他信息</li><li>T开头: 指双绞线, 后面可以继续接其他信息</li></ul></li></ul><h3 id="2-2-2-无线传输介质"><a href="#2-2-2-无线传输介质" class="headerlink" title="2.2.2 无线传输介质"></a>2.2.2 无线传输介质</h3><p>聊完有线的, 来聊聊无线的. 通常分三类:</p><ul><li><strong>无线电波</strong> :<ul><li>穿透能力强, 传输距离长</li><li>信号指向性弱</li><li>如手机信号 &#x2F; Wifi</li></ul></li><li><strong>微波通信</strong> : 也叫 <strong>短波通信</strong> , 波长较短<ul><li>频率带宽高, 信号指向性强</li><li>保密性差</li><li>如卫星通信</li></ul></li></ul><blockquote><p><strong><font color = #fa4659>注意: 短波通信的原理?</font></strong><br>$ C &#x3D; \lambda * f $ , 即 光速 &#x3D; 频率 * 波长 , 因此波长越短, 频率越高, 频率带宽也越高, 同样信号指向性就越强.</p></blockquote><p>事实上, 信号指向性太强有时候不是个很好的事情, 中间万一有个啥玩意给你挡了, 长波还能稍微绕一下, 而短波就只能建中继站了…</p><h3 id="2-2-3-接口特性"><a href="#2-2-3-接口特性" class="headerlink" title="2.2.3 接口特性"></a>2.2.3 接口特性</h3><p>最后寻思一下在接口上有什么需要定义的:</p><ul><li>机械特性:<ul><li>接口所用接线器的形状, 尺寸, 引脚数目和排列…</li></ul></li><li>电气特性:<ul><li>各条线上的电压范围, 传输速率, 距离限制…</li></ul></li><li>功能特性:<ul><li>某条线上出现某一电平电压的意义</li></ul></li><li>过程特性:<ul><li>不同功能的可能的出现顺序</li></ul></li></ul><p>大致了解即可.</p><h2 id="2-3-物理层设备"><a href="#2-3-物理层设备" class="headerlink" title="2.3 物理层设备"></a>2.3 物理层设备</h2><p>本节中将对物理层的设备进行简要的描述</p><h3 id="2-3-1-中继器"><a href="#2-3-1-中继器" class="headerlink" title="2.3.1 中继器"></a>2.3.1 中继器</h3><p>由于信号的传输过程中有损耗, 因此每个在一个介质中的极限传输距离是由上限的. 这时, 要保证网络的覆盖面, 就需要 <strong>中继器</strong> 的参与, 其主要功能是负责信号的 <strong>整形与再生</strong> .</p><ul><li>中继器只有两个端口, 一段负责接收失真信号, 另一端负责发送出整形再生的信号.</li><li>仅支持半双工通信(能双向工作, 但 <strong>不能同时双向工作</strong> )</li><li>两个端口分别对应两个网段</li></ul><h3 id="2-3-2-集线器"><a href="#2-3-2-集线器" class="headerlink" title="2.3.2 集线器"></a>2.3.2 集线器</h3><p><strong>集线器</strong> 本质上是多端口的中继器. 将其中一个端口接收到的信号进行整形再生, 并发送给其余所有端口.</p><ul><li>有N个端口, 对应N个网段</li><li>各个网段属于同一个 <strong>冲突域</strong> .</li><li>意味着任何主机要发送信息都要先进行 <strong>信道争用</strong> .</li></ul><blockquote><p><strong><font color = #3490de>概念: 冲突域</font></strong><br>如果两台主机同时发送数据会导致冲突, 则称这两台主机处于同一个 <strong>冲突域</strong> 内.</p></blockquote><hr><p>了解了这俩设备, 有些特性就很好理解了:</p><ul><li>集线器和中继器不能 <strong>无限串联</strong></li><li>集线器连接的网络, 虽然物理上是星形拓扑, 但 <strong>逻辑上依然是总线拓扑(不同网段上的计算机发送数据仍然会发生冲突)</strong></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84-%E6%80%BB%E7%BA%BF%E5%BD%A2.png" alt="拓扑结构-总线"></p><ul><li>集线器连接的网段会 <strong>共享带宽</strong></li></ul><hr><p>物理层的内容并不多, 主要是对一些涉及到硬件底层的规定作了阐述.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-计组-Chap.2</title>
      <link href="/posts/63625.html"/>
      <url>/posts/63625.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Chap-2-数据的表示和运算"><a href="#计算机组成原理-Chap-2-数据的表示和运算" class="headerlink" title="计算机组成原理 Chap.2 数据的表示和运算"></a>计算机组成原理 Chap.2 数据的表示和运算</h1><blockquote><p>本系列计算机组成原理博文基于Bilibili王道计算机教育的免费考研课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机网络的相关内容. 会在后续时间内一一进行补足.</p></blockquote><h2 id="2-1-计算机中的进制以及数的表示"><a href="#2-1-计算机中的进制以及数的表示" class="headerlink" title="2.1 计算机中的进制以及数的表示"></a>2.1 计算机中的进制以及数的表示</h2><p>第一章中我们寻思了计算机的基本组成结构以及一些总体性的玩意, 这一章我们率先进入一个大难点, <strong>运算</strong> .</p><p>聊到运算, 首先要唠唠这个进制的事.</p><h3 id="2-1-1-进位计数制"><a href="#2-1-1-进位计数制" class="headerlink" title="2.1.1 进位计数制"></a>2.1.1 进位计数制</h3><p><strong>进制</strong> , 这是个挺古老的概念, 这玩意最开始要追溯到罗马数字了, 但我们这里不唠太多有的没的, 仅仅给出一些重要的概念和方法.</p><blockquote><p><strong><font color = #3490de>概念: 基数</font></strong><br>每个数码位所用到的不同符号的个数. 十进制的基数就是10, 二进制的基数就是2.</p></blockquote><p>我们在计算机中通常只涉及到四种常用的进制:</p><ul><li><strong>二进制</strong> : $ (1010)_2 &#x2F; 1010B $</li><li><strong>八进制</strong> : $ (534)_8 $</li><li><strong>十进制</strong> : $ (534)_{10} &#x2F; 534D $</li><li><strong>十六进制</strong> : $ (a145)_{16} &#x2F; a145H &#x2F; 0xa145 $</li></ul><blockquote><p><strong><font color=#fa4659>注意: 进制的表示方法</font></strong><br>二进制的 <strong>B</strong> 来源于英文 <strong>Binary</strong> ; 十进制的 <strong>D</strong> 来源于英文 <strong>Decimalism</strong> ; 十六进制的 <strong>H</strong> 来源于英文的 <strong>Hexadecimal</strong> .</p></blockquote><p><strong>二进制</strong> 是最适合计算机进行信息存储与处理的的进制, 这主要有3方面的原因:</p><ol><li>仅需要 <strong>两个稳定状态</strong> 的物理器件就能表示全部的信息</li><li><strong>0 &#x2F; 1</strong> 刚好对应计算机中的逻辑 <strong>假 &#x2F; 真</strong> , 方便实现逻辑运算</li><li>算术运算可以很方便的使用逻辑门电路实现</li></ol><hr><p>扯远了, 我们拉回来点. 进制知道了, 那自然要涉及到 <strong>书同文</strong> 这么一个事情, 互相转换要整的明明白白的.</p><p>对于 <strong>二进制 &#x2F; 八进制 &#x2F; 十六进制</strong> 转 <strong>十进制</strong> 这个事情, 我们通常采用 <strong>位权相乘</strong> 的方式, 即 <strong>位上的数值 * 对应位的权重值</strong></p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>以常见的16进制举例:<br>16进制转10进制: $ 123.12 &#x3D; 1 \ast 16^2 + 2 \ast 16^1 + 3 \ast 16^0 + 1 \ast 16^{-1} + 2 \ast 16^{-2}  $</p></blockquote><hr><p>这之后, 我们要考虑 <strong>二进制 &#x2F; 八进制 &#x2F; 十六进制互相转换</strong> 的问题. 这个玩意的原理挺简单的, 是由它们基数之间的关系得到的: $ 2^3 &#x3D; 8, 2^4 &#x3D; 16 $ , 因此我们很自然的想到应该能实现 <strong>三个2进制数能与一个8进制数互相转换</strong> , <strong>四个2进制数能与一个16进制数互相转换</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 转换的补零</font></strong><br>由于这种转换方式的起始点是 <strong>小数点</strong> , 因此当某组位数不足时, 需要自动在前 &#x2F; 后补零.</p></blockquote><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>二进制数: 10 011 101 . 101 01<br>八进制数: 235 . 52</p></blockquote><hr><p>最后是 <strong>十进制转二进制 &#x2F; 八进制 &#x2F; 十六进制</strong> 的问题. 这个问题的方法是通过上面的 <strong>位权相乘</strong> 式子得来的. 有想法的读者可以自己举个例子证明一下, 原理很简单.</p><p>十进制的转换要分整数部分和小数部分分别写. 整数部分的处理方法为 <strong>除基取余</strong> , 将每次除完的余数从小数点开始往前写. 小数部分的处理方法为 <strong>乘基取整</strong> , 将每次相乘后的整数位从小数点开始往后写.</p><hr><p>转换整明白了. 我们最后出两个概念: <strong>真值</strong> &#x2F; <strong>机器数</strong> .</p><p>这个问题的根源在于数字这玩意很讨厌, 它有正负, 但是机器上只能通过二进制来表示一个数, 这就意味着必须要单独分一个位来表示这个数是正值还是负值.</p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>真值: +15<br>机器数: 0 1111 (最前方为符号位, 0表示正)</p></blockquote><h3 id="2-1-2-定点数的编码表示"><a href="#2-1-2-定点数的编码表示" class="headerlink" title="2.1.2 定点数的编码表示"></a>2.1.2 定点数的编码表示</h3><p>这标题有点突兀, <strong>定点数</strong> 是个啥玩意?</p><blockquote><p><strong><font color = #3490de>概念: 定点数 &#x2F; 浮点数</font></strong><br><strong>定点数</strong> , 指的是在表示数据时, 小数点的位置是固定的. 举例而言即 <strong>996.007</strong> .<br><strong>浮点数</strong> , 与之对应, 即在表示数据时使用科学计数法的方式将数据拆为两部分. 举例而言即 <strong>$ 9.96007 \ast 10^2 $</strong> .</p></blockquote><p>这么看定点数还挺简单的, 直接写就完了? 理是这么个理, 但由于计算机里面要进行运算的类型不同, 在 <strong>有符号数</strong> 的定点表示部分, 我们还需要接触些新的内容.</p><h4 id="2-1-2-1-无符号数的定点表示"><a href="#2-1-2-1-无符号数的定点表示" class="headerlink" title="2.1.2.1 无符号数的定点表示"></a>2.1.2.1 无符号数的定点表示</h4><blockquote><p><strong><font color = #3490de>概念: 无符号数</font></strong><br>指的是整个机器字长的全部二进制位都是数值位, <strong>没有符号位</strong> .</p></blockquote><p>无符号数的表示原理挺简单的, 因为不涉及到符号位. 我们这里只需要明确其 <strong>表示范围</strong> 即可.</p><p><strong>n位无符号</strong> 数的表示范围: <strong>$ 0 \sim 2^n -1 $</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 无符号数的修饰范围</font></strong><br>通常而言, 无符号数不会用于修饰浮点数, 而仅仅会用于修饰整数.<br>例如, 在C语言中, 无符号的修饰符 <strong>unsigned</strong> 仅能够用于修饰 <strong>int, long long</strong> 等整数类型.</p></blockquote><h4 id="2-1-2-2-有符号数的定点表示"><a href="#2-1-2-2-有符号数的定点表示" class="headerlink" title="2.1.2.2 有符号数的定点表示"></a>2.1.2.2 有符号数的定点表示</h4><p>既然是定点, 通常来说整数和小数就要分开保存了.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E4%BF%9D%E5%AD%98.png" alt="有符号数的定点保存"></p><p>可见, 所谓定点就是将小数点定在了 <strong>整数之后</strong> 以及 <strong>小数之前</strong> . 符号位则永远处于最前面的位置, 除了符号位以外用于表示数值的部分, 我们单独起个名叫 <strong>尾数</strong> .</p><p>明确完这种表示方法, 我们要唠唠一个老大难问题: <strong>原码 &#x2F; 反码 &#x2F; 补码 &#x2F; 移码</strong> .</p><hr><p><strong>原码</strong> , 即用尾数表示 <strong>真值的绝对值</strong> . 这种表示方法是最简单易懂的, 它最符合我们印象中的二进制表示, 只不过单加了一个符号位而已.</p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>+19D<br>定点整数: <font color = red>0</font>0010011<br>注: 上文中将符号位用特殊颜色标出. 实际书写时也有 <strong>在符号位后加一个逗号</strong> 这种习惯. (0,0010011)</p></blockquote><p>现在考虑一下 <strong>原码的表示范围</strong> :</p><p>对于 <strong>n位定点整数</strong> 而言, 由于其尾数(n-1位)其实就是无符号数的表示方法, 因此加上符号位的表示范围: <strong>$ -(2^{n-1}-1) \leq x \leq (2^{n-1}-1) $</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 原码中的0</font></strong><br>0在原码中由于符号位, 可以被分为 +0 &#x2F; -0 两种形式. 这也是为什么我们用n-1位, 只表示出了 $ 2^{n-1} -1 $ 个数的原因.</p></blockquote><p>对于 <strong>n位定点小数</strong> 而言, 我们还是先看尾数(n-1位), 全0为最小值, 全1为最大值, 计算出n-1位尾数能表示的范围: $ 0 \sim 1-2^{-(n-1)} $ .</p><p>然后我们再加上符号位, 得到n位定点小数的表示范围: <strong>$ -(1-2^{-(n-1)}) \leq x \leq (1-2^{-(n-1)}) $</strong> .</p><hr><p><strong>反码</strong> , 定义如下:</p><ul><li>若 <strong>原码为正</strong> , 则该数的反码等同于该数的原码.</li><li>若 <strong>原码为负</strong> , 则该数的反码是该数原码 <strong>除符号位以外各位取反</strong> 的结果.</li></ul><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>-19D<br>$ [x]_原 $ &#x3D; <font color = red>1</font>0010011<br>$ [x]_反 $ &#x3D; <font color = red>1</font>1101100</p></blockquote><p>可见, 原码和反码是 <strong>一一对应</strong> 的关系. 因此在表示范围上, 反码和原码是相同的.</p><blockquote><p><strong><font color=#fa4659>注意: 反码中的0</font></strong><br>有原码的转换得知反码中 +0 &#x2F; -0 的表示:<br>$ [+0]_反 $ &#x3D; 0,0000000<br>$ [-0]_反 $ &#x3D; 1,1111111</p></blockquote><p>反码只是由原码转向补码的一个中间状态, 在实际应用中并没有什么作用.</p><hr><p><strong>补码</strong> , 定义如下:</p><ul><li>若 <strong>原码为正</strong> , 则该数的补码等同于该数的原码.</li><li>若 <strong>原码为负</strong> , 则该数的补码为该数 <strong>反码的末位+1</strong> .</li></ul><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>-19D<br>$ [x]_原 $ &#x3D; <font color = red>1</font>0010011<br>$ [x]_反 $ &#x3D; <font color = red>1</font>1101100<br>$ [x]_补 $ &#x3D; <font color = red>1</font>1101101</p></blockquote><blockquote><p><strong><font color=#fa4659>注意: 补码中的0</font></strong><br>有兴趣的读者可以自行看一下-0转成补码之后的形式, 它会进位出一个范围外的1被系统丢弃, 因此 <strong>+0 &#x2F; -0在补码中的表示是相同的</strong> .</p></blockquote><p>那问题来了, 原来原码和反码都用了两种情况表示0, 你补码把其中一种情况(1,0000000)丢了, 咋整捏?</p><p>因此, 对这种特殊情况做出了特殊规定, 还是拿8位机器码举例:</p><p>在 <strong>定点整数</strong> 中: (1,0000000)用于表示 $ -2^7 $<br>在 <strong>定点小数</strong> 中: (1,0000000)用于表示 $ -1 $</p><p>这意味着, 相比于原码和反码, <strong>补码可以多表示一个负数</strong> , 对于定点整数, 其表示范围为: <strong>$ -(2^{n-1}) \leq x \leq (2^{n-1}-1) $</strong> ; 对于定点小数, 其表示范围为: <strong>$ -1 \leq x \leq (1-2^{-(n-1)}) $</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 补码转原码</font></strong><br>正常而言, 我们应该先把加进去的1减掉, 然后逐位取反对吧. 但这里是二进制, 因此其实我们按照原码转补码的方式(除符号位各位取反再+1)再操作一遍, 就是补码转原码了.</p></blockquote><hr><p><strong>移码</strong> , 定义即:</p><p><strong>在补码的基础上, 将其符号位取反</strong> . <del>(是的, 没有额外的规定了)</del></p><blockquote><p><strong><font color=#fa4659>注意: 移码的表示范围</font></strong><br>移码只用来表示整数.</p></blockquote><p>由于移码是由补码转换而来的, 因此移码和补码的数的表示范围也是相同的.</p><p>关于 <strong>移码的作用</strong> , 我们这里简单提一嘴:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E7%A7%BB%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="移码的作用"></p><p>对比一下补码和移码, 可以发现 <del>补码这叫一个乱七八糟</del> , 把移码当作无符号数来看的话, 正好是真值越大, 对应的无符号数越大.</p><p>因此移码可以很方便的实现整数的大小比较.</p><hr><p>各种码制, 我们唠完了, 但是这一堆有啥用? 我们待会说.</p><h3 id="2-1-3-补码的作用"><a href="#2-1-3-补码的作用" class="headerlink" title="2.1.3 补码的作用"></a>2.1.3 补码的作用</h3><p>搞了这么多乱七八糟的玩意有啥用呢?</p><p>举个简单的例子, 我们用有符号数来表示 +14 + (-14) , 如果直接用原码摁算, 结果显然不是0.</p><p>$$<br>\begin{align*}<br>\space \space \space 00001110 \\<br>+\space 10001110 \\<br>Result \space 10011100<br>\end{align*}<br>$$</p><p>这种情况挺不符合直觉的, 按理来说这玩意应该直接得到0对吧.</p><p>事实上, 我们应该在符号位不同时 <strong>对尾数运用减法</strong> , 可以有效地解决这一问题. 但问题又来了:<br><strong>他娘的减法器比加法器可难设计多了</strong> .</p><p>好嘛, 最终有一帮子人寻思着能不能把减法也用加法整出来, 所以搞出了上面那一坨.<br>这个事怎么实现呢, 得从模运算说起.</p><hr><p>上面我们提到了, 计算机能表示的数字再大, 也有那么个上限. 因此实际上, 我们将数字14变成0, 并不仅仅只能用减法来实现, 我们可以 <strong>直接把它加到上限, 然后进行一个取模运算</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 补数</font></strong><br>在数论中, 指的是两个数相加之后等于模数的情况.</p></blockquote><p>所以, 减去某个数, 实质上等价于 <strong>加上这个数的补数</strong> . 现在问题是, <strong>补数怎么求?</strong></p><p>我们上个小节说了个玩意叫 <strong>补码</strong> . 对, 就那么求.</p><p>现在读者应该明白为啥正数的补码就是它自己了, 因为正数相加的时候根本不需要什么转换, <strong>只有涉及到负数的时候才需要有求补这一步</strong> .</p><h3 id="2-1-4-零扩展-符号扩展"><a href="#2-1-4-零扩展-符号扩展" class="headerlink" title="2.1.4 零扩展 &#x2F; 符号扩展"></a>2.1.4 零扩展 &#x2F; 符号扩展</h3><p>不整啥复杂的了, 直接上概念:</p><blockquote><p><strong><font color = #3490de>概念: 扩展</font></strong><br>指的是从小位宽数据向大位宽数据进行转换. 简单而言就是16位数据转到32 &#x2F; 64位数据的过程.</p></blockquote><p>为啥要扩展? 因为不同的数据之间的运算都需要借助 <strong>ALU</strong> 进行实现, 但ALU能接收的数据宽度是固定的. 因此首先就需要进行一个统一位宽的工作.</p><p>所谓 <strong>零扩展</strong> 和 <strong>符号扩展</strong> 是两种扩展的方法. 适用于不同的情况.</p><hr><p><strong>零扩展</strong> , 适用于无符号整数(unsigned), 这是因为这玩意不受到正负号限制, 因此扩展时只需要 <strong>在高位补零</strong> 即可.</p><p>$$ 01011010 \to 00000000 \space 01011010 $$</p><hr><p><strong>符号扩展</strong> , 适用于带符号整数(short, char, int, longlong, …), 这一类整数在计算机中往往以 <strong>补码</strong> 的形式进行存储, 在符号位扩展时要遵守的原则为 <strong>用符号位扩展高位</strong> .</p><p>$$ 1,1011010 \to 1, 11111111 \space 1011010 $$</p><h2 id="2-2-计算机中的四则运算"><a href="#2-2-计算机中的四则运算" class="headerlink" title="2.2 计算机中的四则运算"></a>2.2 计算机中的四则运算</h2><h3 id="2-2-0-数字电路基础知识补充"><a href="#2-2-0-数字电路基础知识补充" class="headerlink" title="2.2.0 数字电路基础知识补充"></a>2.2.0 数字电路基础知识补充</h3><p>关于最最基础的 <strong>与或非</strong> 运算等知识我们这里不再细说了, 这是数字电路中最最基础的内容. 对此部分不了解的读者请自行查找 <strong>逻辑运算 &#x2F; 逻辑门电路</strong> 相关的内容.</p><p>本小节主要目的在于补充几个比较重要的部件.</p><hr><p><strong>多路选择器(Multiplexer, MUX)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8MUX.png" alt="多路选择器"></p><p>该部件的作用是在 <strong>多个输入中根据控制信号OP的值来选择一个输入让其输出</strong> . 控制信号的位数是有长度要求的: <strong>$ m \geq log_2k \space bit $</strong> . (因为m位信号最多能表示 $ 2^m $ 种可能)</p><blockquote><p><strong><font color=#fa4659>注意: 多路选择器的预留控制信号</font></strong><br>上面提到的情况是该选择器总有一个信号能够通过, 但实际情形中有可能会 <strong>单独预留一个控制信号</strong> , 并将该控制信号单独作为 <strong>拦截所有输入的信号(没有一种输入可以通过)</strong> .<br>最简单的方式及将m扩展一位, 并选择一个不存在的输入作为控制信号即可.</p></blockquote><hr><p><strong>三态门(tristate portal)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B8%89%E6%80%81%E9%97%A8.png" alt="三态门"></p><p>跟上面的多路选择器类似, 但只有一个输入. <strong>当控制信号OP&#x3D;0时, 呈现高阻态, 阻止数据通过, 否则则原样传递数据.</strong> </p><blockquote><p><strong><font color=#fa4659>注意: 高阻态</font></strong><br>高阻态相当于直接把这个电路给 <strong>断掉了</strong> , 它并不属于高电平 &#x2F; 低电平这两种状态之一.</p></blockquote><h3 id="2-2-1-实现运算的硬件单元"><a href="#2-2-1-实现运算的硬件单元" class="headerlink" title="2.2.1 实现运算的硬件单元"></a>2.2.1 实现运算的硬件单元</h3><p>我们先来唠一唠在计算机里面是用什么硬件来实现这些四则运算的.</p><h4 id="2-2-1-1-加法器"><a href="#2-2-1-1-加法器" class="headerlink" title="2.2.1.1 加法器"></a>2.2.1.1 加法器</h4><p>加法器的目的在于实现 <strong>由加数A, 被加数B得到和S</strong> 的过程.</p><p>咱一步步来, 先看对于一位二进制位, 加法器需要有什么:</p><ul><li>被加数的本位 <strong>$ A_i $</strong></li><li>加数的本位 <strong>$ B_i $</strong></li><li>来自低位的进位 <strong>$ C_{i-1} $</strong></li><li>本位和 <strong>$ S_i $</strong></li></ul><p>这几位之间的关系可以用如下的式子表示:</p><p>$$<br>\begin{align}<br>  &amp; S_i &#x3D; A_i \oplus B_i \oplus C_i \tag 1 \\<br>  &amp; C_i &#x3D; A_iB_i + (A_i \oplus B_i)C_{i-1} \tag 2<br>\end{align}<br>$$</p><p>这俩式子我们解释一下:</p><ul><li><strong>(1)</strong> 意味着输入中只要有奇数个1就输出1</li><li><strong>(2)</strong> 意味着输入中至少有两个1时就输出1</li></ul><p>然后给一下这俩式子对应的逻辑电路:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%8D%95%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8%281%29.png" alt="(1)"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%8D%95%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8%282%29.png" alt="(2)"></p><p>把这俩电路封装一下, 仅仅暴露出输入 &#x2F; 输出的接口:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8FullAdder.png" alt="一位全加器FullAdder"></p><p>一位搞定了, n位就不足为惧了, 把n个这样的玩意拼到一块去, 然后把进位的玩意连起来就完事了嘛.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/n%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="n位加法器"></p><p>我们一般称呼这种加法器为 <strong>串行进位的并行加法器</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 串行进位的并行加法器</font></strong><br>指并行数据输入, 但串行进位的加法器.</p></blockquote><hr><p>好的, 这一步步的推下来贼顺溜, 但是问题来了, 这么进位可太慢了.</p><p>我们的目标现在更高了, 我们希望搞出一个能在数据输入的同时就得到所有进位信息的加法器, 即 <strong>并行进位的并行加法器</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 并行进位的并行加法器</font></strong><br>指并行数据输入, 同时并行进位的加法器.</p></blockquote><p>这个玩意的原理我们先不深究, 我们本节中就知道这东西是刚刚的加法器加上 <strong>CLA部件</strong> 改造而来的就成了.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="并行进位的加法器"></p><hr><p>倒腾到现在, 我们的运算速度算是搞上去了, 随后需要再添加一些小细节.</p><ul><li>判断加法器工作后是否溢出.</li><li>判断加法器结果是否为0 (A &#x3D;&#x3D; B ?)</li><li>判断加法器结果的正负 (A &gt; B ?)</li></ul><p>根据我们上面的需求, 给这个加法器加点标志位:</p><ul><li><strong>OF(Overflow Flag)</strong> : 溢出标志, 用于判断 <strong>带符号数</strong> 加减运算是否溢出(1表溢出, 0表未溢出)</li><li><strong>SF(Sign Flag)</strong> : 符号标志, 用于判断 <strong>带符号数</strong> 加减运算结果的正负性(1表负, 0表正)</li><li><strong>ZF(Zero Flag)</strong> : 零标志, 判断加减运算结果是否为0(1表结果为0, 0表结果非0)</li><li><strong>CF(Carry Flag)</strong> : 进位 &#x2F; 借位标志, 用于判断 <strong>无符号数</strong> 加减运算是否溢出(1表溢出, 0表未溢出)</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E5%8A%A0%E6%B3%95%E5%99%A8%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E7%94%9F%E6%88%90.png" alt="加法器标志位的生成"></p><p>$$<br>\begin{align}<br>  &amp; OF &#x3D; C_n \oplus C_{n-1} \tag 1 \\<br>  &amp; SF &#x3D; S_n \tag 2 \\<br>  &amp; ZF &#x3D; \overline{S_n + … + S_2 + S_1} \tag 3 \\<br>  &amp; CF &#x3D; C_{out} \oplus C_{in} &#x3D; C_n \oplus C_0 \tag 4<br>\end{align}<br>$$</p><p>这里面比较难理解的是 (1) 和 (4) , 我们暂且按下不表, 等到后面了解到具体的运算过程中来解答.</p><h4 id="2-2-2-2-快速进位"><a href="#2-2-2-2-快速进位" class="headerlink" title="2.2.2.2 快速进位"></a>2.2.2.2 快速进位</h4><p>我们上一节说除了串行进位还有个并行进位的玩意, 那东西可快. 但是并行进位怎么实现呢?</p><p>得从我们之前写的进位公式说起:</p><p>$$ C_i &#x3D; A_iB_i + (A_i \oplus B_i)C_{i-1} $$</p><p>这东西我们细细一寻思, 嘿, 是个递推.</p><p>这就代表着这玩意能接着往下拆:</p><p>$$<br>\begin{align}<br>  &amp; C_i &#x3D; A_iB_i + (A_i \oplus B_i)C_{i-1} \tag 1 \\<br>  &amp; C_i &#x3D; A_iB_i + (A_i \oplus B_i)(A_{i-1}B_{i-1} + (A_{i-1} \oplus B_{i-1})C_{i-2}) \tag 2 \\<br>  &amp; … \tag 3<br>\end{align}<br>$$</p><p>这意味着我们要算 <strong>$ C_i $</strong> , 需要的信息是:</p><ul><li><strong>$ C_0 $</strong></li><li><strong>$ B_0, B_1, …, B_{i-1} $</strong></li><li><strong>$ A_0, A_1, …, A_{i-1} $</strong></li></ul><p>这一堆东西就好拿了, 意味着其实后面的进位可以直接在运算一开始直接得到.</p><hr><p>但这种情况还有个问题, 这东西套两位就挺复杂的, 这要套64位, 好家伙, 开玩笑呢.</p><p>这就产生了另一种方式, 即 <strong>组内并行, 组间串行</strong> , 即将位数分组(通常是4位一组), 随后组内的进位立刻算出, 组外的运算需要等上一组的进位结果产生后再进行计算.</p><p>当然, 这种方式的原理与此前的两种加法器就大同小异了, 也不太算是一个很重点的玩意, 这里就不再详述.</p><h4 id="2-2-1-3-算术逻辑单元ALU"><a href="#2-2-1-3-算术逻辑单元ALU" class="headerlink" title="2.2.1.3 算术逻辑单元ALU"></a>2.2.1.3 算术逻辑单元ALU</h4><p>ALU, 英文全称 <strong>Arithmetic and Logic Unit</strong> , 翻译为 <strong>算术逻辑单元</strong> .</p><p>考虑我们在第一章中提到的内容: (<a href="https://mug-chen.site/posts/63945.html">专业课总复习-计组-Chap.1</a>)</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="运算器的基本组成"></p><p>得见, ALU是运算器中很重要的一部分. <strong>它负责对各种寄存器中的数据进行处理与运算, 得出结果.</strong></p><blockquote><p><strong><font color=#fa4659>注意: 运算器中的核心</font></strong><br>由于ALU负责各种算数运算和逻辑运算的实现, 因此 <strong>ALU是运算器的核心</strong> , 此外, 后续章节中我们会了解到, 各种算数运算都是途径加法器而实现的, 因此 <strong>ALU的核心是加法器</strong> .</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/ALU%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83.png" alt="ALU算术逻辑单元"></p><p>ALU主要实现的功能有以下三类:</p><ul><li><strong>算数运算</strong> : 加减乘除</li><li><strong>逻辑运算</strong> : 与或非, 异或, 移位</li><li><strong>其他</strong> : 求补, 直送, …</li></ul><p>ALU的输入端即上图中的 <strong>$ A, B $</strong> , 而功能控制则交与控制信号 <strong>$ op $</strong> 进行控制.</p><blockquote><p><strong><font color=#fa4659>注意: 控制信号的位数</font></strong><br>控制信号 $ op $ 的位数是跟ALU的功能总数密切相关的, 具体而言, $ |op| \geq \lceil log_2k \rceil $ , 其中 $ k $ 为ALU的功能总数.<br>读者可能觉着这玩意跟之前提过的一个叫 <strong>多路选择器MUX</strong> 的玩意挺像, 哎, 很对, 在MUX的前面接上对应的功能电路, 再在每个功能电路前接上输入, 它不就是一个简单的ALU嘛.</p></blockquote><p>此外, ALU除了F之外正常还能输出之前提到的四个标志位: <strong>0F, SF, ZF, CF</strong> , 这些标志位信息能够进一步送到运算器的某些寄存器(比如PSW, 又称FR(Flag Register)寄存器)中供CPU取用.</p><h3 id="2-2-2-定点数的移位运算"><a href="#2-2-2-定点数的移位运算" class="headerlink" title="2.2.2 定点数的移位运算"></a>2.2.2 定点数的移位运算</h3><p>唠完了硬件, 我们来唠唠几个运算. 首先从移位运算开始.</p><blockquote><p><strong><font color = #3490de>概念: 移位</font></strong><br>通过改变各个数码位与小数点的相对位置, 从而改变各个数码位的位权.<br>说的简单点就是乘 &#x2F; 除对应的基数.</p></blockquote><p>移位运算通常分三类:</p><ul><li>算术移位</li><li>逻辑移位</li><li>循环移位</li></ul><h4 id="2-2-2-1-算术移位"><a href="#2-2-2-1-算术移位" class="headerlink" title="2.2.2.1 算术移位"></a>2.2.2.1 算术移位</h4><p>我们直接从例子开始:</p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>-20D<br>$ [x]_原 $ &#x3D; <font color = red>1</font>0010100<br><strong>右移一位</strong> 等价于 <strong>$ \div 2^1 $</strong><br>$ [x’]_原 $ &#x3D; <font color = red>1</font>0001010</p></blockquote><p>可见, <strong>原码</strong> 的算术移位就是 <strong>符号位保持不变, 仅对数值位进行移动</strong> .</p><p>进一步的讲:</p><ul><li><strong>原码右移</strong> : 高位补0, 低位舍弃</li><li><strong>原码左移</strong> : 低位补0, 高位舍弃</li></ul><blockquote><p><strong><font color=#fa4659>注意: 右移的精度丢失 &#x2F; 左移的数据溢出问题</font></strong><br>刚刚的例子我们舍弃了一个0, 所以是没问题的.<br>我们如果再右移两位会发生什么? <strong>会舍弃一个1, 得到一个结果2</strong> .<br>这时, 我们如果再单看这个移位的效果, 就不是简单的 $ \div 2^1 $ 了, <strong>它会自动舍弃掉丢失的那个小数</strong> .</p><p>类似的, 我们左移的时候也会遇到数据溢出的问题, 这里也不再赘述.</p></blockquote><hr><p>再来看反码, 我们之前说过的, 正数反码就是原码, 负数反码是原码的 <strong>符号位不变, 数值位取反</strong> .</p><p>因此对于反码:</p><ul><li><strong>正数反码</strong> : 移位规则同原码</li><li><strong>负数反码</strong> : <ul><li>右移: 高位补1, 低位舍弃</li><li>左移: 低位补1, 高位舍弃</li></ul></li></ul><hr><p>最后看补码, 正数补码还是原码, 负数补码是 <strong>反码+1</strong> .</p><p>这意味着啥呢? 我们举个例子:</p><p>$$<br>\begin{align*}<br>  &amp; 原数值: &amp; -20D \\<br>  &amp; 原码: &amp; 1,0010100 \\<br>  &amp; 反码: &amp; 1,1101011 \\<br>  &amp; 补码: &amp; 1,1101100<br>\end{align*}<br>$$</p><p>这是啥意思呢, 负数补码数值位的 <strong>后半部分与原码一样, 前半部分与反码一样</strong> , 所以方法就呼之欲出了:</p><blockquote><p><strong><font color=#fa4659>注意: 后半部分</font></strong><br>这个后半部分指的是 <strong>知道从后往前数第一个1为止</strong> .</p></blockquote><ul><li><strong>正数补码</strong> : 移位规则同原码</li><li><strong>负数补码</strong> :<ul><li>右移: 高位补1, 低位舍弃( <strong>同反码</strong> )</li><li>左移: 低位补0, 高位舍弃( <strong>同原码</strong> )</li></ul></li></ul><h4 id="2-2-2-2-逻辑移位"><a href="#2-2-2-2-逻辑移位" class="headerlink" title="2.2.2.2 逻辑移位"></a>2.2.2.2 逻辑移位</h4><p>逻辑移位更算术移位的区别在于, <strong>逻辑移位是要带着符号位一块移的</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 逻辑移位的适用范围</font></strong><br>一看这个移位的规则, 肯定不能用在有符号数上, <del>那一通移动那不乱套了</del> , 因此逻辑移位 <strong>一般只适用于无符号数</strong> .</p></blockquote><h4 id="2-2-2-3-循环移位"><a href="#2-2-2-3-循环移位" class="headerlink" title="2.2.2.3 循环移位"></a>2.2.2.3 循环移位</h4><p>循环移位的方式不太一样, 但规则比较简单.</p><p>我们要把 <strong>移出的那一位放在要补位的那一位上</strong> .</p><p>而这种情况还有两种方式:</p><ul><li><strong>带进位位</strong> : 移出的位放在进位位上, 进位位放在补位的位上</li><li><strong>无进位位</strong> : 直接把移出的位放在补位的位上</li></ul><h3 id="2-2-3-加减运算"><a href="#2-2-3-加减运算" class="headerlink" title="2.2.3 加减运算"></a>2.2.3 加减运算</h3><p>聊完移位的, 再来聊聊加减. 首先我们要明确 <strong>加减通常不涉及到反码, 我们这里只探讨原码和补码</strong> .</p><h4 id="2-2-3-1-定点数的加减运算"><a href="#2-2-3-1-定点数的加减运算" class="headerlink" title="2.2.3.1 定点数的加减运算"></a>2.2.3.1 定点数的加减运算</h4><p>我们先来探讨 <strong>原码的加减</strong> , 之前我们提过原码正负相加的时候会出现的问题, 详见2.1.3</p><p>因此我们先把原码加减的三种情况捋出来:</p><ul><li><strong>正+正</strong> : 数值位做加法, 结果为正</li><li><strong>负+负</strong> : 数值位做加法, 结果为负</li><li><strong>正+负</strong> : 数值位大-小, 符号同绝对值大的数</li></ul><blockquote><p><strong><font color=#fa4659>注意: 原码减法的处理方式</font></strong><br>减法就将被减数换符号, 随后按照加法的方式运作即可.</p></blockquote><p>当然, 我们这里也只是探讨一下这种情况, 这玩意在计算机里太难实现了. <del>用补码就可以仅用加法实现的东西, 为啥要节外生枝?</del></p><hr><p>这之后, 我们看一下计算机中最通用的 <strong>补码的加减</strong> .</p><p>在进行补码的加减运算时, 不需要考虑符号位, 只需要将对应的数值转变为补码后一同运算即可. 但问题来了, 我们看下面这么个情况:</p><p>$$<br>\begin{align*}<br>  &amp; A&#x3D;15, C&#x3D;124 \\<br>  &amp; [A]_补 &#x3D; 0,0001111 , [C]_补 &#x3D; 0,1111100 \\<br>  &amp; [A+C]_补 &#x3D; 1,0001011 \space (对应真值-117)<br>\end{align*}<br>$$</p><p>我们看到, 上述情况中, 两个正数的补码相加最终得到了一个负数的补码结果, 这即我们所说的 <strong>溢出</strong> . 由于八位补码所能表示的数值范围为: <strong>$ 2^{-7} \leq x \leq 2^7-1 $</strong> , 这已经无法表示原先的正数结果了.</p><p>因此, 我们得节外生枝, 说一说这个 <strong>溢出判断</strong> 该怎么实现.</p><hr><p>我们首先得明确, <strong>溢出</strong> 这个事出现的情况:</p><ul><li><strong>正+正</strong> , 结果为负</li><li><strong>负+负</strong> , 结果为正</li></ul><p>因此, 我们给出几种判断溢出的逻辑:</p><p><strong>(1)采用一位符号位时, 单独设置溢出判断位V</strong></p><p>$$<br>\begin{align*}<br>  &amp; 加数A, 被加数B, 结果S \\<br>  &amp; 对应符号位: A_s, B_s, S_s \\<br>  &amp; V &#x3D; \overline{A_s} \overline{B_s} S_s + A_sB_s \overline{S_s}<br>\end{align*}<br>$$</p><p>这个式子的意思即: <strong>当加数与被加数符号相同, 并且结果符号与加数 &#x2F; 被加数符号相反时, 则产生了溢出</strong> .</p><p><strong>(2)根据符号位的进位和最高数值位的进位情况判断溢出</strong></p><p>符号位进位 <strong>$ C_s $</strong></p><p>最高数值位进位 <strong>$ C_1 $</strong></p><p>$$<br>\begin{array}{}<br>  C_s &amp; C_1 &amp; Res \\<br>  0 &amp; 1 &amp; 上溢 \\<br>  1 &amp; 0 &amp; 下溢<br>\end{array}<br>$$</p><p>又或者当不需要判断上溢还是下溢的时候, 只需要判断:</p><p>$$ V &#x3D; C_s \oplus C_1 $$</p><p>即可.</p><blockquote><p><strong><font color=#fa4659>注意: 标志位OF的产生方式</font></strong><br>请读者回看2.2.1.1中加法器的溢出标志位OF的逻辑表达式, 其使用的溢出判断方式即如上所述.</p></blockquote><p><strong>(3)采用双符号位的补码来表示数值</strong></p><p>$$<br>\begin{array}{}<br>  &amp; 加数 &amp; 00,0001111 \\<br>  &amp; 被加数 &amp; 00,1111100 \\<br>  &amp; Res &amp; 01,0001011<br>\end{array}<br>$$</p><p>可见当最终结果两个符号位不同时, 代表出现了溢出. 其中, <strong>前侧的符号位代表结果原本的符号位</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 双符号位补码的存储方式</font></strong><br>双符号位补码在计算机中同样 <strong>只存储一个符号位</strong> , 只不过在运算时会复制一个符号位而已.</p></blockquote><h4 id="2-2-3-2-无符号数的加减运算"><a href="#2-2-3-2-无符号数的加减运算" class="headerlink" title="2.2.3.2 无符号数的加减运算"></a>2.2.3.2 无符号数的加减运算</h4><p>唠完有符号数, 无符号数就显得友好许多. 这玩意没有符号的限制, 直接加就完了.<br>但是到了减法这一块, 问题出现了: <strong>无符号数没有补码, 怎么整?</strong></p><p>要解决这个问题, 我们需要回忆一下补码的含义: 说白了就是一个数的 <strong>补数</strong> (详见2.1.3).<br>$ A-B &#x3D; A+[B]_补 $<br>明确了这一点之后, 我们的问题就转变为: <strong>怎么求减数的补数?</strong></p><p>事实上, 无符号数的补数的求法与补码的求法几乎一致, 但不需要考虑符号位了(无符号数没有符号位).<br><strong>全部位取反, 末位+1</strong> 即可.<br>这个事明白之后, 按照加法接着算就行了.</p><hr><p>无符号数的加减怎么判断溢出?</p><ul><li><strong>加法:</strong> 最高位进位为 <strong>1</strong> 时发生溢出</li><li><strong>减法:</strong> 最高位进位为 <strong>0</strong> 时发生溢出</li></ul><h4 id="2-2-3-3-补码加减运算电路"><a href="#2-2-3-3-补码加减运算电路" class="headerlink" title="2.2.3.3 补码加减运算电路"></a>2.2.3.3 补码加减运算电路</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%A1%A5%E7%A0%81%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97%E7%94%B5%E8%B7%AF.png" alt="补码加减运算电路"></p><p>我们看到右侧的 <strong>加减法控制信号Sub</strong> 同时连接到了加法器的 <strong>低位进位Cin</strong> 上, 回忆一下刚刚所提到了减法运算方式, 在传来减法后, 需要对减数所有位取反再+1变为加法. 这个电路设计就能实现这种运算方式.</p><blockquote><p><strong><font color=#fa4659>注意: 标志位CF的产生方式</font></strong><br>请读者回看2.2.1.1中加法器的无符号溢出标志位CF的产生方式. $ C_{in} \oplus C_{out} $<br>现在想一想为啥这个产生方式能够这样写出?<br>当 $ C_{in} &#x3D; 0 $ 时, 代表当前为加法, 而无符号数加法的溢出标志为 <strong>最高位进位为1</strong> ;<br>当 $ C_{in} &#x3D; 1 $ 时, 代表当前为减法, 而无符号数减法的溢出标志为 <strong>最高位进位为0</strong> ;</p><p>是不是刚好符合我们的电路设计 : )</p></blockquote><h3 id="2-2-4-乘除运算"><a href="#2-2-4-乘除运算" class="headerlink" title="2.2.4 乘除运算"></a>2.2.4 乘除运算</h3><p>基础的加减说完了, 现在说点更难的乘除. 同样的, 乘除也不会涉及到反码, 我们这里仅对原码和补码进行说明.</p><h4 id="2-2-4-1-原码的乘法运算"><a href="#2-2-4-1-原码的乘法运算" class="headerlink" title="2.2.4.1 原码的乘法运算"></a>2.2.4.1 原码的乘法运算</h4><p>我们首先得考虑一下乘法该怎么算, 列个 <strong>乘法竖式</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%89%8B%E7%AE%97%E4%B9%98%E6%B3%95%E7%AB%96%E5%BC%8F.png" alt="手算乘法竖式"></p><p>那放到二进制里, 是不是一个道理?</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B9%98%E6%B3%95%E7%AB%96%E5%BC%8F.png" alt="二进制乘法竖式"></p><p>这之后, 我们考虑一下竖式到底为什么要 <strong>错位相加</strong> ?</p><p>按照之前提过的位权来思考这个问题:</p><p>$$<br>\begin{align*}<br>  &amp; 0.1011 &#x3D; 1 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} + 1 \times 2^{-4} \\<br>  &amp; 0.1101 &#x3D; 1101 \times 2^{-4} \\<br>  &amp; 0.1011 \times 0.1101 &#x3D; (1 \times 1101 \times 2^{-8}) + (1 \times 1101 \times 2^{-6}) + (1 \times 1101 \times 2^{-5})<br>\end{align*}<br>$$</p><p>可以看到, 随着位权递增, 对应到竖式里面就是错位相加了.</p><hr><p>基本原理搞明白了, 到机器上还有些问题要考虑:</p><ul><li>数字有正负, 符号位咋办?</li><li>乘积的位数太多了, 咋处理?</li><li>每一次的乘积都要保存下来最后统一相加吗? <del>当然不可能, 那64位的俩数相乘岂不是要有64个寄存器</del></li></ul><hr><p>第一个问题的解决方式很简单, 同原码加法一样, <strong>符号位单独处理</strong> .</p><p>$$ 符号位 &#x3D; x_s \oplus y_s $$</p><blockquote><p><strong><font color=#fa4659>注意: 这里异或的含义</font></strong><br>代表着只有两数符号位不同(一正一负)时, 才会得到1(负数).</p></blockquote><p>第二个和第三个问题, 我们就要看在机器中乘法的实现方式了.</p><p>再放一遍这个图:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="运算器的基本组成"></p><p>在乘法中, 三个寄存器各有作用:</p><ul><li>ACC: 存放 <strong>乘积高位</strong></li><li>MQ: 存放 <strong>乘积低位和乘数</strong></li><li>X: 存放 <strong>被乘数</strong></li></ul><blockquote><p><strong><font color = #3490de>概念: 原码一位乘</font></strong><br>指基于原码的, 每次仅逻辑右移一位的乘法形式.<br>下述过程即原码一位乘的具体说明.</p></blockquote><p>我们以如下的例子做一个说明:</p><p>$ x_原 &#x3D; 1.1101, y_原 &#x3D; 0.1011 $</p><p><strong>(1)符号位单独运算, 得到结果的符号位, 此例中为1</strong></p><p><strong>(2)将ACC置零; 并将被乘数和乘数分别放入X和MQ中</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BF%90%E7%AE%97%E5%99%A8%E4%B9%98%E6%B3%95%E4%BE%8B_%E5%88%9D%E6%80%81.png" alt="运算器乘法例_初态"></p><blockquote><p><strong><font color=#fa4659>注意: MQ最低位</font></strong><br>上图中MQ最低位进行了加深标记, 代表着该位是参与下一次乘法的位.</p></blockquote><p><strong>(3)观察当前MQ最低位, 是1则令ACC加上被乘数, 是0则令ACC加0(加法通过ALU实现)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BF%90%E7%AE%97%E5%99%A8%E4%B9%98%E6%B3%95%E4%BE%8B_%E5%8A%A0%E8%A2%AB%E4%B9%98%E6%95%B0.png" alt="运算器乘法例_加被乘数"></p><p><strong>(4)ACC与MQ统一逻辑右移一位</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BF%90%E7%AE%97%E5%99%A8%E4%B9%98%E6%B3%95%E4%BE%8B_%E9%80%BB%E8%BE%91%E5%8F%B3%E7%A7%BB.png" alt="运算器乘法例_逻辑右移"></p><blockquote><p><strong><font color=#fa4659>注意: MQ中原先的最低位被抛弃</font></strong><br>因为原先MQ最低位的位权加和已经完毕, 因此此处可以直接将其丢弃. 将位置腾出来用于存放乘积的低位.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 部分积</font></strong><br>指计算机乘法运算中, ACC与MQ中用于存储乘积的部分.<br>就是上图中红色数字的部分.</p></blockquote><p><strong>(5)从(3)开始重复上述步骤n次(n为数值位个数), 直至乘数的数值位完全移出MQ为止</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BF%90%E7%AE%97%E5%99%A8%E4%B9%98%E6%B3%95%E4%BE%8B_%E8%BF%90%E7%AE%97%E5%AE%8C%E6%AF%95.png" alt="运算器乘法例_运算完毕"></p><p><strong>(6)增添上(1)中计算得到的符号位即可</strong></p><p>最终我们可以得到正确的结果, 其小数点隐含在符号位后方.</p><blockquote><p><strong><font color=#fa4659>注意: 整数乘法</font></strong><br>与小数乘法原理相同, 将小数点变更为分隔符号位的逗号即可.</p></blockquote><hr><p>在王道Bilibili的计算机组成原理课程中, 并未提及 <strong>原码两位乘</strong> 的移位和加减方式, 在本文中进行额外补充.</p><blockquote><p><strong><font color = #3490de>概念: 原码二位乘</font></strong><br>指基于原码的, 每次仅逻辑右移两位的乘法形式.</p></blockquote><p>原码二位乘的主要目的在于 <strong>提高计算机的运算效率</strong> , 其计算原理跟一位乘很类似.</p><p>既然名为 <strong>二位乘</strong> , 自然意味着我们 <strong>一次加法需要利用到MQ的后两位</strong> , 并在进行对应处理后 <strong>逻辑右移两位</strong> .<br>我们先给出运算中乘积高位与被乘数的加法准则, 随后再对这个准则进行解释.</p><p>$$<br>\begin{array}{}<br>  &amp; y_{i-1} \space y_i &amp; C_j &amp; 操作内容 \\<br>  &amp; 0 \space 0 &amp; 0 &amp; 原部分积右移两位, C_j &#x3D; 0 \\<br>  &amp; 0 \space 0 &amp; 1 &amp; 原部分积+X, 右移两位, C_j &#x3D; 0 \\<br>  &amp; 0 \space 1 &amp; 0 &amp; 原部分积+X, 右移两位, C_j &#x3D; 0 \\<br>  &amp; 0 \space 1 &amp; 1 &amp; 原部分积+2X, 右移两位, C_j &#x3D; 0 \\<br>  &amp; 1 \space 0 &amp; 0 &amp; 原部分积+2X, 右移两位, C_j &#x3D; 0 \\<br>  &amp; 1 \space 0 &amp; 1 &amp; 原部分积-X, 右移两位, C_j &#x3D; 1 \\<br>  &amp; 1 \space 1 &amp; 0 &amp; 原部分积-X, 右移两位, C_j &#x3D; 1 \\<br>  &amp; 1 \space 1 &amp; 1 &amp; 原部分积右移两位, C_j &#x3D; 1 \\<br>\end{array}<br>$$</p><p>对上表进行一个解释:</p><ul><li><strong>$ y_{i-1} &#x2F; y_i $</strong> : 指的是MQ的最低两位.</li><li><strong>$ C_j $</strong> : 指的是一个单独的标志位, 用于标记上一次运算时是否有 <strong>欠账</strong></li></ul><blockquote><p><strong><font color=#fa4659>注意: 欠账?</font></strong><br>$ y_{i-1} &#x2F; y_i $ 总共有四种可能: 00 &#x2F; 01 &#x2F; 10 &#x2F; 11, 对应着要加 0 &#x2F; 1 &#x2F; 2 &#x2F; 3 个被乘数X.<br>加 0 &#x2F; 1 &#x2F; 2 个被乘数都比较简单, 可以直接通过将被乘数逻辑左移来实现(左移一次相当于乘2), 唯独这个 <strong>加3个X</strong> 比较难搞.<br>因此为了加速运行, 将 <strong>加3个X</strong> 拆开来, 变成 <strong>加4个X再减1个X</strong> .<br><strong>加4个X</strong> 可以直接在 <strong>部分积右移两位后加1个X</strong> , 而 <strong>减1个X</strong> 则在当次计算中进行完毕.<br>因此这个 $ C_j $ 就代表着一个 <strong>欠账</strong> 的含义, $ C_j &#x3D; 1 $ 代表着需要在右移后多补上一个X.</p></blockquote><h4 id="2-2-4-2-补码的乘法运算"><a href="#2-2-4-2-补码的乘法运算" class="headerlink" title="2.2.4.2 补码的乘法运算"></a>2.2.4.2 补码的乘法运算</h4><p>补码的乘法运算涉及到一个新算法 <strong>Booth算法</strong> .<br>这个方法的特点在于 <strong>符号位也参与运算</strong> . 此外, MQ寄存器多出一个 <strong>辅助位</strong> 进行单独的运算辅助; 对应的ACC与X寄存器也要多一位, 一般此时利用 <strong>双符号位数据</strong> 来填充这多出来的一位.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98_Booth.png" alt="补码一位乘_Booth"></p><blockquote><p><strong><font color=#fa4659>注意: MQ辅助位的位置</font></strong><br>实际上, Booth中添加的辅助位就是原先一位乘中每次丢失的那一个乘数.</p></blockquote><p>在Booth中, 可能加上的数值有以下三种可能:</p><p>$$<br>\begin{array}{}<br>  &amp; 原MQ最低位y_i &amp; 辅助位y_{i+1} &amp; 操作内容 \\<br>  &amp; 0 &amp; 0 &amp; 部分积+[X]_补, 算数右移一位 \\<br>  &amp; 0 &amp; 1 &amp; 部分积+0, 算数右移一位 \\<br>  &amp; 1 &amp; 0 &amp; 部分积+[-X]_补, 算数右移一位 \\<br>  &amp; 1 &amp; 1 &amp; 部分积+0, 算数右移一位<br>\end{array}<br>$$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98_Booth%E4%BE%8B.png" alt="补码一位乘_Booth例"></p><blockquote><p><strong><font color=#fa4659>注意: 部分积算数右移时的补位原则</font></strong><br>这里使用的是 <strong>补码运算</strong> , 因此请格外注意部分积右移时该怎么补空缺出来的位.<br>具体而言, 补与 <strong>当前符号位</strong> 相同的数即可.</p></blockquote><hr><p>与原码相比, 补码的乘法由于 <strong>符号位也参与运算</strong> , 最后会要 <strong>额外进行一次加法</strong> , 但最后一次加法过后 <strong>无需右移</strong> .</p><h4 id="2-2-4-3-原码的除法运算"><a href="#2-2-4-3-原码的除法运算" class="headerlink" title="2.2.4.3 原码的除法运算"></a>2.2.4.3 原码的除法运算</h4><p>说完了乘, 我们来看看除.<br>还是要从最开始的那个问题谈起, 我们最开始是怎么做除法的?</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%89%8B%E7%AE%97%E9%99%A4%E6%B3%95%E7%AB%96%E5%BC%8F.png" alt="手算除法竖式"></p><p>我们此前学过的除法是这么算的, 每一次都尽可能让除数接近上一次求出的余数, 随后得出新一轮的余数.<br>能不能类比到二进制上?</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%99%A4%E6%B3%95%E7%AB%96%E5%BC%8F.png" alt="二进制除法竖式"></p><p>一个道理, 对吧, 甚至二进制的位数判断要更简单一些, 只需要判断当前位的结果是0还是1即可.</p><hr><p>好的, 现在问题简单了<del>(简单个锤子)</del> , 怎么把这种手算的思想转化为计算机的形式?</p><p>我们还得放一遍这个图:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="运算器的基本组成"></p><p>除法中, 三个寄存器同样各有作用:</p><ul><li>ACC: 放置 <strong>被除数和余数</strong></li><li>MQ: 放置 <strong>商</strong></li><li>X: 放置 <strong>除数</strong></li></ul><hr><p>下面我们给出第一种进行原码除法的方法: <strong>恢复余数法</strong></p><p><strong>(1)确定结果符号, $ Res_s &#x3D; x_s \oplus y_s $</strong></p><p><strong>(2)取被除数x, 除数y的绝对值进行计算, 分别写出: $ [x]_原, [y]_原, [y]_补, [-y]_补 $</strong></p><p><strong>(3)将 $ [x]_原 $ 放入ACC, $ [y]_原 $ 放入X, MQ置零</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BF%90%E7%AE%97%E5%99%A8%E9%99%A4%E6%B3%95%E4%BE%8B_%E5%88%9D%E6%80%81.png" alt="运算器除法例_初态"></p><blockquote><p><strong><font color=#fa4659>注意: MQ的最低位</font></strong><br>这里MQ的最低位就是我们要确定的一位商, 将其标注为了深灰色.</p></blockquote><p><strong>(4)计算机默认将MQ的最低位置1, 随后进行如下操作: $ (ACC) &#x3D; (ACC) - (X) $ , 即将ACC内的值减去除数, 再次放入ACC</strong></p><blockquote><p><strong><font color=#fa4659>注意: $ [-y]_补 $ 的作用</font></strong><br>经过前面对于减法的学习, 我们知道实际上减法就是加上对方相反数的补码, 因此这一步用到了我们(2)中写到的 $ [-y]_补 $</p></blockquote><p><strong>(5)检测当前ACC中的符号位, 如果为0则进入下一步, 如果为1则再进行 $ (ACC) &#x3D; (ACC) + (X) $ , 即将ACC内的值加上除数, 再次放入ACC, 并将MQ的最后一位改为0, 进入下一步</strong></p><blockquote><p><strong><font color=#fa4659>注意: (4)(5)之间的关系</font></strong><br>(4)的实际意义是: 计算机先假设这一位商是1, 然后计算出商为1时的结果.<br>(5)的意义在于判断(4)的假设是否正确, 如果ACC此时是正数, 代表这一位商就应该是1, 无需更改; 如果ACC此时是负数, 代表这一位商不应当是1, 因此需要将刚刚减去的除数加回来, 并将错误的商1改回商0.</p></blockquote><p><strong>(6)ACC与MQ一同逻辑左移一位, 并重复(4)-(5)的过程, 直到MQ被占满(即商的长度已经达到机器字长的情况)后, 停止过程.</strong></p><p>给出全过程的流程图:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BF%90%E7%AE%97%E5%99%A8%E9%99%A4%E6%B3%95%E4%BE%8B_%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="运算器除法例_恢复余数流程图"></p><hr><p>上面这方法已经挺好, 但我们还是想再往前走走, 因为这方法判断完还要恢复余数, 太费劲了.<br>要优化, 我们要考虑每次恢复余数之后我们干了点啥:</p><p>我们记当次被除数减去除数后的得到的数值为 <strong>$ a $</strong> , 除数为 <strong>$ b $</strong> .</p><p>$$<br>\begin{align}<br>  &amp; if(a&lt;0) &amp; \tag 0 \\<br>  &amp; (ACC) &#x3D; (a+b) &amp; 恢复余数 \tag 1 \\<br>  &amp; (ACC) &#x3D; 2(a+b)&#x3D;2a+2b &amp; 逻辑左移 \tag 2 \\<br>  &amp; (ACC) &#x3D; 2(a+b)-b &#x3D; 2a+b &amp; 再次减去余数 \tag3 \\<br>  &amp; else \space if(a&gt;0) &amp; \tag 0 \\<br>  &amp; (ACC) &#x3D; 2a &amp; 逻辑左移 \tag 1 \\<br>  &amp; (ACC) &#x3D; 2a-b &amp; 再次减去余数 \tag2<br>\end{align}<br>$$</p><p>因此我们可以直接跳过 <strong>恢复余数</strong> 这个过程, 根据减去余数的正负直接确定下一次减去余数的数值.<br>具体而言:</p><ul><li><strong>$ a&gt;0 $</strong> : 左移, 减除数</li><li><strong>$ a&lt;0 $</strong> : 左移, 加除数</li></ul><p>这种方法被我们称之为 <strong>加减交替法</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 加减交替法的最后一步</font></strong><br>最后一步因为要得出最终结果了, 因此余数的符号位应当保证与被除数的符号位相同, 因此此时还是要恢复余数的.</p></blockquote><p>我们给出加减交替法的流程图:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E8%BF%90%E7%AE%97%E5%99%A8%E9%99%A4%E6%B3%95%E4%BE%8B_%E5%8A%A0%E5%87%8F%E4%BA%A4%E6%9B%BF%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="运算器除法例_加减交替流程图"></p><hr><p>原本而言, 这里应该是有一个补码的除法的, 但是实话实说的讲, 补码除法这里笔者也没看明白, 所以不误导人了, 请有兴趣的读者自行寻找相关资料吧 : (</p><h2 id="2-3-浮点数及其相关运算"><a href="#2-3-浮点数及其相关运算" class="headerlink" title="2.3 浮点数及其相关运算"></a>2.3 浮点数及其相关运算</h2><p>好的, 定点数这一大关, 我们好说歹说算是过去了<del>(稀里糊涂的?)</del></p><p>接下来我们得来看看另一类费劲的玩意, 叫 <strong>浮点数</strong> .</p><h3 id="2-3-1-浮点数的表示"><a href="#2-3-1-浮点数的表示" class="headerlink" title="2.3.1 浮点数的表示"></a>2.3.1 浮点数的表示</h3><p>首先聊聊为啥非得整个浮点数? 当然是我们之前整的定点数有缺陷.<br>非常典型的案例即定点数的 <strong>数据表示范围被卡的很死</strong> , 它与数据长度息息相关, 但无限制的扩充数据长度又是不现实的.</p><p>我们此前在十进制中怎么表示很大的数呢? <strong>科学计数法</strong> , 对吧.<br>因此我们仿照着科学计数法的思路, 来考虑一下浮点数的设计方式:</p><p>$ 3.026 \times 10^{11} $ , 这是个用科学计数法表示的很大的数. 我们要记录的有两个部分:</p><ul><li><strong>阶码</strong> : 即上述案例中的 $ +11 $<ul><li><strong>阶符</strong> : 阶码的符号</li><li><strong>阶码的数值</strong></li></ul></li><li><strong>尾数</strong> : 即上述案例中的 $ 3.026 $<ul><li><strong>数符</strong> : 尾数的符号</li><li><strong>尾数的数值部分</strong></li></ul></li></ul><p>我们按照科学计数法的方式来理解, 可以得到这么个结论:</p><p><strong>阶码控制数据可表示的大小, 尾数控制数据可表示的精度</strong> .</p><p>在计算机中, <strong>阶码</strong> 常常是用 <strong>移码或补码</strong> 表示的定点整数; <strong>尾数</strong> 常常是用 <strong>原码或补码</strong> 表示的定点小数.</p><p>因此, 我们给出浮点数的定义:</p><p>$$ N &#x3D; r^E \times M $$</p><ul><li>r: 阶码的底, 通常为2</li><li>E: 阶码</li><li>M: 尾数</li></ul><hr><p>寻思完了浮点数的定义, 来聊一个标准化的问题, 在本处被称为 <strong>浮点数的规格化</strong> .</p><p>我们知道同一个真值, 其浮点数是可以通过多种方式来表示的:</p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>给出两个二进制的浮点数:<br>$ 0,11;0.0101 $<br>$ 0,10;0.1010 $</p><p>这俩数是不是一样?</p></blockquote><p>我们一寻思, 下面那个数应该更好一点, 因为其表示的尾数精度要更高一些对吧.<br>因此我们给出规定, <strong>尾数数值位</strong> 的最高一位应当是一个 <strong>有效值</strong> , 这样的浮点数被称为 <strong>规格化的浮点数</strong> .</p><p>而我们上面那个例子中, 将第一个浮点数转变为第二个浮点数的过程, <strong>相当于将尾数左移了一位</strong> , 因此这种情况我们称为 <strong>左规</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 左规 &#x2F; 右规</font></strong><br>左规: 指将尾数进行 <strong>算数左移</strong> , 阶码 <strong>减一</strong> .(通常用于运算后结果尾数最高位不是有效值时)<br>右规: 指将尾数进行 <strong>算数右移</strong> , 阶码 <strong>加一</strong> .(通常用于运算后结果尾数符号位不同时, 意味着产生了溢出, 这种情况下一般采取多符号位)</p></blockquote><hr><p>好的, 我们随后说说 <strong>规格化数的特点</strong> :</p><ul><li><strong>原码表示的尾数</strong> : 最高位为1<ul><li>正数<ul><li>最大值: $ 0.11…1 $</li><li>最小值: $ 0.10…0 $</li><li>表示范围: $ \frac{1}{2} \leq x \leq (1-2^{-n}) $ , n为 <strong>尾数的数值位的位数</strong></li></ul></li><li>负数<ul><li>最大值: $ 1.10…0 $</li><li>最小值: $ 1.11…1 $</li><li>表示范围: $ -(1-2^{-n}) \leq x \leq - \frac{1}{2} $</li></ul></li></ul></li><li><strong>补码表示的尾数</strong><ul><li>正数: 同原码, 最高位为1<ul><li>最大值: $ 0.11…1 $</li><li>最小值: $ 0.10…0 $</li><li>表示范围: $ \frac{1}{2} \leq x \leq (1-2^{-n}) $</li></ul></li><li>负数: 由于我们此前提过的, 补码数值位的前半部分同反码, 因此最高位为0<ul><li>最大值: $ 1.01…1 $</li><li>最小值: $ 1.00…0 $ <strong>注意这里就是-1的补码</strong></li><li>表示范围: $ -1 \leq x \leq -(\frac{1}{2} + 2^{-n}) $</li></ul></li></ul></li></ul><hr><p>规格化之后, 我们要继续往后说以下 <strong>浮点数的溢出</strong> .<br>因为即使是浮点数, 也有表示不了的范围不是?</p><p>这个情况下我们需要一并考虑阶码和尾数, 刚刚已经把尾数的范围表示完了, 那阶码就相当于在尾数的范围上乘上一个对应的权值对不?</p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>假设阶码共3位(意味着阶码的数值位只有2位, 阶码的数值范围为 $ -4 \leq x \leq 4 $ ), 以原码表示尾数:<br>该浮点数的正数表示范围区间:<br><strong>$ \frac{1}{2} \times 2^{-4} \leq x \leq (1-2^{-n}) \times 2^4 $</strong></p><p>该浮点数的负数表示范围区间:<br><strong>$ -(1-2^{-n}) \times 2^4 \leq x \leq - \frac{1}{2} \times 2^{-4} $</strong></p></blockquote><p>我们可以发现, 无论怎样, 浮点数总会在两个部分有表示不了的数字:</p><ul><li>0的左右</li><li>能表示的上限值的右侧, 下限值的左侧</li></ul><p>因此, 我们给这几个部分的溢出分别取了几个名字:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%BA%A2%E5%87%BA.png" alt="浮点数的溢出"></p><blockquote><p><strong><font color=#fa4659>注意: 溢出的解决方案</font></strong><br>通常, 下溢会被我们直接当作0处理, 而上溢则会抛出对应异常.</p></blockquote><hr><blockquote><p><strong><font color=#fa4659>注意: IEEE754 内容缺失</font></strong><br>IEEE 754是当前公认的对浮点数的计算机内存储方式, 但奈何博主实在是没捯饬明白这一部分的内容, 只得有待将来补充了. 读者见谅.</p></blockquote><h3 id="2-3-2-浮点数的加减运算"><a href="#2-3-2-浮点数的加减运算" class="headerlink" title="2.3.2 浮点数的加减运算"></a>2.3.2 浮点数的加减运算</h3><p>好了, 我们进入浮点数的运算部分, 从加减开始.</p><p>我们先明确运算的步骤:</p><ul><li><strong>对阶</strong><ul><li>将阶数表达为同一个值. 如 $ 1.2 \times 10^{10} + 1.2 \times 10^{12} $ , 那肯定是先把这俩数后面的乘阶改成一样大的之后才能算是不是.</li><li>通常原则是 <strong>小阶向大阶看齐</strong> .</li></ul></li><li><strong>尾数加减</strong><ul><li>按照此前讲述的定点数加减法进行即可.</li></ul></li><li><strong>规格化</strong><ul><li>按照此前讲述的浮点数规格化的原则进行即可.</li></ul></li><li><strong>舍入</strong><ul><li>浮点数尾数的位数是有限的, 但在对阶的过程中会出现小数过长的情况(因为变小了嘛). 因此可能会出现需要舍弃结果中的某些低位部分的情况, 这时候要决定是否要向对应的高位进1.</li></ul></li><li><strong>判断溢出</strong><ul><li>即某些情况下, 阶码的大小已经超出了浮点数阶码能够表示的范围(比如位数太多了), 此时要进行溢出处理.</li></ul></li></ul><blockquote><p><strong><font color=#fa4659>注意: 小阶向大阶看齐?</font></strong><br>读者不妨想一想如果反过来, 让大阶向小阶看齐会发生什么?<br>那上面的例子中, $ 1.2 \times 10^{12} $ 就会变成 $ 120.0 \times 10^{10} $<br>这种数的问题是小数点前面的有效位太多了, 计算机挺不好处理的, 按照此前我们商定的原则, 尾数转换时只会变小, 不会变大. 更便于计算机处理.</p></blockquote><p>由于这里大部分是之前涉及到的知识, 就不给太详细的说明了, 给出一个王道考研课中的样例供读者参考.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.2%20%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E6%B3%95%E4%BE%8B.png" alt="浮点数加法例"></p><hr><p>关于舍入方法的具体说明:</p><ul><li><strong>0舍1入</strong> : 在右移的过程中, 舍去的为0则末位不变, 舍去的为1则末位+1;</li><li><strong>恒置1法</strong> : 右移后的尾数恒置1;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> Computer Composition Principles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-计网-Chap.1</title>
      <link href="/posts/27171.html"/>
      <url>/posts/27171.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-Chap-1-计算机网络体系结构"><a href="#计算机网络-Chap-1-计算机网络体系结构" class="headerlink" title="计算机网络 Chap.1 计算机网络体系结构"></a>计算机网络 Chap.1 计算机网络体系结构</h1><blockquote><p>本系列计算机网络博文基于Bilibili王道的免费考研课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机组成原理的相关内容.</p></blockquote><h2 id="引子-为什么要考计网"><a href="#引子-为什么要考计网" class="headerlink" title="引子, 为什么要考计网?"></a>引子, 为什么要考计网?</h2><p>在开始梳理前, 稿主认为有必要明确, <strong>为什么是计网? 计网在整个计算机体系中占据了什么样的地位?</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%BC%95%E5%AD%90.png" alt="计算机体系"></p><p>这张图非常清晰的表述了关于我们会梳理的几门课程的地位. <strong>计网</strong> , 主打一个连接性, 两台物理上隔离的设备是如何做到互相通信的? 这就是我们要研究的核心问题.</p><h2 id="1-1-计算机网络概述"><a href="#1-1-计算机网络概述" class="headerlink" title="1.1 计算机网络概述"></a>1.1 计算机网络概述</h2><h3 id="1-1-1-计算机网络的概念"><a href="#1-1-1-计算机网络的概念" class="headerlink" title="1.1.1 计算机网络的概念"></a>1.1.1 计算机网络的概念</h3><p><strong>计算机网络(Computer Network)</strong> 的完整概念其实并没有一个确切的定论, 我们这里给出一种参考:</p><blockquote><p><strong><font color = #3490de>概念: 计算机网络</font></strong><br><strong>计算机网络</strong> 是一个将众多 <strong>分散的</strong> , <strong>自治的</strong> 计算机系统, 通过通信设备与线路连接起来, 由功能完善的软件实现 <strong>资源共享</strong> 和 <strong>信息传递</strong> 的系统</p></blockquote><hr><p>我们随后要明确三个名词的区别, 这三个名词非常相似, 但在计网中意义并不相同.</p><ul><li><strong>计算机网络(Computer Network)</strong> : 简称 <strong>网络</strong> , 是由若干 <strong>结点(node)</strong> 和连接这些结点的 <strong>链路(link)</strong> 组成的系统.</li></ul><blockquote><p><strong><font color = #3490de>概念: 结点</font></strong><br>计网中的结点有很多种, 包含计算机, 集线器, 交换机, 路由器等等.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 链路</font></strong><br>请读者不要被这个名词所误导, 链路可以是有线的, 亦可以是无线的.</p></blockquote><ul><li><strong>互连网(internet)</strong> : 指的是网络中存在 <strong>路由器</strong> 使两个子网能够相互连接的一个计算机网络.</li></ul><blockquote><p><strong><font color=#fa4659>注意: 路由器</font></strong><br>在计网中所说的 <strong>路由器</strong> , 与我们当前通常提及的 <strong>家用路由器</strong> 概念并不完全一致, 这是因为, 家用路由器为了保证便利性, 往往集合了 <strong>路由器</strong> 与 <strong>交换机</strong> 的功能.</p></blockquote><ul><li><strong>互联网(Internet)</strong> : 也叫 <strong>因特网</strong> , 是由各大ISP和国际机构构建的, <strong>覆盖全球范围</strong> 的互连网.</li></ul><blockquote><p><strong><font color = #3490de>概念: ISP(Internet Service Provider)</font></strong><br>ISP, 即互联网服务提供商, 下属有高级路由器将各个大型互连网进行连接. 国内典型案例有: 中国移动 &#x2F; 联通 &#x2F; 电信</p></blockquote><blockquote><p><strong><font color=#fa4659>注意: 协议差别</font></strong><br>在 <strong>互联网(Internet)</strong> 中, 使用的通信协议是有严格规定的, 必须为 <strong>TCP &#x2F; IP通信协议</strong> , 而在 <strong>互连网(internet)</strong> 中, 通信协议可以是自主协定的.</p></blockquote><h3 id="1-1-2-计算机网络的组成和功能"><a href="#1-1-2-计算机网络的组成和功能" class="headerlink" title="1.1.2 计算机网络的组成和功能"></a>1.1.2 计算机网络的组成和功能</h3><p>聊完了概念, 我们来看看计网里面到底有啥玩意.</p><p>我们先从 <strong>具体的组成部分</strong> 的角度来切入, 从组成部分看, 计算机网络可以分为三个大部分:</p><ul><li><strong>硬件</strong><ul><li><strong>主机(End System, 端系统)</strong> : 如手机, 计算机, 智能家居等. 指的是这些设备连接在网络的 <strong>末端</strong></li><li><strong>通信链路</strong> : 如网线, 光纤, 同轴电缆等</li><li><strong>通信设备</strong> : 如集线器, 交换机, 路由器等</li></ul></li><li><strong>软件</strong><ul><li>装载在主机和通信设备上, 目的是方便用户使用, 实现资源共享.</li></ul></li><li><strong>协议</strong><ul><li><strong>规定了计算机网络中的通信规则</strong></li><li>由硬件和软件共同实现</li></ul></li></ul><hr><p>从 <strong>工作方式</strong> 上来看, 计算机网络也能被分为以下两部分:</p><ul><li><strong>边缘部分</strong><ul><li>这部分的网络直接为用户服务, 主要由 <strong>主机</strong> 以及其上的软件组成.</li></ul></li><li><strong>核心部分</strong><ul><li>这部分的网络目的是为 <strong>边缘部分</strong> 提供服务, 主要由大量网络以及连接它们的路由器组成.</li></ul></li></ul><hr><p>随后, 我们了解一下计算机网络这玩意能干啥.</p><p>其实从日常生活中我们已经接触到了很多方面:</p><ul><li>数据通信</li><li>资源共享<ul><li>硬件资源</li><li>软件资源</li><li>数据资源</li></ul></li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡</li><li>…</li></ul><blockquote><p><strong><font color=#fa4659>注意: 数据通信</font></strong><br>这是计算机网络中 <strong>最基本, 最重要</strong> 的功能, 没了它, 后续所有的功能都无法实现 <del>(没了这玩意这个家得散)</del></p></blockquote><blockquote><p><strong><font color = #1fab89>例子: 分布式处理</font></strong><br>一个控制端将一个很复杂的任务分成多个小部分, 分配给处在能够连接的网络中的其余主机, 这即分布式处理的方法.</p></blockquote><blockquote><p><strong><font color = #1fab89>例子: 提高可靠性</font></strong><br>比如你的文件在某个云盘上被备份了, 显然它不应该只被存储了一份, 它应当是在这个云盘下属的多个服务器上都被存储了, 这才能保证厂商服务的可靠性. 这个备份工作就得靠计网对不?</p></blockquote><h3 id="1-1-3-计算机网络中的-交换"><a href="#1-1-3-计算机网络中的-交换" class="headerlink" title="1.1.3 计算机网络中的 交换"></a>1.1.3 计算机网络中的 <em>交换</em></h3><p>我们首先要明白, <strong>交换</strong> 到底是个啥玩意.</p><p>我们此前解释过, 在网络中的端到端通信过程中, 中途需要经过很多 <strong>结点</strong> , 这些结点能够将我们的信息根据某种规则进行传递, 并最终传递至目标端. 而所谓 <strong>交换</strong> , 指的正是这个过程.</p><blockquote><p><strong><font color = #3490de>概念: 交换</font></strong><br>网络设备(如交换机、路由器等)根据一定的规则转发数据包(或数据帧)的过程.</p></blockquote><p>了解概念后, 我们看看有哪些 <strong>交换方式</strong> :</p><ol><li><strong>电路交换</strong></li><li><strong>报文交换</strong></li><li><strong>分组交换</strong></li></ol><hr><p>所谓 <strong>电路交换</strong> , 指的是网络为通信双方分配一条 <strong>专用的</strong> 物理路径, 并且在通信过程中, 这条路径全程归通信双方所有.</p><p>其优势为 <strong>数据传输稳定; 速率高</strong> .</p><p>其劣势为 <strong>线路利用率低; 线路分配的灵活性差</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 电路交换的适用场景</font></strong><br>电路交换往往适用于 <strong>频次低, 传输量大</strong> 的数据通信. 它的方式由早期的 <strong>电话网络</strong> 发展而来.<br>但很遗憾, 在计算机网络中, 往往展现出 <strong>频次高, 传输量小</strong> 的特点. 通信请求往往是突发性的, 因此电路交换并不适用于当前的计算机网络.</p></blockquote><hr><p>捯饬 <strong>报文交换</strong> 之前, 我们得先搞明白 <strong>报文</strong> 是个啥东西.</p><blockquote><p><strong><font color = #3490de>概念: 报文(Message)</font></strong><br><strong>报文</strong> 是数据的一种封装形式, 通常表现为由以下三部分组成的一串数据: <strong>报文头(Header)</strong> , <strong>数据部分(Payload)</strong> , <strong>报文尾(Trailer)</strong> .</p><p>读者可以暂且将其理解为 <strong>带有发送方 &#x2F; 接收方地址的数据信息</strong> 即可</p></blockquote><p>所谓 <strong>报文交换</strong> , 就是网络中的结点能够根据报文中发送方 &#x2F; 接收方的信息(通常处于报文头中), 自主选择一条合适的转发路径, 并将该报文转发至接收方处.</p><p>其优势为: <strong>无需提前建立连接; 通信线路由于报文的转发策略而可以灵活分配; 线路利用率高; 支持差错控制</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 差错控制</font></strong><br><strong>差错控制</strong> 指的是信息传输过程中, 如果因为意料之外的原因导致信息发生了改变, 中间的结点能够由一些报文中附带的信息(通常处于报文头中)察觉到这一点, 甚至将报文进行修正.</p></blockquote><p>其劣势为: <strong>报文通常不定长, 存储转发的缓存开销大, 管理难度大; 长报文易出错, 重传代价高</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 报文交换的适用场景</font></strong><br>报文交换与计算机网络的适用场景非常类似, 即 <strong>频次高, 传输量小</strong> 的数据通信. 它来源于战争时期的 <strong>电报通信</strong> .<br>同时, 我们也意识到了, 报文交换的绝大多数问题都来源于 <strong>报文过长</strong> 这种可能性.</p></blockquote><hr><p><strong>分组交换</strong> 的思路与 <strong>报文交换</strong> 及其类似, 同时修正了部分报文交换的缺点.</p><p>嫌报文太长容易出错? 那我们把长报文切开就好了嘛.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8A%A5%E6%96%87%E5%88%86%E7%BB%84.png" alt="报文分组"></p><blockquote><p><strong><font color = #3490de>概念: 报文分组</font></strong><br><strong>报文分组</strong> , 指将原先很长的数据分成 <strong>定长的</strong> 多个部分, 并将每个部分单独添加上一个 <strong>首部</strong> (作用与报文交换中的首部相同).<br>由于这里对报文分组了, 因此首部中相对于原先报文中的控制信息自然就要多一块来表示这是第几个分组. 我们称作 <strong>分组号</strong> .</p></blockquote><p>这种方式中, 中间的结点(也称 <strong>分组交换机</strong> )会根据首部中的 <strong>IP地址</strong> 来判断发送的起点和终点, 并将一个个的定长分组存储转发至通信终点.</p><p>其继承了 <strong>报文交换的全部优势</strong> , 且额外改进了其劣势, 即 <strong>分组定长, 存储转发管理开销小; 出错概率低; 重传代价低</strong> .</p><p>其劣势为: <strong>与报文交换相比, 控制信息占比增加; 与电路交换相比, 存储转发时延较高; 且存在 <em>分组失序, 丢失</em> 现象</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 虚电路交换</font></strong><br>即参考了 <strong>电路交换</strong> 的思想, 在分组交换的交换方式上, 让交换双方预先进行连接, 并使后续数据传输全程处于该连接线路上.<br>需要明确的是, 这种 <strong>虚电路交换</strong> 并不存在电路交换上面的 <strong>线路独占</strong> 现象.</p></blockquote><blockquote><p><strong><font color=#fa4659>注意: 分组 Vs 虚电路?</font></strong><br>在当前的互联网中, 分组交换最终被作为最广泛应用的交换策略.<br>这得从问题的解决方来考虑, 在分组交换中, <strong>分组失序, 丢失现象的解决方是通信两端</strong> ; 而在虚电路交换中, <strong>这个问题的解决方是中间的交换结点</strong> .<br>从当前的普遍情况而言, 通信两端的处理性能通常是要高于中间结点的性能的, 因此最终选择了前者.</p></blockquote><hr><p>唠完三种交换的基础概念, 我们分析一下这哥仨的 <strong>性能</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="电路交换流程图"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="电路交换示意图"></p><p>上图的设定为: </p><ul><li>每一跳传播时延1ms</li><li>电路交换机建立 &#x2F; 释放吓一跳连接耗时1ms</li><li>接收方处理连接请求耗时2ms</li><li>数据传输速率0.5kb&#x2F;ms</li><li>报文大小4kb</li></ul><p>该流程总耗时 <strong>25ms</strong> , 如果仅看 <strong>报文传送</strong> 的过程, 则仅花费 <strong>11ms</strong> .</p><hr><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="报文交换流程图"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="报文交换示意图"></p><p>上图设定为:</p><ul><li>每一跳传播时延1ms</li><li>数据传输速率0.5kb&#x2F;ms</li><li>报文大小4kb</li><li>报文存储转发时延2ms</li></ul><p>该流程共花费 <strong>31ms</strong> .</p><hr><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="分组交换流程图"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="分组交换示意图"></p><p>上图设定为:</p><ul><li>每一跳传播时延1ms</li><li>数据传输速率0.5kb&#x2F;ms</li><li>报文大小4kb</li><li>分组大小1kb</li><li>分组存储转发时延0.5ms</li></ul><p>该流程共花费 <strong>17.5ms</strong> .</p><hr><p><strong>总结一下</strong></p><p>单从数据传输速率上讲, 其实电路交换最优, 分组其次, 报文最差. 但由于分组的扩展功能较多(如差错控制, 线路分配等此前描述的优势), 并且对于线路的利用率极高, 因此最终当前互联网采用了 <strong>分组交换为主</strong> 的方式.</p><h3 id="1-1-4-计算机网络的分类"><a href="#1-1-4-计算机网络的分类" class="headerlink" title="1.1.4 计算机网络的分类"></a>1.1.4 计算机网络的分类</h3><p>计算机网路的分布标准比较多样, 这里只给出几个比较常见的分类方式:</p><ul><li>按分布范围<ul><li><strong>广域网(WAN, Wide Area Network)</strong> : 通常跨国 &#x2F; 跨洲</li><li><strong>城域网(MAN, Metropolitan Area Network)</strong> : 一个或几个相邻城市</li><li><strong>局域网(LAN, Local Area Network)</strong> : 几十米~几千米不等, 通常是家庭 &#x2F; 公司的网络</li><li><strong>个域网(PAN &#x2F; WPAN, Personal Area Network &#x2F; Wireless Personal Area Network)</strong> : 几十米以内, 个人 &#x2F; 家庭范围的网络</li></ul></li></ul><blockquote><p><strong><font color=#fa4659>注意: 计网中的探讨对象</font></strong><br>计网中主要针对局域网与广域网进行探讨, 对其余的网络仅简单涉及.</p></blockquote><ul><li><p>按传输方式</p><ul><li><strong>广播式网络</strong> : 广播范围内的全部计算机均收到该分组, 但仅目标接收该分组</li><li><strong>点对点网络</strong> : 数据点对点发送到接收方.</li></ul></li><li><p>按拓扑结构</p><ul><li><strong>总线形结构</strong> : 通常数据以广播式传输, 存在 <strong>总线争用</strong> 问题. ( <strong>集线器</strong> )</li><li><strong>环形结构</strong> : 通常数据以广播式传输, 通过 <strong>令牌</strong> 解决总线争用问题. ( <strong>令牌环网</strong> )</li><li><strong>星形结构</strong> : 由中央设备实现数据的点对点传输, 不存在总线争用问题. ( <strong>以太网交换机</strong> )</li><li><strong>网状结构</strong> : 数据通过中间节点实现逐一存储转发, 同属点对点传输. ( <strong>众多路由器构建的广域网</strong> )</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84-%E6%80%BB%E7%BA%BF%E5%BD%A2.png" alt="拓扑结构-总线"></p><blockquote><p><strong><font color = #3490de>概念: 令牌(Token)</font></strong><br>一个环网中只有一个令牌, 网络中只有持有令牌的结点能进行数据的发送.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2.png" alt="拓扑结构-环"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84-%E6%98%9F%E5%BD%A2.png" alt="拓扑结构-星"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84-%E7%BD%91%E5%BD%A2.png" alt="拓扑结构-网"></p><ul><li><p>按使用者</p><ul><li><strong>公用网</strong> : 向公众开放的网络</li><li><strong>专用网</strong> : 仅限某个组织 (企业, 机关, 政府) 内部使用的网络</li></ul></li><li><p>按传输介质</p><ul><li><strong>有线网</strong></li><li><strong>无线网</strong></li></ul></li></ul><p>这俩没啥好说的, 过了.</p><h3 id="1-1-5-计算机网络的性能指标"><a href="#1-1-5-计算机网络的性能指标" class="headerlink" title="1.1.5 计算机网络的性能指标"></a>1.1.5 计算机网络的性能指标</h3><h4 id="1-1-5-1-速率"><a href="#1-1-5-1-速率" class="headerlink" title="1.1.5.1 速率"></a>1.1.5.1 速率</h4><p>通常而言, 某个传输介质需要对应两条 <strong>信道(Channel)</strong> , 一条用于发送数据, 一条用于接收数据. 可以将信道理解成 <strong>有方向性的传输通道</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 速率</font></strong><br>某一信道单位时间内的传输量.</p></blockquote><p>其单位有以下几种:</p><ul><li><strong>bit&#x2F;s</strong> : 也写作 <strong>b&#x2F;s</strong> 或 <strong>bps</strong></li><li><strong>Byte&#x2F;s</strong> : 也写作 <strong>B&#x2F;s</strong> .</li></ul><p>此外, 还要注意几种数量前缀:</p><ul><li>k: $ 10^3 $</li><li>M: $ 10^6 $</li><li>G: $ 10^9 $</li><li>T: $ 10^{12} $</li></ul><h4 id="1-1-5-2-带宽-Bandwidth"><a href="#1-1-5-2-带宽-Bandwidth" class="headerlink" title="1.1.5.2 带宽(Bandwidth)"></a>1.1.5.2 带宽(Bandwidth)</h4><p>某个信道所能传送的最高数据率.</p><blockquote><p><strong><font color = #fa4659>注意: 带宽</font></strong><br>在计网和通信原理中, 带宽的含义并不相同但有其关联.<br>在通信原理中, 表示某信道允许通过的信号频带范围, 单位为Hz.</p><p>这两个玩意通过香农定理和奈氏准则进行关联.</p></blockquote><h4 id="1-1-5-3-吞吐量-Throughput"><a href="#1-1-5-3-吞吐量-Throughput" class="headerlink" title="1.1.5.3 吞吐量(Throughput)"></a>1.1.5.3 吞吐量(Throughput)</h4><p>单位时间通过某个接口 &#x2F; 信道 &#x2F; 网络的数据量.</p><blockquote><p><strong><font color = #fa4659>注意: 吞吐量 Vs 速率? </font></strong><br>通常而言, 速率只针对某个单方向的信道, 但吞吐量能够针对很多的个体, 小到网线的两个方向的信道相加, 大到一整个网路的全部流量, 都可以用吞吐量描述.</p></blockquote><h4 id="1-1-5-4-时延-Delay"><a href="#1-1-5-4-时延-Delay" class="headerlink" title="1.1.5.4 时延(Delay)"></a>1.1.5.4 时延(Delay)</h4><p>指数据从通信一端至另一端所需的时间.</p><p>在计网中, 时延通常由以下四个部分组成:</p><ul><li><strong>发送时延 &#x2F; 传输时延</strong> : 节点将数据推向信道所花的时间</li><li><strong>传播时延</strong> : 数据在信道中传播一定距离所花的时间</li><li><strong>处理时延</strong> : 被路由器处理所花的时间</li><li><strong>排队时延</strong> : 数据排队进入 &#x2F; 排队发出路由器所花的时间</li></ul><p>这里需要额外注意的就是 <strong>发送时延</strong> 和 <strong>传播时延</strong> 这俩玩意, 特容易混, 也特容易考:</p><p>发送时延通常的计算公式为:</p><p><strong>$$ 发送时延(传输时延) &#x3D; \frac{数据长度(bits)}{发送速率(bit&#x2F;s)} $$</strong></p><p>传播时延的计算公式为:</p><p><strong>$$ 传播时延 &#x3D; \frac{信道长度(m)}{数据包在传输介质中的传播速度(m&#x2F;s)} $$</strong></p><p>这种题目的计算通常不会涉及排队时延和处理时延, 因为这俩玩意的长短取决于服务器和网络节点的状况, 比较复杂.</p><hr><p>需要格外注意的是, 这类题目的做法通常更加建议通过类似 <strong>1.1.3</strong> 中使用的网络通信流程图进行, 因为数据被传输上到介质上会立刻进行传输, 因此整个过程是 <strong>并行的</strong> 即同一时刻有些数据在被发送, 而有些数据在传播. 通过类似这种图能够更加清晰的理清做题时的思路:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8A%A5%E6%96%87%E4%BA%A4%E6%8D%A2%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="报文交换流程图"></p><h4 id="1-1-5-5-时延带宽积"><a href="#1-1-5-5-时延带宽积" class="headerlink" title="1.1.5.5 时延带宽积"></a>1.1.5.5 时延带宽积</h4><p>指标如其名, 时延带宽积的计算方式为:</p><p><strong>$$ 时延带宽积 &#x3D; 传播时延 \times 带宽 $$</strong></p><blockquote><p><strong><font color = #fa4659>注意: 这位置用的是传播时延 </font></strong></p></blockquote><p>其单位为: $ bit&#x2F;s \times s &#x3D; bit $</p><p>这玩意意味着什么? 我们捋一下</p><ul><li>带宽意味着信道上最大的传输速率</li><li>传播时延是一个数据从信道最发送端至接收端所需经过的时间</li></ul><p>因此, 时延带宽积意味着 <strong>一条链路中, 已从发送端发出但尚未到达接收端的最大比特数</strong> . 可以理解为一条水管能容纳的最多的水.</p><h4 id="1-1-5-6-往返时延-Round-Trip-Time-RTT"><a href="#1-1-5-6-往返时延-Round-Trip-Time-RTT" class="headerlink" title="1.1.5.6 往返时延(Round Trip Time &#x2F; RTT)"></a>1.1.5.6 往返时延(Round Trip Time &#x2F; RTT)</h4><p>表示从发送方 <strong>发送完数据</strong> , 到发送方收到来自接收方的确认信息总经历的时间.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Round-Trip%20Time.png" alt="RTT"></p><p>从上图来看, 往返时延应该为: <strong>$ t_2 + t_3 + t_4 + t_5 $</strong></p><blockquote><p><strong><font color=#ff9a00>趣闻</font></strong><br>打游戏时游戏给出的那个 <strong>延迟</strong> 其实就是这玩意.</p></blockquote><h4 id="1-1-5-7-信道利用率"><a href="#1-1-5-7-信道利用率" class="headerlink" title="1.1.5.7 信道利用率"></a>1.1.5.7 信道利用率</h4><p>与正常的计算方式相似:</p><p><strong>$$ 信道利用率 &#x3D; \frac{信道中有数据的时间}{信道被使用的总时间} $$</strong></p><blockquote><p><strong><font color = #fa4659>注意: 信道利用率的阈值 </font></strong><br>通常而言, 信道利用率不应过低, 也不应过高.<br>过低资源利用率较低, 过高则容易网络拥塞.</p></blockquote><h2 id="1-2-计算机网络的层次结构"><a href="#1-2-计算机网络的层次结构" class="headerlink" title="1.2 计算机网络的层次结构"></a>1.2 计算机网络的层次结构</h2><h3 id="1-2-1-网络的分层结构"><a href="#1-2-1-网络的分层结构" class="headerlink" title="1.2.1 网络的分层结构"></a>1.2.1 网络的分层结构</h3><p><strong>分层</strong> 是计网中非常重要的思想, 其本质上在于将一个很复杂的问题转化为了一个个小型的, 更容易解决的问题, 并在不同问题的衔接之间建立接口.</p><p>其特点在于如下两个方面:</p><ul><li>将网络在逻辑上划分为多个层次, 并将不同的功能划分至不同的层次中</li><li>不同类型的节点, 其所需要实现的层次并不相同</li></ul><p>我们先自顶向下给出网络的五个层次:</p><ul><li><strong>应用层</strong></li><li><strong>传输层</strong></li><li><strong>网络层</strong></li><li><strong>数据链路层</strong></li><li><strong>物理层</strong></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="计算机网络的分层结构"></p><blockquote><p><strong><font color = #fa4659>注意: 层次固定? 层次功能固定? </font></strong><br>分层的同时请务必注意目的. 我们的根本目的在于 <strong>合理的将计网的全部功能分配在每一层中, 使得整个体系合理且易于实现.</strong><br>因此我们需要明白, 分层不是固定的, 而层次功能也是可以在不同层之间重复的. 只要整个系统能够达成它的功能即可.</p></blockquote><p>在当前的世界上, 存在两种认可度较高的分层标准, 即 <strong>OSI参考模型</strong> 与 <strong>TCP&#x2F;IP模型</strong> . 这二者分别由 国际标准化组织 <strong>ISO</strong> 与 美国国防部阿帕网 <strong>ARPANET</strong> 所提出. 前者是更加标准化的法律标准, 而后者是现实中应用更加广泛的参考.</p><p>因此, 我们能够给出体系结构的概念了:</p><blockquote><p><strong><font color = #3490de>概念: 网络的体系结构</font></strong><br>计算机网络各层以及其实现的功能, 包括实现这个功能需要使用的协议的集合.</p></blockquote><blockquote><p><strong><font color = #fa4659>注意: 抽象的体系结构 </font></strong><br>体系结构这玩意是抽象的, 并不包括各种协议的 <strong>具体实现</strong> , 这是如何综合使用软硬件实现现有规划的问题, 并不是总体设计时需要重点考虑的方面.</p></blockquote><hr><blockquote><p><strong><font color = #3490de>概念: 对等实体 &amp; 协议</font></strong><br><strong>对等实体</strong> 指的是在计算机网路不同节点中处于同一层的实体.<br><strong>协议</strong> 事实上规定的是 <strong>对等实体</strong> 之间的通信规则.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%AE%9E%E4%BD%93%20%26%20%E5%8D%8F%E8%AE%AE.png" alt="实体 &amp; 协议"></p><blockquote><p><strong><font color = #3490de>概念: 接口 &amp; 服务</font></strong><br><strong>接口</strong> 指的是同一节点相邻层之间的调用规则.<br>相邻层通过调用对方的 <strong>接口</strong> 来访问对方所提供的 <strong>服务</strong> .</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E6%8E%A5%E5%8F%A3%20%26%20%E6%9C%8D%E5%8A%A1.png" alt="接口 &amp; 服务"></p><p>我们还需要明确一点, 就是报文首部的问题.</p><blockquote><p><strong><font color = #3490de>概念: 首部 &#x2F; 协议控制信息</font></strong><br>指的是用于说明本报文采取的协议以及对应报文的相关统计信息的一个数据部分. 通常会放在报文数据的前方, 因此称为 <strong>首部</strong> .</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/%E5%8D%8F%E8%AE%AE%E9%A6%96%E9%83%A8.png" alt="报文首部"></p><p>相关的概念有仨:</p><ul><li><strong>协议数据单元 (PDU &#x2F; Protocol Data Unit)</strong> : 说白了就是首部加上原先的数据包</li><li><strong>服务数据单元 (SDU &#x2F; Service Data Unit)</strong> : 说白了就是原先的数据包</li><li><strong>协议控制信息 (PCI &#x2F; Protocol Control Information)</strong> : 说白了就是首部</li></ul><blockquote><p><strong><font color = #fa4659>注意: 三个名词的适用对象 </font></strong><br>上面这仨玩意是针对 <strong>层</strong> 而言的, 这意味着每一层都有其对应的 PDU, SDU, PCI, 理解即可.</p></blockquote><hr><p>理解了网络的分层结构, 我们再回来看协议这个玩意本身, 可能会更好理解一些:</p><p><strong>协议的三要素</strong> 是:</p><ul><li><strong>语法</strong> : 就是首部的格式, 比如首部的哪些字节代表什么含义</li><li><strong>语义</strong> : 就是协议的使用方法, 就是使用这个协议的时候, 要发送什么数据, 该怎么应答…</li><li><strong>时序</strong> : 各种操作的时序关系, 比如收到不同的消息后应当如何应答, 何时应答</li></ul><h3 id="1-2-2-OSI参考模型"><a href="#1-2-2-OSI参考模型" class="headerlink" title="1.2.2 OSI参考模型"></a>1.2.2 OSI参考模型</h3><p>上一节中提到了两种现今广受认可的网络分层模型, 我们先从OSI七层模型说起.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="OSI参考模型"></p><p>这种模型与我们此前认知的五层模型的主要区别在于 <strong>将五层模型中的应用层拆分为另外的三层, 即应用层, 表示层, 会话层</strong> .</p><p>我们现在来探讨一下 <strong>这七层分别负责哪些功能</strong> :</p><ul><li>物理层: 实现相邻节点的比特传输<ul><li>定义电路接口特征(形状, 尺寸, 引脚数)</li><li>定义传输信号的含义(什么情况的信号表示1, 什么情况的信号表示0, 每个比特电信号持续多少秒, …)</li><li>以 <strong>比特(bit)</strong> 为单位</li></ul></li><li>数据链路层(链路层): 确保相邻节点之间的链路在逻辑上无差错<ul><li>进行 <strong>差错控制</strong> , 检错 &#x2F; 纠错 &#x2F; 丢弃 &#x2F; 重传</li><li>实现 <strong>流量控制</strong> , 协调两个节点的速率, 防止速率过大导致丢帧</li><li>以 <strong>帧(frame)</strong> 为单位</li></ul></li><li>网络层: 将数据从源结点 <strong>转发</strong> 至目的结点<ul><li>路由选择: 规划出分组转发的最佳路径</li><li>分组转发: 将分组从合适的端口转发出去</li><li>拥塞控制: 发现拥塞并尝试避免拥塞</li><li>网际互连: 实现异构网络互联, 保证不同内部构造的网络能够互联</li><li>其他功能: 包括流量控制, 差错控制, 连接建立与释放等</li><li>以 <strong>分组 &#x2F; 数据报(packet)</strong> 为单位</li></ul></li><li>传输层: 实现 <strong>端到端</strong> 通信, 即实现进程到进程的通信<ul><li>复用与分用: 目的在于实现数据从某个端口出, 就从其对应的端口入</li><li>其余通用功能: 差控, 流控…</li><li>以 <strong>报文段(segment)</strong> 为单位</li></ul></li><li>会话层: 管理进程之间的会话<ul><li>会话管理: 采用检查点机制, 保证通信失效时可以从检查点再次重传</li></ul></li><li>表示层: 解决不同主机上信息表示不一致的问题<ul><li>数据格式转换: 编码转换, 压缩解密等</li></ul></li><li>应用层: 特定的网络应用根据需求自定义<ul><li>以 <strong>报文(message)</strong> 为单位</li></ul></li></ul><blockquote><p><strong><font color = #fa4659>注意: 层级之间功能的重合 </font></strong><br>读者可能会疑惑, 有些功能为什么在很多层上都有涉及? 比如差错控制, 流量控制等等.<br>事实上, 这是因为它们针对的对象不同, 比如链路层的差错控制只能局限于 <strong>帧</strong> 这个单位, 而网络层的控制则可以针对更大的单位, 即 <strong>数据报</strong> .<br>这样相当于多加了一层保险, 同时也能够及早发现问题的出现.</p></blockquote><h3 id="1-2-3-TCP-IP模型"><a href="#1-2-3-TCP-IP模型" class="headerlink" title="1.2.3 TCP &#x2F; IP模型"></a>1.2.3 TCP &#x2F; IP模型</h3><p>TCP &#x2F; IP模型相对于OSI模型, 在分类上要简洁许多, 仅有如下四层:</p><ul><li>网络接口层<ul><li>基本对等于OSI中的物理层+数据链路层</li></ul></li><li>网络层<ul><li>对等于OSI中的网络层</li></ul></li><li>传输层<ul><li>对等于OSI中的传输层</li></ul></li><li>应用层<ul><li>对等于OSI中的会话层+表示层+应用层</li></ul></li></ul><p>在TCP &#x2F; IP模型中, 设计者认为网络的最上层(应用层), 最下层(物理层), 分别对应着与使用者 &#x2F; 硬件直接打交道的任务, 而使用者的需求繁多, 硬件的类型同样纷繁复杂, 因此这两个部分不应当做出过多的限制规定, 故将OSI模型中的规定大幅度简化, 以留给设计者更充分的创新空间.</p><p>此外, 在传输层和网络层上, 也不尽相同. 在TCP &#x2F; IP模型中, 通常只有传输层进行严格的差错控制以及流量控制. 而下层则往往仅进行数据的传输. 这是因为全局的正确一定能够推测出局部的正确, 而代价则是当出现错误时, 需要令整个报文段整体重传. 也就是说, TCP &#x2F; IP的网络层提供的是 <strong>无连接, 不可靠的服务</strong> .</p><hr><p>本章, 我们对网络的基础概念和一些结构性框架进行了较为详尽的说明, 从下一章开始, 我们将遵循我们此前说的五层结构, 一层一层的进行系统性学习.</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Computer Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专业课总复习-计组-Chap.1</title>
      <link href="/posts/63945.html"/>
      <url>/posts/63945.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理-Chap-1-计算机系统概述"><a href="#计算机组成原理-Chap-1-计算机系统概述" class="headerlink" title="计算机组成原理 Chap.1 计算机系统概述"></a>计算机组成原理 Chap.1 计算机系统概述</h1><blockquote><p>本系列计算机组成原理博文基于Bilibili王道计算机教育的免费考研课程整理而来, 目的在于系统的梳理计算机专业课的基础知识, 并为将来的面试做好充分的准备.</p><p>除本系列外, 计算机考研相关还包括数据结构 &#x2F; 操作系统 &#x2F; 计算机网络的相关内容. 会在后续时间内一一进行补足.</p></blockquote><h2 id="引子-为什么要考计组"><a href="#引子-为什么要考计组" class="headerlink" title="引子, 为什么要考计组?"></a>引子, 为什么要考计组?</h2><p>在开始梳理前, 稿主认为有必要明确, <strong>为什么是计组? 计组在整个计算机体系中占据了什么样的地位?</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E5%BC%95%E5%AD%90.png" alt="计算机体系"></p><p>课程中的这张图非常清晰的表述了关于我们会梳理的几门课程的地位. <strong>计组</strong> , 主打的就是一个基础地位, 它描述了计算机的底层硬件架构, 是计算机最基础, 最底层的原理的阐述.</p><h2 id="1-1-计算机的发展"><a href="#1-1-计算机的发展" class="headerlink" title="1.1 计算机的发展"></a>1.1 计算机的发展</h2><p>我们先明确一个概念, <strong>计算机系统</strong> . </p><p>$$ 计算机系统 &#x3D; 硬件 + 软件 $$</p><p>所谓 <strong>硬件</strong> , 就是我们所说的看得见, 摸得着的玩意, 主机, 外设之类的玩意.<br>所谓 <strong>软件</strong> , 就是我们所说的操作系统, 程序之类的东西, 它进一步被分为:</p><ul><li>系统软件: 操作系统, 数据库管理系统, 标准程序库, 语言处理程序, 服务程序(调试Debug…)等.</li><li>应用软件: 各类对接用户的, 提供更多类型的使用服务的软件.</li></ul><p>而一个 <strong>计算机系统性能的好坏</strong> , 取决于系统软硬件功能的总和.</p><hr><p>显然, 我们计组要探讨的重点不是软件, 我们把话题拉回来, 先谈谈 <strong>硬件的发展</strong>.</p><ul><li><strong>电子管</strong> 时代<ul><li>第一台 <strong>电子数字</strong> 计算机: <strong>ENIAC(1946)</strong> , 使用 <strong>电子管</strong> 作为逻辑元件</li><li>这个时代的计算机普遍 <strong>体积巨大, 耗电量巨大</strong></li></ul></li></ul><blockquote><p><strong><font color=#ff9a00>趣闻</font></strong><br>在这个时代人们普遍使用纸带进行编程, 在纸带上打孔与否来标识0 &#x2F; 1, 但这时如果有只小虫子死在你的纸带上了, 这个纸带可就毁了.</p><p>这也是为啥现在找漏洞都叫 <strong>Debug</strong> 的原因.</p></blockquote><ul><li><p><strong>晶体管</strong> 时代</p><ul><li>以 <strong>晶体管</strong> 作为逻辑元件, 相比于电子管, 体积要小得多</li><li>开始出现 <strong>面向过程的程序设计语言</strong> (FORTRAN), 开始出现 <strong>操作系统</strong></li></ul></li><li><p><strong>中小规模集成电路</strong> 时代</p><ul><li>逻辑元件越来越小, 人们开始将其集中集成在一个基片上</li><li>可靠性高得多</li><li>各种 <strong>高级语言</strong> 开始出现, 出现 <strong>分时操作系统</strong></li></ul></li><li><p><strong>大规模 &#x2F; 超大规模集成电路</strong> 时代</p><ul><li>开始出现 <strong>微处理器(CPU) &#x2F; 微型计算机</strong></li><li>个人计算机(PC)开始萌芽</li></ul></li></ul><blockquote><p><strong><font color = #3490de>概念: 制造工艺</font></strong><br>即每个晶体管在集成电路中所占宽度不超过的值. 常见的13nm, 7nm, 5nm, 3nm等都属于这个范畴.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 逻辑元件</font></strong><br>指的是计算机用来处理电信号(用于表示0 &#x2F; 1的低电平 &#x2F; 高电平)的最小的基本单元.</p></blockquote><hr><p>我们谈到了 <strong>微处理器(CPU)</strong> , 那么自然, 我们把这玩意但拉出来聊聊.</p><p><strong>Intel(英特尔, <del>牙膏厂</del> )</strong> 是此前时代中最富盛名的CPU供应商. 我们拿它推出的芯片来举例.</p><ul><li>8080<ul><li>机器字长: 8位</li></ul></li><li>8086<ul><li>机器字长: 16位</li></ul></li><li>Pentium(奔腾)<ul><li>机器字长: 64位</li></ul></li></ul><blockquote><p><strong><font color = #3490de>概念: 机器字长</font></strong><br>计算机一次整数运算能够处理的二进制位数. 自从进入奔腾处理器后, 包括后续的酷睿系列, 都保持了机器字长64位的形式.</p></blockquote><blockquote><p><strong><font color=#ff9a00>趣闻</font></strong><br>除了 <strong>Intel</strong> , 还有一家供应商叫 <strong>AMD</strong> , 而这两家企业的创始人来自于同一个公司 <strong>仙童半导体公司</strong> , 集成电路这个概念也是由这家公司捅咕出来的.</p></blockquote><hr><p><strong>摩尔定律</strong></p><p>由Intel公司创始人之一 摩尔( <strong>Gordon Moore</strong> ) 提出的经验之谈, <strong>每隔18个月, 集成电路上可容纳的晶体管数量会增加1倍</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: 摩尔定律的适用范围</font></strong><br>值得注意的是, 由于制造工艺的瓶颈, 该定律已经逐步失效. 但我们不应当忽视该定律造成的影响.</p></blockquote><h2 id="1-2-计算机系统的组成"><a href="#1-2-计算机系统的组成" class="headerlink" title="1.2 计算机系统的组成"></a>1.2 计算机系统的组成</h2><h3 id="1-2-1-计算机硬件的基本组成"><a href="#1-2-1-计算机硬件的基本组成" class="headerlink" title="1.2.1 计算机硬件的基本组成"></a>1.2.1 计算机硬件的基本组成</h3><p>谈及 <strong>计算机硬件</strong> , 就离不开一个人: <strong>冯·诺依曼(John von Neumann)</strong> .</p><p>我们要谈到的硬件结构大致可分为以下两种:</p><ul><li>冯诺依曼机</li><li>现代计算机</li></ul><p>我们上一节提到了ENIAC, 世界上第一台计算机, 事实上, 冯 诺伊曼正是这台计算机的 <strong>设计顾问</strong> .</p><p>冯 诺伊曼首先提出的问题是关于计算机执行程序方式的. ENIAC上, 计算机执行程序是需要依赖 <strong>手动接线</strong> 的, 即程序员需要根据下一步要运行的计算来手动调整计算机的线路.</p><p>冯老寻思一下这不行啊, 就提出了这么个概念: <strong>存储程序</strong> .</p><blockquote><p><strong><font color = #3490de>概念: 存储程序</font></strong><br><strong>存储程序</strong> , 指将指令以 <strong>二进制代码</strong> 的形式事先输入计算机的 <strong>主存储器</strong> , 随后按照存储地址顺序来依次执行全部指令, 直到程序执行结束.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E6%97%A9%E6%9C%9F%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA.png" alt="早期冯诺依曼机"></p><p>我们解释一下这图啥意思:</p><ul><li><strong>输入设备</strong> : 将信息转换为计算机能够识别的形式(就二进制嘛)输入</li><li><strong>运算器</strong> : 进行算术运算 &#x2F; 逻辑运算</li><li><strong>存储器</strong> : 存放数据和程序</li><li><strong>控制器</strong> : 利用电信号协调工作, 解析存储器中的指令</li><li><strong>输出设备</strong> : 将计算后的信息转换为可读形式输出</li></ul><blockquote><p><strong><font color=#fa4659>注意: 上图中箭头的区别</font></strong><br>上图中, <strong>实线箭头</strong> 表示数据线, <strong>虚线箭头</strong> 表示控制线 &#x2F; 反馈线.</p></blockquote><hr><p>总结一下冯诺依曼机的几个特点:</p><ol><li>由 <strong>5大部件</strong> 组成</li><li><strong>指令和数据</strong> 以同等地位存储在存储器中</li><li>指令和数据用 <strong>二进制</strong> 表示</li><li>指令由 <strong>操作码</strong> 和 <strong>地址码</strong> 构成</li><li>运用了 <strong>存储程序</strong> 的设计思想</li><li>以 <strong>运算器</strong> 为中心( <strong>任何数据的传送一定会通过运算器完成</strong> )</li></ol><hr><p>问题这就出来了, <strong>运算器</strong> 这玩意本来是负责算数的, 数据传送这种活不应该派给它是不.</p><p>后面人寻思寻思, 把冯诺依曼机改吧改吧, 衍生出了 <strong>现代计算机的结构</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="现代计算机"></p><p>现代计算机的结构特点有以下几点:</p><ul><li><strong>以存储器为中心</strong> (这回运算器不用干数据传送这累活了)</li><li>由于 <strong>运算器</strong> 与 <strong>控制器</strong> 的紧密相关, 因此现代设计工艺中, 通常运算器与控制器在同一个芯片上, 我们称之为 <strong>CPU</strong></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%28CPU%29.png" alt="现代计算机(CPU)"></p><blockquote><p><strong><font color=#fa4659>注意: 主机的概念</font></strong><br><strong><font color = #3490de>概念: 主机</font></strong><br>在计组中, <strong>主机</strong> 指的是CPU(运算器+控制器)与 <strong>主存储器</strong> 的合称. 我们所说的 <strong>内存</strong> 即属于主存之类. 而我们通常说的 <strong>磁盘, 固态</strong> , 属于 <strong>辅助存储器(辅存)</strong> , 它应当被归类于 <strong>I&#x2F;O设备</strong> , 并不在主机之列.</p></blockquote><h3 id="1-2-2-计算机各硬件的工作原理"><a href="#1-2-2-计算机各硬件的工作原理" class="headerlink" title="1.2.2 计算机各硬件的工作原理"></a>1.2.2 计算机各硬件的工作原理</h3><p>看完了组成, 我们自然要来看看原理. 既然现代计算机以存储器为中心, 我们不妨从主存开始.</p><h4 id="1-2-2-1-主存储器"><a href="#1-2-2-1-主存储器" class="headerlink" title="1.2.2.1 主存储器"></a>1.2.2.1 主存储器</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="主存储器的基本组成"></p><p>主存储器由以下三个主要部分:</p><ul><li>存储体</li><li>MAR</li><li>MDR</li></ul><blockquote><p><strong><font color = #3490de>概念: MAR(Memory Access register, 地址寄存器)</font></strong><br>存放和地址相关的二进制数据.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: MDR(Memory Data register, 数据寄存器)</font></strong><br>存放和数据相关的二进制数据</p></blockquote><p>CPU <strong>读出数据</strong> 的过程如下:</p><ol><li>CPU将数据所在地址写入MAR</li><li>主存储器根据MAR中的地址在存储体中找到数据, 将该数据写入MDR</li><li>CPU从MDR中读出该数据</li></ol><p>CPU <strong>写入数据</strong> 的过程与之类似:</p><ol><li>CPU将要写入的数据写入MDR, 将要写入的位置写入MAR</li><li>通过控制总线向主存发出写指令</li><li>主存将MDR中的数据存入MAR指向的地址中</li></ol><hr><p>好, 我们转回头来, 看主存储器中最主要的部分: <strong>存储体</strong> .</p><p>数据在存储体内是要按 <strong>地址</strong> 来进行存储的, 这样的好处不言自明, 写入 &#x2F; 读出数据时, 能够很清晰的通过地址得到具体数据.</p><p><strong>地址</strong> 在存储体中的具体体现即 <strong>存储单元</strong> . 一个存储单元能够存储一串二进制代码.</p><blockquote><p><strong><font color = #3490de>概念: 存储字(word)</font></strong><br>1个存储单元中存放的数据被称为1个存储字.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 存储字长</font></strong><br>一个存储字的位数. 在现代计算机系统中, 通常是 8bit(8比特) 的整数倍.</p></blockquote><p>有了这些概念, 编址就很容易理解了. <strong>每个存储字对应一个地址</strong> , 从0开始. CPU将地址号写入MAR, 读出 &#x2F; 写入对应的字即可.</p><hr><p>有了如上关系, 我们来深究一下一个很重要的公式:</p><p>显然, MAR这个寄存器的位数与存储单元的个数直接挂钩. MDR的位数应当与计算机的存储字长相等.</p><p>我们好像能通过MAR和MDR的位数来算出其主存储器中存储体的大小!</p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>4位MAR, 16位MDR.<br>意味着该存储体有 $ 2^4 $ 个存储单元, 单个存储单元的长度为 $ 16 $ .<br>存储体大小: $ 2^4 \ast 16 &#x3D; 2^8 &#x3D; 256bit $</p></blockquote><blockquote><p><strong><font color=#fa4659>注意: 字与字节</font></strong><br><strong>一个字(word)</strong> 有多少位是根据计算机本身的结构而决定的, 而 <strong>一个字节(Byte)</strong> 的长度固定, 是8bit.</p></blockquote><h4 id="1-2-2-2-运算器"><a href="#1-2-2-2-运算器" class="headerlink" title="1.2.2.2 运算器"></a>1.2.2.2 运算器</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="运算器的基本组成"></p><p>运算器最主要的部件如下:</p><ul><li><strong>ACC(Accumulator, 累加器)</strong> : 用于存放操作数或运算结果</li><li><strong>MQ(Multiple-Quotient Register, 乘商寄存器)</strong> : 在乘除运算时, 用于存放操作数或运算结果</li><li><strong>X(通用寄存器)</strong> : 用于存放操作数</li><li><strong>ALU(Arithmetic and Logic Unit, 算术逻辑单元)</strong> : 通过内部逻辑电路来实现算数运算和逻辑运算</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%BF%90%E7%AE%97%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="运算器中的寄存器"></p><h4 id="1-2-2-3-控制器"><a href="#1-2-2-3-控制器" class="headerlink" title="1.2.2.3 控制器"></a>1.2.2.3 控制器</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="控制器的基本组成"></p><p>控制器中的主要部件如下:</p><ul><li><strong>CU(Control Unit, 控制单元)</strong> : 分析指令, 给出控制信号</li><li><strong>IR(Instruction Register, 指令寄存器)</strong> : 存放当前要执行的指令</li><li><strong>PC(Program Counter, 程序计数器)</strong> : 存放下一条指令的地址, 实际执行中可以自动+1</li></ul><p>设计这三个部件的原因, 与当前时代中控制单元执行指令的流程有关:</p><ol><li>取指令(PC的活)</li><li>分析指令(IR要把指令暂存进来)</li><li>执行指令(CU的活)</li></ol><blockquote><p><strong><font color=#fa4659>注意: 指令周期</font></strong><br>计算机的指令执行远不止这么简单, 这里权为读者留个大致印象, 后续的篇章中会有专门的指令周期说明.</p></blockquote><hr><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://major-course-1310677143.cos.ap-guangzhou.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/Chap.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%28%E5%85%A8%29.png" alt="计算机的基本组成(全)"></p><p>我们这里把这张图放在这里当作总结, 希望读者能够再次回顾前面的知识.</p><blockquote><p><strong><font color=#fa4659>注意: MAR &#x2F; MDR的位置</font></strong><br>由于MAR与MDR与CPU交互的情况过于频繁, 当前制造工艺中常常将这两个本应属于主存的寄存器集成在CPU上, 在此作为补充知识进行说明.</p></blockquote><h3 id="1-2-3-计算机软件"><a href="#1-2-3-计算机软件" class="headerlink" title="1.2.3 计算机软件"></a>1.2.3 计算机软件</h3><p>其实这部分不应该塞到计组里面来说的, 但是为了我们知识的系统性, 还是大致提一嘴.</p><p>我们上面提过关于 <strong>软件的分类</strong> , 即 <strong>系统软件</strong> 以及 <strong>应用软件</strong> . 这里就不再详述了.</p><blockquote><p><strong><font color=#fa4659>注意: 软件的分类</font></strong><br>该部分内容请见1.1</p></blockquote><p>我们现在需要更进一步, 了解一下这些软件是怎么编出来, 又是怎么被运行的.</p><p>当前的计算机语言由高至低可分为:</p><ul><li><strong>高级语言</strong> : C&#x2F;C++, Java, Python</li><li><strong>汇编语言</strong> : 主要表现为助记符的形式</li><li><strong>机器语言</strong> : 即计算机能够直接执行的二进制代码</li></ul><p>通常的软件编写过程, 需要用户利用高级语言编写源程序, 随后经过 <strong>编译程序(编译器)</strong> 转译为汇编语言, 最后经过 <strong>汇编程序(汇编器)</strong> 翻译为机器语言.</p><blockquote><p><strong><font color=#fa4659>注意: 语言的翻译过程</font></strong><br>上述过程是典型的高级语言运行流程, 如C&#x2F;C++; 但随着不同高级语言的发展, 有些高级语言语言能够跳过第一步, 直接通过编译程序将高级语言翻译为机器语言; 还有些高级语言(JavaScript, Python, Shell, 我们也称之为 <strong>脚本语言</strong> )是通过 <strong>解释程序(解释器)</strong> 边执行边解释代码来运行的.</p><p>举例而言, 我们通过C&#x2F;C++写的程序可以直接编译为一个exe文件, 随后这个文件可以直接单独运行而无需任何环境. 但通过脚本语言写的程序则在每一次运行时都需要重新将代码翻译一遍.</p></blockquote><p>我们聊这些, 主要是为了让读者明白, <strong>软件和硬件在逻辑功能上是等价的</strong> . 通常而言, 硬件的 <strong>性能高 &#x2F; 成本高</strong> ; 软件的 <strong>性能低 &#x2F; 成本低</strong> .</p><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>同样实现 <strong>乘法</strong> 这一效果, 我们可以使用硬件单独提供的乘法电路 , 异或直接通过循环相加这种软件的方式. 二者所达成的效果是相同的, 但是在运行效率和设计成本上有显著的差异.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 指令集体系结构(ISA)</font></strong><br><strong>指令集体系结构</strong> , 英文名称 <strong>Instruction Set Architecture</strong> , 是软件与硬件之间的接口, 它定义了一台计算机的硬件实现了哪些指令, 以及每条指令应当如何使用.</p></blockquote><h3 id="1-2-4-计算机系统的层次结构"><a href="#1-2-4-计算机系统的层次结构" class="headerlink" title="1.2.4 计算机系统的层次结构"></a>1.2.4 计算机系统的层次结构</h3><p>本节中的层次结构与上一小节中的计算机语言几乎可以说是层层对应. 我们仍然按照从高到低的结构来聊:</p><ul><li><strong>虚拟机器 M4(高级语言机器)</strong></li><li><strong>虚拟机器 M3(汇编语言机器)</strong></li><li><strong>虚拟机器 M2(操作系统机器)</strong></li><li><strong>传统机器 M1(机器语言机器)</strong></li><li><strong>微程序机器 M0(微指令系统)</strong></li></ul><p>我们能看到有3个层级与我们上面的语言划分完全一一对应, 但多出来这俩玩意 <strong>操作系统机器</strong> 和 <strong>微程序机器</strong> 是个什么玩意?</p><p>操作系统机器泛泛而言可以解释为是系统提供给上层的 <strong>系统调用(System Call)</strong> , 相当于操作系统在机器语言上单独翻译了一层, 上层无需考虑复杂的机器码, 只需要调用操作系统提供的功能即可.</p><blockquote><p><strong><font color = #3490de>概念: 微指令</font></strong><br>实际上, 就是将原先一条条的机器指令再度拆分为一条条功能更加细化, 在系统内设定好的指令, 我们称之为 <strong>微指令</strong> .</p></blockquote><blockquote><p><strong><font color = #1fab89>例子</font></strong><br>举例而言, 我们要将 <strong>变量y加1</strong> , 我们应该首先将 <strong>变量y放入运算器的某个寄存器中</strong> , 随后 <strong>运算器进行运算, 将结果储存在某个寄存器中</strong> , <strong>再将这个结果存回原先y的地址</strong> . 着一条条更为细分的指令就是微指令.</p></blockquote><p>我们需要明确, 从 <strong>M2~M4</strong> 是我们所说 <strong>软件</strong> 的部分, 而 <strong>硬件</strong> 部分则是下层的 <strong>M0~M1</strong> .</p><p>显然, 我们在计组中, 要重点关注下面这两层.</p><h2 id="1-3-计算机性能指标"><a href="#1-3-计算机性能指标" class="headerlink" title="1.3 计算机性能指标"></a>1.3 计算机性能指标</h2><p>我们聊完了硬件的组成部分, 自然要聊聊该怎么判断这玩意好不好.</p><h3 id="1-3-1-存储器的性能指标"><a href="#1-3-1-存储器的性能指标" class="headerlink" title="1.3.1 存储器的性能指标"></a>1.3.1 存储器的性能指标</h3><p>谈到存储器, 有个我们避不开的指标: <strong>容量</strong> . 自然, 越大越好.</p><blockquote><p><strong><font color=#fa4659>注意: 存储器容量的计算</font></strong><br>见1.2.2.1中的内容.</p></blockquote><h3 id="1-3-2-CPU的性能指标"><a href="#1-3-2-CPU的性能指标" class="headerlink" title="1.3.2 CPU的性能指标"></a>1.3.2 CPU的性能指标</h3><p>CPU中比较重要的指标是 <strong>主频</strong> . 谈及这个, 我们还得说一下 <strong>CPU的时钟周期</strong> 这个概念.</p><blockquote><p><strong><font color = #3490de>概念: CPU的主频</font></strong><br>指的是CPU内部数字脉冲信号震荡的频率.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: CPU的时钟周期</font></strong><br>指的是CPU内完成一次信号震荡所用的时间.</p></blockquote><p>$$ CPU主频 &#x3D; \frac{1}{CPU时钟周期} $$</p><p>我们之前所说的 <strong>微指令</strong> 是要严格遵循CPU的时钟周期的, 即一条微指令必须在一个 &#x2F; 或几个CPU的时钟周期内完成. 因此 <strong>CPU主频越高, 通常也意味着CPU越快</strong> .</p><blockquote><p><strong><font color=#fa4659>注意: CPU速度的影响因素</font></strong><br><strong><font color = #3490de>概念: CPI</font></strong><br>凡事无绝对, CPU的速度也受到 <strong>CPI(Clock cycle Per Instruction)</strong> 即执行一条指令所需的时钟周期数. 显然, 这个周期数越小越好, 通常是个平均值.</p></blockquote><p>我们得到CPI, 可以得到 <strong>执行一条指令的平均耗时</strong> .</p><p>$$ 执行一条指令的平均耗时 &#x3D; CPI \ast CPU时钟周期 $$</p><p>除了上面提到的指标, 还有些花里胡哨的玩意, 在这都列举一下:</p><blockquote><p><strong><font color = #3490de>概念: IPS</font></strong><br><strong>IPS(Instruction Per Second)</strong> , 即每秒执行多少条指令, 同样通常是个平均值.</p></blockquote><p>$$ IPS &#x3D; \frac{主频}{平均CPI} $$</p><blockquote><p><strong><font color = #3490de>概念: FLOPS</font></strong><br><strong>FLOPS(Floting-point Operations Per Second)</strong> , 即每秒执行多少次浮点运算.</p></blockquote><h3 id="1-3-3-系统整体性能指标"><a href="#1-3-3-系统整体性能指标" class="headerlink" title="1.3.3 系统整体性能指标"></a>1.3.3 系统整体性能指标</h3><p>不整什么花里胡哨的了, 直接写了.</p><blockquote><p><strong><font color = #3490de>概念: 数据通路带宽</font></strong><br>数据总线一次能够并行传送信息的位数.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 吞吐量</font></strong><br>系统在单位时间内处理请求的数量.</p></blockquote><blockquote><p><strong><font color = #3490de>概念: 响应时间</font></strong><br>用户向计算机发送请求到系统对该请求做出相应并获得所需结果的等待时间.</p></blockquote><hr><p>本章主要是对计算机的系统进行了一定概述. 主要目标在于让读者大致明确 &#x2F; 了解 <strong>计组在搞些什么玩意. 能学到些什么知识</strong> .</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
          <category> 计算机专业课总复习篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> Computer Composition Principles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating-System-Chap.8</title>
      <link href="/posts/38482.html"/>
      <url>/posts/38482.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-8-死锁"><a href="#操作系统-Chap-8-死锁" class="headerlink" title="操作系统 Chap.8 死锁"></a>操作系统 Chap.8 死锁</h1><p>回忆一下前两篇文章, 我们提及了几种操作系统用于同步的机制:</p><ul><li>互斥锁</li><li>信号量</li><li>条件变量</li></ul><p>并且通过这一系列机制, 能够实现很多在操作系统中非常常用的操作.</p><p>但我们同时留下了一些小尾巴没有解决, 比如本文的 <strong>死锁(Deadlock)</strong> 问题.</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>啥是死锁呢?</p><p><em>A set of processes is deadlocked when each process in the set is blocked awaiting an event that can only be triggered by another blocked process in the set.</em><br><em>一个进程的集合出现这么一种情况, 它们之中每一个进程都在等待另一个进程的某个事件, 但此时另一个进程也处于阻塞状态, 这就是死锁.</em></p><p>我们在Chap.6中曾经提及了一个很简单的例子, 这里我们附在下方:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">P0<span class="token operator">:</span> <span class="token comment">//Process 0</span><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>P1<span class="token operator">:</span> <span class="token comment">//Process 1</span><span class="token function">wait</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然, 这俩进程哪个都无法往下进行.</p><p>我们给一个死锁出现的形象案例:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="/./Operation-System-Chap-8/Protential%20Deadlock.png" alt="Protential Deadlock"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="/./Operation-System-Chap-8/Actual%20Deadlock.png" alt="Actual Deadlock"></p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operation-System-Chap.7</title>
      <link href="/posts/1050.html"/>
      <url>/posts/1050.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-7-信号量的应用"><a href="#操作系统-Chap-7-信号量的应用" class="headerlink" title="操作系统 Chap.7 信号量的应用"></a>操作系统 Chap.7 信号量的应用</h1><h2 id="1-前文回顾"><a href="#1-前文回顾" class="headerlink" title="1. 前文回顾"></a>1. 前文回顾</h2><blockquote><p>本部分针对信号量的说明在 <a href="https://mug-chen.site/posts/50395.html">Operating System Chap.6 同步机制</a> 中有较为详尽的讲解, 本处仅为简单回顾.</p></blockquote><p>我们在前文中提及了 <strong>信号量(Semaphore)</strong> 这一重要概念. 它分为以下两类:</p><ul><li>二元信号量(Binary Semaphore)</li><li>计数信号量(Counting Semaphore)</li></ul><p>此外, 信号量自带的队列机制使得其能够抛却传统互斥锁的忙等机制, 利用系统的阻塞 &#x2F; 中断机制解决关键区域的问题.</p><h2 id="2-引入"><a href="#2-引入" class="headerlink" title="2. 引入"></a>2. 引入</h2><p>我们从两种问题谈起:</p><h3 id="2-1-The-Restroom-Problem"><a href="#2-1-The-Restroom-Problem" class="headerlink" title="2.1 The Restroom Problem"></a>2.1 The Restroom Problem</h3><p>此即 <strong>公共卫生间问题</strong> <del>(有点粗俗哈)</del> , 其问题假设如下:<br><em>Given a single-spot restroom, write the function for using the restroom</em><br><em>一个厕所就一个隔间, 写一个该隔间的使用算法.</em></p><p>这其实就是我们上一章节中提及的关键区域的具象化. 我们已经利用信号量解决了这个问题, 用一个二元信号量, 做一个互斥锁即可.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Semaphore  S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// shared among customers (processes)</span><span class="token function">use_restroom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// try to enter the restroom; = lock()</span>Use the restroom <span class="token comment">//critical section</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// leave the restroom; = unlock()</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-The-Bar-Problem"><a href="#2-2-The-Bar-Problem" class="headerlink" title="2.2 The Bar Problem"></a>2.2 The Bar Problem</h3><p>此即 <strong>酒吧问题</strong> , 其问题假设如下:<br><em>Capacity &#x3D; 100</em><br><em>Many customers try to enter the bar concurrently</em><br><em>Please write code to make sure customers&lt;&#x3D;100</em></p><p><em>哎, 问题不一样了, 现在有100个位子, 要保证进入酒吧的人能够始终小于等于100个, 写一个算法.</em></p><p>这时候上文的二元信号量 &#x2F; 亦或互斥锁, 就不是很好用了, 它只能保证对某个资源的互斥利用, 但对于这种大量资源的管理问题, 并不是它的专项.</p><h2 id="3-信号量的使用"><a href="#3-信号量的使用" class="headerlink" title="3. 信号量的使用"></a>3. 信号量的使用</h2><p>我们有问题了, 现在进入本文的正题, 信号量的多种适用场景.</p><h3 id="3-1-确保执行顺序-Enforcing-Orders"><a href="#3-1-确保执行顺序-Enforcing-Orders" class="headerlink" title="3.1 确保执行顺序(Enforcing Orders)"></a>3.1 确保执行顺序(Enforcing Orders)</h3><p>在这里, 我们给两个例子:</p><p>Process 0: Statment A;<br>Process 1: Statment B;</p><p>如何保证语句A在语句B之前执行?</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Semaphore S <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//Shared</span><span class="token comment">//Process 0</span>A<span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Process 1</span><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>B<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>复杂一点?</p><ul><li>Process 0:<ul><li>Statment A1;</li><li>Statment A2;</li></ul></li><li>Process 1:<ul><li>Statment B1;</li><li>Statment B2;</li></ul></li></ul><p>确保执行顺序: A1 -&gt; B1 -&gt; B2 -&gt; A2</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Semaphore S1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>Semaphore S2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//Process 0</span>A1<span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>S1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span>S2<span class="token punctuation">)</span><span class="token punctuation">;</span>A2<span class="token punctuation">;</span><span class="token comment">//Process 1</span><span class="token function">wait</span><span class="token punctuation">(</span>S1<span class="token punctuation">)</span><span class="token punctuation">;</span>B1<span class="token punctuation">;</span>B2<span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>S2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过多个信号量的组合使用, 能够实现不同进程中不同语句的顺序执行.</p><h3 id="3-2-消费者问题-Producer-Customer-Problem"><a href="#3-2-消费者问题-Producer-Customer-Problem" class="headerlink" title="3.2 消费者问题(Producer - Customer Problem)"></a>3.2 消费者问题(Producer - Customer Problem)</h3><p>考虑本章中最重要的主题, <strong>消费者问题</strong> .</p><p><em>One slot; multi Producers keep producing items, while multi Consumers keep consumes items</em><br>我们线考虑比较简单的情况, 一个槽位, 多个生产者在生产, 而多个消费者也在消耗, 怎么控制?</p><p>我们将问题拆分一下, 就能想明白这个问题:</p><ul><li>对于生产者, 它要干啥? 一直生产, 直到槽位被占满, 阻塞.<ul><li>fillSlot();</li></ul></li><li>对于消费者, 它要干啥? 清空槽位上的物品, 直到槽位空, 阻塞.<ul><li>removeItem();</li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Semaphore S_slot <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>Semaphore S_item <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//Producer</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">wait</span><span class="token punctuation">(</span>S_slot<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fillSlot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">signal</span><span class="token punctuation">(</span>S_item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Customer</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">wait</span><span class="token punctuation">(</span>S_item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">signal</span><span class="token punctuation">(</span>S_slot<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>好的, 现在问题更复杂了, 多个槽呢?</p><p>这被称为 <strong>Multi-slot Producer-Customer Problem</strong> . 是个挺重要的问题.</p><p>由于槽位变多了, 显然需要一个新的数据结构进行对多槽位的表达:<br>最合适的数据结构是一个环状结构, 首尾相接.(循环链表)</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-7/Multi-slot.png" alt="Multi-slot"></p><p>现在我们把多槽表示出来, 生产者和消费者要干的事情就跟之前没有区别了.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Producer</span><span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>slots<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">[</span>pi<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">;</span>pi <span class="token operator">=</span> <span class="token punctuation">(</span>pi <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Customer</span><span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>result <span class="token operator">=</span> buffer<span class="token punctuation">[</span>ci<span class="token punctuation">]</span><span class="token punctuation">;</span>ci <span class="token operator">=</span> <span class="token punctuation">(</span>ci <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">;</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>slots<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正规一点的代码如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">monitor ProducerConsumercondition cv_full<span class="token punctuation">,</span> cv_cempty<span class="token punctuation">;</span><span class="token keyword">int</span> count<span class="token punctuation">;</span>procedure <span class="token function">produce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token punctuation">)</span>   <span class="token function">wait</span><span class="token punctuation">(</span>cv_full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// if buffer is full, block</span><span class="token function">put_item</span><span class="token punctuation">(</span>widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// put item in buffer</span>count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// increment count of full slots</span><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">signal</span><span class="token punctuation">(</span>cv_empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// if buffer was empty, wake consumer</span><span class="token punctuation">&#125;</span>procedure <span class="token function">consume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token function">wait</span><span class="token punctuation">(</span>cv_empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// if buffer is empty, block</span><span class="token function">remove_item</span><span class="token punctuation">(</span>widget<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// remove item from buffer</span>count <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// decrement count of full slots</span><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">signal</span><span class="token punctuation">(</span>cv_full<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// if buffer was full, wake producer</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-Barrier-Problem"><a href="#3-3-Barrier-Problem" class="headerlink" title="3.3 Barrier Problem"></a>3.3 Barrier Problem</h3><p>亦称 <strong>栅栏问题</strong> . </p><p><em>Goal: given a number, N, of processes, each process has to wait at some point of its program until all processes reach the point</em><br>给N个进程, 每个进程在某一点, 必须等待, 直到其他所有的进程都运行到这个点为止.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">n <span class="token operator">=</span> the number of threadscount <span class="token operator">=</span> <span class="token number">0</span>mutex <span class="token operator">=</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>barrier <span class="token operator">=</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">Barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token comment">//Operations to shared data</span>count <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> n<span class="token punctuation">)</span>  <span class="token keyword">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>      <span class="token function">signal</span><span class="token punctuation">(</span>barriar<span class="token punctuation">)</span><span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token function">wait</span><span class="token punctuation">(</span>barriar<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一种解决方案如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">n <span class="token operator">=</span> the number of threadscount <span class="token operator">=</span> <span class="token number">0</span>mutex <span class="token operator">=</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>barrier <span class="token operator">=</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token function">Barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span>    count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token keyword">if</span> count <span class="token operator">==</span> n<span class="token operator">:</span>   <span class="token function">signal</span><span class="token punctuation">(</span>barrier<span class="token punctuation">)</span><span class="token function">wait</span><span class="token punctuation">(</span>barrier<span class="token punctuation">)</span><span class="token function">signal</span><span class="token punctuation">(</span>barrier<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>考虑一下, 这种方案中, 有没有可能两个进程运行到if语句, 都发现count &#x3D;&#x3D; n?</p><p>这种情况是可能的, 但事实上, 多出的一次signal操作不会引起任何bug, 因为这代表着两个进程都临近停止点.<br>如果实在看不惯这种事情的发生, 可以将if语句放入mutex的管理区域.</p></blockquote><h3 id="3-4-Writer-Reader-Problem"><a href="#3-4-Writer-Reader-Problem" class="headerlink" title="3.4 Writer-Reader Problem"></a>3.4 Writer-Reader Problem</h3><p>即 <strong>一写多读问题</strong> , 这事在操作系统中可太常见了对吧.</p><ul><li>读线程只读</li><li>写线程会编辑</li><li>写进程必须对对象占有独占访问权, 即写的时候不能读</li><li>读进程没有个数限制</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Shared</span><span class="token keyword">int</span> readcnt<span class="token punctuation">;</span> <span class="token comment">/* Initially = 0 */</span>semaphore r<span class="token punctuation">,</span> whole<span class="token punctuation">;</span> <span class="token comment">/* Initially = 1 */</span><span class="token comment">//Writers</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>whole<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Critical section */</span>    <span class="token comment">/* Writing here */</span>    <span class="token function">signal</span><span class="token punctuation">(</span>whole<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//Readers</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/*Increment readcnt*/</span>    <span class="token function">wait</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*Only one reader a time*/</span>    readcnt<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>readcnt <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">/* First reader in */</span>      <span class="token function">wait</span><span class="token punctuation">(</span>whole<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Lock out writers */</span>    <span class="token function">signal</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Read; mutliple readers may be here */</span>    <span class="token function">wait</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    readcnt<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>readcnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">/* Last out */</span>      <span class="token function">signal</span><span class="token punctuation">(</span>whole<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Let in writers */</span>    <span class="token function">signal</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请务必重视上方这段代码, 它很重要.</p><p>作出一些解释:</p><ul><li>写进程:<ul><li>进入前确保所有读者已经退出读区域</li><li>退出后通知所有读者可以进入</li></ul></li><li>读进程:<ul><li>第一个进入的进程必须确保写进程没有在操作数据</li><li>最后一个退出的进程必须通知写进程可以操作数据了</li></ul></li></ul><hr><p>至此, 对于信号量的应用差不多说完了.</p><p>本篇博文是对上一篇博文, 同步方式的一个补充章, 主要是一些现实中会遇到的问题.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operation-System-Chap.6</title>
      <link href="/posts/50395.html"/>
      <url>/posts/50395.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-6-同步机制"><a href="#操作系统-Chap-6-同步机制" class="headerlink" title="操作系统 Chap.6 同步机制"></a>操作系统 Chap.6 同步机制</h1><h2 id="1-竞争条件-Race-Condition"><a href="#1-竞争条件-Race-Condition" class="headerlink" title="1. 竞争条件(Race Condition)"></a>1. 竞争条件(Race Condition)</h2><h3 id="1-1-啥时候出现"><a href="#1-1-啥时候出现" class="headerlink" title="1.1 啥时候出现?"></a>1.1 啥时候出现?</h3><p><strong>竞争条件(Race Condition)</strong> 指的是当多个线程 &#x2F; 进程针对某个共享变量几乎同时进行操作时, 会出现的问题.</p><p>很显然, 某个进程在执行时, 可能会由于某种原因被暂停, 从而并未完成整个任务. 当涉及到某个共享变量时, 如果缺少对应的同步机制, 就会出现数据冲突 &#x2F; 不一致的问题.</p><hr><p>考虑一个具体的例子:</p><p>假设有个共享变量c, 现在又两个进程都对其进行++c的操作;<br>在系统中, 这一步指令分三步:</p><ul><li>movl c, %eax &#x2F;&#x2F; 把c的值放入eax寄存器</li><li>addl $1, %eax &#x2F;&#x2F; eax寄存器增加1</li><li>movl %eax, c &#x2F;&#x2F; 把eax寄存器的值再复制回c</li></ul><p>我们假设, 进程1执行++c, 执行完第二步后被强行移除了运行队列(由于时间片到期等原因), 随后进程2重新执行++c; 最后进程1再回来把第三步做完.</p><p>发生了啥?<br>我们执行了两遍++c, 但c最终只自增了1.</p><p>显然这已经够麻烦了, 但更麻烦的是, 每次运行这两个进程的时候, 我们不知道其被中断运行时卡在了哪一步, 因此结果是 <strong>不确定</strong> 的(比如某一次运行时CPU频率比较高, 进程1被中断之前就把第三步干完了…)</p><hr><p>类似上文这种问题, 被我们称为 <strong>race condition bug(竞争条件错误)</strong> .</p><h3 id="1-2-临界区-Critical-Section"><a href="#1-2-临界区-Critical-Section" class="headerlink" title="1.2 临界区(Critical Section)"></a>1.2 临界区(Critical Section)</h3><p>为了解决上文提出的问题, 人们提出了 <strong>临界区(Critical Section)</strong> 这一概念:<br><em>A Critical section is a program region that has to access shared data in a synchronized way (say, a mutual exclusion way); otherwise, race condition may occur</em><br><em>临界区是程序中的一个特定的区域, 程序需要以特定的同步方式来访问其中的共享数据.</em></p><p>这意味着, 如果要访问共享数据, 每个进程必须首先 <strong>申请进入临界区</strong> , 当其获取到该许可后, 任何其它的进程均不允许访问该数据. 该进程结束对共享数据的处理后, 需要 <strong>告知退出临界区</strong> , 随后继续完成其余的指令.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-6/Critical%20Section.png" alt="Critical Section"></p><p>因此, 我们几乎已经能明确临界区的设计原则了:</p><ul><li>互斥原则(Mutual Exclusion): 即某个进程在其临界区内部运行时, 其余的进程均无法再进入临界区.</li><li>有限等待(Bounded Waiting): 在某个进程请求进入其临界区后且该请求被批准之前，其他进程可以进入它们临界区的次数必须有一个上限.(事实上, 这是为了保证任何进程不会被无限期的隔离在临界区之外)</li><li>空则让进(Progress): 如果没有任何进程正在其临界区中执行，并且存在一些进程希望进入它们的临界区，那么选择下一个进入临界区的进程的操作不能被无限期推迟。</li><li>让权等待(Preemptive): 取决于内核设定, 若内核允许, 则进程可以在处于内核态时让出临界区的控制权, 反之则必须等到退出内核态后才能释放临界区.</li></ul><h3 id="1-3-互斥机制"><a href="#1-3-互斥机制" class="headerlink" title="1.3 互斥机制"></a>1.3 互斥机制</h3><p>一个好的互斥机制的实现应当满足:</p><ul><li>互斥</li><li>无需对处理器速度或数目进行任何假设</li><li>不会出现外部阻塞问题</li><li>不会出现无限等待问题</li></ul><h2 id="2-基于软件的互斥机制-Software-based-Solutions"><a href="#2-基于软件的互斥机制-Software-based-Solutions" class="headerlink" title="2. 基于软件的互斥机制(Software-based Solutions)"></a>2. 基于软件的互斥机制(Software-based Solutions)</h2><h3 id="2-1-First-Solutions-Dekker’s-algorithm"><a href="#2-1-First-Solutions-Dekker’s-algorithm" class="headerlink" title="2.1 First Solutions: Dekker’s algorithm"></a>2.1 First Solutions: Dekker’s algorithm</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// flag[] is boolean array; and turn is an integer</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span>turn <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// or 1</span>P0<span class="token operator">:</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// indicate intension</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>turn <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// if it is not my turn</span>            flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// back off</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// busy wait</span>            <span class="token punctuation">&#125;</span>   <span class="token comment">// finally, it is my turn</span>            flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// re-indicate intension</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// critical section</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    turn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// remainder section</span>P1<span class="token operator">:</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// indicate intension</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>turn <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// if it is not my turn</span>            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// back off</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>turn <span class="token operator">&lt;</span><span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// busy wait</span>            <span class="token punctuation">&#125;</span>   <span class="token comment">// finally, it is my turn</span>            flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// re-indicate intension</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// critical section</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    turn <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    flag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">// remainder section</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过flag数组来表示某一进程 <strong>是否有进入临界区的意愿</strong></li><li>通过turn保证 <strong>不会有任何一方陷入无限等待的状态</strong></li></ul><h3 id="2-2-Peterson’s-algorithm-–-simplify-Dekker’s"><a href="#2-2-Peterson’s-algorithm-–-simplify-Dekker’s" class="headerlink" title="2.2 Peterson’s algorithm – simplify Dekker’s"></a>2.2 Peterson’s algorithm – simplify Dekker’s</h3><blockquote><p>后续基于Dekker的算法设计, Peterson对该算法进行了封装, 简化:</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-6/Peterson%27s%20algorithm.png" alt="Peterson&#39;s algorithm"></p><p>对于某个进程:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>     <span class="token function">enter_region</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         critical section<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">leave_region</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         remainder section<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>事实上, 互斥机制还能够基于硬件进行实现.</p><p>但实话实说, 基于硬件进行实现比上述这种编程方式还要复杂一些, <del>笔者实在不是很想在这里展开长篇大论</del> , 如果读者感兴趣可前往互联网自行搜索.</p></blockquote><h2 id="3-互斥锁-Mutex-Locks"><a href="#3-互斥锁-Mutex-Locks" class="headerlink" title="3. 互斥锁(Mutex Locks)"></a>3. 互斥锁(Mutex Locks)</h2><p>我们确实能看出, 此前这种基于编程实现的方法比较复杂, 需要简化, 尤为重要的是, 它无法被应用程序的代码员很方便的利用起来.</p><p>因此, 不同操作系统的设计者都会搭建对应的系统工具用于解决这种线程间的 <em>临界区同步</em> 问题, 最典型的, 也是最简单的就是 <strong>互斥锁(Mutex Lock)</strong> .</p><h3 id="3-1-实现逻辑"><a href="#3-1-实现逻辑" class="headerlink" title="3.1 实现逻辑"></a>3.1 实现逻辑</h3><p>互斥锁的实现逻辑比较简单:</p><p>在进入临界区之前, 进程应当先 <strong>获取锁(acquire lock)</strong> , 随后进行需要执行的操作; 操作完毕后, 进程还应当 <strong>释放锁(release lock)</strong> , 使得其余线程能够访问临界区.</p><blockquote><p>额外的, 如果当前进程在获取锁时, <strong>锁正在被其他进程占有</strong> , 则当前进程将进入 <strong>忙等状态</strong> , 直到 <strong>锁被其他进程释放为止</strong> .</p><p>通常, 互斥锁是通过一个 <em>布尔变量(bollean)</em> 进行控制的, 用布尔变量的真假标识当前临界区是否能够被访问.</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>available<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">/*busy wait*/</span>    <span class="token punctuation">&#125;</span>    available <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    available <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Process</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    acquire lock<span class="token punctuation">;</span>        critical section    release lock<span class="token punctuation">;</span>        remainder section<span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>看似这种互斥锁已经能够较好的完成该问题的解决, 但仍然存在不完美之处, <strong>该方案是基于忙等的</strong> . </p><p><em>但其实当前操作系统提供的一些更为高级的互斥锁(pthread_mutex_lock), 已经转而利用了操作系统的阻塞机制, 而不是忙等.</em> (该点了解即可)</p></blockquote><h2 id="4-信号量-Semaphore"><a href="#4-信号量-Semaphore" class="headerlink" title="4. 信号量(Semaphore)"></a>4. 信号量(Semaphore)</h2><p>信号量有两种:</p><ul><li>二元信号量(Binary Semaphore): 作用类似于互斥锁, 其计数值只能是0 &#x2F; 1</li><li>计数信号量(Counting Semaphore): 相比于二元信号量, 其计数值可以 &gt;1 , 通常用于限制对资源的并发访问.</li></ul><h3 id="4-1-如何解决此前的问题-Critical-Section-Problem"><a href="#4-1-如何解决此前的问题-Critical-Section-Problem" class="headerlink" title="4.1 如何解决此前的问题?(Critical Section Problem)"></a>4.1 如何解决此前的问题?(Critical Section Problem)</h3><p>二元信号量提供了两种方法:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//考虑两个进程P1, P2; P1中的操作S1需要在P2中某个操作S2前完成</span>P1<span class="token operator">:</span>    S1<span class="token punctuation">;</span>    <span class="token function">signal</span><span class="token punctuation">(</span>synch<span class="token punctuation">)</span><span class="token punctuation">;</span>P2<span class="token operator">:</span>    <span class="token function">wait</span><span class="token punctuation">(</span>synch<span class="token punctuation">)</span><span class="token punctuation">;</span>    S2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-如何去除忙等机制-without-busy-waiting"><a href="#4-2-如何去除忙等机制-without-busy-waiting" class="headerlink" title="4.2 如何去除忙等机制?(without busy-waiting?)"></a>4.2 如何去除忙等机制?(without busy-waiting?)</h3><p>当前的信号量机制不仅仅有这么一个数字, 每个信号量还伴随着一个 <strong>等待队列(waiting queue)</strong></p><p>队列中的每个条目一般包含这样两个条目:</p><ul><li>value(or Integer): 可能用于标识该条目在队列中的状态(如优先级等)</li><li>pointer to the next record: 即指向下一个条目的指针, 这使得这个等待队列能够形成一个链表</li></ul><p>通常, 当某个进程发现该信号量当前不可用时, 会被放入等待队列中并进入 <strong>阻塞状态(Block)</strong> ;</p><p>当信号量再度可用时, 根据链表队列中的优先级, 删除某个队列项并将其对应的线程转为 <strong>就绪状态(Ready)</strong> ;</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> value<span class="token punctuation">;</span>     <span class="token keyword">struct</span> <span class="token class-name">process</span> <span class="token operator">*</span>list<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> semaphore<span class="token punctuation">;</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// also called P operation// Atomic operation</span>    S<span class="token operator">-></span>value<span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        add <span class="token keyword">this</span> process to S<span class="token operator">-></span>list <span class="token punctuation">;</span>         <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// also called V operation// Atomic operation</span>    S<span class="token operator">-></span>value<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        remove a process P from S<span class="token operator">-></span>list<span class="token punctuation">;</span>          <span class="token function">wakeup</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-死锁-Deadlock-优先级翻转-Priority-Inversion"><a href="#4-3-死锁-Deadlock-优先级翻转-Priority-Inversion" class="headerlink" title="4.3 死锁(Deadlock) &#x2F; 优先级翻转(Priority Inversion)"></a>4.3 死锁(Deadlock) &#x2F; 优先级翻转(Priority Inversion)</h3><p>信号量已经比较完善了, 我们解决了关键区域的问题, 并摆脱了忙等的限制.</p><p>但还有一种比较尴尬的情况, 我们称之为 <strong>死锁(Deadlock)</strong> , 这代表着有两个或更多线程在等待队列里无限期的等待下去, 并无法正常被调用. 这通常是由于不同的信号量使用不当导致的问题, 看如下的例子:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">P0<span class="token operator">:</span> <span class="token comment">//Process 0</span><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span>P1<span class="token operator">:</span> <span class="token comment">//Process 1</span><span class="token function">wait</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除开死锁, 还有 <strong>优先级翻转(Priority Inversion)</strong> 问题, 比如低优先级的进程占用了高优先级进程的资源, 导致高优先级进程无法及试运行.</p><p>对于这两种问题, 还请读者注意一下, 后续会有进一步讨论它们的文章.</p><h3 id="4-4-Busy-waiting-VS-Context-Switch"><a href="#4-4-Busy-waiting-VS-Context-Switch" class="headerlink" title="4.4 Busy-waiting VS Context Switch"></a>4.4 Busy-waiting VS Context Switch</h3><p>我们在此前的文章中(<a href="https://mug-chen.site/posts/20755.html">Operating System Chap.3</a>)提到过, 进程的阻塞 &#x2F; 恢复是需要代价的, 操作系统需要将 <strong>进程控制块(PCB)</strong> 中的内容恢复到内存中, 并继续运行剩余的代码. 这种代价我们一般称之为 <strong>上下文切换(Context Switch)</strong></p><p>考虑如果忙等需要执行的代码量小于上下文切换的代码量, 这种时候忙等的效率其实要高于进程切换.<br>因此最新的操作系统一般会采用两种方式并用的策略来解决关键区域问题.</p><h3 id="4-5-Linux中的互斥锁-pthread-mutex"><a href="#4-5-Linux中的互斥锁-pthread-mutex" class="headerlink" title="4.5 Linux中的互斥锁(pthread_mutex)"></a>4.5 Linux中的互斥锁(pthread_mutex)</h3><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-6/pthread_mutex%20func.png" alt="pthread_mutex func"></p><h2 id="5-监视器-Monitor"><a href="#5-监视器-Monitor" class="headerlink" title="5. 监视器(Monitor)"></a>5. 监视器(Monitor)</h2><p><strong>监视器(Monitor)</strong> 是一种高层的并发编程结构, 它提供了多种受控访问共享数据的方法.</p><h3 id="5-1-组成"><a href="#5-1-组成" class="headerlink" title="5.1 组成"></a>5.1 组成</h3><p>之所以介绍它, 是因为它实际上是对上述机制的一种系统封装:</p><ul><li>共享数据(Shared Data)</li><li>操作共享数据的过程(Procedures that operate on the shared data)</li><li>同步机制(Synchronization): 确保同一时刻只能有一个线程执行监视器中的方法.</li></ul><h3 id="5-2-运作"><a href="#5-2-运作" class="headerlink" title="5.2 运作"></a>5.2 运作</h3><p>说到这, 其实其运作原理已经比较好猜了.</p><p>一个监视器里面有一个 <strong>互斥锁(Mutex lock)</strong> 以及一个 <strong>队列(Queue)</strong> .</p><p>一个进程必须先获得监视器中的互斥锁, 才能运行对监视器中共享数据区域的操作.<br>当这个互斥锁已经被其他进程占有, 则其它想要获得该互斥锁的进程被放入队列中.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-6/Monitor.png" alt="Monitor"></p><blockquote><p>这玩意显然更加容易使用了, 它封装了大部分的方法, 并且基本上不会发生什么意料之外的情况</p><p>但显然, 这玩意也没有信号量那么灵活就是了.</p><p>Java中提供了内置的简单监视器实现: Synchronized</p></blockquote><h2 id="6-条件变量-Condition-Variable-CV"><a href="#6-条件变量-Condition-Variable-CV" class="headerlink" title="6. 条件变量(Condition Variable &#x2F; CV)"></a>6. 条件变量(Condition Variable &#x2F; CV)</h2><p>为啥又冒出来个这呢?</p><p>考虑一种情况, 当某个线程得到了锁, 运行了一段时间了, 但它由于某些 <strong>别的条件不满足</strong> , 导致它自身无法继续运行下去了.</p><p>这时候该咋办捏? 这个线程放弃锁, 并放弃它已经运行的所有步骤, 等到别的条件满足了之后重新来吗? 这显然不可接受.</p><p>条件变量应运而出了.</p><h3 id="6-1-三种操作"><a href="#6-1-三种操作" class="headerlink" title="6.1 三种操作"></a>6.1 三种操作</h3><p>CV其实本质上设计思路跟信号量有点像的. 它也有一个单独的等待队列.</p><p>它就三种操作:</p><ul><li>wait(c, lock)<ul><li>把调用此方法的进程放入CV自己的等待队列(CV’s queue)中</li><li>释放锁(方便其他进程)获取锁继续操作</li></ul></li><li>signal(c)<ul><li>如果这个CV的等待队列中有进程, 从其中拿出一个, 放到监视器的等待队列中 (CV’s queue -&gt; Monitor’s queue)</li></ul></li><li>broadcase(c)<ul><li>将CV等待队列中的所有进程都放入监视器的等待队列中</li></ul></li></ul><blockquote><p>请务必明确, 条件变量的等待队列跟监视器的等待队列是俩概念!</p><p>前者是为了等待某个条件满足, 让当前进程能够继续运行的.<br>后者是为了等待当前进程获得锁, 使自己能够运行的.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-6/Condition%20Variable.png" alt="Condition Variable"></p><h3 id="6-2-实例"><a href="#6-2-实例" class="headerlink" title="6.2 实例"></a>6.2 实例</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//一个简单的存钱 / 取钱例子</span><span class="token function">Strange_withdraw</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>account <span class="token operator">&lt;</span> x<span class="token punctuation">)</span> <span class="token comment">// “if” will not work</span>        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    account <span class="token operator">-=</span> x<span class="token punctuation">;</span>    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">Deposit</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//s1</span>    account <span class="token operator">+=</span> y<span class="token punctuation">;</span>    <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//s2</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明确:</p><ul><li><em><strong>在操作某个条件时, 请务必拿到锁.(s1, s2操作是必须的)</strong></em></li><li><em><strong>请务必将条件变量放在一个循环里面</strong></em></li><li><em><strong>别的线程调用了signal, 并不代表原先的条件一定满足了, 只不过是原先的条件发生了变化, 可以重新判断而已</strong></em></li></ul><hr><p>至此, 各种同步机制就差不离了.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-6/Synchronization%20methods.png" alt="Synchronization methods"></p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating-System-Chap.5</title>
      <link href="/posts/21395.html"/>
      <url>/posts/21395.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-5-进程间通信"><a href="#操作系统-Chap-5-进程间通信" class="headerlink" title="操作系统 Chap.5 进程间通信"></a>操作系统 Chap.5 进程间通信</h1><h2 id="1-进程间通信-IPC"><a href="#1-进程间通信-IPC" class="headerlink" title="1. 进程间通信(IPC)"></a>1. 进程间通信(IPC)</h2><p>一个系统中的多个进程是可以单独运行的, 但同时也存在相互影响的情况(比如通过进程间的数据交换 &#x2F; 共享来协同工作).</p><p>为啥要有合作进程? 这其实跟我们此前提到的多线程(Multithread)出现的理由差不多:</p><ul><li>信息共享</li><li>提高效率</li><li>功能模块化</li><li>便携性</li></ul><p>当然, 合作进程存在的前提在于进程间能够真正做到共享信息, 这就引出了本文的主题: IPC(Interprocess communication &#x2F; 进程间通信).</p><h3 id="1-1-同步机制-Synchronization"><a href="#1-1-同步机制-Synchronization" class="headerlink" title="1.1 同步机制(Synchronization)"></a>1.1 同步机制(Synchronization)</h3><p>通信就通信吧, 干嘛同步啊?</p><p>我们需要明确, 进程间通信的根本需求是要共同完成某个任务, 因此进程之间的信息需要实时更新且保持一致, 否则就得出乱子.</p><p>现在很多进程都能访问同一块数据, 我们要确保它们看到的数据都是一致的, 这就需要我们对 <strong>不同进程处理数据的方法与顺序</strong> 进行详尽的设计.</p><h2 id="2-管道-Pipe"><a href="#2-管道-Pipe" class="headerlink" title="2. 管道(Pipe)"></a>2. 管道(Pipe)</h2><p>我们接下来进入进程间通信的第一种方式, 管道通信.</p><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>顾名思义, 所谓管道就是一个很长的字节流, 一端写入, 一端读出. 该消息传递方式没有 <strong>消息边界</strong> 这一概念.</p><blockquote><p>所谓 <em>消息边界</em> , 个人的理解是, 比如写入端是一行一行写入的, 这一点无法直接提现到读出端上, 因为读出端只能通过一个字节流来读取另一端传递过来的信息. 因此如果需要分割消息, 这个方法可能需要自行定义.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-5/Pipe%20cicular%20ring%20buffer.png" alt="Pipe: Understand it as a circular ring buffer"></p><h3 id="2-2-具体实现"><a href="#2-2-具体实现" class="headerlink" title="2.2 具体实现"></a>2.2 具体实现</h3><p>管道是通过数组来进行实现的:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//fd[0]表示读端</span><span class="token comment">//fd[1]表示写端</span><span class="token comment">//写入端</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭读端</span><span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> string<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> string<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//写入指定字符串</span><span class="token comment">//读出端</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关闭写端</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//buffer: 字符数组(其实就是字节数组)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-5/Pipe%20read%20port%20write%20port.png" alt="Pipe: Read port &amp; Write port"></p><h3 id="2-3-具体机制"><a href="#2-3-具体机制" class="headerlink" title="2.3 具体机制"></a>2.3 具体机制</h3><p>在内核内存系统中, 有一个专门用于管道的文件系统: <em>pipefs</em></p><p>这玩意会在系统初始化阶段就进行安装, 当进程尝试构建一个管道时, 就相当于在这个 <em>pipefs</em> 中创建一个文件. 对读端 &#x2F; 写端分别用文件描述符 <em>O_RDONLY &#x2F; O_WRONLY</em> 来进行控制.</p><p>那如果我硬在关闭的读端读 &#x2F; 在关闭的写端写呢?<br>前者, 系统会直接返回EOF(即 <em>End of file</em> ). 后者, 系统会进入异常处理, 给出 <em>SIGPIPE</em> 信号, 并报写入错误.</p><p>如果读时, 管道里没东西? &#x2F; 写时, 东西太多了?<br>前者, 系统会阻塞读端进程的IO操作, 直到管道里有东西可读为止. 后者, 系统会将过长的消息自动分割为固定字节大小的块(在Linux中, 这个大小为4KB). 再一块一块传输.</p><h3 id="2-4-FIFO-命名管道"><a href="#2-4-FIFO-命名管道" class="headerlink" title="2.4 FIFO &#x2F; 命名管道"></a>2.4 FIFO &#x2F; 命名管道</h3><p>不同于此前我们提及的管道, FIFO不仅仅局限于父进程与子进程之间的通信, 而是可以在两个完全无关的进程之间进行类似管道的通信操作.</p><p>其使用方式如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//Read Port</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_FILE</span> <span class="token expression">"MYFIFO”</span></span>FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span><span class="token keyword">char</span> readbuf<span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* Create the FIFO if it does not exist */</span><span class="token function">mkfifo</span><span class="token punctuation">(</span>myfifo<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>FIFO_FILE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fgets</span><span class="token punctuation">(</span>readbuf<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Received string: %s\n"</span><span class="token punctuation">,</span> readbuf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fclose() will not delete fifo</span><span class="token comment">//Write Port</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FIFO_FILE</span> <span class="token expression">"MYFIFO”</span></span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>FIFO_FILE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">fputs</span><span class="token punctuation">(</span>“Hello<span class="token operator">!</span>”<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码我们能看出来: FIFO不同于管道, 它真正的在计算机的硬盘中创建了一个文件(虽然其IO仍然是通过内核内存实现的). 相应的, 这个文件也不会在管道使用完毕后自动删除.</p><blockquote><p>相对于管道而言, 它的好处在于两点:<br>(1) 不仅仅局限于父子进程间<br>(2) 可以有多个写进程与一个读进程</p></blockquote><h2 id="3-Unix-Domain-Socket"><a href="#3-Unix-Domain-Socket" class="headerlink" title="3. Unix Domain Socket"></a>3. Unix Domain Socket</h2><p>提及Socket, 读者如果有 <em>计算机网络原理</em> 的相关基础, 大概会想到其中的 <em>套接字</em> .</p><p>Unix Domain Socket就是一种专用于本机进程间通信的套接字, 其使用的信息传递方式与计网中的套接字尤为类似.</p><p>为啥要引入它呢:</p><ul><li>这玩意不仅支持字节流, 同时支持数据报传输(可以理解为一个封装好的消息包)</li><li>不同于管道, <em>它是双向的</em> , 这省去了很多麻烦.</li></ul><h3 id="3-1-使用方式"><a href="#3-1-使用方式" class="headerlink" title="3.1 使用方式"></a>3.1 使用方式</h3><p>Unix Domain Socket是通过文件路径进行标识的, 这意味着要使用它, 也需要在硬盘内某个位置创建一个文件.</p><p>对于服务端(或者被称作发起连接端), 其连接流程如下:</p><ul><li>bind(): 绑定指定文件作为套接字</li><li>listen(): 监听, 等待连接请求</li><li>accept(): 收到连接请求后接收该请求</li></ul><p>对于客户端, 其流程要简单一些:</p><ul><li>connect(): 向监听套接字发送连接请求</li></ul><blockquote><p>一个比较清晰的Unix Domain Socket的使用说明:<br><a href="https://systemprogrammingatntu.github.io/mp2/unix_socket.html">https://systemprogrammingatntu.github.io/mp2/unix_socket.html</a></p></blockquote><h2 id="4-共享内存-Shared-Memory"><a href="#4-共享内存-Shared-Memory" class="headerlink" title="4. 共享内存(Shared Memory)"></a>4. 共享内存(Shared Memory)</h2><p>上述两种方式已经能够应对绝大部分的进程间通信需求了, 但我们可以发现, 上述两种方法都需要进行较为繁杂的初始化操作.</p><p>有一种更加高效的数据传输方式, 即通过将 <em>同一块物理内存映射到不同的进程中</em> , 这意味着这两个进程均具有其完全读写权限.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">shmid <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sharedMemoryBlock<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0666</span> <span class="token operator">|</span> IPC_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建共享内存</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sharedMemoryBlock <span class="token operator">*</span>sharedData <span class="token operator">=</span> <span class="token punctuation">(</span>sharedMemoryBlock <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//func to sharedData...</span>    <span class="token function">shmdt</span><span class="token punctuation">(</span>sharedData<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//解绑共享内存</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sharedMemoryBlock <span class="token operator">*</span>sharedData <span class="token operator">=</span> <span class="token punctuation">(</span>sharedMemoryBlock <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//func to sharedData...</span>    <span class="token function">shmdt</span><span class="token punctuation">(</span>sharedData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">shmctl</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span> IPC_RMID<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种进行直接映射, 直接对内存进行操作的方式, 相比于其他方法效率较高.</p><hr><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-5/Comparison%20of%20diffierent%20IPC%20method.png" alt="Comparision of diffierent IPC methods"></p><hr><p>本文梳理了当前较为通用的进程间通信的方式.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating-System-Chap.4</title>
      <link href="/posts/37714.html"/>
      <url>/posts/37714.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-4-中断-异常-信号量"><a href="#操作系统-Chap-4-中断-异常-信号量" class="headerlink" title="操作系统 Chap.4 中断 &#x2F; 异常 &#x2F; 信号量"></a>操作系统 Chap.4 中断 &#x2F; 异常 &#x2F; 信号量</h1><h2 id="1-引子-模式转换-Mode-Switch"><a href="#1-引子-模式转换-Mode-Switch" class="headerlink" title="1. 引子: 模式转换(Mode Switch)"></a>1. 引子: 模式转换(Mode Switch)</h2><p>所谓模式转换, 意味着程序在运行过程中在不同的CPU模式之间切换.</p><blockquote><p>先前提到过的CPU模式: (详见Chap.2中1.3的内容)<br>User Mode: 用户态(目态)<br>Kernel Mode: 内核态(管态)</p></blockquote><p>所以, 到底什么时候会出现模式切换?</p><ul><li>系统调用(System Calls)</li><li>中断(Interrupts)</li><li>异常(Exceptions)</li></ul><p>我们在此前的文章中已经提及了系统调用的内容(详见Chap.2中2.3), 本文我们将对中断与异常进行梳理总结.</p><h2 id="2-异常-Exceptions"><a href="#2-异常-Exceptions" class="headerlink" title="2. 异常(Exceptions)"></a>2. 异常(Exceptions)</h2><h3 id="2-1-异常的分类"><a href="#2-1-异常的分类" class="headerlink" title="2.1 异常的分类"></a>2.1 异常的分类</h3><p>通常我们能遇到的异常分两类:</p><ul><li>程序异常(Programmed exceptions &#x2F; <strong>Traps</strong> )<ul><li>int 0x80; 这是发出系统调用的旧方法</li></ul></li><li>异常运行(Anomalous executions &#x2F; <strong>Faults</strong> )<ul><li>$ a&#x2F;0 $ ; 除0</li><li>p &#x3D; NULL; a &#x3D; *p; 引用空指针</li></ul></li></ul><h3 id="2-2-异常的处理过程"><a href="#2-2-异常的处理过程" class="headerlink" title="2.2 异常的处理过程"></a>2.2 异常的处理过程</h3><p>说到这了, 异常到底是怎么被捕获 &#x2F; 处理的呢?</p><p>我们通过 <strong>除0</strong> 这一典型问题来说明这一过程:</p><ul><li>CPU在运行除法操作时发现了一个异常(即除0操作);</li><li>CPU运行模式切换为内核态(Kernel Mode), 随后对应异常的处理程序(此处即除0异常处理程序)被自动调用.</li><li>该处理程序会自动发送 <strong>SIGFPE(Float Point Exception)</strong> 信号给产生该异常的进程, 随后CPU模式返回用户态</li><li>进行判断:<ul><li>如果该进程定义了浮点异常信号的处理程序, 则执行该程序;</li><li>若否, 则直接杀死该进程</li></ul></li></ul><p>总结一下:</p><p><em>异常在出现的一瞬间会被处理器捕获, 并转向内核态唤醒异常处理程序(Exception Handlers). 随后异常处理程序通常会将该异常转化为一个在用户态能够表示的信号量(SIGNAL), 并退出内核态.</em></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-4/Exception%20handlers%20convert%20exception%20to%20sig.png" alt="Exception handlers convert exception to signal"></p><h3 id="2-3-终止进程"><a href="#2-3-终止进程" class="headerlink" title="2.3 终止进程"></a>2.3 终止进程</h3><p>通常的终止方式有以下几种:</p><ul><li>kill -signame pid &#x2F; kill(pid, sig)<ul><li>pid的含义并不很简单:<ul><li>pid &gt; 0: 意味着指向某个真实的进程</li><li>pid &#x3D;&#x3D; 0: 意味着 <strong>发送异常的进程的同组全部进程</strong></li><li>pid &#x3D;&#x3D; -1: ;意味着 <strong>发送异常的进程有权发送信号的全部进程</strong></li></ul></li></ul></li><li>pthread_kill()<ul><li>用于杀死某个发送进程的指定线程</li></ul></li><li>tgkill(pid, tid, sig)</li><li>sigqueue(pid, sig, value)</li></ul><blockquote><p>需要明确, 当一个进程被终止时, 其父进程会收到 <strong>SIGCHILD</strong> 信号</p></blockquote><h3 id="2-4-信号处理程序"><a href="#2-4-信号处理程序" class="headerlink" title="2.4 信号处理程序"></a>2.4 信号处理程序</h3><p>我们在2.2异常处理的最后一步中涉及到了一个判断.</p><blockquote><p>如果该进程定义了浮点异常信号的处理程序, 则执行该程序;</p></blockquote><p>此即 信号处理程序(Signal handler) 的意义所在.</p><p>正常情况下, 系统针对不同的信号有自己的一套处理机制, 比如上文中遇到SIGFPE信号时, 系统默认的反应是直接杀死该进程.</p><p>但当用户在自己的进程中定义了针对该信号的处理机制时, 系统会优先遵循用户的定义.</p><p>系统提供了两种函数来进行默认处理机制的更改:</p><ul><li>signal(): 通常不推荐使用该函数. 当你定义的处理程序被调用一次后, 它就会失效, 后续的处理继续遵循系统默认的设置.</li><li>sigaction(): 相比前者功能更全面, 如:<ul><li>当定义的处理程序被调用时, 会自动阻塞其它的信号</li><li>如果阻塞中的系统调用(比如read &#x2F; write)被信号处理程序打断, 在信号处理程序执行完毕后, 系统调用会自动重启.</li></ul></li></ul><blockquote><p>事实上, Linux最新版本的signal()已经进行了重新设计, 但本质上它也是通过调用sigaction()来实现的. 并且我们不能确定其他的Unix系统是否如此设计, 因此仍然不建议使用signal()函数.</p></blockquote><h2 id="3-中断-vs-异常-Interrupt-vs-Exception"><a href="#3-中断-vs-异常-Interrupt-vs-Exception" class="headerlink" title="3. 中断 vs 异常?(Interrupt vs Exception)"></a>3. 中断 vs 异常?(Interrupt vs Exception)</h2><p>在Chap.1的2.3节中, 我们曾经提过 <em>中断(Interrupt)</em> 这个事.</p><p>这里我们还得明确一下中断跟异常的关系与区别.</p><p><em>A trap or exception is a software-generated interrupt caused either by an error or a user request.</em><br><em>陷阱 &#x2F; 异常是系统自动产生的中断, 它由错误或用户请求引起.</em></p><p>所以实际上, 中断 &#x2F; 异常出现时, 系统要干的活是差不多的:</p><ul><li>切到内核模式</li><li>保存当前上下文</li><li>通过IDT(Interrupt Descriptor Table)调用对应的处理程序</li><li>恢复现场</li><li>切回用户模式</li></ul><p>关于IDT, 这玩意有点类似于我们在Chap.1中2.3节提到过的 Interrupt Vector Table 的升级版.</p><p>在IVT中, 这个表只会存储每个中断服务例程的具体地址. 而在IDT中, 还会存储对应的类型信息 &#x2F; 权限级别等信息.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Interrupt%20Table.png" alt="Interrupt Vector Table"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-4/Interrupt%20Exception%20Signal.png" alt="Interrupt / Exception / Signal"></p><hr><p>本篇内容较少, 这是因为其实这里的有些内容在前面已经有所涉及了, 本篇权当对前面的内容的进一步引申与阐述.</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating-System-Chap.3</title>
      <link href="/posts/20755.html"/>
      <url>/posts/20755.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-3-进程-线程"><a href="#操作系统-Chap-3-进程-线程" class="headerlink" title="操作系统 Chap.3 进程 &#x2F; 线程"></a>操作系统 Chap.3 进程 &#x2F; 线程</h1><h2 id="1-进程-Process"><a href="#1-进程-Process" class="headerlink" title="1. 进程(Process)"></a>1. 进程(Process)</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><p><em>Process is a program in execution.</em><br><em>进程是一个正在执行的程序</em></p><p>一个进程通常包括多个部分:</p><ul><li>程序代码(Program code &#x2F; Text section)</li><li>当前活动(Current activity)<ul><li>程序计数器(Program counter)</li><li>处理器寄存器(Processor registers)</li></ul></li><li>栈(Stack): 用于存储临时信息, 如函数参数 &#x2F; 返回地址 &#x2F; 局部变量等</li><li>数据区(Data section): 用于存储全局变量</li><li>堆(Heap): 用于内存的动态分配</li></ul><blockquote><p><em>Program is passive entity stored on disk, while process is active.</em><br>程序是存储在硬盘中的被动实体, 而进程是活跃的程序. 这意味着当一个程序的执行文件加载如内存后, 程序就成为了一个进程.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-3/Proccess%20in%20memory.png" alt="Process in memory"></p><h3 id="1-2-进程状态-Process-state"><a href="#1-2-进程状态-Process-state" class="headerlink" title="1.2 进程状态(Process state)"></a>1.2 进程状态(Process state)</h3><p>一个进程被执行的完整周期中, 存在以下五个状态:</p><ul><li>创建(New): 进程刚刚被创建</li><li>就绪(Ready): 进程已经准备好运行, 即进程已经被分配到除CPU以外的全部资源时</li><li>执行(Running): 进程已获得CPU, 程序正在执行</li><li>阻塞(Block &#x2F; Waiting): 正在执行的进程由于某事件而无法继续运行的状态</li><li>终止(Terminated): 进程结束运行</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-3/transitions%20of%20process%20state.png" alt="Transitions of process state"></p><h3 id="1-3-调用栈-Call-stack"><a href="#1-3-调用栈-Call-stack" class="headerlink" title="1.3 调用栈(Call stack)"></a>1.3 调用栈(Call stack)</h3><p><strong>调用栈</strong> 是一种栈数据结构, 它负责存储活动函数的某些信息.</p><p>调用栈由 <strong>栈帧(stack frames &#x2F; activation records)</strong> 构成, 每个函数的调用都对应着一个单独的栈帧, 里面包含:</p><ul><li>传递的参数</li><li>返回地址</li><li>当前的程序计数器值</li><li>局部变量</li></ul><p>调用栈在新的调用出现时, 会增长; 相应的, 在调用结束后, 会缩小.</p><h3 id="1-4-调用约定-Calling-Convention"><a href="#1-4-调用约定-Calling-Convention" class="headerlink" title="1.4 调用约定(Calling Convention)"></a>1.4 调用约定(Calling Convention)</h3><p><strong>调用约定</strong> 规定了一个函数如何调用其它的函数, 以及这个调用如何返回. 包括:</p><ul><li>参数是怎么传递的(如通过寄存器 &#x2F; 通过调用栈)</li><li>参数顺序</li><li>谁来负责恢复调用之前的环境</li><li>返回值是怎样从被调用的函数传递给调用者的</li></ul><h3 id="1-5-执行上下文-Execution-context-Processor-state-PCB"><a href="#1-5-执行上下文-Execution-context-Processor-state-PCB" class="headerlink" title="1.5 执行上下文(Execution context &#x2F; Processor state) &#x2F; PCB"></a>1.5 执行上下文(Execution context &#x2F; Processor state) &#x2F; PCB</h3><p><strong>执行上下文</strong> 指的是CPU寄存器在任意时间点的内容.</p><p>常见的数据有:</p><ul><li>程序计数器(Program counter): 指向当前程序运行位置</li><li>调用栈指针(Call stack pointer): 指向当前调用栈的顶端</li><li>分配给进程的内存的地址</li><li>…</li></ul><blockquote><p>明确 进程状态(Process state) &#x2F; 处理器状态(Processor state) 的区别</p></blockquote><p>执行上下文很重要, 存哪?</p><p><strong>进程控制块PCB(Process Control Block)</strong> 是 <strong>内核内存</strong> 中负责存储执行上下文的数据结构.</p><p>一个PCB中通常存储了:</p><ul><li>执行上下文(Execution context)</li><li>进程ID(Process ID)</li><li>进程控制信息(Process control information)</li></ul><h3 id="1-6-进程控制-Process-Scheduling-进程切换-Process-Switch"><a href="#1-6-进程控制-Process-Scheduling-进程切换-Process-Switch" class="headerlink" title="1.6 进程控制(Process Scheduling) &#x2F; 进程切换(Process Switch)"></a>1.6 进程控制(Process Scheduling) &#x2F; 进程切换(Process Switch)</h3><p>上面说了一堆, 主要是引出操作系统 <strong>进程控制</strong> 这一概念</p><p>我们之前提过, 进程控制是为了最大化CPU资源的利用率, 由于我们已经通过PCB将一个进程结构化了, 因此可以通过结构体数组来管理进程的执行, 即 <strong>控制队列</strong></p><ul><li>Job queue: 包含系统中全部的进程</li><li>Ready queue: 包含当前处于就绪状态, 等待执行的进程</li><li>Device queue: 包含当前所有需要等待I&#x2F;O设备的进程</li></ul><p>进程在不同状态间转换, 体现在控制队列中, 即 <strong>进程在不同队列之间迁移.</strong></p><p>我们上文中提及到进程的 <strong>阻塞态</strong> , 当进程进入该状态, 操作系统需要暂存其状态并切换至其他的进程, 这即所谓 <strong>进程切换</strong> .</p><p>当需要进程切换时, OS要进行如下操作:</p><ul><li>将进程当前的上下文存储到它的PCB中</li><li>从处于就绪态的进程中选择一个进程</li><li>从被选择的进程的PCB中恢复其上下文</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-3/Process%20Switch.png" alt="Process Switch"></p><blockquote><p>事实上, 进程切换广泛存在于操作系统的运行过程中: 我们刚刚提及到的进程进入阻塞态只是进程切换的一种情况.<br>进程阻塞 &#x2F; 进程结束运行 &#x2F; CPU时间片被用尽 时, 均会导致进程切换.</p></blockquote><h3 id="1-7-进程的创建-Process-Creation-与终止-Termination"><a href="#1-7-进程的创建-Process-Creation-与终止-Termination" class="headerlink" title="1.7 进程的创建(Process Creation) 与终止(Termination)"></a>1.7 进程的创建(Process Creation) 与终止(Termination)</h3><p>从用户视角而言, 要创建一个进程只需要调用OS提供的系统函数即可:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//error: No process created</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//Parent process</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>  <span class="token comment">//pid == 0</span>  <span class="token comment">//Child process</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UNIX系统中, 进程通过 <strong>Process Identifier(pid)</strong> 进行管理, 通过一棵进程树来进行管理.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-3/Process%20tree.png" alt="Process Tree"></p><p>对于这一对父子进程, 子进程是由父进程创建出来的, 那自然子进程运行完毕后也要由父进程进行处理. 通常, 会有如下语句:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">//error: No process created</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Parent will wait the child to complete</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Child will exit and finish its work</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然, 在某些情况下, 子进程未能正常退出, 或者父进程异常终止时, 则父进程会强制结束其下属全部子进程, 这是通过:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一系统调用实现的.</p><h3 id="1-8-僵尸进程-Zombie-Process"><a href="#1-8-僵尸进程-Zombie-Process" class="headerlink" title="1.8 僵尸进程(Zombie Process)"></a>1.8 僵尸进程(Zombie Process)</h3><p><em>If no parent waiting (did not invoke wait()) process is zombie</em></p><p>当一个进程退出后, 它会进入被称为 <strong>僵尸进程</strong> 的状态. 当其父进程调用wait()后, 该僵尸进程才会被清理.</p><p>Init Process(pid &#x3D; 1)会定期收集未能及时清理的僵尸进程.</p><blockquote><p>init进程是一个特殊的进程, 是Linux系统中所有进程的起点。它是系统引导过程中由内核启动的第一个用户级进程。init进程的PID始终为1, 它是所有其他进程的祖先进程.</p></blockquote><h2 id="2-线程-Thread"><a href="#2-线程-Thread" class="headerlink" title="2. 线程(Thread)"></a>2. 线程(Thread)</h2><p>我们上面提及的进程都是 <strong>单线程的</strong> , 这意味着一个线程只能同时执行单个任务.</p><p>人们认为线程这种划分仍然不够细致, 因此进一步提出了 <strong>多线程(Multithread)</strong> 的概念.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-3/SingleThread%20%26%20Multithread.png" alt="Single Thread VS Multithread"></p><p>多线程是很有好处的:</p><ul><li>持续响应(Responsiveness): 一个进程的部分线程被阻塞时, 其余线程还能够继续响应指示. 这对于用户界面的设计尤为重要.</li><li>资源共享(Resource Sharing): 不同的线程共享一个进程的资源, 这相比于不同进程之间的信息传递要快很多</li><li>经济(Economy): 线程的创建要比进程创建快很多</li></ul><h3 id="2-1-用户线程-User-Thread-内核线程-Kernel-Thread"><a href="#2-1-用户线程-User-Thread-内核线程-Kernel-Thread" class="headerlink" title="2.1 用户线程(User Thread) &#x2F; 内核线程(Kernel Thread)"></a>2.1 用户线程(User Thread) &#x2F; 内核线程(Kernel Thread)</h3><p>当前的线程主要分两类:</p><ul><li>用户线程(User Thread): 在内核之上运行, 由用户层线程库提供支持</li><li>内核线程(Kernel Thread): 由操作系统直接提供支持</li></ul><blockquote><p>在Windows以及Linux中, 用户线程与内核线程是一对一(One-to-one)的. 这意味着每个用户线程都映射到一个内核线程</p><p>除一对一之外, 多对一(Many-to-one)也是一种设计模型, 但由于其多对一的设计方式, 一个线程出现问题会导致整个映射都崩溃掉, 这有违多线程的初衷, 因此采用该种方式的操作系统较少.</p><p>除上, 还有多对多(Many-to-many) &#x2F; 一对多与多对多混用 等线程设计模型.</p></blockquote><p>当前, 总共有三个广为使用的多线程库:</p><ul><li>POSIX Pthreads</li><li>Windows threads</li><li>Java threads</li></ul><hr><p>至此, 我们总结一下进程与线程的知识与关联:</p><ul><li>进程: 一个被执行的程序实例<ul><li>不同的进程有不同的内存地址空间</li><li>创建进程需要很高的资源占用</li><li>一个进程最少是单线程的</li></ul></li><li>线程: 是进程下的一个实体, 专用于代码执行<ul><li>同进程下不同的线程共享着很多资源, 如内存地址空间 &#x2F; 已经打开的文件等.</li><li>创建线程耗费的资源显著少于创建进程</li><li>对应的, 廉价的共享资源方式代表着一个线程的错误可能引起其余线程的崩溃</li></ul></li></ul><hr><p>至此, 进程与线程我们基本梳理完毕.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-Chap.4</title>
      <link href="/posts/54039.html"/>
      <url>/posts/54039.html</url>
      
        <content type="html"><![CDATA[<h1 id="密码学-Chap-4-分组密码"><a href="#密码学-Chap-4-分组密码" class="headerlink" title="密码学 Chap.4 分组密码"></a>密码学 Chap.4 分组密码</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-引入"><a href="#1-1-引入" class="headerlink" title="1.1 引入"></a>1.1 引入</h3><p><strong>分组密码</strong> , 实质上描述的是一种加密方式, 它将明文分为一个个等长的消息组, 在密钥的控制下按固定算法分别进行每组的加密, 最终再将 <strong>等长的</strong> 密文组拼接后输出.</p><p>$$ m_1, m_2, …, m_k \to (m_1, m_2, …, m_n)(m_{n+1}, m_{n+2}, …, m_{2n})… \to (y_1, y_2, …, y_m)(y_{m+1}, y_{m+2}, …, y_{2m})… $$</p><h3 id="1-2-基本概念"><a href="#1-2-基本概念" class="headerlink" title="1.2 基本概念"></a>1.2 基本概念</h3><ul><li>n &#x2F; m : 分组长度. 我们可见, 分组密码的分组长度与加密后的分组长度不一定相同.<ul><li>n &gt; m 时, 称为有数据压缩的分组密码.</li><li>n &lt; m 时, 称为有数据扩展的分组密码.</li><li>n &#x3D; m 是最常见的方式.</li></ul></li><li>实质上, 研究分组密码就是研究 $ (x_1,x_2, …, x_n) \to (y_1, y_2, …, y_m) $ 这一过程.</li></ul><blockquote><p>可见, 通常而言研究的就是明 &#x2F; 密文的二元组, 因此也可表示为 $ GF(2)^n \to GF(2)^m $ 的映射.</p></blockquote><h3 id="1-3-历史沿途"><a href="#1-3-历史沿途" class="headerlink" title="1.3 历史沿途"></a>1.3 历史沿途</h3><p>这一部分简单了解即可.</p><p>分组密码出现的标志是上世纪70年代出现的 <strong>美国数据加密标准 DES (Data Encryption Standard) 算法</strong> . 它所持有的一些特征也为当代的分组密码所继承, 如算法完全公开, 信息安全性大程度取决于密钥的安全性等.</p><h3 id="1-4-关于安全性"><a href="#1-4-关于安全性" class="headerlink" title="1.4 关于安全性"></a>1.4 关于安全性</h3><p>分组密码作为不同于古典密码的新产物, 其出现目的在于防范来自于现代计算机的攻击, 因此其安全性标准要更复杂一些.</p><p>现代分组密码的 <strong>密码算法是完全公开的</strong> , 这意味着其安全性仅依赖于密钥的复杂程度.</p><p>评判分组密码的安全性, 首先需要考虑攻击者可能获取到什么信息:</p><ul><li>截获在不安全信道上传输的全部密文</li><li>攻击者的计算能力</li><li>获得的其余信息等</li></ul><p>在攻击者拥有的信息越多 &#x2F; 拥有的计算能力越强的前提下, 如果一个系统仍然是安全的, 则这个系统的安全性越高.</p><blockquote><p>所谓 <strong>相对安全</strong> 与 <strong>绝对安全</strong> 的概念也源于这个考量, 当一个系统对于一个拥有无限计算机资源的攻击者都是安全的, 则这个系统被称之为绝对安全的系统. 反之则均称之为相对安全的系统.</p><p>很遗憾, 当前来看, 绝对安全的系统并不存在. 因此我们通常从密码应用时期的硬件算力所需的破译时间来进行评判一个相对安全的系统.</p><p>如果攻击者利用其手中有限的算力破译该密码算法所需要的时间远超该新系统所保护的内容的有效期，我们称这个系统是 <strong>计算上安全的</strong></p></blockquote><h3 id="1-5-分组密码的设计原则"><a href="#1-5-分组密码的设计原则" class="headerlink" title="1.5 分组密码的设计原则"></a>1.5 分组密码的设计原则</h3><p>人们认为分组密码应当具备两个特性:</p><ul><li><strong>复杂-难于分析</strong><ul><li>分组长度足够大</li><li>密钥量足够大</li><li><strong>混乱和扩散</strong> :<ul><li>混乱: 指的是使得明文和密文之间的统计特性难以分析</li><li>扩散: 指的是每一位明文数字的影响都应当迅速地体现在密文多个输出的数字中</li></ul></li></ul></li><li><strong>简单-易于实现</strong><ul><li>硬件实现则必须高效</li><li>软件实现则必须灵活 &#x2F; 代价低</li></ul></li></ul><blockquote><p><strong>混乱(Confusion)</strong> 与 <strong>扩散(Diffusion)</strong> 是由香农(Shannon)提出的两个一般性的现代密码设计原则</p></blockquote><p><strong>复杂与简单</strong> 这两个要求其实有着本质性的矛盾, 分组密码的目的在于设计出能在二者之间找到平衡的算法.</p><h2 id="2-迭代密码"><a href="#2-迭代密码" class="headerlink" title="2. 迭代密码"></a>2. 迭代密码</h2><h3 id="2-1-迭代"><a href="#2-1-迭代" class="headerlink" title="2.1 迭代?"></a>2.1 迭代?</h3><p>如上文所说, 为了在复杂与简单之间找到平衡, 提出了 <strong>迭代密码</strong> 这一创新性的概念, 它意味着将一个简单的密码算法进行多轮循环迭代, 从而达到复杂的效果.</p><p>我们给一个具体定义:</p><p>定义 $ K $ 为一个确定长度的二元密钥, 迭代算法会指定一个固定的 &#x2F; 公开的密钥编排方案, 得到 $ N_r $ 个 <strong>轮密钥</strong> (也称 <strong>子密钥</strong> ) , 记为 $ (K_0, K_1, …, K_{N_r}) $ . 此后, 还会设计一个公开的 <strong>轮函数</strong> $ g $ , 它以 轮密钥 $ K_r $ 以及当前状态 $ w_{r-1} $ 作为输入, 输出当前轮的中间状态 $ w_r $ .</p><p>轮函数即:</p><p>$$ w_r &#x3D; g(K_r, w_{r-1}) $$</p><p>初态 $ w_0 $ 被我们定义为明文, 经过 $ N_r $ 轮的最终态 $ w_{N_r} $ 被我们定义为密文 $ y $ .</p><hr><p>迭代密码的复杂性我们保证了, 但我们好像忘记了点问题, 咋解密?</p><p>对于迭代密码, 其解密的过程就是加密的逆过程, 因此, 除了上述定义外, 我们还要求轮函数 $ g $ <strong>必须是可逆的</strong> , 这使得解密者能够上述过程的逆过程重现明文.</p><h3 id="2-2-Feistel-结构"><a href="#2-2-Feistel-结构" class="headerlink" title="2.2 Feistel 结构"></a>2.2 Feistel 结构</h3><p>Feistel 结构是迭代密码的一种经典的具体实现, 它将每一个状态 $ w_r $ 分为左右两部分, $ L_i $ &amp; $ R_i $ , 同时轮函数的输出也分为左右两部分, 其具体定义如下:</p><p>$$<br>\begin{aligned}<br>  L_i &amp; &#x3D; R_{i-1} \<br>  R_i &amp; &#x3D; L_{i-1} \oplus f(K_i, R_{i-1})<br>\end{aligned}<br>$$</p><p>这里的函数 $ f $ 是一个公开的函数, 它以轮密钥 $ K_i $ 以及当前状态 $ R_{i-1} $ 作为输入, 其输出与 $ L_{i-1} $ 进行异或运算后得出下一轮的 $ R_i $ .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E5%AF%86%E7%A0%81%E5%AD%A6/Chap.4/Feistel%E7%BB%93%E6%9E%84.png" alt="Feistel结构"></p><h2 id="3-DES"><a href="#3-DES" class="headerlink" title="3. DES"></a>3. DES</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>DES 是一种 <strong>16轮</strong> 的Feistel密码, 其分组长度为 <strong>64位</strong> , 并用一个 <strong>64位</strong> 的密钥进行加密, 最终获取一个 <strong>64位</strong> 的密文串.</p><h3 id="3-2-DES的具体流程"><a href="#3-2-DES的具体流程" class="headerlink" title="3.2 DES的具体流程"></a>3.2 DES的具体流程</h3><p>DES 的具体流程分以下几步:</p><ul><li><strong>初始置换</strong> : 在对64位明文串进行加密前, 通常先对明文做一个初始的置换, 我们称之为 <strong>IP(Initial Permutation)</strong></li><li><strong>子密钥生成( Generate Subkeys</strong> ):<ul><li>64位密钥初始置换, 我们称之为 <strong>PC-1(Permutation Choice 1)</strong> , 这个置换会将64位密钥变为56位密钥.</li><li>分为左右两部分 $ C_0 $ &amp; $ D_0 $ , 每部分28位, 并对两部分分别根据当前轮数进行循环左移( <strong>Left Shift</strong> ).</li><li>左移后, 将两部分拼接起来, 得到56位的二进制串, 随后再进行一次置换 <strong>PC-2(Permutation Choice 2)</strong> , 这个置换进一步将56位二进制串变为48位二进制串(该串即为当轮子密钥).</li><li>将上述过程循环16次, 得到16个子密钥.</li></ul></li><li><strong>16轮迭代</strong> :<ul><li>根据Feistel结构, 将64位明文串分为左右两部分, 分别记为 $ L_0 $ &amp; $ R_0 $ , 各32位</li><li>下一轮的左侧 $ L_i $ 就是上一轮的右侧 $ R_{i-1} $</li><li>下一轮的右侧 $ R_i $ 需要先计算 $ f $ 函数:<ul><li>将 $ R_{i-1} $ 先进行一次扩展置换 <strong>E(Expansion Permutation)</strong> , 得到一个48位二进制串, 我们称之为 $ E(R_{i-1}) $</li><li>将这个 48位串 $ E(R_{i-1}) $ 与 当轮子密钥 $ K_i $ 进行异或运算, 得到一个48位二进制串, 我们称之为 $ S_2 $ </li><li>将该48位串 $ S_2 $ 按照一定的规则分成8个6位串, 每个6位串通过一个S盒置换变为一个4位串, 最终得到一个32位二进制串, 我们称之为 $ S_3 $</li><li>最终将 $ S_3 $ 进行一个置换 <strong>P(Permutation)</strong> , 得到 $ f(R_{i-1}, K_i) $</li></ul></li><li>下一轮的右侧 $ R_i $ 就是 $ L_{i-1} \oplus f(R_{i-1}, K_i) $</li><li>上述过程循环16次, 得到 $ L_{16} $ &amp; $ R_{16} $</li></ul></li><li><strong>尾部逆置换</strong> : 最后将 $ L_{16} $ &amp; $ R_{16} $ 反向拼接起来, 再进行一个 逆置换(Inverse Permutation) , 得到最终的64位密文串.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E5%AF%86%E7%A0%81%E5%AD%A6/Chap.4/DES%E8%BF%87%E7%A8%8B.png" alt="DES流程"></p><h3 id="3-3-具体说明1-置换"><a href="#3-3-具体说明1-置换" class="headerlink" title="3.3 具体说明1: 置换?"></a>3.3 具体说明1: 置换?</h3><p>上述过程中多次涉及到了 <strong>置换</strong> 这一概念, 在DES中, 置换是通过矩阵体现的.</p><p>我们以初始置换为例:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int IP[64] &#x3D; &#123;    58, 50, 42, 34, 26, 18, 10, 2,    60, 52, 44, 36, 28, 20, 12, 4,    62, 54, 46, 38, 30, 22, 14, 6,    64, 56, 48, 40, 32, 24, 16, 8,    57, 49, 41, 33, 25, 17, 9, 1,    59, 51, 43, 35, 27, 19, 11, 3,    61, 53, 45, 37, 29, 21, 13, 5,    63, 55, 47, 39, 31, 23, 15, 7&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们进一步给出上述过程中用到的全部置换矩阵:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int IP_INV[64] &#x3D; &#123;    40, 8, 48, 16, 56, 24, 64, 32,    39, 7, 47, 15, 55, 23, 63, 31,    38, 6, 46, 14, 54, 22, 62, 30,    37, 5, 45, 13, 53, 21, 61, 29,    36, 4, 44, 12, 52, 20, 60, 28,    35, 3, 43, 11, 51, 19, 59, 27,    34, 2, 42, 10, 50, 18, 58, 26,    33, 1, 41, 9, 49, 17, 57, 25&#125;;const int EP[48] &#x3D; &#123;32,  1,  2,  3,  4,  5, 4,  5,  6,  7,  8,  9, 8,  9, 10, 11, 12, 13,12, 13, 14, 15, 16, 17,16, 17, 18, 19, 20, 21,20, 21, 22, 23, 24, 25,24, 25, 26, 27, 28, 29,28, 29, 30, 31, 32,  1&#125;;const int PC1[56] &#x3D; &#123;    57, 49, 41, 33, 25, 17, 9,    1, 58, 50, 42, 34, 26, 18,    10, 2, 59, 51, 43, 35, 27,    19, 11, 3, 60, 52, 44, 36,    63, 55, 47, 39, 31, 23, 15,    7, 62, 54, 46, 38, 30, 22,    14, 6, 61, 53, 45, 37, 29,    21, 13, 5, 28, 20, 12, 4&#125;;const int PC2[48] &#x3D; &#123;    14, 17, 11, 24, 1, 5,    3, 28, 15, 6, 21, 10,    23, 19, 12, 4, 26, 8,    16, 7, 27, 20, 13, 2,    41, 52, 31, 37, 47, 55,    30, 40, 51, 45, 33, 48,    44, 49, 39, 56, 34, 53,    46, 42, 50, 36, 29, 32&#125;;const int P[32] &#x3D; &#123;    16, 7, 20, 21, 29, 12, 28, 17,    1, 15, 23, 26, 5, 18, 31, 10,    2, 8, 24, 14, 32, 27, 3, 9,    19, 13, 30, 6, 22, 11, 4, 25&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述矩阵的意义为, 原二进制串中的第 IP[i] 位, 将会移动到新二进制串的第 i 位. 比如原串中的第 58 位, 将会移动到新串的第 1 位.</p><p>DES中几乎全部的置换都是通过这种形式进行的, 并且每个置换对应的置换矩阵是固定的 &#x2F; 公开的.</p><h3 id="3-4-具体说明2-S盒"><a href="#3-4-具体说明2-S盒" class="headerlink" title="3.4 具体说明2: S盒?"></a>3.4 具体说明2: S盒?</h3><p>在DES中, S盒是DES的另一个核心部分, 每一个S盒都将一个6位的二进制串转为4位, 共8个S盒, 它将48位二进制串变为32位二进制串.</p><p>我们以第一个 S盒 为例:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#123;    &#123;14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7&#125;,    &#123; 0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8&#125;,    &#123; 4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0&#125;,    &#123;15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该盒中有4行 &#x2F; 16列, 我们假设待转的6位串为 110101 :</p><ul><li>将第一位与最后一位取出来, 拼接后作为行数: 即 11 , 第3行</li><li>将第二位至第五位取出, 作为列数: 即 1010 , 第10列</li><li>取出的数为 3 , 转化为对应的4位二进制串: 0011</li></ul><p>剩余的S盒如法炮制即可.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int Sbox[8][4][16] &#x3D; &#123;    &#123;        &#123;14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7&#125;,        &#123; 0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8&#125;,        &#123; 4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0&#125;,        &#123;15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13&#125;    &#125;,    &#123;        &#123;15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10&#125;,        &#123;3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5&#125;,        &#123;0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15&#125;,        &#123;13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9&#125;    &#125;,    &#123;        &#123;10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8&#125;,        &#123;13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1&#125;,        &#123;13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7&#125;,        &#123;1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12&#125;    &#125;,    &#123;        &#123;7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15&#125;,        &#123;13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9&#125;,        &#123;10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4&#125;,        &#123;3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14&#125;    &#125;,    &#123;        &#123;2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9&#125;,        &#123;14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6&#125;,        &#123;4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14&#125;,        &#123;11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3&#125;    &#125;,    &#123;        &#123;12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11&#125;,        &#123;10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8&#125;,        &#123;9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6&#125;,        &#123;4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13&#125;    &#125;,    &#123;        &#123;4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1&#125;,        &#123;13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6&#125;,        &#123;1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2&#125;,        &#123;6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12&#125;    &#125;,    &#123;        &#123;13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7&#125;,        &#123;1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2&#125;,        &#123;7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8&#125;,        &#123;2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11&#125;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-具体说明3-生成子密钥时的左移"><a href="#3-5-具体说明3-生成子密钥时的左移" class="headerlink" title="3.5 具体说明3: 生成子密钥时的左移?"></a>3.5 具体说明3: 生成子密钥时的左移?</h3><p>生成子密钥的左移是 <strong>循环左移</strong> , 每次左移的位数由轮数决定, 具体每轮左移位数由一个数组给出:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int SHIFT_SCHEDULE[16] &#x3D; &#123;    1, 1, 2, 2, 2, 2, 2, 2,    1, 2, 2, 2, 2, 2, 2, 1&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-代码"><a href="#3-6-代码" class="headerlink" title="3.6 代码"></a>3.6 代码</h3><p>博主在这里就不给全部代码了, 将几个重要功能的代码给出: (生成子密钥 &#x2F; F函数)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void generateSubKey(const bitset&lt;64&gt; key_bin, vector&lt;bitset&lt;48&gt;&gt;&amp; subkey) &#123;    &#x2F;&#x2F;Generate sub-key    &#x2F;&#x2F;PC1    bitset&lt;56&gt; permutedKey;    for (int i &#x3D; 0; i &lt; 56; i++) &#123;        permutedKey[i] &#x3D; key_bin[PC1[i] - 1];    &#125;    &#x2F;&#x2F;Left-shift    bitset&lt;28&gt; right(permutedKey.to_string().substr(0, 28));    bitset&lt;28&gt; left(permutedKey.to_string().substr(28, 56));    for (int i &#x3D; 0; i &lt; 16; i++) &#123;        for (int j &#x3D; 0; j &lt; SHIFT_SCHEDULE[i]; j++) &#123;            bool left_t &#x3D; left[0];            bool right_t &#x3D; right[0];            for (int k &#x3D; 1; k &lt; 28; k++) &#123;                left[k - 1] &#x3D; left[k];                right[k - 1] &#x3D; right[k];            &#125;            left[27] &#x3D; left_t;            right[27] &#x3D; right_t;        &#125;        bitset&lt;56&gt; temp;        for (int j &#x3D; 0; j &lt; 28; j++) &#123;            temp[j] &#x3D; left[j];            temp[28 + j] &#x3D; right[j];        &#125;        &#x2F;&#x2F;PC2        bitset&lt;48&gt; sub;        for (int j &#x3D; 0; j &lt; 48; j++) &#123;            sub[j] &#x3D; temp[PC2[j] - 1];        &#125;        subkey[i] &#x3D; sub;    &#125;    return;&#125;bitset&lt;32&gt; f(bitset&lt;32&gt; R, bitset&lt;48&gt; subKey) &#123;    bitset&lt;48&gt; expandR;    for (int i &#x3D; 0; i &lt; 48; i++) &#123;        expandR[i] &#x3D; R[EP[i] - 1];    &#125;    expandR ^&#x3D; subKey;    bitset&lt;32&gt; output;    for (int i &#x3D; 0; i &lt; 8; i++) &#123;        int row &#x3D; expandR[i * 6] * 2 + expandR[i * 6 + 5];        int col &#x3D; expandR[i * 6 + 1] * 8 + expandR[i * 6 + 2] * 4 + expandR[i * 6 + 3] * 2 + expandR[i * 6 + 4];        int val &#x3D; Sbox[i][row][col];        bitset&lt;4&gt; v(val);        string t &#x3D; v.to_string();        reverse(t.begin(), t.end());        bitset&lt;4&gt; v_rev(t);        for (int j &#x3D; 0; j &lt; 4; j++) &#123;            output[i * 4 + j] &#x3D; v_rev[j];        &#125;    &#125;    bitset&lt;32&gt; output_P;    for (int i &#x3D; 0; i &lt; 32; i++) &#123;        output_P[i] &#x3D; output[P[i] - 1];    &#125;    return output_P;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-讨论"><a href="#3-7-讨论" class="headerlink" title="3.7 讨论"></a>3.7 讨论</h3><p>DES 是一个十分完善的加密算法了, 但仍然有较为明显的争论:</p><ul><li>$ f $ 函数(尤其是S盒) 的设计原理未知</li><li>密钥长度过短: DES的实际密钥只需要56位的枚举, 因此在当前算力的条件下, 其无法抵御穷举式攻击</li></ul><p>随后, 为了解决上述问题, 也推出了二重DES &#x2F; 三重DES算法.</p><h2 id="4-分组密码的工作模式"><a href="#4-分组密码的工作模式" class="headerlink" title="4. 分组密码的工作模式"></a>4. 分组密码的工作模式</h2><blockquote><p>DES只负责对64位的密钥进行加密, 但实际生活中大部分明文是远超64位的, 因此我们设计了不同的工作模式, 使得DES可以处理任意长度的明文.</p></blockquote><p>在1977年DES颁布后, 1981年针对该算法制定了4种基本工作模式, 随后在2000年又有一种工作模式被加入, 共计5种常用工作模式:</p><ul><li>ECB: Electronic Codebook</li><li>CBC: Cipher Block Chaining</li><li>CFB: Ciphertext Feedback</li><li>OFB: Output Feedback</li><li>CRT: Counter Mode</li></ul><h3 id="4-1-电子密码本-ECB"><a href="#4-1-电子密码本-ECB" class="headerlink" title="4.1 电子密码本(ECB)"></a>4.1 电子密码本(ECB)</h3><p>电子密码本是最简单的工作模式, 其将明文分组后, 直接使用DES进行加密, 然后输出密文分组.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E5%AF%86%E7%A0%81%E5%AD%A6/Chap.4/ECB.png" alt="ECB"></p><p>本模式中, 各分组的加密结果不受其余分组的影响.</p><p>ECB的优劣:</p><ul><li>优<ul><li>可并行处理</li><li>误差传递仅会出现在对应的一个分组上, 不会影响其他分组</li></ul></li><li>劣<ul><li>无法隐藏明文的模式信息(相同的明文加密出的一定是相同的密文)</li></ul></li></ul><h3 id="4-2-密文分组链接模式-CBC"><a href="#4-2-密文分组链接模式-CBC" class="headerlink" title="4.2 密文分组链接模式(CBC)"></a>4.2 密文分组链接模式(CBC)</h3><p>CBC模式在ECB的基础上, 引入了初始向量(IV), 使得每个分组在加密前, 都会与上一个分组的密文进行异或操作, 然后再进行加密.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E5%AF%86%E7%A0%81%E5%AD%A6/Chap.4/CBC.png" alt="CBC"></p><p>各个分组的加密结果不仅受自身影响, 同时也受到其前方所有分组的影响( <del>这里有点类似区块链的感觉</del> )</p><h3 id="4-3-密文反馈模式-CFB"><a href="#4-3-密文反馈模式-CFB" class="headerlink" title="4.3 密文反馈模式(CFB)"></a>4.3 密文反馈模式(CFB)</h3><p>CFB模式在CBC的基础上, 将加密过程拆分为两部分: 生成密钥流和异或操作.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E5%AF%86%E7%A0%81%E5%AD%A6/Chap.4/CFB.png" alt="CFB"></p><p>CFB模式中, 每个分组在加密前, 都会先进行一次加密, 然后再与明文进行异或操作, 最后输出密文分组.</p><p>它相对于CBC好在哪? 我们会发现每一次加密过后, 会产生一定位数的 <strong>垃圾密钥流</strong> , 因此如果出错, 其影响的位数是有限的, 因为迟早这种错误引发的影响会被新的密钥流覆盖掉.</p><hr><p>至此, 本篇博文对于分组密码进行了初步梳理, 并给出了典型案例DES的详细实现.</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System-Chap.2</title>
      <link href="/posts/23774.html"/>
      <url>/posts/23774.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-2-CPU模式-OS服务"><a href="#操作系统-Chap-2-CPU模式-OS服务" class="headerlink" title="操作系统 Chap.2 CPU模式 &#x2F; OS服务"></a>操作系统 Chap.2 CPU模式 &#x2F; OS服务</h1><blockquote><p>本篇博文我们将更加详细地介绍关于CPU不同模式的实现方式, 以及操作系统的系统服务</p></blockquote><h2 id="1-CPU模式-CPU-Mode"><a href="#1-CPU模式-CPU-Mode" class="headerlink" title="1. CPU模式(CPU Mode)"></a>1. CPU模式(CPU Mode)</h2><p>在上篇博文中我们提及过, CPU有两种广为人知的模式:</p><ul><li>内核模式(Kernel Mode): 也称为管态(Manager Mode), CPU必须处于此模式才能执行内核代码</li><li>用户模式(User Mode): 也称为目态(Usual Mode), CPU通常在这个模式上执行用户代码</li></ul><h3 id="1-1-保护环-Protection-Ring"><a href="#1-1-保护环-Protection-Ring" class="headerlink" title="1.1 保护环(Protection Ring)"></a>1.1 保护环(Protection Ring)</h3><p>在现在操作系统中, CPU的不同模式是通过 <strong>保护环(Protection Ring)</strong> 来实现的, 不同等级的保护环代表着不同的权限等级. 通常 <strong>保护环等级越低, 权限越高</strong> .</p><blockquote><p>保护环是由上世纪60年代的操作系统: Multics 6400 所引入的概念, 尽管这个操作系统并不成功, 但其引入的许多概念直至今日仍然再为许多操作系统所采用</p></blockquote><p>举例而言, 一个x86架构的CPU, 通常会有以下几种保护环:</p><ul><li>Ring 0: 内核模式</li><li>Ring 1: 系统服务</li><li>Ring 2: 设备驱动</li><li>Ring 3: 用户模式</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/Protection%20Ring.png" alt="Protection Ring"></p><h3 id="1-2-有必要吗"><a href="#1-2-有必要吗" class="headerlink" title="1.2 有必要吗?"></a>1.2 有必要吗?</h3><p>为什么操作系统必须衍生出这么多的环? 有何好处?</p><p>从分层角度而言, 衍生出不同权限等级的保护环至少有三种好处:</p><ul><li><strong>Fault Isolation</strong> : 即 <strong>故障隔离</strong> , 一个在高层环(如Ring 3)的程序崩溃, 不会影响到底层环(如Ring 0)的程序, 同时, 这个故障通常还能够被底层环中的某些代码处理</li><li><strong>Privileged instructions</strong> : 即 <strong>特权指令</strong> , 我们在第一章提到过这个概念, 通过不同保护环的划分, 操作系统能够更清晰的明确指令的权限等级, 并将其分配给不同等级的环.</li><li><strong>Privileged Memory Space</strong> : 即 <strong>特权内存</strong> , 不同的保护环有不同的内存访问权限. 这有利于内存的划分.</li></ul><p>我们通过几个例子来进一步理解上面的说法:</p><ul><li>在用户模式下出现的各种问题(Eg. 除0 &#x2F; 非法访问 &#x2F; 空指针引用等)能够被内核捕获并抛出异常, 从而不会使得整个系统崩溃.</li><li>很多特权指令只能通过内核模式来运行, 用户模式通常会抛出异常(Eg. 在x86架构中, 在Ring 3 中执行特权指令会引发异常: GP (General Protection) exceptions)</li><li>某些内存仅有内核模式能够读写(Eg: 在上篇博文中提及的, 用于Multi programming的进程列表等)</li></ul><blockquote><p>我们需要指出, 除Kernel Mode和User Mode外, 还有两个概念: <strong>Real Mode 和 Protect Mode</strong> , 这两个模式与前两者并不相同, Real Mode 模式下, 并没有保护环的概念, 所有指令都可以执行, 所有内存都可以访问, 它通常被用于早期计算机中; 而Protect Mode 模式下, 引入了保护环机制, 是现代操作系统的基础.</p></blockquote><h3 id="1-3-模式切换-Mode-Switch"><a href="#1-3-模式切换-Mode-Switch" class="headerlink" title="1.3 模式切换(Mode Switch)"></a>1.3 模式切换(Mode Switch)</h3><p>如果特权指令的限制如此严格(甚至I&#x2F;O都是特权指令), 那么用户程序如何能够与硬件进行交互?</p><p>通常, 用户程序通过 <strong>系统调用(System Call)</strong> 来进行模式切换, 进而调用特权指令.</p><p>举例而言, printf函数的执行过程:</p><p><em><strong>printf libc call(Ring 3) &#x3D;&gt; write system call &#x3D;&gt; Kernel Mode(Ring 0)</strong></em></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/System%20Call.png" alt="System Call"></p><hr><p><strong>Root &amp; UnRoot?</strong></p><p><strong>明确指出, Root这个概念与Kernel Mode并不是一个概念!</strong></p><p>Root 通常指的是一个具有超级权限的用户, 他可以访问所有文件; 而未获得Root权限的用户只能访问系统中的部分文件.</p><p>但不论是否是Root用户, CPU都将处于User Mode, 当需要执行特权指令时, 仍然需要通过上文所述的方式进入内核模式.</p><hr><h3 id="1-4-保护环-虚拟化-Ring-Virtualization"><a href="#1-4-保护环-虚拟化-Ring-Virtualization" class="headerlink" title="1.4 保护环 &amp; 虚拟化(Ring &amp; Virtualization)"></a>1.4 保护环 &amp; 虚拟化(Ring &amp; Virtualization)</h3><p>在介绍本部分之前, 我们需要先引入一个概念: HyperVisor.</p><p><em>A Hypervisor is a Virtual Machine Monitor (VMM) that runs and manages virtual machines</em></p><p><em>Hypervisor是一个虚拟机监控设备, 负责运行 &#x2F; 管理全部虚拟机.</em></p><p>因此理论上, HyperVisor所处的保护环层级必须要比虚拟机的操作系统(VM Kernel)要低, 这样其才能控制虚拟机, 或捕获由于虚拟机所产生的异常.</p><p>那放哪呢?</p><p>传统的方式是 <strong>HyperVisor运行在Ring 0, 将 VM Kernel上移到 Ring 1</strong> . 当虚拟机需要运行特权指令时, 通过陷阱(Trap)机制, 由HyperVisor捕获并执行.</p><p>这种方式的代价是运行效率的降低, 因为这种陷阱机制需要二进制转译, 额外增加了模式切换的开销.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/Full%20virtualization%20using%20Binary%20Translation.png" alt="Full virtualization using Binary Translation"></p><p>为了解决这个问题, 在2005 &#x2F; 2006年, Intel和AMD分别推出了一个额外的保护环层级: Ring -1, 这使得虚拟化有了新的构建方式: 将HyperVisor单独运行在Ring -1, 将VM Kernel运行在Ring 0.</p><p>这样做的好处在于, 虚拟机系统本身仍处于Ring 0, 因此它与VMM的通信无需进行二进制转译, 这大幅度提高了运行效率.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/Full%20virtualization%20without%20Binary%20Translation.png" alt="Full virtualization without Binary Translation"></p><h2 id="2-操作系统相关服务-Operating-System-Services"><a href="#2-操作系统相关服务-Operating-System-Services" class="headerlink" title="2. 操作系统相关服务(Operating System Services)"></a>2. 操作系统相关服务(Operating System Services)</h2><p><em>Operating systems provide an environment for <strong>execution of programs</strong> and <strong>services to programs and users.</strong></em><br><em>操作系统为程序的正确执行提供相关环境, 并为程序及用户提供相对应的服务.</em></p><h3 id="2-1-用户服务"><a href="#2-1-用户服务" class="headerlink" title="2.1 用户服务"></a>2.1 用户服务</h3><ul><li>用户界面(User Interface &#x2F; UI)<ul><li>Command Line(CLI)</li><li>Graphics User Interface(GUI)</li><li>Batch</li></ul></li><li>程序执行(Program Excution)<ul><li>向内存中装载程序</li><li>提供中断服务(正常中断 &#x2F; 异常)</li></ul></li><li>I&#x2F;O操作(I&#x2F;O Operations)</li><li>操作文件系统(File-System Manipulation)<ul><li>增删改查</li></ul></li><li>信息交换(Communications)<ul><li>通过共享内存或消息传递管道</li></ul></li><li>错误检测(Error Detection)</li></ul><h3 id="2-2-提升运行效率的服务"><a href="#2-2-提升运行效率的服务" class="headerlink" title="2.2 提升运行效率的服务"></a>2.2 提升运行效率的服务</h3><ul><li>合理的资源分配(Resource Allocation)<ul><li>处理器周期</li><li>主存</li><li>文件储存</li></ul></li><li>审计 &#x2F; 统计(Accounting)<ul><li>跟踪当前所有的用户, 即他们在使用多少 &#x2F; 如何使用当前的计算机资源</li></ul></li><li>保护 &#x2F; 安全事项<ul><li>保证当前所有访问系统的操作均处于控制下</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/System%20call%20Services.png" alt="Operating System Services"></p><h3 id="2-3-系统调用-System-Calls"><a href="#2-3-系统调用-System-Calls" class="headerlink" title="2.3 系统调用(System Calls)"></a>2.3 系统调用(System Calls)</h3><p>本质上而言, 是操作系统为程序提供服务的接口. 通常使用高级语言(C &#x2F; C++)书写.</p><p>当然, 通常会通过更高层的 <strong>应用程序接口(Application Programming Interface &#x2F; API)</strong> 进行间接调用, 直接进行调用的情况较少.</p><p>典型的案例如:</p><ul><li>Win32 API(Windows)</li><li>POSIX API(POSIX based systems, UNIX &#x2F; Linux &#x2F; Mac OS X)</li><li>Java API(Java Virtual Machine)</li></ul><h4 id="2-3-1-系统调用的实现"><a href="#2-3-1-系统调用的实现" class="headerlink" title="2.3.1 系统调用的实现"></a>2.3.1 系统调用的实现</h4><p>正常情况下, 系统会给出对每个系统调用给一个单独的数字来标识它. <strong>系统调用接口(System-call Interface)</strong> 维护着这样的一个索引表.</p><p>当应用程序接口(API)向系统调用接口(System call Interface)发出了对应的系统调用请求后, 系统调用接口在内核中调用预期的系统调用服务, 并返回执行状态(或任何返回值).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/System%20Call%20Table.png" alt="System Call Table"></p><blockquote><p>这样设计的目的在于简化程序设计的流程, 程序设计者不需要知道系统调用的具体细节, 只需要遵守API的规则并得知内核会返回什么东西即可.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/API%20%26%20System%20call.png" alt="How a application invoke System call"></p><h4 id="2-3-2-系统调用的信息-参数传递-Parameter-Passing"><a href="#2-3-2-系统调用的信息-参数传递-Parameter-Passing" class="headerlink" title="2.3.2 系统调用的信息 &#x2F; 参数传递(Parameter Passing)"></a>2.3.2 系统调用的信息 &#x2F; 参数传递(Parameter Passing)</h4><p>通常而言, 应用进行系统调用时, 除了索引表中的索引外, 还需要传递其余不少参数.</p><p>这种参数传递通常有三种方法:</p><ul><li>直接通过寄存器传递参数(Through registers)</li><li>将参数存储在块或表中, 并通过寄存器将指定块 &#x2F; 表的地址传入(Address Passing)</li><li>将参数入栈, 操作系统将自行将栈中的参数弹出.(Through Stack)</li></ul><h4 id="2-3-3-系统调用提供的服务"><a href="#2-3-3-系统调用提供的服务" class="headerlink" title="2.3.3 系统调用提供的服务"></a>2.3.3 系统调用提供的服务</h4><p>总体而言, 系统调用提供的服务与上文中操作系统所提供的服务高度重合. <del>(废话, 不高度重合怎么实现操作系统的功能)</del></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Operation-System-Chap-2/System%20call%20Services.png" alt="System call Services"></p><blockquote><p>可以通过 <strong>starce</strong> &#x2F; <strong>ltrace</strong> 来跟踪系统调用(System Call) &#x2F; 库调用(Library Call)</p></blockquote><hr><p>本章节主要对CPU的不同模式以及操作系统服务(尤其是系统调用)进行了说明.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System-Chap.1</title>
      <link href="/posts/23966.html"/>
      <url>/posts/23966.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统-Chap-1-介绍"><a href="#操作系统-Chap-1-介绍" class="headerlink" title="操作系统 Chap.1 介绍"></a>操作系统 Chap.1 介绍</h1><blockquote><p>写在前面:<br>本部分章节的几乎全部内容来自于博主大学中的课程: 操作系统. 由于博主所参与的课程是英文PPT授课, 因此会尽可能将对应内容结合书本进行中文的整理. 但文中用词不当等问题, 还敬请读者海涵.<br>本部分文章应当会涉及到以下内容: (1)数据结构(Data Structure); (2)计算机组成原理(Computer Hardware Foundations); (3)C++相关内容<br>我们正式开始.</p></blockquote><h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统?"></a>1.1 什么是操作系统?</h3><p><strong>操作系统(Operating System)</strong> 这个名词我们都不陌生. 其系统定义却显得有些模糊.</p><p><em>Operating System acts as an intermediary between a user of a computer and the computer hardware.</em></p><p><em>操作系统在计算机中作为中介存在于电脑用户与电脑硬件之间.</em></p><p>一个合格的操作系统的目标是很明确的:</p><ul><li>能够运行用户的程序, 使用户解决问题的过程变得更简单</li><li>将计算机变得更加简单易用</li><li>以一种有效率的方式利用计算机的硬件</li></ul><h3 id="1-2-操作系统的作用"><a href="#1-2-操作系统的作用" class="headerlink" title="1.2 操作系统的作用?"></a>1.2 操作系统的作用?</h3><p>为什么我们几乎必须需要一个操作系统? 以英文的简写来描述的话, 可以归纳为: <strong>RIPS</strong></p><ol><li>Resource Management: 资源管理</li><li>Inter-process Communication(IPC): 进程间通信</li><li>Protection(Isolation &amp; Access Control): 必要的保护工作(如隔离 &#x2F; 权限控制)</li><li>Services to User Programs(System Calls): 为用户程序提供服务(如System Calls系列命令)</li></ol><blockquote><p>我们需要注明的是: 不同的设备, 所配备的操作系统的侧重点必然不同.<br>例如: 个人计算机(PC)只需要供给某一个用户的需求, 因此它只需要全力照顾这一个用户的需求即可; 但如果是服务器(Server)等场景, 它就需要同时处理, 分配资源给多个用户, 这二者的操作系统需要达成的目标不同, 其功能侧重点也必然有所差距.</p></blockquote><h3 id="1-3-计算机系统结构"><a href="#1-3-计算机系统结构" class="headerlink" title="1.3 计算机系统结构"></a>1.3 计算机系统结构</h3><p>从系统的划分来看, 计算机系统能够被划分为以下四个部分:</p><ul><li>Hardware: 硬件, 提供最基础的计算资源<ul><li>CPU</li><li>Memory</li><li>I&#x2F;O Devices</li></ul></li><li>Operating System: 操作系统, 控制 &#x2F; 协调各个用户与应用对底层硬件资源的使用</li><li>Application programs: 用户程序, 定义应当使用何种资源来解决使用者的问题<ul><li>Word Processors</li><li>Web Browsers</li><li>Video Games</li></ul></li><li>Users: 使用者<ul><li>People</li><li>Machines</li><li>Other Computers</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Four%20Components%20of%20a%20Computer%20System.png" alt="计算机系统的四个部分"></p><h3 id="1-4-操作系统的子系统"><a href="#1-4-操作系统的子系统" class="headerlink" title="1.4 操作系统的子系统?"></a>1.4 操作系统的子系统?</h3><p>操作系统手下按照功能, 分出了四个子系统:</p><ul><li>Process Management: 进程管理<ul><li>Processes: 进程</li><li>Threads: 线程</li><li>Synchronization: 同步</li></ul></li><li>Memory Management: 内存管理<ul><li>Physical Memory: 物理内存</li><li>Virtual Memory: 虚拟内存</li></ul></li><li>Device Management: 设备管理<ul><li>Networks: 网络</li><li>Display: 显示设备</li></ul></li><li>Information Managent: 信息管理<ul><li><strong>File Systems</strong> : 文件管理系统</li><li>File Sharing &amp; Protection: 文件共享 &#x2F; 保护</li></ul></li></ul><h3 id="1-5-所以-究竟怎么总结操作系统这么个玩意"><a href="#1-5-所以-究竟怎么总结操作系统这么个玩意" class="headerlink" title="1.5 所以, 究竟怎么总结操作系统这么个玩意?"></a>1.5 所以, 究竟怎么总结操作系统这么个玩意?</h3><p>其实, 并没有系统的定义. 但我们可以大致将其看成:</p><ul><li>A Resource allocator: 一个资源分配者, 为其他所有程序分配资源</li><li>A Control Program: 一个控制程序, 管理着所有其他程序的执行.</li></ul><hr><p><em><strong>“The one Program running at all time on the computer” is the Kernel. Everything else if either a System Program or an Application Program.</strong></em></p><p><em>我们需要明确, 在电脑上始终运行着的程序是 <em><strong>内核</strong></em> , 任何其它的程序要么是系统程序, 要么是应用程序.</em></p><h2 id="2-内存管理-中断"><a href="#2-内存管理-中断" class="headerlink" title="2. 内存管理 &#x2F; 中断"></a>2. 内存管理 &#x2F; 中断</h2><h3 id="2-1-内存的分配方式"><a href="#2-1-内存的分配方式" class="headerlink" title="2.1 内存的分配方式"></a>2.1 内存的分配方式</h3><p>通常而言, CPU 以及 全部设备的控制器通过总线与一片公用的内存相连, 这代表着所有的CPU与设备需要争夺内存的访问周期. 争夺结果需要由操作系统决定.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Memory%20Competing.png" alt="Memory Competing"></p><h3 id="2-2-本地缓冲区"><a href="#2-2-本地缓冲区" class="headerlink" title="2.2 本地缓冲区"></a>2.2 本地缓冲区</h3><p>我们上文提到, 每种设备都涉及到自己的控制器.</p><p>事实上, 每种设备控制器都下属着自己的一类设备类型, 同时, 每种设备类型都拥有自己的缓冲区, 用于存放数据.</p><p>这个缓冲区被称为设备的 <strong>本地缓冲区(Local Buffer)</strong> , CPU &#x2F; 设备控制器通过本地缓冲区 向 &#x2F; 从 设备 发送 &#x2F; 接受 数据.</p><p>当然, CPU与设备控制器之间也需要移交控制权, 因此, 产生了 <strong>中断机制(Interrupt)</strong> .</p><h3 id="2-3-中断"><a href="#2-3-中断" class="headerlink" title="2.3 中断"></a>2.3 中断</h3><p>通常而言, <strong>中断</strong> 代表着设备将控制权通过 <strong>中断向量</strong> 转移至 <strong>终端服务进程</strong> . 相对应的, 中断向量拥有计算机全部服务的中断进程地址.</p><blockquote><p>我们需要指出, 并不是只有程序运行完毕后才会产生中断, 当出现了用户请求 &#x2F; 异常时, 也会产生中断, 这种中断我们一般称之为 <strong>陷阱(Trap)</strong> &#x2F; <strong>异常(Exception)</strong></p></blockquote><p>当中断产生时, 操作系统会 <strong>保护现场</strong> , 通常表现为 <strong>存储寄存器 &#x2F; 程序计数器的值</strong> . 随后, 会判断产生中断的类型, 通常由两类:</p><ul><li>Polling: 轮询</li><li>Vectored Interrupt: 向量中断</li></ul><p>不同类型的中断会通过不同的代码(Vector Number)进行标识, 操作系统根据代码类型决定如何处理中断.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Interrupt%20Table.png" alt="Interrupt Vector Table"></p><p>通常而言, 现代操作系统是 <strong>中断驱动</strong> 的.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Interrupt%20Timeline.png" alt="Interrupt Timeline"></p><h3 id="2-4-DMA-Direct-Memory-Access"><a href="#2-4-DMA-Direct-Memory-Access" class="headerlink" title="2.4 DMA(Direct Memory Access)"></a>2.4 DMA(Direct Memory Access)</h3><p>在计算机组成原理中提及过这个概念.</p><p><em>Device Controller transfers blocks of data from buffer storage directly to main memory without CPU intervention.</em></p><p><em>设备控制器可以直接将数据块从缓冲存储直接传输到主内存, 而不需要CPU的干预.</em></p><p>之所以这样做, 是为了避免过多的中断影响某些高速IO设备的效率, 尽可能地让数据传输速率接近内存读写速度.</p><h3 id="2-5-内存结构"><a href="#2-5-内存结构" class="headerlink" title="2.5 内存结构"></a>2.5 内存结构</h3><p>内存的结构可大致划分为四个部分:</p><ul><li>Main memory: 主内存<ul><li>是CPU可以直接访问的唯一大型存储器</li><li>随机存储</li><li>通常易失</li></ul></li><li>Secondary storage: 二级存储<ul><li>主内存的扩展, 提供非易失存储空间</li></ul></li><li>Hard Disk Drives(HDD): 硬盘</li><li>Non-volatile memory: 非易失性内存</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Storage%20Hierarchy.jpg" alt="Storage Hierarchy"></p><hr><p>回过头来, 我们给一张现代计算机的运行方式图:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/How%20Modern%20Computer%20Works.jpg" alt="How a Modern Computer Works"></p><p>对于操作系统, 它所涉及到的内存管理活动主要有:</p><ul><li>监视当前内存的使用情况, 具体而言, 哪块内存被哪个程序所使用?</li><li>分配 &#x2F; 释放内存, 决定哪个进程的数据能够被放入 &#x2F; 移出内存?</li></ul><h2 id="3-多核-多进程"><a href="#3-多核-多进程" class="headerlink" title="3. 多核 &#x2F; 多进程"></a>3. 多核 &#x2F; 多进程</h2><h3 id="3-1-多处理器系统"><a href="#3-1-多处理器系统" class="headerlink" title="3.1 多处理器系统"></a>3.1 多处理器系统</h3><p>虽然大多数计算机如今仍然是单处理器的, 但不可否认, 多处理器系统已经出现, 并被广泛应用.</p><p>这样的系统也被称为 <strong>并行系统(Parallel System)</strong> .</p><ul><li><strong>SMP(Symmetric Multiprocessing)</strong> : 对称多处理器系统</li><li><strong>ASMP(Asymmetric Multiprocessing)</strong> : 非对称多处理器系统</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Symmetric%20Multiprocessing%20Architecture.jpg" alt="Symmetric Multiprocessing Architecture"></p><p>当然, 多处理器系统并不是我们介绍的重点, 我们这部分暂且先行掠过.</p><h3 id="3-2-多道程序设计-Multiprogramming"><a href="#3-2-多道程序设计-Multiprogramming" class="headerlink" title="3.2 多道程序设计(Multiprogramming)"></a>3.2 多道程序设计(Multiprogramming)</h3><p><strong>多道程序设计</strong> 指的是操作系统通过维护内存中的任务列表, 来保证CPU的资源能够时刻被利用, 是一种提高资源利用率的做法.</p><p>具体而言, OS会将当前计算机需要执行的所有任务统一压入内存中, 并通过 <strong>调度器(Scheduler)</strong> 来决定当前CPU应该执行哪个任务. 如果当前执行的任务需要等待中断(如I&#x2F;O操作), 则调度器会切换至下一个任务.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Memory%20Layout%20for%20Multiprogrammed%20System.png" alt="Memory Layout for Multiprogrammed System"></p><h3 id="3-3-多任务-Timesharing-Multitasking"><a href="#3-3-多任务-Timesharing-Multitasking" class="headerlink" title="3.3 多任务(Timesharing &#x2F; Multitasking)"></a>3.3 多任务(Timesharing &#x2F; Multitasking)</h3><p><strong>多任务</strong> 是现代操作系统的一大扩展, 不同于多道程序设计, 它保证CPU会在当前电脑的所有任务之间频繁切换, 保证每个任务都能够获取到部分CPU资源, 以达到用户同时与多个程序交互的目的.</p><h3 id="3-4-多模式设计-Multimode-Operation"><a href="#3-4-多模式设计-Multimode-Operation" class="headerlink" title="3.4 多模式设计(Multimode Operation)"></a>3.4 多模式设计(Multimode Operation)</h3><p>最普遍为人所知的设计被称作 <strong>Dual-mode</strong> , 即 <strong>用户模式(User Mode)</strong> 和 <strong>内核模式(Kernel Mode)</strong> . 这种设计的出现是为了使系统更加安全, 防止用户程序对系统造成破坏.</p><p>具体而言, 硬件自身会根据当前所处模式给出模式位, 操作系统会根据模式位来决定是否允许当前程序访问某些资源.</p><p>有些指令(Instructions)被标记为 <strong>特权指令(Privileged Instructions)</strong> , 这代表着它们只能在内核模式下才能被运行.</p><p>当用户程序需要调用相关的指令时, 往往通过System Call的方式, 将当前模式切换至内核模式; 当特权指令执行完毕后, 会将模式切换回用户模式.</p><p>当然, 对于操作系统来说, 它需要保证用户程序不会无限期的通过System Call来占用CPU资源. 因此, 操作系统会为每个程序设置一个计时器, 当计时器到期时, 操作系统会强制收回权限, 严重时直接终止程序.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Operating%20System/Chap.1/Dual-mode.png" alt="Dual-mode"></p><h3 id="3-5-进程管理-Process-Management"><a href="#3-5-进程管理-Process-Management" class="headerlink" title="3.5 进程管理(Process Management)"></a>3.5 进程管理(Process Management)</h3><p>进程管理是操作系统的一大核心, 我们需要先搞清楚两个概念的区别.</p><p><em>A process is a program in execution, it is a unit of work within the system. Program is a Passive Entity, Process is a Active Entity.</em></p><p><em>一个进程是一个正在被执行的程序, 表现为系统中的一系列任务集合. 程序是一个被动实体, 而进程是一个主动实体.</em></p><blockquote><p>线程与进程不同, 线程是进程的一个子集, 一个进程可以包含多个线程, 但一个线程只能属于一个进程.</p></blockquote><p>通常而言, 进程分 <strong>单线程进程(Single-threaded Process)</strong> 和 <strong>多线程进程(Multi-threaded Process)</strong> 两种. 对于前者, 它只有一个 <strong>程序计数器(Program Counter)</strong> , 负责记录下一个要执行的指令的位置; 对于后者, 它的每个线程都有一个程序计数器.</p><p>对于操作系统, 它在进程管理过程中的主要作用如下:</p><ul><li>创建(Create) &#x2F; 终止(Terminate) 用户 &#x2F; 系统进程</li><li>暂停(Suspend) &#x2F; 恢复(Resume) 进程</li><li>提供进程同步(Synchronization) &#x2F; 通信(Communication) 机制</li><li>提供死锁(DeadLock)处理机制</li></ul><h2 id="4-信息管理"><a href="#4-信息管理" class="headerlink" title="4. 信息管理"></a>4. 信息管理</h2><p>现代操作系统将各类物理属性抽象成了信息存储单元, 我们称之为 <strong>文件(File)</strong> . 因此, 对信息的管理实质上很大程度上依赖于 <strong>文件系统(File System)</strong> .</p><h3 id="4-1-文件系统-File-System"><a href="#4-1-文件系统-File-System" class="headerlink" title="4.1 文件系统(File System)"></a>4.1 文件系统(File System)</h3><p>操作系统对于文件管理的参与主要有:</p><ul><li>创建 &#x2F; 删除文件(夹)</li><li>操作 文件 &#x2F; 目录 的属性</li><li>将文件映射到辅助存储(Secondary Storage)上</li><li>文件的备份 &#x2F; 恢复</li></ul><hr><p>本章节仅是一个引入章节, 目的在于对操作系统的一系列功能做出一些最基本的说明.</p><p>更细节的部分将在后续章节中进行详细讨论.</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-Chap.3</title>
      <link href="/posts/4438.html"/>
      <url>/posts/4438.html</url>
      
        <content type="html"><![CDATA[<h1 id="密码学-Chap-3-古典密码学"><a href="#密码学-Chap-3-古典密码学" class="headerlink" title="密码学 Chap.3 古典密码学"></a>密码学 Chap.3 古典密码学</h1><h2 id="1-古典密码概述"><a href="#1-古典密码概述" class="headerlink" title="1. 古典密码概述"></a>1. 古典密码概述</h2><p><em>In cryptography, a classical cipher is a type of cipher that was used historically but for the most part, has fallen into disuse.</em><br>-From Wikipedia</p><p><strong>古典密码</strong> , 指的是在计算机出现之前, 人类使用各种方法进行加密和解密的技术. 但时至如今, 由于计算机的出现, 大部分古典密码算法已经不再使用.</p><h3 id="1-1-古典密码的分类"><a href="#1-1-古典密码的分类" class="headerlink" title="1.1 古典密码的分类"></a>1.1 古典密码的分类</h3><p>古典密码按照加密方式的不同, 主要分以下几类:</p><ul><li><strong>代换密码</strong> : 即基于字符的密码, 其将明文中的每一个字符替换成密文中的另一个字符.<ul><li>单字母代换密码<ul><li>单表代换密码</li><li>多表代换密码</li></ul></li><li>多字母代换密码</li></ul></li><li><strong>置换密码</strong> : 又被称为 <strong>换位密码</strong> , 明文中的字母保持相同, 但顺序被打乱了.</li><li><strong>轮转机</strong></li></ul><h3 id="1-2-单字母代换密码"><a href="#1-2-单字母代换密码" class="headerlink" title="1.2 单字母代换密码"></a>1.2 单字母代换密码</h3><p><strong>单字母代换密码</strong> , 又称 <strong>简单代换密码</strong> , 是一种最简单的代换密码, 其将明文中的每一个字符替换成密文中的另一个字符.</p><ul><li>单表代换密码<ul><li><strong>移位密码</strong> (Shift Cipher)</li><li>乘数密码 (Multiplicative Cipher)</li><li><strong>仿射密码</strong> (Affine Cipher)</li><li>多项式密码 (Polynomial Cipher)</li></ul></li><li>多表代换密码<ul><li><strong>维吉尼亚密码</strong> (Vigenere Cipher)</li><li>博福特密码 (Beaufort Cipher)</li><li>滚动密钥密码 (Running-Key Cipher)</li></ul></li></ul><h3 id="1-3-多字母代换密码"><a href="#1-3-多字母代换密码" class="headerlink" title="1.3 多字母代换密码"></a>1.3 多字母代换密码</h3><p><strong>多字母代换密码</strong> , 又称 <strong>矩阵变换密码</strong> , 特点表现为能够通过矩阵变换方便的描述和实现.</p><ul><li><strong>希尔密码</strong> (Hill Cipher)</li><li><strong>Playfair密码</strong> (Playfair Cipher)</li></ul><h2 id="2-单字母代换密码"><a href="#2-单字母代换密码" class="headerlink" title="2. 单字母代换密码"></a>2. 单字母代换密码</h2><h3 id="2-1-单表代换密码"><a href="#2-1-单表代换密码" class="headerlink" title="2.1 单表代换密码"></a>2.1 单表代换密码</h3><h4 id="2-1-1-移位密码-Shift-Cipher"><a href="#2-1-1-移位密码-Shift-Cipher" class="headerlink" title="2.1.1 移位密码 (Shift Cipher)"></a>2.1.1 移位密码 (Shift Cipher)</h4><p><strong>移位密码</strong> 是一种最简单的单表替换密码, 其具体规则为: 将明文中的每一个字符替换成其后面第 $ k $ 个字符, 其中 $ k $ 被称为为密钥(Key).</p><p>$$ e_k(x) &#x3D; (x + k) mod \space 26 $$</p><p>$$ d_k(y) &#x3D; (y - k) mod \space 26 $$</p><blockquote><p>之所以以e &#x2F; d 开头, 是因为加密 &#x2F; 解密的英文: <strong>encrypt &#x2F; decrypt</strong> . <strong>这种写法我们会经常用到, 读者请注意.</strong></p></blockquote><p>由于上述加密机制最初被 <strong>儒勒 · 凯撒</strong> 所用(当时 $ k &#x3D; 3 $ ) , 因此当 k &#x3D; 3 时, 移位密码又被称为 <strong>凯撒密码</strong> (Caesar Cipher).</p><hr><p>这种加密机制显然不够安全, 在当前的计算机背景下, 破译者只需要进行密钥穷举, 就能很轻松地得到原来的明文.</p><p><strong>一个密码体制安全</strong> 的 <strong>必要条件</strong> 是能够抵抗穷尽密钥的攻击, 最普遍的做法是密钥空间足够大. 显然, 移位密码完全不符合这个条件.</p><h4 id="2-1-2-仿射密码-Affine-Cipher"><a href="#2-1-2-仿射密码-Affine-Cipher" class="headerlink" title="2.1.2 仿射密码 (Affine Cipher)"></a>2.1.2 仿射密码 (Affine Cipher)</h4><p><strong>仿射密码</strong> 是一种比移位密码更复杂的单表替换密码, 其将移位密码中的明文字符值前方加了一个系数.</p><p>$$ e(x) &#x3D; (ax + b) mod \space 26 $$</p><blockquote><p>需要注明, 当 $ b &#x3D; 0 $ 时, 就是我们所说的乘积密码(Multiplicative Cipher).</p></blockquote><p>显然, 这种机制的解密并没那么简单了, 我们需要保证对于任意 $ y $ , 同余方程 $ ax + b \equiv y (mod \space 26) $ 有唯一解 $ x $ .</p><p>对于同于方程有了解的读者应当了解, 这需要 $ a $ 和 $ 26 $ 互素, 即 $ gcd(a, 26) &#x3D; 1 $ . </p><blockquote><p>如您还并不了解同余方程, 请见: <a href="https://mug-chen.site/posts/53655.html">密码学Chap.2 数论基础</a> 以及 <a href="https://mug-chen.site/posts/56920.html">信安数学基础-期末复习章</a> . 这两章中有更加详细的解释.</p></blockquote><hr><p>我们讨论一下仿射密码的密钥空间: </p><p>与26互素的数: {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25} , 共12个.</p><p>因此仿射密码的总密钥空间: $ 12 \times 26 &#x3D; 312 $ . 这对于现代计算机而言仍然不够安全.</p><h4 id="2-1-3-仿射密码的推广形式"><a href="#2-1-3-仿射密码的推广形式" class="headerlink" title="2.1.3 仿射密码的推广形式"></a>2.1.3 仿射密码的推广形式</h4><p>如果我们更加深入一点, 将仿射密码的机制进行推广, <strong>并不局限于26个字母的话</strong> , 我们可以得到更大的密钥空间.</p><p>$$ e(x) &#x3D; (ax + b) mod \space m $$</p><p>显然, 这要求 $ gcd(a, m) &#x3D; 1 $ , 总密钥空间为 $ \phi(m) \times m $ ( $ \phi $ 为欧拉函数).</p><h4 id="2-1-4-频率分析-对抗单表代换的利器"><a href="#2-1-4-频率分析-对抗单表代换的利器" class="headerlink" title="2.1.4 频率分析: 对抗单表代换的利器"></a>2.1.4 频率分析: 对抗单表代换的利器</h4><p>频率分析是古典密码学中最为经典的一种分析方式, 由于英文中的大部分字母出现频率是存在显著差别的, 因此我们可以通过分析密文中的字母频率, 来推测出明文.</p><p>举个例子: 在英文中, <strong>字母 E 出现的频率最高</strong> , 因此我们可以推测密文中出现频率最高的字母是明文中的 E , 此外, 双字符的统计频率也具有很高的参考价值, 比如常见的双字母组: {th &#x2F; he &#x2F; in &#x2F; er &#x2F; on &#x2F; an &#x2F; …}</p><h3 id="2-2-多表代换密码"><a href="#2-2-多表代换密码" class="headerlink" title="2.2 多表代换密码"></a>2.2 多表代换密码</h3><p><strong>多表代换密码</strong> 是对抗频率分析的有效手段. 其基本思想是: 将明文中的每一个字符替换成密文中的另一个字符, <strong>但密钥是变化的</strong> .</p><h4 id="2-2-1-维吉尼亚密码-Vigenere-Cipher"><a href="#2-2-1-维吉尼亚密码-Vigenere-Cipher" class="headerlink" title="2.2.1 维吉尼亚密码 (Vigenere Cipher)"></a>2.2.1 维吉尼亚密码 (Vigenere Cipher)</h4><p><strong>维吉尼亚密码</strong> 是一种多表代换密码, 其<strong>密钥是一个字符串</strong> (通常是一个单词), 明文中的每一个字符通过密钥中的字符进行加密, 密钥中的字符循环使用.</p><p>定义: $ K(Key) &#x3D; (k_1, k_2, k_3, … , k_n) $ </p><p>$$ e_K(x_1, x_2, x_3, … , x_m) &#x3D; (x_1 + k_1, x_2 + k_2, x_3 + k_3, … , x_m + k_m) mod \space 26 $$</p><p>$$ d_K(y_1, y_2, y_3, … , y_m) &#x3D; (y_1 - k_1, y_2 - k_2, y_3 - k_3, … , y_m - k_m) mod \space 26 $$</p><hr><p>我们对维吉尼亚的密钥空间进行一个简要的分析:</p><p>由于其密钥是一个长度为 m 的字符串, 因此其密钥空间为 $ 26^m $ .</p><p>显然, m 越长, 密钥空间越大, 因此维吉尼亚密码的安全性就越好.</p><blockquote><p>最理想的情况是, 密钥长度等同于明文长度. 此时被称为 <strong>滚动密钥密码</strong></p></blockquote><h4 id="2-2-2-随机序列密钥算法-Vernam-Cipher"><a href="#2-2-2-随机序列密钥算法-Vernam-Cipher" class="headerlink" title="2.2.2 随机序列密钥算法(Vernam Cipher)"></a>2.2.2 随机序列密钥算法(Vernam Cipher)</h4><p>随机序列密钥算法的思路与维吉尼亚密码类似, 但其密钥长度与明文长度相同, 且采用二进制数据进行加密:</p><p>$$ E: C_i &#x3D; P_i \bigoplus K_i $$</p><p>$$ D: P_i &#x3D; C_i \bigoplus K_i $$</p><blockquote><p>符号 $ \bigoplus $ 表示 <strong>异或运算</strong> .<br>C 通常表示 <strong>密文(Ciphertext)</strong> , P 通常表示 <strong>明文(Plaintext)</strong> .</p></blockquote><h2 id="3-多字母代换密码"><a href="#3-多字母代换密码" class="headerlink" title="3. 多字母代换密码"></a>3. 多字母代换密码</h2><h3 id="3-1-PlayFair密码算法-Playfair-Cipher"><a href="#3-1-PlayFair密码算法-Playfair-Cipher" class="headerlink" title="3.1 PlayFair密码算法(Playfair Cipher)"></a>3.1 PlayFair密码算法(Playfair Cipher)</h3><p>PlayFair密码算法是一种多表代换密码, <strong>其将明文中的双字母组根据一个由密钥生成的 $ 5 \times 5 $ 矩阵进行加密</strong> , 其加密方式如下:</p><ol><li><strong>生成密钥矩阵</strong> :</li></ol><p>预先写一个 $ 5 \times 5 $ 的矩阵, 然后自左上至右下填充字母, 先将密钥字(Key)中的字母填入, 然后将剩余的字母按字母表顺序填入, <strong>如果出现重复字母, 则跳过</strong> , 同时, <strong>字母 J 和 I 填入同一格内</strong> .</p><p>举个例子: 密钥为Cipher, 则密钥矩阵为:</p><pre class="line-numbers language-none"><code class="language-none">C I P H ER A B D FG K L M NO Q S T UV W X Y Z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>加密</strong> :</li></ol><p>先将明文中按照两个为一组的双字母组进行分组, 如果前后出现字母组的两个字母相同, <strong>则在两个字母之间填充分隔符</strong> (如x).</p><p>举个例子: Plaintext: <strong>Balloon</strong> -&gt; <strong>ba lx lo on</strong></p><p>然后, 对于每一个双字母组, <strong>在密钥矩阵中找到两个字母的位置</strong> , 然后根据以下规则进行加密:</p><ul><li>如果两个字母在同一行, 则将两个字母分别向右移动一位, 如果到达行末, 则移动到行首.</li><li>如果两个字母在同一列, 则将两个字母分别向下移动一位, 如果到达列末, 则移动到列首.</li><li>如果两个字母不在同行 &#x2F; 同列, 则取两个字母对应的矩形的另一个对角线上的两个字母.</li></ul><p>以上面的密钥矩阵与明文为例:</p><pre class="line-numbers language-none"><code class="language-none">C I P H ER A B D FG K L M NO Q S T UV W X Y Zba lx lo onba -&gt; dblx -&gt; splo -&gt; gson -&gt; ug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-希尔密码-Hill-Cipher"><a href="#3-2-希尔密码-Hill-Cipher" class="headerlink" title="3.2 希尔密码(Hill Cipher)"></a>3.2 希尔密码(Hill Cipher)</h3><p><strong>希尔密码</strong> 将明文中的字符按照规定的长度分为若干字符组, 然后对每一个字符组进行加密.</p><p>设一个长度为2的字符组, $ (p_1, p_2) $ , 则密钥必然为一个 $ 2 \times 2 $ 的矩阵 $ K $ , 加密方式如下:</p><p>$$ E: (c_1, c_2) &#x3D; (p_1, p_2) \times K $$</p><p>相应的, 解密方式:</p><p>$$ D: (p_1, p_2) &#x3D; (c_1, c_2) \times K^{-1} $$</p><p>其中, $ K^{-1} $ 为矩阵 $ K $ 的逆矩阵.</p><blockquote><p>对于希尔密码而言, 其矩阵的逆矩阵必须存在, <strong>并且矩阵的行列式必须与26互质</strong> (否则矩阵中的分数无法通过取模运算化为整数), 否则希尔密码无法进行解密.</p></blockquote><h2 id="4-置换密码"><a href="#4-置换密码" class="headerlink" title="4. 置换密码"></a>4. 置换密码</h2><p><strong>置换密码</strong> 的特点是: 明文中的字符在加密后保持不变, 只是位置发生了变化.</p><p>即定义有限集 $ X $ 上的置换( <strong>双射函数</strong> ): $ \pi:X \to X $</p><p>$$ e_{\pi}(x_1, x_2, …, x_m) &#x3D; (x_{\pi(1)}, x_{\pi(2)}, …, x_{\pi(m)}) $$</p><p>$$ d_{\pi}(y_1, y_2, …, y_m) &#x3D; (y_{\pi^{-1}(1)}, y_{\pi^{-1}(2)}, …, y_{\pi^{-1}(m)}) $$</p><p>上式中, $ \pi^{-1} $ 表示 $ \pi $ 的逆置换.</p><h3 id="4-1-栅栏密码-Rail-Fence-Cipher"><a href="#4-1-栅栏密码-Rail-Fence-Cipher" class="headerlink" title="4.1 栅栏密码(Rail Fence Cipher)"></a>4.1 栅栏密码(Rail Fence Cipher)</h3><p><em>In the rail fence cipher, the plaintext is written downwards diagonally on successive “rails” of an imaginary fence, then moving up when the bottom rail is reached, down again when the top rail is reached, and so on until the whole plaintext is written out.</em><br>From Wikipedia</p><p>栅栏密码是一种简单的置换密码, 将明文按照特定的规则(像一个栅栏)排列, 然后按照自上至下 &#x2F; 自左向右的顺序读取.</p><p>举个例子: Plaintext: WE ARE DISCOVERED. RUN AT ONCE!</p><p>按照3个栅栏排列:</p><pre class="line-numbers language-none"><code class="language-none">W . . . E . . . C . . . R . . . U . . . O . . . . E . R . D . S . O . E . E . R . N . T . N . E . . A . . . I . . . V . . . D . . . A . . . C . <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>形成密文: WECRUO ERDSOEERNTNE AIVDAC</p><hr><p>另一种方式是直接将明文进行划分, 横着写, 竖着读:</p><p>Plaintext: We are discovered. run at once.</p><p>共24个字母, 写成四行:</p><pre class="line-numbers language-none"><code class="language-none">W E A R E DI S C O V ER E D R U NA T O N C E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>形成密文: WIRAESETACDORORNEVUCDENE</p><p>解密时通过总字母数猜测栅栏数(就是写了几行), 竖着写再横着读就行.</p><hr><p>至此, 博主课内需要涉及到的古典密码学算法就可以结尾了.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学-Chap.2</title>
      <link href="/posts/53655.html"/>
      <url>/posts/53655.html</url>
      
        <content type="html"><![CDATA[<h1 id="密码学-Chap-2-数论基础"><a href="#密码学-Chap-2-数论基础" class="headerlink" title="密码学 Chap.2 数论基础"></a>密码学 Chap.2 数论基础</h1><blockquote><p>本博文的创作目的是为博主本学期课程 <em>密码学</em> 做一个整体的知识梳理与总结, 并希望有助于后续进一步扩展知识面.<br>希望能够帮助到读到本文的读者.<br>之所以从第二章开始, 是因为本文是按照读者所受教学顺序进行梳理的, 第一章绪论暂且放下不表.</p></blockquote><p>数论基础, 是以 <strong>整数的整除性</strong> 为中心的一部分知识. 至于为什么要在这里提及, 是因为 <strong>数论是密码学成立的基础</strong> , 在古典密码学 &#x2F; 公钥密码学等方面对数论均有涉及.</p><p>本章内容会与同博客中 <strong>信安数学基础_Fin</strong> 的内容高度重合, 在这里权当重新梳理了.</p><h2 id="1-整除"><a href="#1-整除" class="headerlink" title="1. 整除"></a>1. 整除</h2><p><strong>定义:</strong></p><p>设 a, b 是两个整数, 其中 $ b \neq 0 $ , 如果存在整数 m 使得 $ a &#x3D; bm $ 成立, 则我们称 <strong>b 整除 a</strong> 或 <strong>a 可被 b 整除</strong> , b可称为a的因数, a可称为b的倍数. 上述关系还可记作:</p><p>$$ b \mid a $$</p><p>反之, 则可记作:</p><p>$$ b \nmid a $$</p><p><strong>整除有以下几个性质:</strong></p><ol><li>If $ a \mid 1 $ , then $ a &#x3D; \pm 1 $</li><li>If $ a \mid b $ , and $ b \mid a $ , then $ a &#x3D; \pm b $</li><li>For any $ b \neq 0 $ , $ b \mid 0 $</li><li>If $ a \mid b $ and $ b \mid c $ , then $ a \mid c $ (传递性)</li><li>If $ b \mid g $ and $ b \mid h $ , then for arbitary integers m, n, there is $ b \mid (mg+nh) $</li></ol><h2 id="2-带余除法"><a href="#2-带余除法" class="headerlink" title="2. 带余除法"></a>2. 带余除法</h2><p><strong>定义:</strong></p><p>如 a, n是两个整数, 其中 $ n&gt;0 $ , 则存在两个整数 q, r, 使得 $ a &#x3D; nq+r $ , 其中 $ 0 \leq r &lt; n $ , $ q &#x3D; [a&#x2F;n] $ , 并且q与r是唯一的.</p><p>我们称q是 <strong>a被n除的不完全商</strong> , r是 <strong>a被n除的余数</strong> .</p><p>这带余除法有啥用呢?</p><p><strong>整数分类</strong></p><p>我们不扯那么多专业术语, 博主的理解, 就是以 n 为标尺, 将整数集合 <strong>根据除以n所得的余数</strong> 进行分类.</p><p>举个例子: 奇数偶数就相当于以2为标尺, 将整数集合分成了余数为 0 &#x2F; 1 的两个类.</p><p>这就是信安数学基础那一章中 <strong>剩余类</strong> 的概念.</p><h2 id="3-最大公约数"><a href="#3-最大公约数" class="headerlink" title="3. 最大公约数"></a>3. 最大公约数</h2><p><strong>定义:</strong></p><p>两个数 a, b 的最大公约数 c 满足:</p><ol><li>c 是 a, b 的公约数, 即 $ c \mid a $ and $ c \mid b $</li><li>a, b 的任意公约数均为 c 的因数, 即 If $ d \mid a $ and $ d \mid b $ , then $ d \mid c $ .</li></ol><p>我们将最大公约数记为: $ gcd(a, b) $ , 特殊的, 如果 $ gcd(a, b) &#x3D; 1 $ , 则称 <strong>a, b 互素</strong> .</p><p><strong>最大公约数有以下性质:</strong></p><ol><li>$ gcd(a, b) &#x3D; gcd(b, a) &#x3D; gcd(a, -b) &#x3D; gcd(\mid a\mid , \mid b \mid) &#x3D; gcd(a, a-b) $</li><li>$ gcd(0, a) &#x3D; a $</li></ol><p>怎么求最大公因数呢?</p><p><strong>欧几里得算法</strong></p><p>本质上是这个定理:</p><p>$$ gcd(a, b) &#x3D; gcd(b, a-kb) &#x3D; gcd(b, r) $$</p><p>也被称为 <strong>辗转相除法</strong> .</p><p>进行一系列辗转相除后, <strong>最后一个不等于0的余数</strong> 就是 $ gcd(a, b) $ 的值.</p><h2 id="4-模运算"><a href="#4-模运算" class="headerlink" title="4. 模运算"></a>4. 模运算</h2><p>模运算是专门用于余数运算的运算方式:</p><p>对于 $ a &#x3D; nq+r $ , 我们通常将 r 记作: $ r &#x3D; a \space mod \space n $</p><p>用模运算的方式表示剩余类:</p><p>$$ a \equiv b \space mod \space n $$</p><p>这说明 a, b 处于关于n的同一个剩余类内, 即 a, b 关于n同余.</p><p><strong>模运算还有以下性质:</strong></p><ol><li>$ [(a \space mod \space n)+(b \space mod \space n)] \space mod \space n &#x3D; (a+b) \space mod \space n $</li><li>$ [(a \space mod \space n)-(b \space mod \space n)] \space mod \space n &#x3D; (a-b) \space mod \space n $</li><li>$ [(a \space mod \space n) \times (b \space mod \space n)] \space mod \space n &#x3D; (a \times b) \space mod \space n $</li></ol><h2 id="5-剩余类"><a href="#5-剩余类" class="headerlink" title="5. 剩余类"></a>5. 剩余类</h2><p>我们一般将关于n的全部剩余类 (即 <strong>n就是上文中进行整数分类的标尺</strong> ) 记为 $ Z_n $ .</p><p>关于 $ Z_n $ , 上方的模运算有以下性质:</p><ul><li>交换律<ul><li>$ (w+x)mod \space n &#x3D; (x+w)mod \space n $</li><li>$ (w \times x)mod \space n &#x3D; (x \times w)mod \space n $</li></ul></li><li>结合律<ul><li>$ [(w+x)+y]mod \space n &#x3D; [w+(x+y)]mod \space n $</li><li>$ [(w \times x) \times y]mod \space n &#x3D; [w \times (x \times y)]mod \space n $</li></ul></li><li>分配律<ul><li>$ [w \times (x+y)]mod \space n &#x3D; [w \times x + w \times y]mod \space n $</li></ul></li><li>单位元<ul><li>$ (0+w)mod \space n &#x3D; w \space mod \space n $</li><li>$ (1 \times w)mod \space n &#x3D; w \space mod \space n $</li></ul></li></ul><blockquote><p>关于可约律, 会在介绍完 加法 &#x2F; 乘法逆元 后进行阐述.</p></blockquote><h2 id="6-加法逆元-乘法逆元"><a href="#6-加法逆元-乘法逆元" class="headerlink" title="6. 加法逆元 &#x2F; 乘法逆元"></a>6. 加法逆元 &#x2F; 乘法逆元</h2><p>对于 $ w \in Z_n $ , 存在 $ z \in Z_n $ , 使得 $ w+z \equiv 0 \space mod \space n $ , 则 <strong>w, z互为加法逆元</strong> , 记为 $ z &#x3D; -w $ .</p><p>类似的, 如果有 $ w \times z \equiv 1 \space mod \space n $ , 则 <strong>w, z互为乘法逆元</strong> .</p><blockquote><p>加法逆元总是存在的, 但并未每个w都能有乘法逆元.<br>事实上, 当且仅当w与当前标尺n互素时, w才有乘法逆元.(见下侧定理)</p></blockquote><p><strong>乘法逆元的存在性定理</strong></p><p>设 $ a \in Z_n $ , 若 $ gcd(a, n) &#x3D; 1 $ , 则 a 在 $ Z_n $ 中有乘法逆元.</p><p>根据上述定理, 可知任一素数 p 对应的 $ Z_p $ 中所有元素均有乘法逆元. (因为任何元素都与p互素)</p><p><strong>需要明确, 可约率成立的前提是元素有逆元.</strong></p><ul><li>可约率<ul><li>$ (a+b) \equiv (a+c) \space mod \space n $ , 则 $ b \equiv c \space mod \space n $ , 该式恒成立, 因为加法总是有逆元.</li><li>$ (a \times b) \equiv (a \times c) \space mod \space n $ , 则 $ b \equiv c \space mod \space n $ , 该式当且仅当 <strong>a有乘法逆元时成立</strong> .</li></ul></li></ul><h3 id="6-1-乘法逆元的求法"><a href="#6-1-乘法逆元的求法" class="headerlink" title="6.1 乘法逆元的求法"></a>6.1 乘法逆元的求法</h3><p>加法逆元很好求, 但乘法逆元不是很容易一眼瞪出来. 这时, 我们通常使用 <strong>扩展欧几里得算法</strong> .</p><p>所谓 <strong>扩展欧几里得算法</strong> , 意味着求出两数 a, b 的最大公约数 $ gcd(a, b) $ 后, 将整个过程逆着倒腾回去, 用 a, b 的线性组合表示出 $ gcd(a, b) $ , 即:</p><p>$$ gcd(a, b) &#x3D; n \times a + m \times b $$</p><p>我们假设想求 a 关于 b 的乘法逆元:</p><ul><li>利用欧几里得算法验证 $ gcd(a, b) &#x3D; 1 $</li><li>利用扩展欧几里得算法倒回去求出 m, n</li><li>这个m就是b的乘法逆</li></ul><p>具体过程读者可参考本博客中 <a href="https://mug-chen.site/posts/56920.html">信安数学基础_Fin</a> 这一章.</p><h2 id="7-素数"><a href="#7-素数" class="headerlink" title="7. 素数"></a>7. 素数</h2><p>如果整数p的因子只有 $ \pm 1, \pm p $ , 则p是素数.</p><p><strong>引入素数是为了引入一个重要定理: 整数分解定理</strong></p><p>任意整数 a 都能唯一的分解为下列形式:</p><p>$$ a &#x3D; p_1^{a_1}p_2^{a_2}…p_t^{a_t} $$</p><p>其中 $ p_1, p_2, …, p_t $ 均为素数.</p><p>我们用更加简洁的语言描述一下上面的定理:</p><p>$$ a &#x3D; \prod_{p \in P} p^{a_p} $$</p><p>这其中 $ P $ 是全体素数组成的集合. $ a_p $ 指的是对应素数的指数项(大部分取0) .</p><p>我们利用这种方式, 可以 <strong>利用一个唯一的非零指数列表来表示一个整数</strong> :</p><p>$$ 11011 &#x3D; \lbrace a_7 &#x3D; 1, a_{11} &#x3D; 2, a_{13} &#x3D; 1 \rbrace $$</p><p>即 $ 11011 &#x3D; 7^1 \times 11^2 \times 13^1 $</p><p>为啥要这么干呢, 因为这么表示整数可以很方便的表示两数的相乘, 将对应指数相加即可.</p><p>啥意思?</p><p>$ 12 &#x3D; \lbrace a_2 &#x3D; 2, a_3 &#x3D; 1 \rbrace $ , $ 18 &#x3D; \lbrace a_2 &#x3D; 1, a_3 &#x3D; 2 \rbrace $ . 则 $ 12 \times 18 &#x3D; \lbrace a_2 &#x3D; 2+1 &#x3D; 3, a_3 &#x3D; 1+2 &#x3D; 3 \rbrace $ .</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cryptography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/posts/9977.html"/>
      <url>/posts/9977.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-数据库"><a href="#1-1-数据库" class="headerlink" title="1.1 数据库"></a>1.1 数据库</h3><p>数据库（Database）是按照数据结构来组织、存储和管理数据的仓库, 每个数据库都有一个或多个不同的表, 用来存储数据.</p><p>按照 <strong>关系型数据库</strong> 的层次结构, 数据模型分为:</p><ul><li>库: 最大的存储结构</li><li>表: 每类数据存储在一张表中, 一个库中含有多个表</li><li>列: 每个表中该类数据的不同特性</li><li>行: 表中数据按行存储, 一行为一条记录</li></ul><p>很类似 Excel 的感觉, 对吧.</p><blockquote><p><strong>关系型 &amp; 非关系型?</strong></p><p><strong>非关系型数据库</strong> 主要通过键值对 &#x2F; 散列存储的方式进行存储, 这种数据库效率较高, 但能进行的操作也相对应的较为简单. </p><p>我们这里讲的MySQL属于关系型数据库, 数据之间有严格的相互关系, 这代表这我们数据库一旦建立, 就可以很轻松的进行各种操作, 但相对应的, 效率较低.</p></blockquote><h3 id="1-2-DBMS-数据库管理系统"><a href="#1-2-DBMS-数据库管理系统" class="headerlink" title="1.2 DBMS: 数据库管理系统"></a>1.2 DBMS: 数据库管理系统</h3><p>有了仓库, 自然就要有仓管, 我们所说的DBMS(DataBase Management System) 就起这个作用.</p><p>常见的DBMS有:</p><ul><li>MySQL</li><li>Oracle</li><li>DB2</li><li>SQLite</li><li>…</li></ul><p>我们本章节采用MySQL数据库管理系统进行数据库的各种操作.</p><p>MySQL目前的稳定版本分 5.7 和 8.0 两个版本, 我们这里采用8.0版本.</p><blockquote><p>详细版本号: 8.2.0</p></blockquote><p>至于MySQL的安装, 这里不再赘述, 读者可自行上网搜索, 很多的: )</p><p>需要明确的是, MySQL并不像传统的可视化程序, 它是一个后台服务, 安装全过程完成后, 它会跑在你电脑后台的一个端口上(我这边默认为3306)</p><p>这个服务默认开机自启动, 但如果读者发现哪次没有启动, 这里给出两种开启方式:</p><ul><li>通过呼出任务管理器, 在 <strong>服务</strong> 栏搜索MySQL, 找到对应的服务启动即可.</li><li>通过cmd(管理员权限)利用 <strong>net start &#x2F; stop (对应服务名)</strong> 进行开启 &#x2F; 关闭.</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/MySQL/cmd%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8MySQL.png" alt="cmd方式启动MySQL"></p><blockquote><p>别忘了在Path中加MySQL的bin目录, 这样就可以在cmd中直接使用MySQL命令了.</p></blockquote><h3 id="1-3-SQL-结构化查询语言"><a href="#1-3-SQL-结构化查询语言" class="headerlink" title="1.3 SQL: 结构化查询语言"></a>1.3 SQL: 结构化查询语言</h3><p>SQL(Structured Query Language) 是一种用于管理关系型数据库的编程语言, 它定义了操作数据库的各种语法, 通过SQL, 我们可以方便的进行各种数据库操作.</p><blockquote><p>SQL是标准化的语言, 不同的关系型数据库都支持SQL, 但同时不同的数据库管理系统也会进行相应的扩展. 这点根据不同的管理系统而定.</p></blockquote><p>本章中主要针对MySQL进行阐述, 因此主要针对MySQL的SQL语法进行讲解.</p><p>我们的SQL主要从如下方面进行:</p><ul><li>数据定义: DDL</li><li>数据操作: DML</li><li>数据查询: DQL</li><li>数据控制: DCL</li><li>事务控制: TCL</li></ul><h3 id="1-4-SQL可视化编写工具"><a href="#1-4-SQL可视化编写工具" class="headerlink" title="1.4 SQL可视化编写工具"></a>1.4 SQL可视化编写工具</h3><p>我们在进行数据库的操作时, 一般不会直接在命令行中编写SQL, 而是使用一些可视化工具, 如:</p><ul><li>Vscode引入相关插件</li><li>Navicat</li><li>MySQL Workbench</li><li>SQLyog</li><li>…</li></ul><p>这些工具可以方便我们进行各种数据库操作, 但本质上, 它们都是通过SQL语句进行数据库操作的.</p><blockquote><p>详细版本号: 13.1.7</p></blockquote><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h2><h3 id="2-1-数据库的基本操作"><a href="#2-1-数据库的基本操作" class="headerlink" title="2.1 数据库的基本操作"></a>2.1 数据库的基本操作</h3><h4 id="2-1-1-数据库的登录"><a href="#2-1-1-数据库的登录" class="headerlink" title="2.1.1 数据库的登录"></a>2.1.1 数据库的登录</h4><p>通过在命令行中输入:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql <span class="token operator">-</span>u<span class="token operator">&lt;</span>username<span class="token operator">></span> <span class="token operator">-</span>p<span class="token operator">&lt;</span>password<span class="token operator">></span> <span class="token operator">-</span>h<span class="token operator">&lt;</span>hostname<span class="token operator">></span> <span class="token operator">-</span>P<span class="token operator">&lt;</span>port<span class="token operator">></span> <span class="token operator">&lt;</span>databasename<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-u: 用户名(默认为root)</li><li>-p: 密码(在安装过程中自己设置的密码)</li><li>-h: 主机名(如果本地运行, 默认为localhost, 默认情况下可省略)</li><li>-P: 端口号(默认为3306, 默认情况下可省略)</li><li>&lt;databasename&gt;: 数据库名, 可省略</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/MySQL/cmd%E7%99%BB%E5%BD%95MySQL.png" alt="cmd登录MySQL"></p><h4 id="2-1-2-查看数据库版本"><a href="#2-1-2-查看数据库版本" class="headerlink" title="2.1.2 查看数据库版本"></a>2.1.2 查看数据库版本</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> version<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/MySQL/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC.png" alt="查看数据库版本"></p><h4 id="2-1-3-数据库注释"><a href="#2-1-3-数据库注释" class="headerlink" title="2.1.3 数据库注释"></a>2.1.3 数据库注释</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 单行注释</span><span class="token comment">/*多行注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-4-退出数据库"><a href="#2-1-4-退出数据库" class="headerlink" title="2.1.4 退出数据库"></a>2.1.4 退出数据库</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-1-5-SQLyog可视化界面"><a href="#2-1-5-SQLyog可视化界面" class="headerlink" title="2.1.5 SQLyog可视化界面"></a>2.1.5 SQLyog可视化界面</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/MySQL/SQLyog%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.png" alt="SQLyog可视化界面"></p><p>我们通过SQLyog看到的界面如上图所示.</p><ul><li>左侧: 库 &#x2F; 表总览</li><li>左上方: 执行选项</li><li>中上侧空白: 编写SQL语句</li><li>中下侧空白: 执行结果 &#x2F; 表信息展示</li></ul><h3 id="2-2-DDL-数据定义语言"><a href="#2-2-DDL-数据定义语言" class="headerlink" title="2.2 DDL: 数据定义语言"></a>2.2 DDL: 数据定义语言</h3><p>MySQL中, 一个完整的数据创建过程分四步: 创建库 -&gt; 定字段 -&gt; 创建表 -&gt; 插数据</p><p><strong>DDL(Data Defination Language)</strong> 是数据定义语言, 主要用于定义数据库, 表, 索引, 视图等, 负责定义 &#x2F; 管理数据库的结构, 本身并不涉及对数据的操作.</p><p>DDL中重要的关键字分三个: </p><ul><li>CREATE: 创建</li><li>ALTER: 修改</li><li>DROP: 删除</li></ul><h4 id="2-2-1-MySQL命名规范"><a href="#2-2-1-MySQL命名规范" class="headerlink" title="2.2.1 MySQL命名规范"></a>2.2.1 MySQL命名规范</h4><p>关于标识符:</p><ul><li>数据库名 &#x2F; 表名不得超过30个字符, 变量名不得超过29个字符</li><li>必须只能包含 A-Z, a-z, 0-9, _ 共63个字符, 不能以数字开头</li><li>中间不能包含空格</li><li>同一个MySQL软件中, 数据库不可同名; 同一个库中, 表不能同名; 同一个表中, 字段不能同名</li><li>不能与常用方法冲突, 如果坚持使用, 需要用 <strong>&#96;</strong> 进行引用</li></ul><p>除此之外, 有一些推荐使用的规范:</p><ul><li>库 &#x2F; 表 &#x2F; 列名尽可能使用小写字母, 单词之间利用 <strong>_</strong> 进行连接</li><li>数据库名与应用名称一致: 一个应用通常而言只需要一个数据库, 因此我们通常将应用名称作为数据库名</li><li>表命名最好遵循 <strong>业务名称_表</strong> 的形式, 如: trade_config, pay_task</li><li>列名最好遵循 <strong>表属性_实体</strong> , 如: user_name, order_id</li></ul><h4 id="2-2-2-库的管理"><a href="#2-2-2-库的管理" class="headerlink" title="2.2.2 库的管理"></a>2.2.2 库的管理</h4><h5 id="2-2-2-1-创建数据库"><a href="#2-2-2-1-创建数据库" class="headerlink" title="2.2.2.1 创建数据库"></a>2.2.2.1 创建数据库</h5><p>库的创建有一种推荐方式以及多个可选项:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>databasename<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">&lt;</span><span class="token keyword">charset</span><span class="token operator">></span> <span class="token keyword">COLLATE</span> <span class="token operator">&lt;</span><span class="token keyword">collate</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里对可选参数进行解释:</p><ul><li>IF NOT EXISTS: 如果库不存在, 则创建( <strong>推荐无论如何都加上这个参数</strong> )</li><li>CHARACTER SET: 指定字符集(默认utf8mb4)</li><li>COLLATE: 指定排序规则(默认 <strong>utf8mb4_0900_ai_ci</strong> , 排序规则不区分大小写; 另一种方式是 <strong>utf8mb4_0900_as_cs</strong> , 这种方式会识别大小写的区别)</li></ul><p>默认字符集与排序规则可以通过命令进行查看:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'character_set_database'</span><span class="token punctuation">;</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'collation_database'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="2-2-2-2-查看-使用库"><a href="#2-2-2-2-查看-使用库" class="headerlink" title="2.2.2.2 查看 &#x2F; 使用库"></a>2.2.2.2 查看 &#x2F; 使用库</h5><p>查看库有以下方式:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token keyword">DATABASES</span><span class="token punctuation">;</span> <span class="token comment">-- 查看当前所有数据库</span><span class="token keyword">SELECT</span> <span class="token keyword">DATABASE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">-- 查看当前使用的数据库</span><span class="token keyword">SHOW</span> <span class="token keyword">TABLES</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>databasename<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">-- 查看指定数据库中的所有表</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>databasename<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">-- 查看指定数据库的创建信息</span><span class="token keyword">USE</span> <span class="token operator">&lt;</span>databasename<span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">-- 使用指定数据库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明确, 第五条指令是使用数据库的先决条件.</p><h5 id="2-2-2-3-修改-删除库"><a href="#2-2-2-3-修改-删除库" class="headerlink" title="2.2.2.3 修改 &#x2F; 删除库"></a>2.2.2.3 修改 &#x2F; 删除库</h5><p>我们可以通过语句对库的字符集与排序方式进行修改.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>databasename<span class="token operator">></span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">&lt;</span><span class="token keyword">charset</span><span class="token operator">></span> <span class="token keyword">COLLATE</span> <span class="token operator">&lt;</span><span class="token keyword">collate</span><span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意, 原生SQL是不支持 <strong>修改库名</strong> 这种操作的, 所有的重命名库(不论是否是原生支持的), 本质上都是 <strong>创建新库-&gt;转移数据-&gt;删除旧库</strong> 的一个操作.</p><p>删除库的指令如下:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>databasename<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样的, IF EXISTS 是推荐使用的参数.</p><blockquote><p>删库之前, 务必谨慎谨慎再谨慎!</p></blockquote><h4 id="2-2-3-表的管理"><a href="#2-2-3-表的管理" class="headerlink" title="2.2.3 表的管理"></a>2.2.3 表的管理</h4><h5 id="2-2-3-1-表的创建"><a href="#2-2-3-1-表的创建" class="headerlink" title="2.2.3.1 表的创建"></a>2.2.3.1 表的创建</h5><p>创建表比创建库复杂许多, 因为创建过程中不仅仅需要指定表名, 还需要进行列的定义:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span>&#123;    <span class="token operator">&lt;</span>columnname<span class="token operator">></span> <span class="token operator">&lt;</span>datatype<span class="token operator">></span> <span class="token punctuation">[</span>Optional constraints <span class="token keyword">for</span> <span class="token keyword">column</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> <span class="token operator">&lt;</span><span class="token keyword">comment</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token operator">&lt;</span>columnname<span class="token operator">></span> <span class="token operator">&lt;</span>datatype<span class="token operator">></span> <span class="token punctuation">[</span>Optional constraints <span class="token keyword">for</span> <span class="token keyword">column</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> <span class="token operator">&lt;</span><span class="token keyword">comment</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">[</span>Optional constraints <span class="token keyword">for</span> <span class="token keyword">column</span><span class="token punctuation">]</span><span class="token punctuation">;</span>&#125;<span class="token punctuation">[</span>Optional constraints <span class="token keyword">for</span> <span class="token keyword">table</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">COMMENT</span> <span class="token operator">&lt;</span><span class="token keyword">comment</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们进行一下说明:</p><ul><li>&lt;tablename&gt;: 表名</li><li>&lt;columnname&gt;: 列名</li><li>&lt;datatype&gt;: 列的数据类型</li><li>Optional constraints for column: 列的约束条件</li><li>Optional constraints for table: 表的约束条件</li><li>COMMENT: 注释</li></ul><p>其中利用中括弧 <strong>[]</strong> 括起来的是可选参数.</p><blockquote><p>注释是很有必要的, <del>你也不希望第二天看不懂自己建了个啥玩意吧</del></p></blockquote><h5 id="2-2-3-2-列的数据类型"><a href="#2-2-3-2-列的数据类型" class="headerlink" title="2.2.3.2 列的数据类型"></a>2.2.3.2 列的数据类型</h5><p>MySQL中, 列的数据类型颇多, 这里对常用类型进行枚举:</p><ul><li>整型: 后面都可以加Unsigned修饰符变为无符号位整数(如 <columnname> INT UNSIGNED)<ul><li>TINYINT: 1字节 二进制范围: -128<del>127 &#x2F; 0</del>255</li><li>SMALLINT: 2字节 范围: -32768<del>32767 &#x2F; 0</del>65535</li><li>MEDIUMINT: 3字节 范围: -8388608<del>8388607 &#x2F; 0</del>16777215</li><li>INT: 4字节 范围: -2147483648<del>2147483647 &#x2F; 0</del>4294967295</li><li>BIGINT: 8字节 范围: -9223372036854775808<del>9223372036854775807 &#x2F; 0</del>18446744073709551615</li></ul></li></ul><blockquote><p>在标准SQL中, 仅支持INT以及SMALLINT, 其他类型都是MySQL特有的</p></blockquote><ul><li>浮点型: <ul><li>FLOAT(M, D): 单精度浮点型, 固定占用4字节, M为总长度(最高24位), D为小数位数(最高8位)</li><li>DOUBLE(M, D): 双精度浮点型, 固定占用8字节, M为总长度(最高53位), D为小数位数(最高30位)</li><li>DECIMAL(M, D): 精确小数型, 大小动态计算, M为总长度(最高65位), D为小数位数(最高30位)</li></ul></li></ul><blockquote><p>由于float和double的精度问题, 因此在需要精确计算的场景下, 一律推荐使用decimal</p></blockquote><ul><li>字符串类型:<ul><li>CHAR(maxlength): 通常用于存储较短的字符串, 是固定长度字符串(不论存储多少字符, <strong>都会占用4*maxlength个字节(在utf8mb4编码下计算)</strong> ), $ 0&lt;maxlength&lt;255 $ </li><li>VARCHAR(maxlength): 通常用于存储较长的字符串, 是可变长度字符串(占据内存大小根据存储字符数变化), $ 0&lt;maxlength&lt;65535 $</li></ul></li></ul><blockquote><p>CHAR在声明时, 可以不写maxlength, 系统默认设定为1, VARCHAR在声明时, 必须写maxlength</p></blockquote><p>我们写的最大值 <strong>65535</strong> 是数据库中一行数据的最大占有空间, 同时在MySQL中, 默认利用一字节来表示改行是否为空, 因此实际上可以用于存储字符的存储大小为 65534 个字节, 如果使用utf8mb4编码, 则为 16383 个字符</p><p>那问题来了, 如果我们就是要存非常长的数据到一个格里面, 怎么办?</p><p>MySQL提供了TEXT类型, 用于存储较长的字符串, 这种类型在存储时不受到一行最大存储量的限制.</p><ul><li>长字符串(TEXT)类型:<ul><li>TINYTEXT: 最大长度为255字节</li><li>TEXT: 最大长度为65535字节</li><li>MEDIUMTEXT: 最大长度为16777215字节</li><li>LONGTEXT: 最大长度为4294967295字节(最大能存4g的文本)</li></ul></li></ul><blockquote><p>说归说, TEXT这玩意性能实在是堪忧, 这个它的各类操作非常的慢, 因此在涉及到超长文本的处理中, 一般而言可以直接存到本地的文本文件中, 并保存本地文件的相对地址, 以供将来调用</p></blockquote><ul><li>时间类型<ul><li>YEAR: 年份, 1字节, 范围: 1901~2155</li><li>TIME: 时间, 3字节, 范围: -838:59:59~838:59:59 (HH:MM:SS)</li><li>DATE: 日期, 3字节, 范围: 1000-01-01~9999-12-31 (YYYY-MM-DD)</li><li>DATETIME: 日期时间, 8字节, 范围: 1000-01-01 00:00:00~9999-12-31 23:59:59 (YYYY-MM-DD HH:MM:SS)</li><li>TIMESTAMP: 时间戳, 4字节, 范围: 1970-01-01 00:00:01~2038-01-19 03:14:07 (YYYY-MM-DD HH:MM:SS)</li></ul></li></ul><blockquote><p>年份的时间格式其实是可以利用两位时间格式的, [00<del>69] 代表 [2000</del>2069], [70<del>99] 代表 [1970</del>1999] , 但这种方式不是十分明确, 不推荐使用.</p><p>关于时间格式的自动更新, 可以通过: TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</p></blockquote><h5 id="2-2-3-3-表的修改"><a href="#2-2-3-3-表的修改" class="headerlink" title="2.2.3.3 表的修改"></a>2.2.3.3 表的修改</h5><p>修改表主要分两种操作:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">--修改表名</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>oldtablename<span class="token operator">></span> <span class="token keyword">RENAME</span> <span class="token operator">&lt;</span>newtablename<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">--修改表的结构</span><span class="token comment">--在原表中添加一列:</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">ADD</span> <span class="token operator">&lt;</span>columnname<span class="token operator">></span> <span class="token operator">&lt;</span>datatype<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">FIRST</span><span class="token operator">/</span><span class="token keyword">AFTER</span> <span class="token operator">&lt;</span>columnname<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">--这之中, FIRST表示将新列添加到表的最前面, AFTER表示将新列添加到指定列的后面, 如加上&lt;columnname>, 则表示将新列添加到&lt;columnname>的 前面 / 后面</span><span class="token comment">--修改表中某一列的名称</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> CHANGE <span class="token operator">&lt;</span>oldcolumnname<span class="token operator">></span> <span class="token operator">&lt;</span>newcolumnname<span class="token operator">></span> <span class="token operator">&lt;</span>datatype<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">FIRST</span><span class="token operator">/</span><span class="token keyword">AFTER</span> <span class="token operator">&lt;</span>columnname<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">--修改表中某一列的数据类型</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">MODIFY</span> <span class="token operator">&lt;</span>columnname<span class="token operator">></span> <span class="token operator">&lt;</span>datatype<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">FIRST</span><span class="token operator">/</span><span class="token keyword">AFTER</span> <span class="token operator">&lt;</span>columnname<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">--删除表中某一列</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">DROP</span> <span class="token operator">&lt;</span>columnname<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-3-4-表的删除"><a href="#2-2-3-4-表的删除" class="headerlink" title="2.2.3.4 表的删除"></a>2.2.3.4 表的删除</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除表</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>tablename1<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>tablename2<span class="token operator">></span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">-- 可以同时删除多个表</span><span class="token comment">-- 清空表的数据</span><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上述操作是无法回滚的, 请务必慎重操作</p></blockquote><hr><p>至此, 数据库中 DDL 的部分基本上理清楚了.</p><h3 id="2-3-DML-数据操纵语言"><a href="#2-3-DML-数据操纵语言" class="headerlink" title="2.3 DML: 数据操纵语言"></a>2.3 DML: 数据操纵语言</h3><p>DML主要针对数据库中数据的 <strong>增 &#x2F; 删 &#x2F; 改</strong> , 这三种操作不会影响数据库结构, 但会真正改变数据库中的数据.</p><p>DML主要涉及的关键字有:</p><ul><li>INSERT: 插入</li><li>UPDATE: 更新</li><li>DELETE: 删除</li></ul><p>由于数据库中的基本单位是 <strong>一行</strong> , 因此我们进行上述操作时, 都要建立在锁定行的基础上, 请读者明确这个思路.</p><h4 id="2-3-1-插入数据"><a href="#2-3-1-插入数据" class="headerlink" title="2.3.1 插入数据"></a>2.3.1 插入数据</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 插入一行, 并为一行中的所有字段添加数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 需要为表中每一个字段(即每一列)指定值, 值的顺序必须与字段定义时相同</span><span class="token comment">-- 插入一行, 并为指定字段添加数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>value1<span class="token punctuation">,</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 插入多行数据</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token keyword">value</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">value</span> n<span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">value</span> n<span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token punctuation">(</span>column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token keyword">value</span> <span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">value</span> n<span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">value</span> n<span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 每个括弧中为一行数据, 括弧之间利用逗号隔开</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-修改-更新数据"><a href="#2-3-2-修改-更新数据" class="headerlink" title="2.3.2 修改 &#x2F; 更新数据"></a>2.3.2 修改 &#x2F; 更新数据</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 修改表中所有行的数据（全表修改）</span><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">SET</span> column1 <span class="token operator">=</span> value1<span class="token punctuation">,</span> column2 <span class="token operator">=</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token comment">-- 修改表中指定行的数据（条件修改）</span><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">SET</span> column1 <span class="token operator">=</span> value1<span class="token punctuation">,</span> column2 <span class="token operator">=</span> value2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3-删除数据"><a href="#2-3-3-删除数据" class="headerlink" title="2.3.3 删除数据"></a>2.3.3 删除数据</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 删除表中所有行数据（全表删除）</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">-- 删除表中指定行数据（条件删除）</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span> <span class="token keyword">WHERE</span> condition<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>从严重程度上来看, DELETE 与 TRUNCATE 的区别在于: DELETE 是逐行删除, 而TRUNCATE 是全表删除, 相对而言, DELETE 由于可以回滚, 更加安全一些.</p></blockquote><h3 id="2-4-DQL-数据查询语言"><a href="#2-4-DQL-数据查询语言" class="headerlink" title="2.4 DQL: 数据查询语言"></a>2.4 DQL: 数据查询语言</h3><p>DQL(Data Query Language), 即数据查询语言, 其主要用于查询数据库中指定内容. 不会影响库表结构, 也不会更改原数据, DQL <strong>会根据原表数据查询出一个虚拟表</strong> .</p><p>DQL中最重要的关键字即:</p><ul><li>SELECT</li></ul><p>此外, 查询分 <strong>单表查询</strong> 以及 <strong>多表查询</strong> , 单表查询只需要根据特定的真实表通过指定查询语法生成虚拟表即可. 而多表查询需要先利用合并语法将多张真实表合并, 再利用查询语法生成虚拟表.</p><p>本节中主要对单表查询进行阐述.</p><h4 id="2-4-1-基础-SELECT-语句"><a href="#2-4-1-基础-SELECT-语句" class="headerlink" title="2.4.1 基础 SELECT 语句"></a>2.4.1 基础 SELECT 语句</h4><h5 id="2-4-1-1-非表查询"><a href="#2-4-1-1-非表查询" class="headerlink" title="2.4.1.1 非表查询"></a>2.4.1.1 非表查询</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> <span class="token number">9</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">SELECT</span> VERSION<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- SELECT 后方可以跟任意表达式, 会根据表达式输出结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4-1-2-指定表查询"><a href="#2-4-1-2-指定表查询" class="headerlink" title="2.4.1.2 指定表查询"></a>2.4.1.2 指定表查询</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询某个表中的特定列</span><span class="token keyword">SELECT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">-- 查询多个表中的指定列</span><span class="token keyword">SELECT</span> table1<span class="token punctuation">.</span>column1<span class="token punctuation">,</span> table2<span class="token punctuation">.</span>column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token keyword">table</span> n<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">-- * 表示查询该表中的所有列</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4-1-3-查询指定列-并重命名"><a href="#2-4-1-3-查询指定列-并重命名" class="headerlink" title="2.4.1.3 查询指定列, 并重命名"></a>2.4.1.3 查询指定列, 并重命名</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询指定列, 并将查询结果在虚拟表内重命名</span><span class="token keyword">SELECT</span> column1 <span class="token keyword">as</span> alias1<span class="token punctuation">,</span> column2 <span class="token keyword">as</span> alias2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span class="token comment">-- as 可以省略, 即以下形式也行得通</span><span class="token keyword">SELECT</span> column1 alias1<span class="token punctuation">,</span> column2 alias2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种做法看起来挺无厘头的, 事实上, 在后期我们将数据库中的内容映射至某些指定位置时, 这种虚拟表的列重命名是非常重要的一环.</p><h5 id="2-4-1-4-去除查询结果中的重复行"><a href="#2-4-1-4-去除查询结果中的重复行" class="headerlink" title="2.4.1.4 去除查询结果中的重复行"></a>2.4.1.4 去除查询结果中的重复行</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询指定列, 并去除得到结果(虚拟表)中的重复数据</span><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这种语法会将结果中 <strong>完全相同</strong> 的整行进行合并, 仅仅显示成1行数据.</p><h5 id="2-4-1-5-查询常数值"><a href="#2-4-1-5-查询常数值" class="headerlink" title="2.4.1.5 查询常数值"></a>2.4.1.5 查询常数值</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token string">'value'</span> <span class="token keyword">as</span> column1<span class="token punctuation">,</span> column2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>tablename<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种语法会将查询结果中的每一行都添加一个名为 column1 的列, 其值为 ‘value’ . 其本质上与 2.4.1.3 中的内容是一个道理.</p><h2 id="3-数据库中的一些常用函数"><a href="#3-数据库中的一些常用函数" class="headerlink" title="3. 数据库中的一些常用函数"></a>3. 数据库中的一些常用函数</h2><blockquote><p>本部分不会十分的系统, 因为在学习过程中会额外接触到很多函数, 但又不好将其加到上文中, 因此此处单开一章, 权作记录.</p></blockquote><p><strong>判空, 并赋予默认值</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">IFNULL<span class="token punctuation">(</span>culumn<span class="token punctuation">,</span> <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 如果column为空, 则返回value, 否则返回column本身的值</span><span class="token comment">-- 例如:</span><span class="token keyword">SELECT</span> IFNULL<span class="token punctuation">(</span>salary<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> 月薪 <span class="token keyword">FROM</span> employees<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>常用于在某些被选择的表内存在大量NULL类型时, 进行展示的默认值设定.</p><hr>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-end(1)</title>
      <link href="/posts/15663.html"/>
      <url>/posts/15663.html</url>
      
        <content type="html"><![CDATA[<h1 id="Front-end-Design-1"><a href="#Front-end-Design-1" class="headerlink" title="Front-end Design(1)"></a>Front-end Design(1)</h1><blockquote><p>写在前面</p><p>本章节的产生原因在于博主需要参加的大创(全称: 大学生创新创业竞赛)项目需要相关的前端界面设计, 而博主恰好负责这一部分较多, 因此在此新开一坑, 衔接此前HTML&amp;CSS的章节, 并在此之上继续向前, 目的在于在博文的最后能够设计出一个较为完整的前端界面出来.</p></blockquote><h2 id="1-JavaScript-概述"><a href="#1-JavaScript-概述" class="headerlink" title="1. JavaScript 概述"></a>1. JavaScript 概述</h2><p>JS, 全称 JavaScript, 是一个使用十分广泛, 应用较广的 <strong>脚本语言</strong> , 被广泛运用在前端的设计上, 通过JS的种种 <strong>行为</strong> , 能够实现前端界面的动画, 以及一些较为合理的交互逻辑.</p><h3 id="1-1-ECMAScript-JavaScript"><a href="#1-1-ECMAScript-JavaScript" class="headerlink" title="1.1 ECMAScript &amp; JavaScript"></a>1.1 ECMAScript &amp; JavaScript</h3><p>通俗而言, ECMAScript(后文简称ES)是由国际组织(ECMA)指定的一个脚本语言规范, 而JavaScript(后文简称JS)是由Netscape公司开发的, 基于 ES 的脚本语言.</p><p>ES的广为流传的版本为ES6, 它于2015年发布.</p><h3 id="1-2-JS-语句-标识符"><a href="#1-2-JS-语句-标识符" class="headerlink" title="1.2 JS 语句 &#x2F; 标识符"></a>1.2 JS 语句 &#x2F; 标识符</h3><p>JS作为单独的脚本语言, 它有其自己的一套语法, 一套单独的规范.</p><p>JS的标识符可以容纳的字符包括 <strong>字母, 数字, 下划线, $</strong> 这四种, 数字不能用在标识符开头.</p><blockquote><p>除此之外, 其实中文也可以作为标识符, 但本文中不推荐这样做. 中文进入代码行中出现的各种编码问题, 适配问题已经能搞得博主焦头烂额了.</p></blockquote><p>除此之外, JS也有一套关键字, 类似于C中的 <strong>break, return, …</strong> , 它们有自己的作用, 因此不能作为单独的标识符使用. 这些关键字我们会在后文中的使用中慢慢引出, 读者在此大可不必过于在意.</p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>在JS中, 变量可以非常简单的利用统一的符号进行定义:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>关于这个前后的&lt;script&gt;, 有HTML基础的读者应该看出这是个标签了, 确实, 由于JS的重要应用就是前端的设计, 因此常常需要插在HTML中进行书写, 具体方式即在相应的html文件中插入对应的标签即可. 后文会将这前后的标签省略, 还请读者记住这个事情.</p></blockquote><h4 id="1-3-1-变量的监视"><a href="#1-3-1-变量的监视" class="headerlink" title="1.3.1 变量的监视"></a>1.3.1 变量的监视</h4><p>但不同于C, Java的编译器提供的良好环境, 我们如何监视JS中的各种变量呢? 一个比较直接的方式是通过控制台显示出来.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过这样的语句, 我们可以通过浏览器中 <strong>检查-&gt;控制台</strong> 的界面查看变量的当前值.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/console.log.png" alt="Console.log"></p><h4 id="1-3-2-变量提升"><a href="#1-3-2-变量提升" class="headerlink" title="1.3.2 变量提升"></a>1.3.2 变量提升</h4><p>在JS中, 为了增加兼容性, 会将脚本中所有声明的变量提前至代码运行前优先声明.</p><p>这句话不是很好理解, 我们举个例子:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果以C语言输出的角度来看, 上面这段代码应当报错, 但实际上, 在浏览器中显示的状态:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.png" alt="变量提升"></p><p>相当于, 浏览器在运行这段脚本时, 其实相当于这样:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这即所谓变量提升的意义.</p><hr><p>在当今的开发过程中, var的使用已经比较少, 这是因为var变量提升这个特性往往会引起一些额外的错误, 因此ES6中引入了新的变量声明方式, 即let和const.</p><p>let, const与var的区别在于, let和const声明的变量不会进行变量提升, 这代表着开发者可以 <strong>更加稳定的控制变量的作用域</strong> .</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述代码将会报错, 因为let声明的变量不会进行变量提升.</p><hr><h3 id="1-4-JS的引入"><a href="#1-4-JS的引入" class="headerlink" title="1.4 JS的引入"></a>1.4 JS的引入</h3><p>与CSS类似, JS除开在HTML中单独书写外, 还可以通过外部文件引入的方式进行.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type <span class="token operator">=</span> <span class="token string">"text/javascript"</span> src <span class="token operator">=</span> <span class="token string">"./my_first_js.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src <span class="token operator">=</span> <span class="token string">"http://..."</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述内容分别代表了从本地引入js, 以及从网络外部连接引入js的方法.</p><h3 id="1-5-JS的注释"><a href="#1-5-JS的注释" class="headerlink" title="1.5 JS的注释"></a>1.5 JS的注释</h3><p>JS中的注释可以通过两种方式进行:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 这是一条注释</span><span class="token comment">/*这是一条多行注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明确, 这种注释是只能在JS中进行的. 相对应, 读者别忘记HTML与CSS中的注释形式.</p><p>当然, 比较方便的快捷键是 <strong>Ctrl + &#x2F;</strong></p><h3 id="1-6-JS的输出"><a href="#1-6-JS的输出" class="headerlink" title="1.6 JS的输出"></a>1.6 JS的输出</h3><p>这里简要提供三种方式</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Method 1</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"This is Method 1."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Method 2</span>Document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"This is Method 2."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Method 3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"This is Method 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种方式以弹出框的形式来输出内容, 用户可见:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/%E5%BC%B9%E5%87%BA%E6%A1%86%E5%BD%A2%E5%BC%8F.png" alt="Method 1"></p><p>第二种方式在页面上单独显示一行字体, 用户同样可见:</p><p>第三种方式我们之前说过了, 在控制台中进行相关输出, 用户不可见:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/%E5%86%99%E5%85%A5%E9%A1%B5%E9%9D%A2%26%E6%8E%A7%E5%88%B6%E5%8F%B0.png" alt="写入页面 / 控制台"></p><h3 id="1-7-JS的数据类型"><a href="#1-7-JS的数据类型" class="headerlink" title="1.7 JS的数据类型"></a>1.7 JS的数据类型</h3><h4 id="1-7-1-原始数据类型"><a href="#1-7-1-原始数据类型" class="headerlink" title="1.7.1 原始数据类型"></a>1.7.1 原始数据类型</h4><p>原始数据类型, 也被称为基本数据类型, 一般有三个:</p><ul><li>数值</li><li>字符串</li><li>布尔值</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span><span class="token keyword">var</span> bool <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-7-2-合成数据类型"><a href="#1-7-2-合成数据类型" class="headerlink" title="1.7.2 合成数据类型"></a>1.7.2 合成数据类型</h4><p>合成数据类型, 也被称为复合数据类型, 一般由多个原始数据类型组成(C中的结构体):</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Mug-chen"</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token literal-property property">admin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意, 变量之间通过 <strong>,</strong> 隔开</p><h4 id="1-7-3-特殊类型"><a href="#1-7-3-特殊类型" class="headerlink" title="1.7.3 特殊类型"></a>1.7.3 特殊类型</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">null</span><span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-7-4-类型判断"><a href="#1-7-4-类型判断" class="headerlink" title="1.7.4 类型判断"></a>1.7.4 类型判断</h4><p>在数据类型的判断上, 常用typeof函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//number</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//string</span><span class="token keyword">var</span> boo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> boo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//boolean</span><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object</span><span class="token comment">//两个特殊类型的结果</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>null通常表示对象为空; undefined一般表示数值为空.</p><h3 id="1-8-运算符"><a href="#1-8-运算符" class="headerlink" title="1.8 运算符"></a>1.8 运算符</h3><p>整体的运算符与C语言基本相同, 这里仅提及不同处.</p><h4 id="1-8-1-除法"><a href="#1-8-1-除法" class="headerlink" title="1.8.1 除法"></a>1.8.1 除法</h4><p>当然, 这里的除法是可以直接算出小数的, 不会像C, java那样整数除以整数只能得到整数解.</p><h4 id="1-8-2-严格等于-严格不等于"><a href="#1-8-2-严格等于-严格不等于" class="headerlink" title="1.8.2 严格等于 &amp; 严格不等于"></a>1.8.2 严格等于 &amp; 严格不等于</h4><p>在JS中, 等于运算符 “=&#x3D;” 出现了一个衍生, 叫 <strong>严格等于</strong> “&#x3D;&#x3D;&#x3D;”, 二者的区别在于, 前者会先进行类型转换再比较, 后者不会:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">==</span> <span class="token string">"5"</span><span class="token punctuation">)</span> \\<span class="token boolean">true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">===</span> <span class="token string">"5"</span><span class="token punctuation">)</span> \\<span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类似的, 也有 <strong>!&#x3D;</strong> 与 <strong>!&#x3D;&#x3D;</strong> 的使用, 我们推荐使用 <strong>严格等于 &#x2F; 严格不等于</strong> .</p><h4 id="1-8-3-布尔运算"><a href="#1-8-3-布尔运算" class="headerlink" title="1.8.3 布尔运算"></a>1.8.3 布尔运算</h4><p>这里主要提及取反 <strong>!</strong> , 因为实际应用过程中常常对非布尔值进行取反(主要是方便), 我们这里给出6个取反后为真的例子.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">!</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token keyword">undefined</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">//空字符串取反</span><span class="token operator">!</span><span class="token number">NaN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-9-语句"><a href="#1-9-语句" class="headerlink" title="1.9 语句"></a>1.9 语句</h3><h4 id="1-9-1-条件语句"><a href="#1-9-1-条件语句" class="headerlink" title="1.9.1 条件语句"></a>1.9.1 条件语句</h4><p>给三种</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// if_else</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//elseif</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//switch</span><span class="token keyword">switch</span><span class="token punctuation">(</span>var_name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token operator">...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token operator">...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token operator">...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见, 与C &#x2F; Java极其类似.</p><h4 id="1-9-2-三元运算符"><a href="#1-9-2-三元运算符" class="headerlink" title="1.9.2 三元运算符"></a>1.9.2 三元运算符</h4><p>即C &#x2F; Java中都有的特殊的条件判断:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span><span class="token operator">></span><span class="token number">2</span> <span class="token operator">?</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">:</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-9-3-循环语句"><a href="#1-9-3-循环语句" class="headerlink" title="1.9.3 循环语句"></a>1.9.3 循环语句</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-10-字符串"><a href="#1-10-字符串" class="headerlink" title="1.10 字符串"></a>1.10 字符串</h3><p>字符串与Java中类似, 换行需要利用 <strong>\</strong> </p><h4 id="1-10-1-字符串常用方法"><a href="#1-10-1-字符串常用方法" class="headerlink" title="1.10.1 字符串常用方法"></a>1.10.1 字符串常用方法</h4><p>(1) <strong>charAt</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//指定位置字符</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World."</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(2) <strong>concat</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//字符串连接</span><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以有多个参数, 参数之间利用逗号隔开</span><span class="token keyword">var</span> str3 <span class="token operator">=</span> <span class="token string">"!"</span><span class="token punctuation">;</span><span class="token keyword">var</span> s <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然, 熟悉java的读者, 应该知道, 直接用+也可以连接字符串, 也没毛病.</p><p>那用concat有什么区别?</p><p>事实是, +使用类型强转, 而concat调用它们的 <strong>toString()</strong> 方法.</p><p>一般情况下区别不大就是了.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">var</span> grade <span class="token operator">=</span> <span class="token string">"grade: "</span><span class="token keyword">var</span> str <span class="token operator">=</span> grade<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(3) <strong>substring</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//子字符串</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//llo </span><span class="token comment">//第二个参数可不写</span><span class="token keyword">var</span> sub_1 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//llo World</span><span class="token comment">//会自动排序两个参数的大小</span><span class="token keyword">var</span> sub_2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于</span><span class="token keyword">var</span> sub_2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//负数会被自动转化成0</span><span class="token keyword">var</span> sub_3 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于</span><span class="token keyword">var</span> sub_3 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与Java中相同, 含前不含后.</p><p>(4) <strong>substr</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//子字符串, 但第二个参数是字符串长度</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//llo </span><span class="token comment">//第二个参数不写, 则一直取到最后</span><span class="token comment">//第一个参数写成负数, 则取逆序的字母值</span><span class="token comment">//第二个参数写成负数, 则自动置为0(空字符串)</span><span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//l</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(5) <strong>indexOf</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//查看一个字符串在另一个字符串中第一次出现的位置, 如果找不到返回0</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token string">"Wor"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//6</span><span class="token comment">//可以接受第二个参数, 表示开始查找的位置</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(6) <strong>trim</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//用于去除字符串两端的特殊字符, 包括空格, 制表符\t, \r, 回车符\n等</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"      Hello World      "</span><span class="token punctuation">;</span><span class="token keyword">var</span> res <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ES6新增扩展方法:</span><span class="token function">trimStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//去掉头部特殊字符</span><span class="token function">trimEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//去掉尾部特殊字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(7) <strong>split</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//字符串分割函数, 返回一个由子字符串组成的数组</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World Here Is My Blog"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//["Hello", "World", "Here", "Is", "My", "Blog"]</span><span class="token comment">//可以进行空字符串分割, 返回一个由字符串中每个字符单独组成的字符串组成的数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//省略参数, 则返回原字符串组成的数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以接受第二个参数, 限定返回数组的最大成员数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//["H", "e", "l"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是主要使用的字符串方法, 但其实JS中字符串方法远不止这么多, 希望读者使用时可以有限查一查有没有对应的函数. <del>毕竟直接调库比手搓一个函数可方便多了(笑)</del></p><h3 id="1-11-数组"><a href="#1-11-数组" class="headerlink" title="1.11 数组"></a>1.11 数组</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token string">'World'</span><span class="token punctuation">,</span> <span class="token string">'!'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在JS中, 数组的声明一般直接使用var进行. 不同的是, 由于没有了类型的区分, 因此一个数组中可以存在各种类型的数据(整数 &#x2F; 浮点数 &#x2F; 字符串 &#x2F; 数组).</p><h4 id="1-11-1-数组操作"><a href="#1-11-1-数组操作" class="headerlink" title="1.11.1 数组操作"></a>1.11.1 数组操作</h4><p>(1) <strong>求长</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(2) <strong>遍历</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//传统的遍历方法(即利用for / while进行循环)在此不在叙述</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3) <strong>判断类型</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回一个布尔值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(4) <strong>快捷添加 &#x2F; 删除元素</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'World'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在数组后方添加一条或多条数据</span><span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除数组的最后一个元素, 并返回它</span><span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//删除数组的第一个元素, 并返回它</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于 <strong>shift</strong> 这个方法, 有一种很常见的写法, 即利用它来清空数组(顺便正序遍历也可以):</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//var arr = [...];</span><span class="token keyword">var</span> temp<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>temp <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//当数组为空时, 相当于将一个"undefined"赋值给temp, 会返回false, 循环自然结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相对应的, 也可以快捷的向头部添加元素:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//var arr = [...];</span>arr<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//向头部添加一个或多个元素</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>(5) <strong>将数组输出</strong></p><p>方法 <strong>join</strong> 可以指定分隔符来将整个数组转变为字符串输出.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//默认用逗号</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用空格</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>联系前面提供的字符串split方法, 可以将数组和字符串实现轻松的互相转换.</p><p>(6) <strong>数组合并</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'world'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//var arr3 = ...</span><span class="token keyword">var</span> temp <span class="token operator">=</span> arr1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span> arr3<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以将一个或多个数组的内容合并到一起并返回, 不会改变原数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(7) <strong>逆序</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//逆序排列原数组, 会改变原数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种方法可以用于翻转字符串, 具体而言, 先将字符串转为数组, 再用reverse反转数组, 最后转为字符串即可.</p><p>(8) <strong>查找</strong></p><p>与字符串相同, 查找某一个元素在数组中第一次出现的位置, 不存在则返回-1;</p><p>不再详述.</p><h3 id="1-12-函数"><a href="#1-12-函数" class="headerlink" title="1.12 函数"></a>1.12 函数</h3><p>在JS中, 函数的声明如下:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">function_name</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//利用function进行声明, 可以传入参数, 并传出返回值</span><span class="token comment">//亦或通过函数表达式的方法进行声明</span><span class="token keyword">const</span> <span class="token function-variable function">function_name</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上两种方法都好理解(对于此前有编程基础的读者而言), JS中额外引入了箭头函数:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">function_name</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//箭头函数的语法, 可以省略function关键字, 并将函数体写在箭头后侧</span><span class="token comment">//此外, 如果箭头函数只有一个参数, 可以省略参数列表的括号</span><span class="token keyword">const</span> <span class="token function-variable function">function_name</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//如果箭头函数的函数体只有一行, 可以省略花括号, 并将return关键字一并省略</span><span class="token keyword">const</span> <span class="token function-variable function">function_name</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=></span> <span class="token operator">...</span><span class="token punctuation">;</span><span class="token comment">//最后, 如果箭头函数的返回值只有一个, 可以省略return关键字, 并将返回值直接写在箭头后侧</span><span class="token keyword">const</span> <span class="token function-variable function">function_name</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token operator">=></span> x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>要明确, 箭头函数简略写返回值时, 无法返回用{}包裹的对象, 因为JS会将{}解析为函数体, 而不是对象.</p></blockquote><h3 id="1-13-对象"><a href="#1-13-对象" class="headerlink" title="1.13 对象"></a>1.13 对象</h3><p>对象是一个非常重要的概念, 同时这里与Java中的一些语法差距较大, 我们重点叙述一下:</p><p>类似Java, 对象中包含属性和方法.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Mug-chen"</span><span class="token punctuation">,</span>    <span class="token literal-property property">job</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token string">"?"</span><span class="token punctuation">,</span>    <span class="token operator">...</span>    <span class="token function-variable function">getName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与Java中的对象极其类似, 只不过声明方法时需要通过 <strong>方法名:function</strong> 进行声明, 同时属性之间通过 , 隔开即可.</p><p>此外, 还可以在对象内套对象:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> Reader<span class="token punctuation">&#123;</span>    Re1<span class="token punctuation">&#123;</span>        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Bob"</span><span class="token punctuation">,</span>        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token string">"18"</span><span class="token punctuation">,</span>        <span class="token operator">...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    Re2<span class="token punctuation">&#123;</span>        <span class="token operator">...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以通过多层引用进行信息调用.如: <strong>Reader.Re1.name</strong> ;</p><p>此外, 如果希望检查对象中是否包含某个属性, 可以使用 <strong>in</strong> 运算符, 可以返回一个布尔值:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"name"</span> <span class="token keyword">in</span> user<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><p>事实上, 在JS中, 属性名可以非常的复杂, 但此时使用属性名时不能使用一般的 <strong>.</strong> 进行引用, 而需要使用 <strong>[]</strong> 进行引用, 如:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Mug-chen"</span><span class="token punctuation">,</span>    <span class="token literal-property property">job</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token string">"?"</span><span class="token punctuation">,</span>    <span class="token number">12345</span>@#$<span class="token operator">%</span><span class="token operator">:</span> <span class="token string">"???"</span>    <span class="token function-variable function">getName</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>user<span class="token punctuation">[</span><span class="token string">"12345@#$%"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//调用时需要使用[]进行引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <strong>[]</strong> 来进行属性的添加和修改与使用.有什么不同? </p><p>除了上文中提到的, [] 可以用于非常复杂的属性名外, 其还可以提取变量名来进行属性的定义:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">;</span>obj<span class="token punctuation">[</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Mug-chen"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Mug-chen, 这里的属性名为变量str的值, 即name</span><span class="token comment">//假设更改为obj.str = "Mug-chen", 则相当于添加了一个属性名为 "str" 的属性, 属性值为"Mug-chen"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时, obj[str] 等价于 obj[“name”], 也就是 obj.name.</p><hr><h4 id="1-13-1-通过Symbol添加属性"><a href="#1-13-1-通过Symbol添加属性" class="headerlink" title="1.13.1 通过Symbol添加属性"></a>1.13.1 通过Symbol添加属性</h4><p>Symbol是ES6中引入的一种新的数据类型, 可以用于创建独一无二的属性名.</p><p>在ES6中, 可以通过Symbol来添加属性, 具体如下:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> mysymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">[</span>mysymbol<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Mug-chen"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">[</span>mysymbol<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Mug-chen</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通常来说, 使用Symbol添加属性的目的在于不让外界访问到该属性, 因为Symbol是独一无二的, 外界无法通过常规方式访问到该属性.</p><h3 id="1-14-类"><a href="#1-14-类" class="headerlink" title="1.14 类"></a>1.14 类</h3><p>在ES6中, 对于 <strong>类</strong> 这个概念有了引入.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">addAge</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> User1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"Alice"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>User1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>User1<span class="token punctuation">.</span><span class="token function">addAge</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>User1<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与Java显著的不同在于, JS中不需要再类前明确声明类的所有属性, 而是通过构造器(constructor)或其他方法直接添加即可.</p><h3 id="1-15-继承-多态-原型"><a href="#1-15-继承-多态-原型" class="headerlink" title="1.15 继承 &#x2F; 多态 &#x2F; 原型"></a>1.15 继承 &#x2F; 多态 &#x2F; 原型</h3><p>JS中, 同样有类继承的操作, 同样使用 <strong>extends</strong> 关键字:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addAge</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在JS中, 类的继承是单继承的, 即一个类只能继承自一个父类.</p><hr><p>类似的, 多态我们此前也提过, 意为在子类中可以重写父类的方法(包括构造方法).</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addAge</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"Student: "</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>请明确, 当重写子类的构造函数时, 第一行必须是super(), 即调用父类的构造函数, 这点的意义在于子类想要构造一个实例, 必须首先构造一个父类实例.</p></blockquote><hr><p><strong>原型</strong></p><p>在JS中, 直接通过console的方式打印一个对象时, 只会打印对象的一部分属性, 这被称为对象自身的属性, 包含:</p><ul><li>直接通过对象添加的属性</li><li>在类中通过x &#x3D; y的方式添加的属性(包括通过函数表达式书写的函数)</li></ul><p>但还有另一类对象不会显式地出现在console中, 这就是 <strong>原型对象</strong> . 原型对象存储的位置(内存)与对象自己并不一定相邻, 源对象可以通过 <strong>__proto__</strong> 的方式来引用原型对象中的内容, 或者通过方法: Object.getPrototypeOf(obj) 来获取原型对象.</p><ul><li>当访问对象中的内容时, 会先从对象自身查找, 如果找不到, 则会去原型对象中查找</li><li>原型对象中存储的属性:<ul><li>类中通过fun_name(){}添加的方法</li><li>通过this.x &#x3D; y的方式添加的属性</li><li>对象的构造函数constructor</li></ul></li></ul><hr><p><strong>原型链</strong></p><p>显然, 原型对象也是对象, 也就有原型对象的原型对象…(套娃.jpg), 这一条捋下去, 就能形成一个原型链(最终一定会捋到 <strong>null</strong> ), 也就是JS中对象继承的原理(我们称之为 <strong>原型继承</strong> ).</p><p>因此, 我们具象化对象调用属性的过程: </p><ol><li>先从对象自身查找</li><li>如果找不到, 则去原型对象中查找</li><li>如果找不到, 则去原型对象的原型对象中查找</li><li>直到找到Object.prototype(因为Object.prototype的原型对象是null), 如果仍然找不到, 则返回undefined</li></ol><blockquote><p>为啥要有原型这个玩意?</p><p>在JS中, 同类型对象的原型对象是相同的, 因此, 当我们通过原型对象来添加方法时, 所有的对象都可以调用这个方法, 而不必为每个对象都添加一次, 这就是原型链的意义.</p></blockquote><h2 id="2-JS与网页的交互-DOM"><a href="#2-JS与网页的交互-DOM" class="headerlink" title="2. JS与网页的交互: DOM"></a>2. JS与网页的交互: DOM</h2><p>DOM是Document Object Model的缩写, 意为文档对象模型, 是一种用于表示和操作HTML或XML文档的编程接口.</p><p>事实上, DOM属于Web API的一部分, 它提供了许多方法, 可以通过这些方法来访问和操作HTML文档中的元素.</p><p>DOM的原理在于将整个HTML文件视作一整个对象树, 而HTML中的每个标签都是树的一个节点, JS通过DOM对于HTML中的节点进行访问 &#x2F; 操作, 达到控制HTML行为的效果.</p><h3 id="2-1-DOM的入口节点-文档节点-document"><a href="#2-1-DOM的入口节点-文档节点-document" class="headerlink" title="2.1 DOM的入口节点(文档节点): document"></a>2.1 DOM的入口节点(文档节点): document</h3><p>document是DOM的入口节点, 代表整个HTML文档, 可以通过document来访问HTML中的所有元素.</p><p>通过此前提及的 <strong>原型</strong> 相关内容, 我们可以逐级回溯到document的原型链:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/Document%E5%8E%9F%E5%9E%8B%E9%93%BE.png" alt="Document原型链"></p><p>$$ HTMLDocument -&gt; Document -&gt; Node -&gt; EventTarget -&gt; Object.prototype $$</p><p>为什么要梳理这条原型链? </p><p>有这条原型链, 代表着这一条链上的所有属性 &#x2F; 方法, 对于document对象都是可用的. 这也代表着读者此后遇到不理解的内容, 有迹可循.</p><p>部分属性举例:</p><ul><li>document.documentElement: 返回文档的根元素, 即<html>标签</li><li>document.body: 返回文档的<body>元素</li><li>document.title: 返回文档的标题</li><li>document.URL: 返回文档的URL</li><li>…</li></ul><h3 id="2-2-DOM的元素节点-element"><a href="#2-2-DOM的元素节点-element" class="headerlink" title="2.2 DOM的元素节点: element"></a>2.2 DOM的元素节点: element</h3><p>element是DOM的元素节点, 代表HTML中的每一个标签, 可以通过element来访问和操作HTML中的标签.</p><h4 id="2-2-1-元素节点的获取"><a href="#2-2-1-元素节点的获取" class="headerlink" title="2.2.1 元素节点的获取"></a>2.2.1 元素节点的获取</h4><ul><li>通过document对象来获取元素节点<ul><li>document.getElementById(“id”): 通过id来获取 <strong>单个</strong> 元素节点</li><li>document.getElementsByClassName(“class”): 通过类名来获取 <strong>一组</strong> 元素节点;    <ul><li>返回一个 <strong>类数组对象</strong> , 这代表这个返回的对象 <strong>不能用数组的某些方法</strong> , 比如forEach等…</li><li>返回的这个类数组对象是 <strong>实时更新的</strong> , 代表着查询一次后, 数组中会自动将后续添加的符合要求的元素加进去</li></ul></li><li>document.getElementsByTagName(“tag”): 通过标签名来获取 <strong>一组</strong> 元素节点<ul><li>类似, 返回类数组 &#x2F; 实时更新</li><li>可以通过 <strong>document.getElementByTagName(“*”)</strong> 来获取文档中的所有节点</li></ul></li><li>document.querySelectorAll(“.class”): 通过CSS选择器来获取 <strong>一组</strong> 元素节点<ul><li>引号内为一个 <strong>Css选择器</strong></li><li>返回一个类数组</li><li>不会实时更新</li></ul></li><li>document.querySelector(“.class”): 通过CSS选择器来获取 <strong>单个</strong> 元素节点<ul><li>如果文档中有多个符合要求的元素, 则之后返回第一个符合条件的元素</li></ul></li></ul></li><li>通过document对象来创建元素节点<ul><li>document.createElement(“tag”): 通过标签名来创建一个元素节点</li></ul></li></ul><h4 id="2-2-2-元素节点的操作"><a href="#2-2-2-元素节点的操作" class="headerlink" title="2.2.2 元素节点的操作"></a>2.2.2 元素节点的操作</h4><p>我们相似的捋一下元素节点的原型链, 以div为例:</p><p>$$ HTMLDivElement -&gt; HTMLElement -&gt; Element -&gt; Node -&gt; … $$</p><hr><p>1.通过元素节点查找 <strong>范围内的符合要求的节点</strong></p><p>这一点与2.2.1几乎一致, 只需要将document更改为对应的对象即可, 不再赘述.</p><hr><p>2.获取其他节点</p><ul><li><strong>element.childNodes</strong> : 获取element的所有子节点(不常用)<ul><li>返回一个类数组对象</li><li>类数组对象中包含所有子节点, 包括文本节点和注释节点(换行等空白节点也会包括进去)</li><li>还有一些fistchild, lastchild等属性, 由于不实用, 这里不再详述</li></ul></li><li><strong>element.children</strong> : 获取element的所有子元素节点<ul><li>返回一个类数组对象</li><li>类数组对象中只包含子元素节点</li><li>firstElementChild: 获取第一个子元素</li><li>lastElementChild: 获取最后一个子元素</li><li>nextElementSibling: 获取下一个兄弟元素</li><li>previousElementSibling: 获取上一个兄弟元素</li><li>parentElement: 获取父元素</li></ul></li><li><strong>element.tagName</strong> : 获取当前元素的标签名</li></ul><hr><p>3.修改元素内文本</p><ul><li><strong>element.innerHTML</strong> : 获取或设置元素内的HTML内容<ul><li>可以读取到元素内的所有内容(包括标签)</li><li>利用innerHTML插入内容时, 有被xss注入的风险</li></ul></li><li><strong>element.textContent</strong> : 获取或设置元素内的文本内容<ul><li>只能读取到元素内的文本内容(不包括标签), 代表着不会考虑css样式, 显示标签中的原始结果</li><li>插入的内容会被转义</li></ul></li><li><strong>element.innerText</strong> : 获取或设置元素内的文本内容<ul><li>会忽略掉元素内的空白节点(包括换行等空白节点), 会考虑css样式(比如一个标签中有display: none的css设置, 则这个标签的内容不会被innerText读取到) </li><li>插入的内容会被转义</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blockchain-2</title>
      <link href="/posts/3283.html"/>
      <url>/posts/3283.html</url>
      
        <content type="html"><![CDATA[<h1 id="Blockchain-2"><a href="#Blockchain-2" class="headerlink" title="Blockchain(2)"></a>Blockchain(2)</h1><blockquote><p>在本节中, 我们主要会针对 <strong>以太坊</strong> 这一另一个主要的加密货币进行说明.</p><p>仍然需要写在前面, 本文主要基于 《区块链技术与应用》(北京大学 肖臻教授) 的课程进行笔记整理与内容扩展, 文中除开视频内容外,也会涉及到一些博主自己的思考, 烦请读者理性看待. 在此也附上视频链接(<a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=1&vd_source=4565edcb254cb6582d6382ac80011294">https://www.bilibili.com/video/BV1Vt411X7JF?p=1&amp;vd_source=4565edcb254cb6582d6382ac80011294</a>), 有了他们的工作, 才能让区块链这一技术为更多人所知.</p><p>在此对 肖臻教授 以及 北京大学相应课程组 表达诚挚的敬意与感激!</p></blockquote><h2 id="Part-1-以太坊概述"><a href="#Part-1-以太坊概述" class="headerlink" title="Part.1 以太坊概述"></a>Part.1 以太坊概述</h2><p><strong>以太坊(Ethereum)</strong> 对于比特币中出现的各种问题进行了更为针对性的改进, 包括但不限于 <strong>出块时间 &#x2F; 谜题设计 &#x2F; 共识协议</strong> 等等方面.</p><p>与此同时, 以太坊相对于比特币的最显著的该进, 在于 <strong>智能合约(Smart Contract)</strong> 的提出.</p><hr><p>为什么要提出智能合约?</p><p>在BTC时代, BTC实现的最重要的成就是它达成了一个真正的 <strong>去中心化的货币政策(Decentralized Currency)</strong> , 比特币通过技术手段取代了一部分本该通过政府来保证的公信力; 人们看到了BTC的成功, 并希望将这种去中心化的思路推而广之(If we can decentralize currency, what else can we decentralize?), 以太坊在此基础上设计出了 <strong>去中心化的合约设计(Decentralized Contract)</strong> , 智能合约类似地通过技术手段, 取代了一部分原本应当由司法机关来保证的合约公信力.</p><hr><h2 id="Part-2-账户"><a href="#Part-2-账户" class="headerlink" title="Part.2 账户"></a>Part.2 账户</h2><h3 id="2-1-以太坊中的账户模型"><a href="#2-1-以太坊中的账户模型" class="headerlink" title="2.1 以太坊中的账户模型"></a>2.1 以太坊中的账户模型</h3><p>在比特币中, 账户仅仅是一个 &lt;公钥, 私钥&gt;对, 这意味着账户十分容易创建, 而且一个人可以很轻松地拥有多个账户. 同时一个账户中的余额需要通过查询 UTXO 才能真正得知(比特币是基于交易的账本: Transaction based ledger).</p><p>这种方法的好处在于隐私性的保护较强, 但同时也意味着交易过程中有了很多麻烦 <del>(用户自己可能都说不清我有多少钱, 更别提别人了)</del></p><p>典型的麻烦在于, 当一个用户(我们后文称之为用户1)希望向另一个人转账时, 他必须将他此前参与交易的输出(相当于此前转到自己一个账户上的钱)全部花出去(这代表着假设交易金额与输出金额不等, 则用户1必须单独再创建一个账户来接受找零, 详情请见上一个章节的11.1). 显然, 这相当的别扭.</p><p>在以太坊中, 采用了传统的 <strong>基于账户的模型(Account Based Ledger)</strong> , 这代表着系统上必须显式记录每个账户上有几个ETH. 此时要检测交易是否合法, 则只需检查转账账户上是否有足够的金额即可, 无需像比特币一般说明金额的具体来源.</p><p>这种模型对 <strong>双花攻击(Double Spending Attack)</strong> 有天然的防御作用, 因为交易必定需要扣除余额. </p><hr><p><strong>重放攻击(Replay Attack)</strong></p><p>重放攻击指的是 <strong>收款人</strong> 在收到付款人的交易请求后, 正常接收这个交易, 但在后续过程中再次向交易网络中重新转发这个交易, 达到让自己多次收款的目的.</p><p>以太坊采用的账户模型对于重放攻击是需要单独进行防护的, 以太坊对每个账户单独设置了一个域nonce, 表示 <strong>这个账户的总交易数</strong> , 如果收款方重放该交易, 会由于总交易数nonce相同而被无恶意的节点拒绝.</p><hr><h3 id="2-2-账户的分类"><a href="#2-2-账户的分类" class="headerlink" title="2.2 账户的分类"></a>2.2 账户的分类</h3><p>以太坊中含有两类账户:</p><ul><li>Externally owned Account: 也称外部账户(或普通账户), 这种账户很类似比特币中的账户, 利用公私钥控制. 这种账户的状态值包括:<ul><li>Balance: 账户余额</li><li>nonce: 账户交易总数(类似计数器)</li></ul></li><li>Smart contract Accound: 也称合约账户, 合约账户不是通过公私钥进行控制的, 同时合约账户也不能主动发起交易, 这代表着它涉及的所有交易都是由外部发起的, 同时每调用一次合约账户会导致其存储内的某些特定状态值发生变化. 其状态值包括:<ul><li>Balance</li><li>nonce</li><li>code: 代码</li><li>storage: 存储(其他额外的状态值)</li></ul></li></ul><p>后续我们会进一步对上面的各种状态进行说明, 读者在这里不必过于纠结它们的用途.</p><h3 id="2-3-为什么是-账户模型"><a href="#2-3-为什么是-账户模型" class="headerlink" title="2.3 为什么是 账户模型 ?"></a>2.3 为什么是 账户模型 ?</h3><p>以太坊为什么要改用 <strong>账户模型</strong> ?</p><p>当然, 交易更方便, 速度更快是理由之一. 但更本质的原因, 在于以太坊创建的系统是 <strong>智能合约系统</strong> , 而合约的根本, 在于交易双方必须要 <strong>保持稳定</strong> , 想比特币那样收一笔钱换一个地方的做法在合约中显然是行不通的.</p><h2 id="Part-3-数据结构"><a href="#Part-3-数据结构" class="headerlink" title="Part.3 数据结构"></a>Part.3 数据结构</h2><h3 id="3-1-状态树"><a href="#3-1-状态树" class="headerlink" title="3.1 状态树"></a>3.1 状态树</h3><p>谈完了模型, 我们来说说实现方式.</p><p>我们需要实现的, 是一个从账户地址(Address)到账户状态(State)的有效映射. 在以太坊中, 账户地址是一个160bit的二进制数, 我们一般将其表示为40个16进制数.</p><hr><p>我们先来排除一个错误选项: Merkle Tree 能当此任吗?</p><p>答案是否定的. 有两个原因.</p><p>首先, 我们如果通过哈希的方式将 <strong>以太坊中所有的账户</strong> 组织在同一颗 Merkle Tree 中, 会导致任何账户信息更新的操作的开销都十分庞大. 因为 Merkle Tree 这玩意通过哈希指针连接双亲结点与孩子节点, 因此牵一发而动全身, 而所有账户一起组成的 Merkle Tree , 实在是太大了.</p><p>其次, 比特币中能够采用 Merkle Tree 的原因在于 Merkle Tree 仅存在于一个区块中, 它仅仅组织一个区块内的交易排列, 以及包含的交易信息. 这个过程有一个很明确的 <strong>共识源头</strong> 即获取到记账权的那个节点(挖到这个区块的矿工). 但如果以太坊的账户管理仍然套用 Merkle Tree , 这个共识源头就不好找了, 意味着让所有节点形成共识的难度也过高.</p><p>因此, 我们排除利用 Merkle Tree 来存储账户信息的想法.</p><hr><h4 id="3-1-1-Trie-字典树"><a href="#3-1-1-Trie-字典树" class="headerlink" title="3.1.1 Trie(字典树)"></a>3.1.1 Trie(字典树)</h4><p>我们揭晓以太坊的数据结构之前, 先来说说这个简化的数据结构: <strong>Trie(字典树)</strong> .</p><p><em>In computer science, a trie, also called digital tree or prefix tree, is a type of k-ary search tree, a tree data structure used for locating specific keys from within a set.</em></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Trie_example.svg" alt="Trie"></p><p>这种数据结构, 就是专门用于通过关键字来进行数据查找的. 通过例子也能够看出, 一般而言这种查找是通过字符串进行的.</p><p>提到字符串, 我们想一想能跟以太坊建立起什么联系?</p><p>前面提及到的, 以太坊的地址是160bit的二进制数, 而我们通常使用 <strong>40位16进制数</strong> 来表示. 这意味着, 如果使用Trie进行存储, 算上字符串结束符, 每个节点 <strong>最多</strong> 能够衍生出 <strong>17个分支</strong> , 树的 <strong>深度</strong> 固定为 <strong>41</strong>.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Trie_complexity.png" alt="Trie_complexity"></p><hr><p><strong>Trie相比于Merkle Tree有什么好处?</strong></p><p>上图中, 我们发现对于Trie, 搜索, 插入, 删除的时间复杂度都取决于字符长度, 而我们这里字符长必定是40. 显然, 相比于 Merkle Tree , Trie的各种操作效率可高太多了.</p><p>此外, 不论怎么打乱重排给入这颗 Trie, 最后构造出的Trie应当是一样的, 因为Trie是根据字符串本身进行插入操作的.</p><p>最后, 当这棵Trie需要更新时, 也不用访问其他分支, 不用遍历, 只需要根据给定地址访问指定分支即可, 即更新局部性控制的很好.</p><hr><p>按理来说, Trie已经挺不错了, 但人们还是不满足, 人们觉得查找效率还是不够高.</p><p>对于上面的例子而言, 像 <strong>inn</strong> 这样的节点, 我还需要找三次才能找到它, 但它过程中没有什么分支, 那我能不能再度简化查找过程?</p><h4 id="3-1-2-Patricia-Tree-路径压缩前缀树-压缩前缀树"><a href="#3-1-2-Patricia-Tree-路径压缩前缀树-压缩前缀树" class="headerlink" title="3.1.2 Patricia Tree(路径压缩前缀树 &#x2F; 压缩前缀树)"></a>3.1.2 Patricia Tree(路径压缩前缀树 &#x2F; 压缩前缀树)</h4><p><strong>Patricia Tree(Trie)</strong> , 也称路径压缩前缀树(字典树) , 是一种在传统字典树上对于单一路径进行进一步压缩的前缀树.</p><p>我们给出一个路径压缩的例子:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Patricia_trie.svg" alt="Patricia_trie"></p><p>这样的好处在于: 树的深度显著减少了, 查找花费的时间更短了.</p><p>当然, 我们也需要明确, 路径压缩也意味着需要插入新单词的时候可能涉及到更复杂的 <strong>路径拆分操作</strong> . 同时, 路径压缩只在数中插入键值分布比较分散的时候比较有效.(举例而言, 单词很长, 但总数并不多时), 当键值分布过于密集, 意味着可供压缩的路径较少, 则这种方法与传统字典树的效率差的并不多.</p><p>当然, 我们这里只需要考虑这160位地址, 即以太坊的地址总空间有 $ 2^{160} $ 次方这么大, 这是个天文数字, 我们的地址分布也因此及其稀疏. 因此采用路径压缩的方式的效果还是很不错的.</p><h4 id="3-1-3-Merkle-Patricia-Tree-梅克尔路径压缩前缀树-MPT"><a href="#3-1-3-Merkle-Patricia-Tree-梅克尔路径压缩前缀树-MPT" class="headerlink" title="3.1.3 Merkle Patricia Tree(梅克尔路径压缩前缀树 &#x2F; MPT)"></a>3.1.3 Merkle Patricia Tree(梅克尔路径压缩前缀树 &#x2F; MPT)</h4><p>我们继续向下, 现在我们成功的将这棵树压缩了一下, 理论上讲, 相比于此前的Trie, 采用Patricia Tree的树应该要精简许多, 那我们现在想想, 是否能将这棵树中的指针换成哈希指针呢?</p><p>当然可以, 这正是我们现在的主流做法. 我们最终可以将这棵树的根哈希值放入块头中, 用于保证整棵树没有被改变过, 同时, 要查找时, 我们可以利用Patricia Tree的特点, 通过前缀快速查找到一个节点是否存在.</p><hr><p>读者读到这里可能会有疑问, 为什么之前Merkle Tree行不通, 现在就突然能成了?</p><p>我们思考我们上面这一系列流程干了些啥: 我们通过用户地址将每个账户进行了标识, 明确了要利用 <strong>字典树</strong> 的性质来进行查找, 这保证了状态树查找时的效率; 我们通过 <strong>路径压缩</strong> , 在以太坊的用户地址分布及其分散的情况下, 极大程度上降低了树的深度和宽度, 这保证了树的大小不会太大; 我们利用 <strong>梅克尔树</strong> 的性质, 在指针上附加哈希值, 保证了树的不易篡改性.</p><p>因此, 事实上, Merkle Patricia Tree 是一种对 <strong>数据完整性 &#x2F; 存储效率 &#x2F; 查找效率</strong> 的平衡.</p><hr><blockquote><p>我们此前在以太坊的账户章节(2.2)中提及: 以太坊中存在两种账户, <strong>普通账户</strong> 与 <strong>合约账户</strong> . 事实上, 这两种账户需要存储的内容不尽相同, 因此用于存储它们账户状态的 MPT 结构自然也不同.</p><p>那这两种账户是怎么同步在全球的以太坊树中的呢? 答案是, 通过我们前面提到的账户地址.</p><p>全球的以太坊树是一颗大的MPT, 它其中的每个叶子节点都是一个账户的地址, 这个地址指向一颗小的MPT. 至于指向的是哪种MPT, 则根据账户本身的类型来决定(普通账户MPT &#x2F; 合约账户MPT).</p><p>因此, 以太坊的MPT存储方式是分级存储的.</p></blockquote><p>这也代表着修改的便利性, 当一个新区块被添加到区块链中, 需要 <strong>根据全球MPT找到区块内所有涉及到的账户MPT -&gt; 修改对应的账户MPT</strong> 即可完成操作, 其他不涉及到的内容可以原封不动的搬过来.</p><blockquote><p>相对应的, 在修改账户MPT时, 也只需要寻找到需要修改的变量, 修改之, 即可. 不需要整体重新建立.</p></blockquote><h4 id="3-1-4-Roll-Back"><a href="#3-1-4-Roll-Back" class="headerlink" title="3.1.4 Roll Back"></a>3.1.4 Roll Back</h4><p>我们会发现, 以太坊中每个区块都要维护一个全局状态树和很多的个人账户状态树, 这看起来好像很浪费? 为什么要这么设计?</p><p>不同于比特币10分钟的出块时间, 以太坊的出块时间非常快, 接近15s. 这意味着很有可能产生临时性的分叉, 直到某一个分叉胜出后, 其余分叉才被判定为 <strong>Orphan Block</strong> 而被淘汰. 现在我们想一想, 当某一个节点所正在接受的分支被淘汰了, 它们应当怎样转到正确的分支上?</p><p>他们需要先进行 <strong>回滚操作(Roll Back)</strong> , 随后才能沿着新链条继续下去, 但这个回滚操作应当如何进行? </p><p>这就用到了此前区块中保存的状态树, 由于以太坊智能合约的存在, 以太坊的交易类型极大的复杂化, 因此必须要保存此前区块的全部状态树以保证 <strong>回滚的准确性</strong> .</p><h4 id="3-1-5-Key-Value-Pair"><a href="#3-1-5-Key-Value-Pair" class="headerlink" title="3.1.5 Key-Value Pair"></a>3.1.5 Key-Value Pair</h4><p>我们倒腾了这么半天, 状态树这东西到底里面是什么?</p><p>说说白了, 就是一个个的键值对.</p><p>对于账户状态树而言, 其 键(Key) 就是账户地址的哈希(那个160位二进制数的哈希值, 采用Keccak-256加密算法), 值(Value) 就是该地址对应的账户对象(包括余额 &#x2F; nonce &#x2F; {代码哈希} &#x2F; {存储根} , 利用RLP进行字符数组序列化操作)</p><blockquote><p>RLP(Recursive Length Prefix) 是一种数据编码方法, 目的在于将任意结构的数据进行高效的序列化 &#x2F; 反序列化操作, 具体序列化完成后体现为字节序列.</p></blockquote><hr><p><strong>状态树中的共享节点</strong></p><p>状态树中这种键值对的存储方式决定了以太坊的账户状态树的运作模式, 即只有账户状态被改变时, 才需要新建一个分支来存储它, 在本区块中 <strong>某个账户状态未发生变化</strong> , 则在本区块的状态树中, 可以原封不动的将上个区块的键值对搬过来(相当于还是指向同一个账户即可).</p><p>这代表着其实以太坊的状态树中, 存在大量的共享节点, 也使得存储效率得以提升.</p><hr><h3 id="3-2-交易树-收据树"><a href="#3-2-交易树-收据树" class="headerlink" title="3.2 交易树 &#x2F; 收据树"></a>3.2 交易树 &#x2F; 收据树</h3><p>在上一节中, 我们了解了以太坊中的状态树, 而这一节, 我们需要了解两个较小的树 <strong>交易树 &amp; 收据树</strong> , 之所以说它们比较小, 是因为相比于状态树, 这两棵树只会将 <strong>某个区块内涉及到的交易 &#x2F; 收据进行存储</strong> , 而不会像状态树一样存储所有账户的状态.</p><p>但从数据结构上来说, 交易树和收据树本质上还是 <strong>MPT</strong> . 不过与状态树不同的是, 交易树 &#x2F; 收据树 <strong>无法共享节点</strong> .</p><h3 id="3-3-Bloom-Filter"><a href="#3-3-Bloom-Filter" class="headerlink" title="3.3 Bloom Filter"></a>3.3 Bloom Filter</h3><h4 id="3-3-1-Bloom-Filter-的定义"><a href="#3-3-1-Bloom-Filter-的定义" class="headerlink" title="3.3.1 Bloom Filter 的定义"></a>3.3.1 Bloom Filter 的定义</h4><p>Bloom Filter 是一种用于 <strong>快速查找</strong> 的数据结构, 从理论上来讲, 它可以用于快速查找一个元素是否在一个集合中.</p><p>其原理是, 算法首先产生一个 <strong>数组</strong> , 将这个数组整体 <strong>初始化置0</strong> , 此后对于集合中的每个元素都运用 <strong>一个或多个哈希函数</strong> , 将其映射到数组中的 <strong>多个位置</strong> , 对于这些位置, <strong>置1</strong> .</p><p>当需要查找某个元素是否在上文中的集合中时, 只需要将这个元素运用相同的哈希函数, 映射到数组的对应位置, 并 <strong>检查这些位置是否都为1</strong> 即可.</p><p>这样做的好处在于检查者不需要得知一个集合中全部的元素, 而只需要知道这个集合映射过后的一个指定数组就可以进行查找操作, 这是对空间复杂度与时间复杂度的极大优化.</p><p><em>A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set. False positive matches are possible, but false negatives are not – in other words, a query returns either “possibly in set” or “definitely not in set”.</em></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Bloom_filter.svg" alt="Bloom Filter"></p><hr><p>但Bloom Filter也有缺陷, 由于其采用了哈希算法, 因此 <strong>哈希碰撞</strong> 就显得不可避免. 当要查询的元素(这个元素本身 <strong>并不在集合内</strong> )进行哈希过后, 产生的哈希值与集合中某个元素完全一致时(即产生了哈希碰撞), 此时就会出现误判现象. 因此, Bloom Filter只能代表 <strong>元素一定不在集合中</strong> 或 <strong>元素很可能在集合中</strong> 这两种结果.</p><blockquote><p>这也就是为何Bloom Filter可能采用 <strong>一组</strong> 而非一个哈希函数, 一组哈希函数的哈希碰撞率是很低的, 能够有效降低这种数据结构查找时的误判率.</p></blockquote><p>除此以外, Bloom Filter还 <strong>无法删除元素</strong> , 如果我们草率地将要删除的元素对应的数组位改为0, 如果集合中有同样映射到此位置上的元素, 则这个元素就会被误删.</p><h4 id="3-3-2-Bloom-Filter-in-Ethereum"><a href="#3-3-2-Bloom-Filter-in-Ethereum" class="headerlink" title="3.3.2 Bloom Filter in Ethereum?"></a>3.3.2 Bloom Filter in Ethereum?</h4><p>Bloom Filter 在以太坊中主要被用于区块头中的 <strong>交易树根</strong> 和 <strong>收据树根</strong> 的快速查找, 以此来提升以太坊的查询效率.</p><p>由于以太坊的交易复杂性, 导致频繁的查找某一 <strong>特定类型</strong> 的交易的操作是十分常见的. 因此以太坊引入了Bloom Filter数据结构, 以达到快速查找的目的.</p><p>以太坊中, 每个交易自身都有一个Bloom Filter(就是我们前面说的数组), 而区块头中的交易树根和收据树根则是所有交易Bloom Filter的 <strong>并集</strong> . 当查询者需要查找对应类型的交易时, 会先根据指定类型查找区块头中的交易树根 &#x2F; 收据树根; 如果找到了, 则再遍历区块中所有交易的Bloom Filter, 查找区块中是否有指定类型的交易.</p><blockquote><p>注意, 由于Bloom Filter的误判可能性, 因此可能会出现查询区块头时匹配成功, 但区块中其实并没有指定类型交易的情况(出现了哈希碰撞).</p></blockquote><h2 id="Part-4-共识协议-Ghost"><a href="#Part-4-共识协议-Ghost" class="headerlink" title="Part.4 共识协议: Ghost"></a>Part.4 共识协议: Ghost</h2><p>我们进入Ghost之前, 先考虑一下为什么比特币的挖矿协议用在以太坊上不可行?</p><p>在比特币中, 出现分叉后, 会根据后续挖矿的进度来决定最长合法链, 而被抛弃的链条(Orphan Block)上面的一切改动都会被作废, 包括区块记账权获得者的铸币奖励. 这是因为比特币的出块时间非常长, 有10分钟, 因此这种临时性的分叉不会对整个网络造成太大影响.</p><p>但在以太坊中, 出块时间只有15秒, 分叉的可能性大大提高. 如果还像以前一样, 分叉上的交易 &#x2F; 奖励全部作废, 这就代表着节点费劲千辛万苦挖出来的区块可能是个无用功, 这是不可接受的. 因此, 以太坊引入 <strong>Ghost</strong> 协议来解决这个问题.</p><blockquote><p>需要明确的是, Ghost协议并不是以太坊的发明, 以太坊在初版Ghost的基础上进行了一定的修改, 并应用于自己的系统中.</p></blockquote><h3 id="4-1-Ghost-Protocol"><a href="#4-1-Ghost-Protocol" class="headerlink" title="4.1 Ghost Protocol"></a>4.1 Ghost Protocol</h3><p>在此前 <strong>以太坊的出块奖励还未归零</strong> 时, Ghost规定, 如果当前区块链中存在 <strong>叔块(Uncle Block, 即比特币中的 Orphan Block)</strong> , 并且这个叔块 <strong>还未被主链接受(即此前还没有主链上的节点引用这个叔块)</strong>, 则主链上的节点(Nephew Block)可以在其挖出区块的头部将这个叔块包含进来, 即将叔块的哈希值放入自己的区块头中. 这被称为 <strong>引用叔块</strong> , 相对应的, 引用叔块的矿工会得到一笔引用奖励, 通常为 $ \frac{1}{32} $ 的常规区块奖励.</p><p>一个 Nephow Block 最多可以包括 2 个叔块.</p><p>需要明确的是, 以太坊中的 叔块 并不是严谨上的叔叔. 它在技术上的定义细节如下:</p><ul><li>Uncle Block 的出块时间必须比 Nephew Block 的出块时间早.</li><li>Uncle Block 的高度必须比 Nephew Block 低 <strong>6个区块</strong> 以内.</li><li>Uncle Block 不能是 Nephew Block 的 <strong>直接祖先区块</strong> .</li></ul><p>必须满足这三点, 一个区块才能被视作叔块, 并被包含在Nephew Block中.</p><p>与此同时, 被引用的叔块的记账人也能够获得一笔补偿费, 在当时, 这个补偿费是 $ \frac{8-differce \space height}{8} $ 的常规区块奖励, 其中 $ difference \space height &#x3D; nephewHeight - uncleHeight $ , 即叔块和当前块的高度差, 这样设计代表 <strong>以太坊鼓励出现分叉后立即合并</strong> , 因为合并越早, 得到的奖励越多.</p><blockquote><p>之所以加 <strong>出块奖励还未归零</strong> 这个定语, 是因为在 <strong>2022年9月15日</strong> 以太坊完成 <strong>合并升级(The Merge)</strong> 后, 以太坊已经转向POS(Proof of Stake)共识机制, 出块奖励已经归零, 因此叔块不再产生奖励.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理_Fin</title>
      <link href="/posts/61250.html"/>
      <url>/posts/61250.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><blockquote><p>写在前面:<br>本文是针对《计算机组成原理》(唐朔飞编著 &#x2F; 第三版) 一书的总结, 也是博主应对期末考试的知识梳理.<br>本文中使用了大量的图片, 它们大多来自课上的PPT, 在这里对于PPT作者致以诚挚的谢意, 如有侵权, 请联系作者进行博文的删除操作.<br>文中如果提到书目页数, 指向的也是上文提到的教材.</p><p>此外, 由于博主的课堂教授顺序与书中不尽然相同, 因此会按照课堂的教授顺序进行梳理, 章节名称以及序号会以书中的名称 &#x2F; 序号为准. 读者可根据目录快速查询到相关章节.</p></blockquote><h2 id="Chap-1-计算机系统概论"><a href="#Chap-1-计算机系统概论" class="headerlink" title="Chap.1 计算机系统概论"></a>Chap.1 计算机系统概论</h2><h3 id="1-1-计算机系统的组成"><a href="#1-1-计算机系统的组成" class="headerlink" title="1.1 计算机系统的组成"></a>1.1 计算机系统的组成</h3><h4 id="1）软硬件概念"><a href="#1）软硬件概念" class="headerlink" title="1）软硬件概念"></a>1）软硬件概念</h4><ul><li>硬件：各类实体、主机 &#x2F; 外设等</li><li>软件：由具有各类特殊功能的信息（程序）组成<ul><li>系统软件：用于管理整个计算机系统</li><li>应用软件</li></ul></li></ul><h4 id="2）解题过程-层次结构"><a href="#2）解题过程-层次结构" class="headerlink" title="2）解题过程 &amp; 层次结构"></a>2）解题过程 &amp; 层次结构</h4><p>计算机的程序运行过程主要经过以下过程：</p><p>高级语言程序-&gt;翻译为机器语言程序-&gt;运行-&gt;输出结果</p><p>根据该解题过程，可以将计算机分为如下层次结构：</p><ul><li>虚拟机器M4：用高级语言书写，利用 <strong>编译程序</strong> 翻译为汇编语言程序。</li><li>虚拟机器M3：用汇编语言书写，利用 <strong>汇编程序</strong> 翻译为机器语言程序。</li><li>操作系统机器M2：用机器语言解释操作系统。</li><li>实际机器M1：用微指令解释机器指令。</li><li>微程序机器M0：用硬件直接执行微指令。</li></ul><h4 id="3）计算机体系结构-Vs-计算机组成"><a href="#3）计算机体系结构-Vs-计算机组成" class="headerlink" title="3）计算机体系结构 Vs 计算机组成"></a>3）计算机体系结构 Vs 计算机组成</h4><ul><li>计算机体系结构：包含的主要是程序员能够见到的计算机系统属性。 <strong>概念性的结构与功能</strong> 。指令集、寻址技术等。</li><li>计算机组成：包含如何 <strong>实现计算机体系结构</strong> 涉及到的属性，但这些属性对于程序员而言大部分是透明的。</li></ul><h3 id="1-2-计算机的基本组成"><a href="#1-2-计算机的基本组成" class="headerlink" title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h3><h4 id="1）冯·诺依曼计算机的特点"><a href="#1）冯·诺依曼计算机的特点" class="headerlink" title="1）冯·诺依曼计算机的特点"></a>1）冯·诺依曼计算机的特点</h4><ul><li>由五大部件组成<ul><li>运算器：算术运算、逻辑运算，并暂存结果</li><li>存储器：存放数据、程序</li><li>控制器：控制、指挥程序和数据的输入、运行，并处理运算结果</li><li>输入设备：将人类能识别的信息转化为机器信息</li><li>输出设备：将机器信息（运算结果）转化为人类可识别的信息</li></ul></li><li>指令、数据以 <strong>同等地位</strong> 存于存储器，可按地址寻访</li><li>指令和数据均用二进制表示</li><li>指令由操作码和地址码组成</li><li>指令在存储器内按顺序存放</li><li>机器以运算器为中心</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A1%86%E5%9B%BE.png" alt="冯·诺伊曼计算机框图"></p><h4 id="2）现代计算机框图"><a href="#2）现代计算机框图" class="headerlink" title="2）现代计算机框图"></a>2）现代计算机框图</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A1%86%E5%9B%BE.png" alt="现代计算机框图"></p><ul><li>主机<ul><li>CPU<ul><li>ALU运算器</li><li>CU控制单元</li></ul></li><li>主存储器</li></ul></li><li>I&#x2F;O设备</li></ul><h4 id="3）计算机工作步骤"><a href="#3）计算机工作步骤" class="headerlink" title="3）计算机工作步骤"></a>3）计算机工作步骤</h4><ul><li>上机前的准备<ul><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序（不同的算法对应的解题程序完全不同）</li></ul></li></ul><p>如：计算 ax^2 + bx + c –&gt; (ax + b)x + c</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/ax%5E2%2Bbx%2Bc%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B.png" alt="计算例"></p><ul><li>解题过程</li></ul><p>（1）存储器的基本组成：</p><p>①存储体：</p><p>存储体-&gt;存储单元-&gt;存储元件</p><p>类比为：一栋大楼-&gt;一个房间-&gt;一个床位</p><p>一个存储元件能表示一位二进制数。<br>一个存储单元代表着一串二进制代码，这被称为一个字。</p><p>②MAR &amp; MDR：</p><p>MAR被称为地址寄存器，反应存储单元的个数。<br>MDR被称为数据寄存器，反应存储字长。</p><p>举例：MAR：4位，MDR：8位<br>代表有16个存储单元（2^4），一个存储单元由八位二进制数组成。</p><hr><p>（2）运算器的基本组成及操作过程：</p><p>加法：</p><ul><li>[M] -&gt; X</li><li>[ACC]+[X] -&gt; ACC</li></ul><p>减法：</p><ul><li>[M] -&gt; X</li><li>[ACC]-[X] -&gt; ACC</li></ul><blockquote><p>对于加减法，无需使用MQ，即乘商寄存器，只需要将最终结果暂存在ACC中即可。</p></blockquote><p>乘法：</p><ul><li>[M] -&gt; MQ</li><li>[ACC] -&gt; X</li><li>0 -&gt; ACC</li><li>[X]*[MQ] -&gt; ACC&#x2F;&#x2F;MQ</li></ul><blockquote><p>对于乘法，由于十分可能出现溢出，因此需要将ACC与MQ串在一起存储结果，我们记成 ACC&#x2F;&#x2F;MQ ，这里的MQ是乘商寄存器。</p></blockquote><p>除法：</p><ul><li>[M] -&gt; X</li><li>[ACC]&#x2F;[X] -&gt; MQ</li><li>R -&gt; ACC</li></ul><blockquote><p>对于除法，将结果暂存在乘商寄存器中，将余数存在ACC内。</p></blockquote><hr><p>（3）控制器的基本组成：</p><ul><li>PC：程序计数器，存放当前需要执行指令的地址</li><li>IR：指令寄存器，存放当前即将执行的指令</li><li>CU：控制单元</li></ul><p>完成一条指令需要三步：</p><ul><li>取指：PC（PC直接与MAR相连，方便取指）</li><li>分析：IR（IR的高位，即操作码会送到CU，记为OP(IR)-&gt;CU；IR的低位，即地址码会送到MAR，记作Ad(IR)-&gt;MAR）</li><li>执行：CU（发送各种位操作命令序列）</li></ul><p>例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%96%E6%95%B0%E6%8C%87%E4%BB%A4%E5%AE%8C%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="取数指令完成过程"></p><h3 id="1-3-计算机硬件的技术指标"><a href="#1-3-计算机硬件的技术指标" class="headerlink" title="1.3 计算机硬件的技术指标"></a>1.3 计算机硬件的技术指标</h3><h4 id="1）机器字长"><a href="#1）机器字长" class="headerlink" title="1）机器字长"></a>1）机器字长</h4><p>CPU一次能处理数据的位数。</p><h4 id="2）存储容量"><a href="#2）存储容量" class="headerlink" title="2）存储容量"></a>2）存储容量</h4><p>$$ 存储容量 &#x3D; 存储单元个数 * 存储字长 $$</p><p>存储单元个数由MAR体现，即：<strong>2^MAR 个存储单元</strong> ；而MDR反应存储字长， <strong>字长就是MDR位数本身</strong> 。</p><p>常用的存储单位：</p><p>1 byte &#x3D; 2^3 bit &#x3D; 8 bit</p><p>1 KB &#x3D; 2^10 byte</p><p>1 MB &#x3D; 2^10 KB</p><p>1 GB &#x3D; 2^10 MB</p><h4 id="3）运算速度"><a href="#3）运算速度" class="headerlink" title="3）运算速度"></a>3）运算速度</h4><ul><li>主频</li><li>吉普森法： $ T_M &#x3D; \sum_{i&#x3D;1}^n f_i * t_i $ 其中TM为机器运行速度，fi表示第i种指令占全部操作的占比数，ti表示该种指令的运行时间。</li><li>MIPS：每秒执行百万条指令</li><li>CPI：执行一条指令所需时钟周期数</li><li>FLOPS：每秒浮点运算次数</li></ul><h2 id="Chap-6-计算机的运算方法"><a href="#Chap-6-计算机的运算方法" class="headerlink" title="Chap.6 计算机的运算方法"></a>Chap.6 计算机的运算方法</h2><h3 id="6-1-无符号数和有符号数"><a href="#6-1-无符号数和有符号数" class="headerlink" title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h3><h4 id="1）无符号数"><a href="#1）无符号数" class="headerlink" title="1）无符号数"></a>1）无符号数</h4><p>顾名思义，无符号数无正负，所有的位数都用于表示数字的大小。</p><p>例：8位无符号数能表示的范围：0~255（$ 2^8 -1 $）</p><h4 id="2）有符号数"><a href="#2）有符号数" class="headerlink" title="2）有符号数"></a>2）有符号数</h4><p>利用单独的一位符号位来表示正负，用0表示正，用1表示负。</p><p>下面提三种表示方法：</p><p>①原码表示法</p><p>最简单的一种方法，符号位+数值位，数值位上就是 <strong>真值的绝对值</strong> 。</p><p>严谨定义如下：</p><p>$$ x_{整数}[原] &#x3D; \begin{cases}<br>    x, 2^n &gt; x \geq 0 \\<br>    2^n - x, 0 \geq x &gt; -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[原] &#x3D; \begin{cases}<br>    x, 1 &gt; x \geq 0 \\<br>    1 - x, 0 \geq x &gt; -1\<br>\end{cases} $$</p><p>其实不用摁记原始定义，在实际换算上，整数使用带余除法，小数利用不断乘2，取整数位的操作来获得即可。</p><p><strong>需要注意的是，在x &#x3D; 0时，正零和负零利用原码的表示是不同的：</strong> </p><p>$ [+0]_原 &#x3D; 0,0000 $<br>$ [-0]_原 &#x3D; 1,0000 $</p><hr><p>②补码表示法</p><p>计算机为了归一加法和减法，利用了另一种表示方法，即 <strong>补码</strong> 的概念。</p><p>补码的根本概念需要说起同余，即涉及到了带余除法的概念，具体而言，-3与+9在除以12时，余数是一样的，因此在模12的意义下，这俩是一个数。</p><p>因此，我们类比上面的思路，可以将负数转化为相对应的模数。</p><p>给出严谨定义如下：</p><p>$$ x_{整数}[补] &#x3D; \begin{cases}<br>    x, 2^n &gt; x \geq 0 \\<br>    2^{n+1} + x \space(mod \space 2^{n+1}), 0 &gt; x \geq -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[补] &#x3D; \begin{cases}<br>    x, 1 &gt; x \geq 0 \\<br>    2 + x \space (mod \space 2), 0 &gt; x \geq -1\<br>\end{cases} $$</p><p>需要说明的是，式子里的x是真值。</p><p>还是不用摁记定义，有一种快捷的方式可以求补码。</p><p>显然，正数的补码不用管，就是它自身；<br>负数的补码可以通过 <strong>除符号位每位取反，最后在末位再加1求得</strong> 。</p><p><strong>两个特殊的案例：</strong></p><p>首先，根据定义（这里不要用快捷的求补码方式），+0 和 -0 的补码是一样的，都是 0,0000</p><p>第二，关于多出来的 1,0000这个值怎么办，这个值原先是 -0的原码，但是现在-0被占据了，那就将其指向最小的那个负数，这也就是为什么补码可以比原码表示的负数个数多一个。</p><p>举个例子，8位原码表示的范围是： $ -2^7+1 \to 2^7-1 $ </p><p>而8位补码能表示的范围是： $ -2^7 \to 2^7-1 $</p><hr><p>③反码表示法</p><p>反码表示法的严谨定义如下：</p><p>$$ x_{整数}[反] &#x3D; \begin{cases}<br>    x, 2^n &gt; x \geq 0 \\<br>    (2^{n+1} - 1) + x \space(mod \space 2^{n+1} - 1), 0 \geq x &gt; -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[反] &#x3D; \begin{cases}<br>    x, 1 &gt; x \geq 0 \\<br>    (2 - 2^{-n}) + x \space(mod \space 2 - 2^{-n}), 0 \geq x &gt; -1 \<br>\end{cases} $$</p><p>这里n是指小数的位数</p><p>同样的，有一种快速求反码的方式，即 <strong>除了符号位之外各位取反</strong> 即可。</p><p>我们把三种东西总结一下：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%EF%BC%8C%E8%A1%A5%EF%BC%8C%E5%8F%8D.png" alt="原，补，反"></p><hr><p>最后，提一嘴关于移码的内容。</p><p>移码是为了解决补码无法非常直观的看出数字大小而发明的。</p><p>其定义为：</p><p>$$ x[移] &#x3D; 2^n + x $$</p><p>n是整数的位数。</p><p>其快捷算法即 <strong>先将补码算出来，改一个符号位即可</strong> 。</p><p>显然，根据移码的定义，移码这里也没有+0，-0的区分。</p><p>而对于对应数位上最小的那个值，其移码为全0。</p><p>举个例子：n&#x3D;5时， $ -2^5[移] &#x3D; 0,00000 $</p><p>这也与其补码相匹配，毕竟 $ -2^5[补] &#x3D; 1,00000 $</p><h3 id="6-2-数的定点表示和浮点表示"><a href="#6-2-数的定点表示和浮点表示" class="headerlink" title="6.2 数的定点表示和浮点表示"></a>6.2 数的定点表示和浮点表示</h3><h4 id="1）定点表示"><a href="#1）定点表示" class="headerlink" title="1）定点表示"></a>1）定点表示</h4><p>即将小数点位置固定在某一位置，这样的方法容易在进行运算时产生溢出风险，尤其是在处理的数字不是纯整数或纯小数时。</p><h4 id="2）浮点表示"><a href="#2）浮点表示" class="headerlink" title="2）浮点表示"></a>2）浮点表示</h4><p>浮点数是当前更多采用的方法，其一般形式为：</p><p>$$ N &#x3D; S * r^j $$</p><ul><li>S: 尾数，小数，可正可负</li><li>r: 基数，一般取2，4，8，16等</li><li>j: 阶码，整数，可正可负</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F.png" alt="浮点数的表示形式"></p><p>n，是尾数的位数，反映了浮点数的精度<br>m，是阶码的位数，反映了浮点数的表示范围</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4.png" alt="浮点数的表示范围"></p><hr><p>浮点数的规格化：即将类似 0.00001 这类的小数转化成 $ 0.10000 * 2^{1,0100} $ 这样的德行（这里全用的二进制机器数），说的再简单点，就是把小数点后面能用阶码表示的0全去了。</p><p>具体怎么规格化呢，先将真值对应的二进制数字进行规格化，比如： $ -0.0001011 &#x3D; 2^{-3} * -0.1011$ ，而后再进行对应的机器数转换，后面这个转换过程中不需要再做任何移位操作。</p><p>需要注意的是，规格化之后也涉及到补码、反码之类的一堆形式，一般会给要求，如 <strong>阶原尾补</strong> 之类的，即阶码用原码表示，尾数用补码表示。</p><p>关于机器0：当尾数为0时，不论阶码为何值，均按照机器0处理。</p><h3 id="6-3-定点运算"><a href="#6-3-定点运算" class="headerlink" title="6.3 定点运算"></a>6.3 定点运算</h3><p>计算机中的乘法是通过类似笔算乘法的方式通过移位来实现的：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%AC%94%E7%AE%97%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png" alt="笔算乘法的改进"></p><p>这里A是 <strong>被乘数</strong> , B是 <strong>乘数</strong> .</p><p>因此我们将其化为下面的竖式:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%AC%94%E7%AE%97%E4%B9%98%E6%B3%95_%E7%AB%96%E5%BC%8F.png" alt="改进笔算乘法的竖式表示"></p><p>上面的步骤可以总结为:</p><ul><li>利用加法和移位进行乘法运算.</li><li>由乘数的末尾决定是否与被乘数相加, 而后进行 <strong>整体右移</strong> , 乘数最后一位丢弃, 同时结果(即原先部分积)右移一位, 将放不下的那一位放在 <strong>乘数右移空出的高位</strong> 上.</li><li>总次数取决于乘数的位数</li></ul><h4 id="6-3-1-原码一位乘"><a href="#6-3-1-原码一位乘" class="headerlink" title="6.3.1 原码一位乘"></a>6.3.1 原码一位乘</h4><p>原码一位乘与上述笔算乘法思想完全相同, 不过需要额外考虑 <strong>符号位</strong> 的问题, 这里一般采取 <strong>符号位和数值位分开处理</strong> 的方法.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98.png" alt="原码一位乘"></p><p>最终将符号位 ( $ 1 \bigoplus 0 &#x3D; 1 $ ) 加上即可得到最终结果: 1.10110110.</p><h4 id="6-3-2-原码两位乘"><a href="#6-3-2-原码两位乘" class="headerlink" title="6.3.2 原码两位乘"></a>6.3.2 原码两位乘</h4><p>两位乘法是为了后续为了节省时间而设计出来的算法, 但是两位乘法涉及到 <strong>加三个被乘数</strong> , 而计算机对于三这个数字并不高效, 因此通过单独一个进位位来进行处理:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98.png" alt="原码两位乘_原理"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98_%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png" alt="原码两位乘_运算规则"></p><p>需要额外说明的是, 由于原码二位乘涉及到进位问题( 详细来说, 就是可能需要加两倍的被乘数[即左移一位], 或者减去一倍的被乘数[符号位全部置1] ) 因此在原码两位乘时, 我们需要 <strong>写三个符号位</strong> .</p><p>原码两位乘的符号位仍然需要单独处理, 乘法是否结束看的是乘数位数( <strong>x位需要右移 $ \frac{x}{2} $ 次, 每次右移两位</strong> ).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98_%E4%BE%8B.png" alt="原码两位乘_例"></p><h4 id="6-3-3-补码乘法"><a href="#6-3-3-补码乘法" class="headerlink" title="6.3.3 补码乘法"></a>6.3.3 补码乘法</h4><p>补码一位乘:</p><p>补码一位乘即利用补码的形式进行与上述模式类似的优化乘法, 运算规则如下:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98_%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png" alt="补码一位乘_运算规则"></p><hr><p>这里着重介绍Booth算法:</p><p>Booth算法 <strong>无需考虑被乘数和乘数的符号</strong> , 这里不对其原理进行详细介绍, 仅给出计算规则:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Booth%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="Booth_计算公式"></p><p>请额外注意: <strong>Booth算法的乘数需要带着符号位</strong> , 也正因如此, <strong>Booth算法的最后一步加法无需右移</strong> .</p><p>此外, Booth算法的右移是 <strong>补码右移</strong> , 补上的数字 <strong>同当前计算结果的符号位</strong> .</p><p>给个例子:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Booth_%E4%BE%8B.png" alt="Booth_例"></p><h3 id="6-4-浮点四则运算"><a href="#6-4-浮点四则运算" class="headerlink" title="6.4 浮点四则运算"></a>6.4 浮点四则运算</h3><p>本节需要明确的问题是处理两个规格化的浮点数之间的运算.</p><p>对于浮点数:</p><p>$$ x &#x3D; S_x * 2^{j_x} $$</p><p>$$ y &#x3D; S_y * 2^{j_y} $$</p><h4 id="6-4-1-浮点加减"><a href="#6-4-1-浮点加减" class="headerlink" title="6.4.1 浮点加减"></a>6.4.1 浮点加减</h4><p>可以分为三步来进行:</p><ul><li>对阶: 相当于正常运算中的对齐对应位操作</li><li>尾数求和: 利用对应的补码加减定点运算进行</li><li>规格化</li><li>舍入: 如果规格化过程中出现了 <strong>尾数末尾丢失</strong> 的情况, 要考虑舍入</li></ul><hr><p>1.对阶:</p><p>显然, 阶数小的浮点数应当向阶数大的浮点数看齐.</p><p>为了方便, 这里应当 <strong>尽可能使用补码运算</strong> .</p><p>2.尾数求和:</p><p>利用化完的补码进行加减即可.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E5%8A%A0%E5%87%8F_%E4%BE%8B.png" alt="浮点加减_例"></p><p>3.规格化:</p><p>规格化, 意思为需要将加(减)完的数转变为规格化数.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A7%84%E6%A0%BC%E5%8C%96%E6%95%B0.png" alt="规格化数"></p><p>由于我们这里通常使用补码加, 因此要记住补码的规格化数特点: <strong>符号位和第一数位不同</strong> .</p><p>延续上例:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A7%84%E6%A0%BC%E5%8C%96_%E6%96%B9%E6%B3%95.png" alt="规格化_方法"></p><p>4.舍入:</p><p>即考虑被舍弃的尾数应当如何处理:</p><ul><li>0舍1入: 被舍弃的值是0则直接舍弃, 是1则将舍弃后尾数加1(精度较高)</li><li>恒置1: 不论舍弃的低位是什么, <strong>舍弃后的最低位</strong> 恒置为1</li></ul><h4 id="6-4-2-浮点乘除"><a href="#6-4-2-浮点乘除" class="headerlink" title="6.4.2 浮点乘除"></a>6.4.2 浮点乘除</h4><p>与加减不同, 浮点乘除不需要考虑对阶, 直接进行运算即可:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E4%B9%98%E9%99%A4.png" alt="浮点乘除"></p><p>除法运算并不要求掌握, 这里不细说了.</p><h3 id="6-5-算术逻辑单元ALU"><a href="#6-5-算术逻辑单元ALU" class="headerlink" title="6.5 算术逻辑单元ALU"></a>6.5 算术逻辑单元ALU</h3><h4 id="6-5-1-ALU概述"><a href="#6-5-1-ALU概述" class="headerlink" title="6.5.1 ALU概述"></a>6.5.1 ALU概述</h4><p>因为这不是数字电路基础的复习, 因此对于ALU的详细电路组成不会进行非常详细的讲解.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/ALU.png" alt="ALU"></p><p>中间的ALU其实是相当复杂的组合逻辑电路, 典型的四位ALU芯片为74181, 在数字电路中有所提及.</p><p>这里只需要明确, ALU是 <strong>根据 $ K_i $ 的不同取值对 $ A_i, B_i $ 进行相应的操作, 从而使 $ F_i $ 输出对应的运算结果</strong> 的器件即可(明确一下, 这里i使可以取多位的, 要不然ALU只能进行一位数的两种运算也太low了).</p><h4 id="6-5-2-快速进位链"><a href="#6-5-2-快速进位链" class="headerlink" title="6.5.2 快速进位链"></a>6.5.2 快速进位链</h4><p>我们需要详细了解的是ALU的快速进位链, 即ALU进位的过程.</p><hr><p>1.并行加法器:</p><p>这种进位是最慢的, 因为它需要等待前面的位运算完毕产生进位信号 $ C_i $ 后, 才能进行自己的运算.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BF%AB%E9%80%9F%E8%BF%9B%E4%BD%8D%E9%93%BE_%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="并行加法器"></p><hr><p>2.串行进位链:</p><p>我们先看正常全加器中 $ C_i $ 的逻辑表达式</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%85%A8%E5%8A%A0%E5%99%A8%E9%80%BB%E8%BE%91_%E8%BF%9B%E4%BD%8D%E6%9D%A1%E4%BB%B6.png" alt="进位条件"></p><p>可见, 将其进位公式抽象成了:</p><p>$$ C_i &#x3D; d_i + t_i C_{i-1}, d_i &#x3D; A_i B_i, t_i &#x3D; A_i+B_i $$</p><p>显然, $ d_i, t_i $ 都是可以先算出来的, 而 $ C_{i-1} $ 需要等待下位传递.</p><p>因此, 一个像这样的串行进位链就出来了:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E9%93%BE.png" alt="串行加法链"></p><p>如果一个与非门的判断延迟时间: $ t_y $</p><ul><li>一位进位信号产生时间: $ 2t_y $</li><li>n位进位信号产生时间: $ 2nt_y $</li></ul><hr><p>3.并行进位链:</p><p>其实将上面的 $ C_0, C_1, C_2 $ 等元素进行递推, 就可以发现并行进位链的效率可以进一步提高(相当于 $ C_{-1} $ 的进位信号来了, 就可以一次产生4个进位信号).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E9%93%BE.png" alt="并行进位链"></p><p>这样的结构需要额外在每个进位位前面加一个 <strong>与或非门</strong> , 我们假设其判断时间为: $ 1.5t_y $</p><p>可见, 仅需要 $ 1.5t_y + t_y &#x3D; 2.5t_y $ 的时间, 就可以产生四位的进位信号, 效率很高.</p><p>但是肉眼可见的, 这种进位的电路相当的复杂, 因此, 只能成组使用.</p><p>(1) 单重分组跳跃进位:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E9%93%BE_%E5%8D%95%E9%87%8D%E5%88%86%E7%BB%84.png" alt="并行进位链_单重分组"></p><p>可见, 将四位为1组, 每组可以在 $ 2.5t_y $ 的时间内产生进位信号, 并将最后一位的进位信号传向下一组.</p><p>(2) 双重分组跳跃进位链:</p><p>在上述分组的基础上, 每小组再分成一个大组:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D_%E7%94%B5%E8%B7%AF.png" alt="双重分组跳跃进位_电路"></p><p>我们以第八小组为例, 给出进位逻辑: </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D%E9%93%BE_%E9%80%BB%E8%BE%91.png" alt="双重分组跳跃进位链_逻辑"></p><p>可见, 可以通过进一步拆解递推公式, 发现一大组中的四个小组的进位信号 $ C_i $ 都可以通过前一个大组传来的最终进位信号 $ C_{-1} $ 得到, 进而进一步设计电路节省时间.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E8%B7%B3%E8%B7%83%E5%88%86%E7%BB%84_%E5%A4%A7%E7%BB%84%E7%94%B5%E8%B7%AF.png" alt="双重跳跃分组_大组电路"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E8%B7%B3%E8%B7%83%E5%88%86%E7%BB%84_%E5%B0%8F%E7%BB%84%E7%94%B5%E8%B7%AF.png" alt="双重跳跃分组_小组电路"></p><p>小组分组电路中, 由于第8小组的 <strong>最高位进位</strong> $ C_3 $ 可以根据 $ T_8, D_8 $ 得到, 而 $ T_8, D_8 $ <strong>还可以进一步用于后续小组(第5, 6, 7小组)的进位</strong> , 因此不再输出 $ C_3 $ , 转而输出 $ T_8, D_8 $</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D%E9%93%BE_%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90.png" alt="双重分组跳跃进位链_时间分析"></p><p>可见, 双重分组跳跃进位链产生16位进位的时间进一步缩短到 $ 7.5t_y $ , 究其根本原因在于每一个小组的最高位进位( $ C_15, C_11, C_7, C_3 $ )通过电路提前根据 $ C_{-1} $ 算出来了, 而不像单重分组那样需要等待前几个分组的信号.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/32%E4%BD%8D%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E9%93%BE_%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90.png" alt="32位双重分组跳跃链_时间分析"></p><h2 id="Chap-4-存储器"><a href="#Chap-4-存储器" class="headerlink" title="Chap.4 存储器"></a>Chap.4 存储器</h2><h3 id="4-1-存储器概述"><a href="#4-1-存储器概述" class="headerlink" title="4.1 存储器概述"></a>4.1 存储器概述</h3><h4 id="4-1-1-存储器分类"><a href="#4-1-1-存储器分类" class="headerlink" title="4.1.1 存储器分类"></a>4.1.1 存储器分类</h4><p>存储器有多种分类方式:</p><ul><li>按存储介质分类<ul><li>半导体存储器: TTL &#x2F; MOS</li><li>磁表面存储器: 磁头, 载磁体</li><li>磁芯存储器: 硬磁材料, 环状原件</li><li>光盘存储器: 激光, 激光材料</li></ul></li><li>按存取方式分类:<ul><li>存取时间与物理地址无关(随机访问)<ul><li>随机存储器( <strong>可读可写</strong> )</li><li>只读存储器( <strong>只读</strong> )</li></ul></li><li>存取时间与物理地址有关(串行访问)<ul><li>顺序存取存储器(磁带)</li><li>直接存取存储器(磁盘)</li></ul></li></ul></li><li><strong>按在计算机中的作用分类</strong> :<ul><li>主存储器:<ul><li>RAM<ul><li>静态RAM: SRAM</li><li>动态RAM: DRAM, SDRAM</li></ul></li><li>ROM<ul><li>MROM</li><li>PROM</li><li>EPROM</li><li>EEPROM</li></ul></li></ul></li><li>Flash Memory(闪存)</li><li>高速缓冲存储器(Cache)</li><li>辅助存储器: 磁盘, 磁带, 光盘</li></ul></li></ul><h4 id="4-1-2-存储器的层次结构"><a href="#4-1-2-存储器的层次结构" class="headerlink" title="4.1.2 存储器的层次结构"></a>4.1.2 存储器的层次结构</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%B9%E6%AF%94.png" alt="存储器对比"></p><p>由于目前比较常见的说法都按照在计算机中的作用分类, 因此我们通常利用该种分类方式来描述存储器的主要特性.</p><p>根据上图的层次性质对比, 可以将计算机的存储层次归纳为:</p><p>$$ CPU \iff 缓存 \iff 主存 \iff 辅存 $$</p><p>这其中:</p><ul><li><strong>$ 缓存 \iff 主存 $ 层次主要解决CPU与主存速度不匹配的问题</strong></li><li><strong>$ 主存 \iff 辅存 $ 层次主要解决存储系统的容量问题</strong></li></ul><h3 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h3><h4 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h4><p><strong>主存的基本组成</strong> 如下图所示:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="主存的基本组成"></p><p><strong>MAR &#x2F; MDR</strong> 即地址寄存器和数据寄存器在第一章中有所提及, CPU向MAR, MDR发送数据, 而后MAR, MDR分别通过地址总线和数据总线与内存的相应电路相连, 并以此达到读或写的目的.</p><h4 id="4-2-2-主存中存储单元的地址"><a href="#4-2-2-主存中存储单元的地址" class="headerlink" title="4.2.2 主存中存储单元的地址"></a>4.2.2 主存中存储单元的地址</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E9%85%8D_%E6%8C%89%E5%AD%97%E8%8A%82%E4%B8%8E%E6%8C%89%E5%AD%97%E5%AF%BB%E5%9D%80.png" alt="按字节与按字寻址"></p><p><strong>地址线</strong> 决定了计算机的寻址空间: 一根地址线能够一个二进制位.</p><p>如果按照字节编址: 寻址范围为 $ 2^{24} &#x3D; 16M $</p><p>如果按照字编址: 寻址范围则缩小为 $ \frac{2^{24}}{\frac{x}{8}}, x是字的位数 $ , 即 $ \frac{原寻址范围}{一个字包含的字节数} $</p><p>读者可以将按照字编制理解为将多个字节打了个包, 只能寻找到一个包裹而不能单独将包裹内的字节拿出来, 因此寻址范围也需要相应减少.</p><h4 id="4-2-3-主存的技术指标"><a href="#4-2-3-主存的技术指标" class="headerlink" title="4.2.3 主存的技术指标"></a>4.2.3 主存的技术指标</h4><p>主要有三种存储器指标可供参考:</p><ul><li>存储容量: 主存存放二进制代码的总位数</li><li>存储速度<ul><li>存取时间: 包括 <strong>访问时间, 读出时间, 写入时间</strong></li><li>存取周期: 连续两次 <strong>独立</strong> 的存储器操作所需的最小间隔时间</li></ul></li><li>存储器的带宽: 位&#x2F;秒</li></ul><blockquote><p>存储器带宽的算法要会, 具体而言, $ 单次取出位数*存储器频率 $ , 通常可能给出一个存取周期, 给出单次取出位数, 会让算存储器带宽.</p></blockquote><h4 id="4-2-4-半导体存储芯片"><a href="#4-2-4-半导体存储芯片" class="headerlink" title="4.2.4 半导体存储芯片"></a>4.2.4 半导体存储芯片</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87_%E5%AE%B9%E9%87%8F%E8%AF%B4%E6%98%8E.png" alt="半导体存储芯片及容量说明"></p><p>目前主流的半导体存储芯片利用地址线通过译码驱动电路指向存储矩阵中的内存单元, 再由数据线将内存单元中的数据取出.</p><blockquote><p>可以直接根据地址线和数据线的数量来计算出总芯片容量, $ 容量 &#x3D; 2^{地址线位数} * 数据线位数 $ , 即 <strong>总共多少个存储单元 * 一个存储单元内多少位</strong> .</p></blockquote><p><strong>片选线</strong> 用于选取存储芯片(后文会提及), <strong>读写控制线</strong> 用于决定进行何种(读 &#x2F; 写)操作.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%89%87%E9%80%89%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="片选线"></p><p>上图也能证明, 很多存储器是由 <strong>多片容量更小的存储器组合在一起</strong> 组成的.</p><h4 id="4-2-5-半导体存储芯片的译码驱动方式"><a href="#4-2-5-半导体存储芯片的译码驱动方式" class="headerlink" title="4.2.5 半导体存储芯片的译码驱动方式"></a>4.2.5 半导体存储芯片的译码驱动方式</h4><p>1.线选法:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8_%E7%BA%BF%E9%80%89%E6%B3%95.png" alt="线选法"></p><p>线选法原理简单, 如上图所示, 很多的存储单元组成 $ m*n $ 位的矩阵, 地址译码器先将地址线的二进制数译码为对应的行数, 而位线再通过与对应列数对齐将一行的所有位输出.</p><p>2.重合法:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8_%E9%87%8D%E5%90%88%E6%B3%95.png" alt="重合法"></p><p>重合法通过二维的地址译码器选中一个特定的存储单元. 两侧的译码单元作用与上面的线选法原理相同.</p><h4 id="4-2-6-静态RAM及芯片举例"><a href="#4-2-6-静态RAM及芯片举例" class="headerlink" title="4.2.6 静态RAM及芯片举例"></a>4.2.6 静态RAM及芯片举例</h4><p>静态RAM通过触发器与放大器等元器件进行数据读写, 这里不对具体的原理电路进行说明, 进进行芯片举例:</p><p><strong>Intel 2114</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%202114%20RAM%E7%9F%A9%E9%98%B5.png" alt="Intel 2114 RAM"></p><p>总体思路与重合法(矩阵单元选择)的方法很像, 但2114的列地址译码器可以一次选择一行中的四位(即 $ x, x+16, x+32, x+48 $ 四列), 从而达到一次传输出4位二进制数据的效果.</p><p>这里以写操作举例:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%202114%20%E5%86%99%E6%93%8D%E4%BD%9C.png" alt="Intel 2114 写操作"></p><h4 id="4-2-7-动态RAM及芯片举例"><a href="#4-2-7-动态RAM及芯片举例" class="headerlink" title="4.2.7 动态RAM及芯片举例"></a>4.2.7 动态RAM及芯片举例</h4><p>动态RAM通过电容存储电荷的原理来寄存信息. 电容上的电荷仅能持续 1~2 ms, 因此, 必须每2ms对所有存储单元恢复一次原状态, 这被称为 <strong>再生或刷新</strong> .</p><p>由于动态RAM的基本单元性质, 它读出的高低电平与 <strong>原存信息反相</strong> .</p><p><strong>Intel 1103</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%201103%20%E8%AF%BB%E6%93%8D%E4%BD%9C.png"></p><hr><p><strong>动态RAM的刷新</strong></p><p>由于电容的特性, 动态RAM需要定时进行刷新.</p><p><strong>1.集中刷新</strong></p><p>即在一段时间后单独拉出一段整时间进行全体刷新:</p><p>需要明确的是, 刷新是跟行地址强相关的, 即一次存取周期刷新一整行.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png" alt="集中刷新"></p><p>图中两个概念:</p><ul><li>死区: 用于刷新的时间, 即 $ 存取周期 * 矩阵行数 $</li><li>死时间率: 死区时间占比, 即 $ \frac{死区时间}{刷新时间间隔} $</li></ul><p><strong>2.分散刷新</strong></p><p>分散刷新将刷新分布在了存取周期内, 即花一半的周期进行读 &#x2F; 写, 另一半的周期用于刷新.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM_%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png" alt="分散刷新"></p><p>由于刷新按行进行, 因此只需要 $ (0.5+0.5)*128 &#x3D; 128\mu s $ 就能完成一整次刷新. 并且不会存在停止读写的死区时间.</p><p>代价是存取周期更长了, 整个系统的速度受影响.</p><p><strong>3.异步刷新</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM_%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png" alt="异步刷新"></p><p>异步刷新想将分散刷新与集中刷新结合起来, 其做到每行隔 2ms 刷新一次, 平均到每行, 即 $ \frac{2*10^3}{128} &#x3D; 15.6 \mu s $ 刷新一行. 仍有死区, 但死区很短, 并且对系统速度影响较小.</p><h4 id="4-2-8-动态RAM与静态RAM的比较"><a href="#4-2-8-动态RAM与静态RAM的比较" class="headerlink" title="4.2.8 动态RAM与静态RAM的比较"></a>4.2.8 动态RAM与静态RAM的比较</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM%E4%B8%8E%E9%9D%99%E6%80%81RAM%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="动 / 静态比较"></p><h4 id="4-2-9-只读存储器ROM"><a href="#4-2-9-只读存储器ROM" class="headerlink" title="4.2.9 只读存储器ROM"></a>4.2.9 只读存储器ROM</h4><ul><li>MROM</li><li>PROM(一次性编程)</li><li>EPROM(多次性编程)</li><li>EEPROM(电可擦写多次性编程)</li><li>Flash Memory(闪存)<ul><li>便宜</li><li>电可擦洗</li><li>比EEPROM快</li></ul></li></ul><h3 id="4-3-存储器与CPU的连接"><a href="#4-3-存储器与CPU的连接" class="headerlink" title="4.3 存储器与CPU的连接"></a>4.3 存储器与CPU的连接</h3><h4 id="4-3-1-存储容量扩展"><a href="#4-3-1-存储容量扩展" class="headerlink" title="4.3.1 存储容量扩展"></a>4.3.1 存储容量扩展</h4><p><strong>1.位扩展(增加存储字长)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="位扩展"></p><p><strong>2.字扩展(增加存储字(也可理解为存储单元)的数量)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="字扩展"></p><p><strong>3.字 &#x2F; 位同时扩展(上述二者结合)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E5%AD%97%2C%20%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="字 / 位扩展"></p><p>由上述说明可知, 通过地址线的增加来实现字扩展(扩大寻址空间), 通过数据线的增加来实现位扩展(扩大存储单元位数)</p><h4 id="4-3-2-存储器与CPU的连接"><a href="#4-3-2-存储器与CPU的连接" class="headerlink" title="4.3.2 存储器与CPU的连接"></a>4.3.2 存储器与CPU的连接</h4><p>例题: 见书P94~99 例4.1 &#x2F; 4.2 &#x2F; 4.3</p><p>通常可以分为四步: </p><ul><li>写出要求主存地址空间分配的二进制码</li><li>确定使用的芯片数量及类型</li><li>分配CPU的地址线</li><li>形成片选信号</li></ul><p>需要注意的是, 这里题目中给出的4K, 8K往往代表 <strong>寻址空间</strong> 而并非 <strong>总容量</strong> (举例而言, 如果题目希望分配4K地址的系统程序区, 而系统又有8根数据线, 你应当分配一个4K*8位的存储芯片, 而并非是一个256bit*8位的存储芯片), 即这里的地址指的都是编好地址的一个个存储单元, 而并非单独的一位.</p><h3 id="4-4-提高访存速度的措施"><a href="#4-4-提高访存速度的措施" class="headerlink" title="4.4 提高访存速度的措施"></a>4.4 提高访存速度的措施</h3><p>总体而言, 提高访存速度有三种方法:</p><ul><li>采用高速器件</li><li>采用层次结构(Cache-主存)</li><li>调整主存结构</li></ul><p>从主存结构说起:</p><p><strong>1.单体多字系统</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E7%BB%93%E6%9E%84_%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F.png" alt="单体多字系统"></p><p>这种设计的目的在于单次从存储体中某一地址取出多条指令, 并在此后每隔一定时间送给CPU一条指令, 这极大程度上提高了主存的带宽, 但显然, 这种设计的前提在于指令必须是连续存储的.</p><blockquote><p>劣势: 遇到 <strong>转移指令</strong> 或 <strong>操作数不能连续存放的指令</strong> 时, 效果不明显</p></blockquote><p><strong>2.多体并行系统</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%28%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%29.png" alt="多体并行系统(高位交叉编址)"></p><p>相当于将主存再度分层, 分为N个模块, 每个模块都有自己的MAR, MDR可供独立使用, 这使得它们可以并行工作, 又可以交叉工作.</p><p>上图所谓 <strong>高位交叉</strong> 即高位地址表示体号, 低位地址表示体内地址. 这种编址可以使不同的请求源同时访问不同的体, 实现 <strong>多体并行操作</strong> ;</p><hr><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%28%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%29.png" alt="多体并行系统(低位交叉编址)"></p><p>与高位交叉相反的思路是 <strong>低位交叉</strong> , 即低位地址表示体号, 高位地址表示体内地址, ( <strong>将所有内存分成几个体, 就称作模几交叉, 比如上图就是一个模4的交叉编址</strong> ) 这种方式能够在不改变存取周期的前提下增加存储器的带宽: </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89_%E5%A2%9E%E5%A4%A7%E5%B8%A6%E5%AE%BD.png" alt="低位交叉_增大带宽"></p><p>如上图, 低位交叉可以通过硬件设计使得 <strong>不同的体先后在同一个访存周期的不同时段启动</strong> , 以此达到一个访存周期传递多条指令的效果(上例中读顺序: 0-&gt;1-&gt;2-&gt;3-&gt;0-&gt;1-&gt;2-&gt;3)</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89_%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86.png" alt="低位交叉_流水线原理"></p><hr><p>存储器控制部件(存控)</p><p>存控中含有四个部件:</p><ul><li>控制线路</li><li>节拍发生器</li><li>存控标记触发器</li><li>排队器</li></ul><p>其中, 排队器是相当重要的, 它能根据请求源的紧急程度为CPU处理顺序排序, 具体顺序: 易发生代码丢失的请求源-&gt;严重影响CPU工作的请求源-&gt;其他请求源;</p><hr><p>高性能存储芯片</p><p>SDRAM(同步DRAM): 能在系统时钟的控制下进行写入和读出, 这使得 <strong>CPU无需等待</strong> ;</p><p>带Cache的DRAM: 继承了一个由SRAM组成的Cache, 有利于猝发式读取;</p><h3 id="4-5-高速缓冲存储器"><a href="#4-5-高速缓冲存储器" class="headerlink" title="4.5 高速缓冲存储器"></a>4.5 高速缓冲存储器</h3><p>简称 <strong>缓存</strong> , 位于CPU与主存之间, 负责解决CPU的 <strong>空等</strong> 现象, 容量比主存小, 速度比主存高;</p><h4 id="4-5-1-Cache工作原理"><a href="#4-5-1-Cache工作原理" class="headerlink" title="4.5.1 Cache工作原理"></a>4.5.1 Cache工作原理</h4><p>主存和缓存均按照块存储(类似于前面的多体并行系统), 块的大小相同, 一个块中有很多存储单元;</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%96%E5%9D%80.png" alt="主存和缓存的编址"></p><p>缓存内共有C块, 主存共有M块, 显然, M&gt;&gt;C;</p><p>因此, 需要根据某种规则将主存的块与缓存的块建立联系, 这就衍生出两个名词:</p><ul><li>命中: 主存块成功调入了缓存, 建立了对应关系;</li><li>未命中: 主存块未调入缓存, 对应关系未能建立;</li></ul><h4 id="4-5-2-Cache的命中率以及效率"><a href="#4-5-2-Cache的命中率以及效率" class="headerlink" title="4.5.2 Cache的命中率以及效率"></a>4.5.2 Cache的命中率以及效率</h4><p>即CPU希望访问的信息在Cache中的比率.</p><p>$$ Cache命中率 \space h &#x3D; \frac{Nc}{Nc+Nm} $$</p><p>上式中: Nc表示访问Cache的次数, Nm表示访问主存的次数;</p><p><strong>可以通过命中率推断主存系统的平均访问时间:</strong></p><p>设:</p><ul><li>访问Cache的时间 $ t_c $ </li><li>访问主存的时间 $ t_m $ </li><li>Cache命中率 $ h $</li></ul><p>则主存系统的平均访问时间:</p><p>$$ t_a &#x3D; h * t_c + (1-h) * t_m $$</p><blockquote><p>上面这个式子的意义就是: 命中缓存, 则直接从缓存里取; 未命中缓存, 则需要进一步访问主存;</p></blockquote><p>进一步推出 <strong>Cache-主存系统的效率</strong> :</p><p>$$ Efficiency &#x3D; \frac{访问Cache的时间}{平均访问时间} * 100 %  &#x3D; \frac{t_c}{h * t_c + (1-h) * t_m} * 100 % $$</p><h4 id="4-5-3-Cache的读写"><a href="#4-5-3-Cache的读写" class="headerlink" title="4.5.3 Cache的读写"></a>4.5.3 Cache的读写</h4><p>下列框图为Cache的读操作</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Cache%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C.png" alt="Cache的读操作"></p><p>在写操作上, 则有两种方法: </p><ul><li>写直达法: 写操作时 <strong>既将数据写入Cache, 也写入主存</strong> , 花费时间为 <strong>访问主存的时间</strong></li><li>写回法: 写操作时 <strong>只把数据写入Cache</strong> , 当Cache数据需要被替换出去后再写回主存, 花费时间是 <strong>访问Cache的时间</strong></li></ul><h4 id="4-5-4-Cache-主存的地址映射"><a href="#4-5-4-Cache-主存的地址映射" class="headerlink" title="4.5.4 Cache-主存的地址映射"></a>4.5.4 Cache-主存的地址映射</h4><p><strong>1.直接映射</strong></p><p>直接映射很容易理解, 就是一个取模操作.</p><p>我们上面提到过的变量这里列一下:</p><ul><li>m: 主存地址中存储块数的位数, 这说明主存总共有 $ M &#x3D; 2^m $ 个块</li><li>c: Cache地址中用于存储块数的位数, 这说明Cache中共有 $ C &#x3D; 2^c $ 个块</li><li>i: Cache中的块号</li><li>j: 主存中的块号</li></ul><p>我们可以得到:</p><p>$$ i &#x3D; j(mod \space C) \space 或者 i &#x3D; j(mod\space 2^c) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="直接映射"></p><p>此时, CPU传来的主存地址的高m位被分成了两部分: 低c位指的就是对应Cache的字块地址, 而高(m-c)位则代表 <strong>主存字块标记</strong> , 表示当前Cache中存放的是主存的第几组数据( <strong>相当于把主存按照Cache的总字块数量再度分了个类</strong> : 0<del>[C-1], C</del>[2C-1], …, [M-C]~[M-1]). 如果读者看过上一篇博文, 或者了解过数论相关的知识, 这就是 <strong>同余类</strong> 的概念.</p><p>当CPU传过来一个对应地址时, Cache先找到对应的同余类, 而后看 <strong>主存字块标记</strong> 字段能否与对应Cache地址的 <strong>标记</strong> 字段匹配, 如果匹配则命中缓存, 直接调用Cache中的数据, 如果不匹配则仍需要进一步访问主存, 并同时替换Cache的对应字块, 并修改该块Cache的 <strong>标记</strong> .</p><p>这种映射方式容易理解, 但不够灵活.</p><hr><p><strong>2.全相联映射</strong></p><p>即Cache中每一个字块都可以与主存的任何字块建立对应关系. 这意味着 <strong>主存字块标记字段</strong> 以及 Cache对应的 <strong>标记</strong> 字段均 <strong>上升到了m位</strong> , 并且CPU每传来一个主存地址, 都需要与Cache的每个 <strong>标记</strong> 全部比较一遍, 效率无疑是比较低的.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射"></p><hr><p><strong>3.组相联映射</strong></p><p>组相联映射是对上面两种方式的一种折中.</p><p>具体而言, 组相联映射对Cache也进行了分组, 将Cache分成Q组, 每组有R块. </p><p>借鉴直接映射, 我们还是有这个式子: </p><p>$$ i &#x3D; j(mod \space Q) $$</p><p>相当于将主存对应组别映射到Cache对应同余类的组别中.</p><p>我们假设Q &#x3D; 16, R &#x3D; 2, C &#x3D; Q*R &#x3D; 32;(Cache中总共32块, 2块为一组, 共16组)</p><p>则主存标号为 0, 16, 32, …, M-16 的字块对应Cache的第0组, 它们中任意一个字块都能存储到这一组2个块中的任意一个之中.</p><p>即: 主存的第j块映射到Cache的第i组内(直接映射), 同时, 又能存在第i组R个字块中的任意一个中(全相联映射).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="组相联映射"></p><p>这种映射方式仍然将CPU传来的主存地址的高m位分类了, 组地址 $ q &#x3D; c-r $ 表示对应Cache的第几组, 前面 $ m-q &#x3D; m-c+r $ 位代表主存字块标记, 需要与Cache中的对应组 $ 2^r &#x3D; R $ 个标记字段相比较.</p><hr><p>上面这一段可以说是存储器中最不好理解的一段, 主要是涉及到的变量确实很多, 读者还请尽力理解.</p><p>给几个例子:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E4%BE%8B.png" alt="缓存_例"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E4%BE%8B2.png" alt="缓存_例"></p><h2 id="Chap-7-指令系统"><a href="#Chap-7-指令系统" class="headerlink" title="Chap.7 指令系统"></a>Chap.7 指令系统</h2><h3 id="7-1-机器指令"><a href="#7-1-机器指令" class="headerlink" title="7.1 机器指令"></a>7.1 机器指令</h3><h4 id="7-1-1-指令的一般格式"><a href="#7-1-1-指令的一般格式" class="headerlink" title="7.1.1 指令的一般格式"></a>7.1.1 指令的一般格式</h4><p>计算机的指令一般由 <strong>操作码</strong> 和 <strong>地址码</strong> 两部分构成.</p><p>总共有三种设计方式:</p><ul><li><p>长度固定指令: 主要用于指令字长较长的情况;</p></li><li><p>长度可变指令: 操作码分散在不同字段中, 显然, 这会增加指令译码 &#x2F; 分析 &#x2F; 控制器设计的难度;</p></li><li><p>扩展操作码指令: 随着地址数减少, 操作码的位数增加, 这里通过16位字长指令来解释一下这个设计思路:  </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8A%80%E6%9C%AF.png" alt="扩展操作码技术"></p><p>可见, 每将一种三地址指令分解, 则可以分解成 $ 2^4 $ 个二地址指令, $ 2^8 $ 个一地址指令</p><p>(这里一地址, 二地址, 三地址指的是地址数目)</p></li></ul><h4 id="7-1-2-地址码的设置机制"><a href="#7-1-2-地址码的设置机制" class="headerlink" title="7.1.2 地址码的设置机制"></a>7.1.2 地址码的设置机制</h4><p>一条指令中的地址数量有很多种情况, 通常分为:</p><ul><li><p>四地址<br>顾名思义, 四地址中含有四个地址;<br>通常情况下, 这分别表示 <strong>第一操作数 &#x2F; 第二操作数 &#x2F; 结果存储 &#x2F; 下一条指令的地址</strong> ;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E5%9B%9B%E5%9C%B0%E5%9D%80.png" alt="四地址"></p></li><li><p>三地址<br>三地址区别于四地址, 它将下一条指令的地址隐去了, 通常隐含在程序计数器PC中(程序计数器见第一章);<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%B8%89%E5%9C%B0%E5%9D%80.png" alt="三地址"></p></li><li><p>二地址<br>二地址进一步简化指令, 它将结果存储的位置也隐去, 这意味着它必须将结果存在:  </p><ol><li>$ A_1 $ &#x2F; $ A_2 $ 中</li><li>累加器ACC中<br>前者的情况, 一条指令需要访存4次(取指令, 读两个数, 存一个数), 而如果仅存在ACC中, 则只需要访存3次(取指令, 取两个数).<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%BA%8C%E5%9C%B0%E5%9D%80.png" alt="二地址"></li></ol></li><li><p>一地址<br>一地址进一步简化, 直接省去了一个操作数的位置, 因为它默认另一个操作数处于累加器ACC中;<br>它会固定将结果存在ACC中;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%B8%80%E5%9C%B0%E5%9D%80.png" alt="一地址"></p></li><li><p>零地址<br>零地址没有地址码, 这意味着它无法执行正常的运算操作, 一般是空操作 &#x2F; 停机 &#x2F; 返回 &#x2F; 中断返回等.</p></li></ul><blockquote><p>需要指明的是, 并不是地址数越多越好, 因为地址数越少, 它能包含的位数就越多, 这说明其寻址范围就越大.</p></blockquote><h4 id="7-1-3-指令字长的设置"><a href="#7-1-3-指令字长的设置" class="headerlink" title="7.1.3 指令字长的设置"></a>7.1.3 指令字长的设置</h4><p>从上面的描述应该不难看出, 指令字长取决于:</p><ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数地址的个数</li></ul><p>一般而言, 指令字长可以有两种方法来设计:</p><ol><li>指令字长固定: 即 $ 指令字长 &#x3D; 存储字长 $ ;</li><li>指令字长可变: 即 $ 指令字长按照字节的倍数来变化 $ ;</li></ol><h3 id="7-2-操作数类型及操作种类"><a href="#7-2-操作数类型及操作种类" class="headerlink" title="7.2 操作数类型及操作种类"></a>7.2 操作数类型及操作种类</h3><h4 id="7-2-1-操作数类型"><a href="#7-2-1-操作数类型" class="headerlink" title="7.2.1 操作数类型"></a>7.2.1 操作数类型</h4><p>机器中的操作类型有: 地址 &#x2F; 数字 &#x2F; 字符 &#x2F; 逻辑数等.</p><p>它们的表示方法如下:</p><ul><li>地址: 无符号整数</li><li>数字: 定点数 &#x2F; 浮点数 &#x2F; 十进制数</li><li>字符: ASCⅡ</li><li>逻辑数: 逻辑运算</li></ul><h4 id="7-2-2-存储器中的数据存放"><a href="#7-2-2-存储器中的数据存放" class="headerlink" title="7.2.2 存储器中的数据存放"></a>7.2.2 存储器中的数据存放</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE.png" alt="存储器中的数据存放"></p><h4 id="7-2-3-操作类型"><a href="#7-2-3-操作类型" class="headerlink" title="7.2.3 操作类型"></a>7.2.3 操作类型</h4><p>操作类型大体可分为以下四类:</p><ul><li><p>数据传送: 从 <strong>寄存器或存储器</strong> 将数据送往 <strong>存储器或寄存器</strong> 的操作;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B_%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81.png" alt="数据传送"></p></li><li><p>算术逻辑操作: 在运算器ALU中进行的各类计算操作;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B_%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91.png" alt="算术逻辑"></p></li><li><p>移位: 算术移位(保留符号位, 适用于有符号数), 逻辑移位(不保留符号位, 适用于无符号数), 循环移位(将移出的位数重新移入, 分带进位 &#x2F; 不带进位)等:</p><ul><li>不带进位的循环移位: 直接将移出的值原样移到另一侧即可;</li><li>带进位的循环移位: 即在原先循环移位的基础上加了一个 <strong>进位位</strong>, 当移位时, 将 <strong>进位位</strong> 的值赋给空出的位置, 并将被移出的值赋给 <strong>进位位</strong> ;</li></ul></li><li><p>转移: </p><ul><li>无条件转移: JMP</li><li>条件转移: <ul><li>结果为零转移(Z &#x3D; 1): JZ</li><li>结果溢出转移(O &#x3D; 1): JO</li><li>结果有进位转移(C &#x3D; 1): JC</li><li>跳过一条指令: SKP, 其通常格式为: SKP DZ, 表示如果完成触发器D为0, 则跳过下一条指令;</li></ul></li></ul></li><li><p>陷阱(Trap)与陷阱指令: 陷阱一般指一种意外事故导致的中断, 这种类型的指令一般不提供给用户直接使用. 而是在出现事故时, 由CPU自动产生并执行.</p></li><li><p>输入输出: </p><ul><li>输入指令: 从 <strong>端口地址</strong> -&gt; CPU的寄存器;</li><li>输出指令: 从 CPU的寄存器 -&gt; 端口地址;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4.png" alt="输入输出指令"></li></ul></li></ul><h3 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h3><p>寻址方式, 指的是如何 <strong>确定本条指令操作数的存放地址, 以及确定下一条欲执行指令的存放地址</strong> ;</p><p>更简单地讲, 就是完成了这两件事: </p><ul><li>指令寻址</li><li>数据寻址</li></ul><h4 id="7-3-1-指令寻址"><a href="#7-3-1-指令寻址" class="headerlink" title="7.3.1 指令寻址"></a>7.3.1 指令寻址</h4><p>指令寻址涉及到的操作相对简单, 分为 <strong>顺序寻址</strong> 和 <strong>跳跃寻址</strong> 两种.</p><p>顺序寻址即 <strong>直接在程序计数器PC上加1, 得到新一条指令的地址</strong> .</p><p>跳跃寻址需要通过 <strong>转移指令</strong> 给出下一条指令的地址(转移指令的定义见上一节).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80.png" alt="指令寻址"></p><h4 id="7-3-2-数据寻址"><a href="#7-3-2-数据寻址" class="headerlink" title="7.3.2 数据寻址"></a>7.3.2 数据寻址</h4><p>数据寻址相对于指令寻址要复杂很多, 这里我们给出两个名词:</p><ul><li>形式地址A: 即指令字中的地址;</li><li>有效地址EA: 操作数的真实地址;</li></ul><p>在数据寻址中, 一般会将一个指令字分为 <strong>操作码</strong> &#x2F; <strong>寻址特征</strong> &#x2F; <strong>形式地址A</strong> 三部分. 机器通过寻址特征来进行相关操作, 进而找到有效地址.</p><p><strong>1.立即寻址:</strong></p><p>所谓立即寻址, 即 <strong>形式地址A就是操作数</strong> , 这也被称为 <strong>立即数</strong> , 显然, 这种形式的好处在于无需访存, 但A的位数也限制了操作数的大小.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="立即寻址"></p><p><strong>2.直接寻址:</strong></p><p>直接寻址即 <strong>有效地址由形式地址直接给出</strong> , 显然, 这种方式需要访存一次, A的位数决定了本次指令操作数的寻址范围.</p><p>$$ EA &#x3D; A $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="直接寻址"></p><p><strong>3.隐含寻址:</strong></p><p>隐含寻址, 说明有某一个操作数的地址时隐含在操作码中的, <strong>其实就是上面一地址指令的思路</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.png" alt="隐含寻址"></p><p>举个例子: 比如8086中的MUL指令, 其被乘数是隐含在AX寄存器或AL寄存器中的, 而这个地址不用给出, 而是通过操作码(MUL)给出的.</p><p>这种方式使得指令字中少了一个地址字段, 可以有效缩短指令字长.</p><p><strong>4.间接寻址</strong></p><p>间接寻址, 即 <strong>有效地址由形式地址间接提供</strong> , 换言之, 即需要通过形式地址对应主存块的内容多次跳转才能得到有效地址.(读者如果有过编程基础, 其实就是 <strong>指针</strong> 的思想)</p><p>$$ EA &#x3D; (A) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="间接寻址"></p><p>类似的, 指针也分单层和多层, 上图右侧即通过多次反复跳转进行寻址的过程. 这种方式的好处是扩大了寻址范围, 但每一次寻址都需要耗费对应的访存时间.</p><p>间接寻址其实运用的十分广泛, 典型代表比如当用户调用子程序时, 会通过间接寻址的方式给出子程序的起始地址.</p><p><strong>5.寄存器寻址</strong></p><p>寄存器寻址, 即 <strong>有效地址是寄存器编号, 由形式地址直接给出</strong> .</p><p>$$ EA &#x3D; R_i $$</p><p>这种方式省去了访存的时间成本, 只需要访问寄存器即可, 执行较快, 并且可以有效缩短指令字长(给一个编号与给一个地址的长度必然前者更短一些), 但寄存器个数有限, 代表着这种方式也有其局限性.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png" alt="寄存器寻址"></p><p><strong>6.寄存器间接寻址</strong></p><p>与第四种间接寻址的想法十分类似, 只不过这次有效地址存在寄存器中, 形式地址仍然只给出寄存器编号.</p><p>$$ EA &#x3D; (R_i) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="寄存器间接寻址"></p><p>这种方式相比于间接寻址能够减少一次访存时间开销(因为第一次只需要访问寄存器即可).</p><p><strong>7.基址寻址</strong></p><p>基址寻址通过一个寄存器作为 <strong>基址寄存器(BR)</strong> , 其有效地址表示为:</p><p>$$ EA &#x3D; (BR) + A $$</p><p>通常, 在程序执行的过程中, BR内的内容是不变的, 这个值由操作系统或管理程序决定. 这种方式可以一定程度上扩大寻址范围, 有利于多道程序的运行.</p><p>相应的, 作为基址寄存器的寄存器也分两类:</p><ul><li>采用专用寄存器作为基址寄存器</li><li>采用通用寄存器作为基址寄存器(此时, 哪个通用寄存器作为基址寄存器由用户指定)</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%281%29.png" alt="采用专用寄存器的基址寻址"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%282%29.png" alt="采用通用寄存器的基址寻址"></p><p><strong>8.变址寻址</strong></p><p>变址寻址的思路与基址寻址的思路恰好反过来, 有这么一个变址寄存器IX(可专用可通用), 在程序执行的过程中, IX的内容由用户给定, 并且 <strong>可以变化</strong> , 而对应的, 形式地址A不再变化.</p><p>$$ EA &#x3D; (IX) + A $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="变址寻址"></p><p>这种方式同样可以扩大寻址范围, 同时非常适合 <strong>处理数组问题</strong> .</p><p><strong>9.相对寻址</strong></p><p>相对寻址更特殊一点, 通过给出 <strong>操作数与当前指令的地址差值</strong> 来寻找操作数.</p><p>$$ EA &#x3D; (PC) + A $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="相对寻址"></p><p>这种方式对于书写程序浮动的情况相当有利, 也广泛被用于转移指令中.</p><p><strong>10.堆栈寻址</strong></p><p>堆栈寻址使用了 <strong>数据结构中的栈结构</strong> , 其通过先进后出的思路来设计寻址.</p><p>其通过一个变量 SP 来维护栈顶地址, 每当入栈一个指令后, 栈顶-1; 对应的, 每出栈一条指令, 则栈顶+1(注: 这是通过字编址的情况, 如果通过字节编址则需要加减相应指令以字节计数的长度);</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80.png" alt="堆栈寻址"></p><h3 id="7-4-指令格式"><a href="#7-4-指令格式" class="headerlink" title="7.4 指令格式"></a>7.4 指令格式</h3><p>这一节主要讲述设计指令时需要考虑的各类因素, 但它对考试不是很重要, 这里不在枚举了, 仅引出一个概念:</p><p>平均码长: </p><p>$$ \sum_{i} F_i * B_i $$</p><p>其中:</p><ul><li>$ i $ : 表示指令</li><li>$ F_i $ : 表示指令的频率</li><li>$ B_i $ : 表示编码该条指令所用的位数</li></ul><p>给个例子:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B3%E5%9D%87%E7%A0%81%E9%95%BF_%E4%BE%8B.png" alt="平均码长_例"></p><blockquote><p>本题中, 编码方式涉及到了一些霍夫曼树的知识, 简单来说, 频率越高的指令, 码长应当越短;</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B3%E5%9D%87%E7%A0%81%E9%95%BF_%E4%BE%8B_%E8%A7%A3.png" alt="平均码长_例_解"></p><blockquote><p>本章中, 涉及到了RISC与CISC的对比, 在博文中不在列举, 请见PPT</p></blockquote><h2 id="Chap-8-CPU的结构与功能"><a href="#Chap-8-CPU的结构与功能" class="headerlink" title="Chap.8 CPU的结构与功能"></a>Chap.8 CPU的结构与功能</h2><h3 id="8-1-CPU的结构"><a href="#8-1-CPU的结构" class="headerlink" title="8.1 CPU的结构"></a>8.1 CPU的结构</h3><h4 id="8-1-1-CPU的功能"><a href="#8-1-1-CPU的功能" class="headerlink" title="8.1.1 CPU的功能"></a>8.1.1 CPU的功能</h4><p>在第一章中, 提及过CPU的两个重要组成部分: <strong>控制器(CU)</strong> 与 <strong>运算器(ALU)</strong> ;</p><ul><li>控制器<ul><li>取指令</li><li>分析指令</li><li>执行指令 &#x2F; 发出各种操作命令</li><li>控制程序输入 &#x2F; 结果输出</li><li>总线管理</li><li>处理异常 &#x2F; 特殊请求</li></ul></li><li>运算器<ul><li>实现算术运算 &#x2F; 逻辑运算</li></ul></li></ul><blockquote><p>总而言之, CPU实现的功能分五大类: 指令控制(PC, IR) &#x2F; 操作控制(CU, 时序电路) &#x2F; 时间控制(CU, 时序电路) &#x2F; 数据加工(ALU, 寄存器) &#x2F; 处理中断(中断系统)</p></blockquote><h4 id="8-1-2-CPU的结构框图"><a href="#8-1-2-CPU的结构框图" class="headerlink" title="8.1.2 CPU的结构框图"></a>8.1.2 CPU的结构框图</h4><p>结构框图</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png" alt="CPU的结构框图"></p><hr><p>内部结构</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/CPU%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="CPU的内部结构"></p><hr><p>关于CPU的寄存器:</p><ul><li>通用寄存器: 存放操作数</li><li>数据寄存器: 存放操作数</li><li>地址寄存器: 存放地址</li><li>条件码寄存器: 存放条件码(一般是程序分支的依据)</li></ul><p>通常的工作顺序:</p><p>$$ PC \to MAR \to M \to MDR \to IR $$</p><h3 id="8-2-指令周期"><a href="#8-2-指令周期" class="headerlink" title="8.2 指令周期"></a>8.2 指令周期</h3><h4 id="8-2-1-指令周期的概念"><a href="#8-2-1-指令周期的概念" class="headerlink" title="8.2.1 指令周期的概念"></a>8.2.1 指令周期的概念</h4><p>指令周期, 指 <strong>取出并完成一条指令所需的全部时间</strong> .</p><p>其基本组成过程分为: </p><ul><li>取指周期: 取指令</li><li>(间指周期): 取有效地址</li><li>执行周期: 取操作数</li><li>(中断周期): 保存程序断点</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.png" alt="指令周期流程"></p><h4 id="8-2-2-指令周期的数据流"><a href="#8-2-2-指令周期的数据流" class="headerlink" title="8.2.2 指令周期的数据流"></a>8.2.2 指令周期的数据流</h4><p><strong>1.取指周期数据流</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_取指周期"></p><ul><li>PC存放现行指令的地址, 该地址被送到MAR, 并随后被送至地址总线</li><li>CU向存储器发读命令</li><li>对应MAR指向单元的内容经过数据总线送到MDR, 再送至IR</li><li>CU控制PC+1</li></ul><p><strong>2.间指周期数据流</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E9%97%B4%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_间指周期"></p><ul><li>CU检查IR中的内容, 确定本条指令是否有间指操作</li><li>如果有间指操作, 则MDR中的右侧N位(被称作 <strong>Ad(MDR)</strong> )会被送到MAR, 并被进一步送至地址总线</li><li>CU向存储器发读命令</li><li>获取有效地址, 存入MDR</li></ul><p><strong>3.执行周期数据流</strong></p><p>不同指令的执行周期数据流往往差别较大, 因此这里无法利用框图表示.</p><p><strong>4.中断周期数据流</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png" alt="数据流_中断周期"></p><ul><li>CU将用于保存程序断点的存储器特殊地址(典型案例, 比如此前在堆栈寻址中讲到的SP, 即指向栈顶的指针)送往MAR, 进一步送往地址总线</li><li>CU向存储器发写命令</li><li>将PC中的内容(程序断点)送到MDR, 并经过数据总线写入存储器</li><li>CU将中断程序的入口地址送至PC, 为下一个取指周期做好准备</li></ul><h3 id="8-3-指令流水"><a href="#8-3-指令流水" class="headerlink" title="8.3 指令流水"></a>8.3 指令流水</h3><h4 id="8-3-1-系统并行性"><a href="#8-3-1-系统并行性" class="headerlink" title="8.3.1 系统并行性"></a>8.3.1 系统并行性</h4><p>所谓指令流水, 是提高 <strong>系统并行性</strong> 的一种称呼, 即希望两个或两个以上事件在同一时间段发生.</p><p>并行性分等级:</p><ul><li>过程级: 指作业, 进程之间的并行, 这可以通过软件实现</li><li>指令级: 指不同指令之间, 或指令内部的操作之间的并行, 这需要通过硬件实现</li></ul><h4 id="8-3-2-指令流水的具体设计"><a href="#8-3-2-指令流水的具体设计" class="headerlink" title="8.3.2 指令流水的具体设计"></a>8.3.2 指令流水的具体设计</h4><p><strong>最简单的方式: 串行执行</strong></p><p>串行指令是我们最容易想到的, 它的工作方式就是一条条指令进行下去, 没有任何并行性, 效率也自然很低.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E4%B8%B2%E8%A1%8C.png" alt="指令流水_串行"></p><p><strong>进一步设计: 二级流水</strong></p><p>第二种想法是将取指令和执行指令分开:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E4%BA%8C%E7%BA%A7%E5%B9%B6%E8%A1%8C.png" alt="指令流水_二级并行"></p><p>这种方式也被称为 <strong>指令预取</strong> , 如果取指阶段和执行阶段在时间上完全重叠, 那么理论上指令周期可以减半, 速度可以提高一倍.</p><p>但很遗憾, 指令的执行时间一般大于取指时间, 因此二者速度其实并不十分匹配; 另外, 遇到一些条件转移指令时, 往往下一步是不可知的, 必须等待上一条指令执行阶段结束, 判断出条件真伪后才能进行下一阶段的取指.</p><p><strong>再度分级: 六级流水</strong></p><p>为了解决二级流水遇到的以上问题, 我们将指令的处理过程继续细化分解:</p><ul><li>FI(Fetch Instruction): 取指</li><li>DI(Decode Instruction): 指令译码</li><li>CO(Calculate operand address): 计算操作数地址</li><li>FO(Fetch operand): 取操作数</li><li>EI(Execute instruction): 执行指令</li><li>WO(Write back operand): 写操作数</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E5%85%AD%E7%BA%A7%E5%B9%B6%E8%A1%8C.png" alt="指令流水_六级并行"></p><p>我们考虑一个含有六条指令的程序, 如果串行执行: 需要6*9 &#x3D; 54个时间单位, 而通过上述流水线的思路, 则只需要14个时间单位!</p><h4 id="8-3-3-流水线性能评估"><a href="#8-3-3-流水线性能评估" class="headerlink" title="8.3.3 流水线性能评估"></a>8.3.3 流水线性能评估</h4><p><strong>1.吞吐率</strong></p><p>即 <strong>单位时间内流水线所完成指令的数量</strong></p><p>设 m 段的流水线隔段时间为 $ \Delta t $</p><p>(1) 最大吞吐率</p><p>$$ T_{pmax} &#x3D; \frac{1}{\Delta t} $$</p><p>(2) 实际吞吐率: 连续处理n条指令的吞吐率</p><p>$$ T_p &#x3D; \frac{n}{m * \Delta t + (n-1) * \Delta t} $$</p><p><strong>2.加速比</strong></p><p>设流水线各段时间为 $ \Delta T $ , 每条指令共 m 段;</p><p>加速比即 <strong>非流水线的速度与 m 段的流水线的速度之比</strong></p><p>则:</p><p>$$ S_p &#x3D; \frac{n * m * \Delta t}{m * \Delta t + (n-1) * \Delta t} &#x3D; \frac{n * m}{m+n-1} $$</p><p><strong>3.效率</strong></p><p>流水线自身的效率, 即 <strong>流水线中各功能段的利用率</strong></p><p>$$ 效率 &#x3D; \frac{m * n * \Delta t}{m * (m+n-1) * \Delta t} &#x3D; \frac{n}{m+n-1} $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%88%E7%8E%87%E8%AF%B4%E6%98%8E.png" alt="流水线效率说明"></p><h3 id="8-4-中断系统"><a href="#8-4-中断系统" class="headerlink" title="8.4 中断系统"></a>8.4 中断系统</h3><p>本节本来放到了 I&#x2F;O 设备后讲述, 在本文中为了整体性将其与第八章其余内容放在一块, 读者也可以先不看这一节</p><h4 id="8-4-1-概述"><a href="#8-4-1-概述" class="headerlink" title="8.4.1 概述"></a>8.4.1 概述</h4><p>引发中断的因素有很多:</p><ul><li>人为设置的中断(转管指令)</li><li>程序性事故(移出, 操作码不能识别, 除法非法)</li><li>硬件故障</li><li>I&#x2F;O 设备</li><li>外部事件(用键盘中断现行程序)</li></ul><p>每个可能出现中断的请求源, 都有一个 <strong>INTR(中断请求标记触发器)</strong> , 其分散在多个中断源的接口电路中, 也集中在CPU的中断系统内</p><h4 id="8-4-2-中断判优逻辑"><a href="#8-4-2-中断判优逻辑" class="headerlink" title="8.4.2 中断判优逻辑"></a>8.4.2 中断判优逻辑</h4><p>1.分散在各个中断源的接口电路中, 比如 I&#x2F;O 设备的链式排队器(见第五章 5.5)</p><p>2.集中在CPU内:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9B%86%E4%B8%AD%E5%9C%A8CPU%E5%86%85%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F%E7%94%B5%E8%B7%AF.png" alt="集中在CPU内的中断排队电路"></p><p>3.通过软件轮流查询:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%80%9A%E8%BF%87%E8%BD%AF%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BD%AE%E6%B5%81%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F.png" alt="通过软件逻辑轮流查询的中断排队"></p><h4 id="8-4-3-中断服务程序入口地址的寻找"><a href="#8-4-3-中断服务程序入口地址的寻找" class="headerlink" title="8.4.3 中断服务程序入口地址的寻找"></a>8.4.3 中断服务程序入口地址的寻找</h4><ul><li>通过硬件直接形成中断向量寻找(见5.4)</li><li>通过软件查询</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80_%E8%BD%AF%E4%BB%B6%E6%9F%A5%E8%AF%A2.png" alt="中断服务程序入口地址_软件查询"></p><h4 id="8-4-4-中断响应的条件与时间"><a href="#8-4-4-中断响应的条件与时间" class="headerlink" title="8.4.4 中断响应的条件与时间"></a>8.4.4 中断响应的条件与时间</h4><p>见5.5</p><h4 id="8-4-5-多重中断"><a href="#8-4-5-多重中断" class="headerlink" title="8.4.5 多重中断"></a>8.4.5 多重中断</h4><p>即优先级别高的中断源有权中断优先级别低的中断源</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD.png" alt="多重中断"></p><p>需要说明的是, 保护多重中断中, 因为 <strong>存在多次保护现场操作</strong> , 因此保护现场的暂存地址不可能永远是那个特殊的0地址了, 每次新中断时, 要将 <strong>原先0地址内的内容转存</strong> .</p><h4 id="8-4-6-屏蔽技术"><a href="#8-4-6-屏蔽技术" class="headerlink" title="8.4.6 屏蔽技术"></a>8.4.6 屏蔽技术</h4><p>重点理解 <strong>屏蔽字与优先等级的改变</strong> , 具体而言, <strong>屏蔽字为1</strong> 代表 <strong>对应中断源的中断请求会被本中断请求屏蔽掉</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B1%8F%E8%94%BD%E5%AD%97%26%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%AD%89%E7%BA%A7.png" alt="屏蔽字&amp;中断优先等级"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%96%B0%E5%B1%8F%E8%94%BD%E5%AD%97%E7%9A%84%E5%A4%84%E7%90%86%E9%A1%BA%E5%BA%8F.png" alt="新屏蔽字的处理顺序"></p><p>如上图所示, 响应优先级是不能被更改的, 因此A处理完后, 还是会优先响应B, 但是 <strong>C的处理优先级更高, 所以C可以打断B的响应</strong> , 同理, D打断C的响应, 并最先处理完, 随后C处理完, B处理完.</p><h2 id="Chap-9-控制单元的功能"><a href="#Chap-9-控制单元的功能" class="headerlink" title="Chap.9 控制单元的功能"></a>Chap.9 控制单元的功能</h2><h3 id="9-1-操作命令的分析"><a href="#9-1-操作命令的分析" class="headerlink" title="9.1 操作命令的分析"></a>9.1 操作命令的分析</h3><p>回忆第八章的内容, 指令的执行过程分四个周期, 在这里将每个周期实现的操作再度利用比较标准的语言描述一下:</p><p><strong>1.取指周期</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_取指周期"></p><ul><li>$ PC \to MAR \to 地址线 $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to IR $</li><li>$ OP(IR) \to CU $</li><li>$ (PC) + 1 \to PC $</li></ul><p><strong>2.间指周期</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E9%97%B4%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_间指周期"></p><ul><li>$ 指令形式地址 \to MAR $ 即 $ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to Ad(IR) $</li></ul><p><strong>3.执行周期</strong></p><p>(1)非访存指令:</p><ul><li>CLA(将ACC清零): $ 0 \to ACC $</li><li>COM(ACC取反): $ \overline{ACC} \to ACC $</li><li>SHR(算术右移): $ L(ACC) \to R(ACC), ACC_0 \to ACC_0 $ (后面一步代表符号位不变)</li><li>CSL(循环左移): $ R(ACC) \to L(ACC), ACC_0 \to ACC_n $</li><li>STP(停机): $ 0 \to G $</li></ul><p>(2)访存指令:</p><ul><li>加法指令: $ ADD \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ (ACC) + (MDR) \to ACC $</li></ul></li><li>存数指令: $ STA \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to W $</li><li>$ ACC \to MDR $</li><li>$ MDR \to M(MAR) $</li></ul></li><li>取数指令: $ LDA \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to ACC $</li></ul></li></ul><p>(3)转移指令(不访存)</p><ul><li>无条件转: $ JMP \space X $<ul><li>$ Ad(IR) \to PC $</li></ul></li><li>条件转移: $ BAN \space X $ , 这里假设 $ A_7 &#x3D; 1 $ 为满足条件<ul><li>$ A_7 * Ad(IR) + \overline{A_7} * (PC) \to PC $</li></ul></li></ul><p>上述指令的执行周期总结如下:<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E7%B1%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" alt="三类指令的指令周期"></p><p><strong>4.中断周期</strong></p><p>中断分两种:</p><ul><li>关中断</li><li>程序中途中断</li></ul><p>二者区别只在需要执行的第一个操作</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png" alt="数据流_中断周期"></p><ul><li>保存程序断点:<ul><li>关中断: $ 0 \to MAR $ , 即断点存入0地址</li><li>程序中途中断: $ (SP)-1 \to SP \to MAR $ , 即断点进栈</li></ul></li><li>$ 1 \to W $</li><li>$ PC \to MDR $</li><li>$ MDR \to M(MAR) $</li><li>$ 中断程序入口地址M \to PC $</li><li>$ 0 \to EINT $</li></ul><h3 id="9-2-控制单元的功能"><a href="#9-2-控制单元的功能" class="headerlink" title="9.2 控制单元的功能"></a>9.2 控制单元的功能</h3><h4 id="9-2-1-控制单元的外特性"><a href="#9-2-1-控制单元的外特性" class="headerlink" title="9.2.1 控制单元的外特性"></a>9.2.1 控制单元的外特性</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83_%E5%A4%96%E7%89%B9%E6%80%A7.png" alt="控制单元_外特性"></p><p>从图中, 我们整理一下控制单元的输入 &#x2F; 输出信号来源:</p><ul><li>输入信号<ul><li>时钟: CU受到时钟控制</li><li>指令寄存器 ( $ OP(IR) \to CU $ ), 与操作码相关</li><li>标志: CU收到各类标志寄存器的控制</li><li>外来信号: 如INTR(中断请求) &#x2F; HRQ(总线请求)</li></ul></li><li>输出信号<ul><li>CPU内的各种控制信号<ul><li>来自寄存器的</li><li>来自PC的</li><li>来自ALU的</li></ul></li><li>送到控制总线的信号<ul><li>$ \overline{MREQ} $ , 访存控制信号</li><li>$ \overline{IO} &#x2F; M $ , 访问IO &#x2F; 存储器的控制信号</li><li>$ \overline{RD} $ , 读命令</li><li>$ \overline{WR} $ , 写命令</li><li>$ INTA $ , 中断响应信号</li><li>$ HLDA $ , 总线响应信号</li></ul></li></ul></li></ul><h4 id="9-2-2-控制信号举例"><a href="#9-2-2-控制信号举例" class="headerlink" title="9.2.2 控制信号举例"></a>9.2.2 控制信号举例</h4><p>详见书 $ P_{380} $</p><p>这里仅对是否使用CPU内部总线进行说明, CPU内部总线是一根将所有器件串连起来的总线, 相当于所有的信号都可以通过内部总线传递给其他部件.</p><h4 id="9-2-3-多级时序系统"><a href="#9-2-3-多级时序系统" class="headerlink" title="9.2.3 多级时序系统"></a>9.2.3 多级时序系统</h4><p><strong>1.机器周期</strong></p><p>机器周期是 <strong>所有指令执行过程中的一个基准时间</strong> ;</p><p>这个基准时间的确定需要考虑:</p><ul><li>完成最复杂的指令功能的时间</li><li>访问一次存储器的时间</li></ul><p>通常, 访存时间比CPU中的处理要长很多, 因此在 <strong>指令字长 &#x3D; 存储字长</strong> 的前提下, <strong>取指周期 &#x3D; 机器周期</strong></p><hr><p><strong>2.时钟周期</strong></p><p>一个机器周期内可以完成若干个微操作, 因此将 <strong>机器周期进一步细分为若干个时间相等的时钟周期</strong></p><p>时钟周期是 <strong>计算机操作的最小单位时间</strong> , 可以利用它产生一个或几个微操作命令</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%20%26%20%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png" alt="机器周期&amp;时钟周期"></p><hr><p><strong>3.多级时序系统</strong></p><p>一个指令周期包含多个机器周期, 一个机器周期包含多个时钟周期.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%A4%9A%E7%BA%A7%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F.png" alt="多级时序系统"></p><hr><p><strong>4.机器主频</strong></p><p>机器主频越快:</p><ul><li>机器速度越快</li><li>一个机器周期中包含的时钟周期数越多</li><li>一个指令周期中包含的机器周期数越多</li></ul><h4 id="9-2-4-控制方式"><a href="#9-2-4-控制方式" class="headerlink" title="9.2.4 控制方式"></a>9.2.4 控制方式</h4><p>1.同步控制方式</p><ul><li>采用定长的机器周期: 即以最长的微操作序列以及最繁的微操作作为标准, <strong>每个机器周期内节拍数目相同</strong></li><li>采用不定长的机器周期: 每个机器周期内节拍数不等</li><li>中央控制+局部控制: 将大部分指令安排在统一 &#x2F; 较短的机器周期内完成, 对于少数较复杂的指令, 采用局部控制方法完成</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E5%A4%AE%E6%8E%A7%E5%88%B6%2B%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6.png" alt="中央控制+局部控制"></p><p>2.异步控制方式</p><ul><li>无基准时标信号</li><li>无固定应答节拍和严格的时钟同步</li><li>采用应答方式</li></ul><p>3.联合控制方式</p><ul><li>同步+异步</li></ul><p>4.人工控制方式</p><ul><li>Reset</li><li>连续+单条指令执行转换开关</li><li>符合停机开关</li></ul><h2 id="Chap-10-控制单元的设计"><a href="#Chap-10-控制单元的设计" class="headerlink" title="Chap.10 控制单元的设计"></a>Chap.10 控制单元的设计</h2><h3 id="10-1-微程序设计"><a href="#10-1-微程序设计" class="headerlink" title="10.1 微程序设计"></a>10.1 微程序设计</h3><h4 id="10-1-1-微程序设计思想"><a href="#10-1-1-微程序设计思想" class="headerlink" title="10.1.1 微程序设计思想"></a>10.1.1 微程序设计思想</h4><p>将一条机器指令进一步细分, 一条机器指令对应一个 <strong>微程序</strong> , 一个微程序对应很多条 <strong>微指令</strong> .</p><p>如果预先将一些操作可预测的微程序写进ROM中, 则可以大大提高执行速度.</p><h4 id="10-1-2-微程序控制单元工作原理"><a href="#10-1-2-微程序控制单元工作原理" class="headerlink" title="10.1.2 微程序控制单元工作原理"></a>10.1.2 微程序控制单元工作原理</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83.png" alt="微程序控制单元"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A1%86%E5%9B%BE.png" alt="微程序控制单元框图"></p><p>这其中:</p><ul><li>控制存储器(控存): 是核心部件, 负责存放全部微程序</li><li>CMAR(控存地址寄存器): 存放欲读出的微指令地址</li><li>CMDR(控存数据寄存器): 存放从控存读出的微指令</li><li>顺序逻辑: 用于控制微指令序列</li></ul><p>微指令的基本格式中:</p><ul><li>操作控制字段负责发出控制信号</li><li>顺序控制字段负责指出下一条微指令的地址(简称 <strong>下地址</strong> )</li></ul><p>给出工作方式:</p><ul><li>取指阶段<ul><li>取指周期微程序首地址 $ M \to CMAR $</li><li>将对应控存中的第一条微指令读到控存数据寄存器 $ CM(CMAR) \to CMDR $</li><li>根据微指令的操作控制字段发出控制信号, 如 $ PC \to MAR, 1 \to R $ 等诸如此类</li><li>根据微指令的顺序控制字段找到下一条微指令, 即 $ Ad(CMDR) \to CMAR $</li><li>回到第二步, 循环进行, 直到相应指令已经存入IR中为止</li></ul></li><li>执行阶段<ul><li>将操作码送至微地址形成部件, 其输出即第一条微指令的地址, $ OP(IR) \to 微地址形成部件 \to CMAR $</li><li>$ CM(CMAR) \to CMDR $</li><li>发出控制信号, $ Ad(CMDR) \to CMAR $ …</li><li>直至指令执行结束为止</li></ul></li></ul><p><strong>微指令有两个很重要的问题:</strong></p><ul><li>操作控制字段如何形成微操作命令</li><li>后续地址如何形成</li></ul><h4 id="10-1-3-微指令的编码方式-控制方式"><a href="#10-1-3-微指令的编码方式-控制方式" class="headerlink" title="10.1.3 微指令的编码方式(控制方式)"></a>10.1.3 微指令的编码方式(控制方式)</h4><p>即 <strong>微指令的操作控制字段如何产生应当产生的控制信号</strong> , 解决第一个问题.</p><p>1.直接编码(直接控制方式)</p><p>这种方式代表 在操作控制字段中 <strong>每一位代表一个微操作命令</strong> , 该位为1则代表该控制信号有效;</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81_%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6.png" alt="微指令编码_直接控制"></p><p>2.字段直接编码方式</p><p>这种方式将控制字段中的位分成了若干段, 每一段经过单独译码后发出控制信号, <strong>每段中的命令是互斥的</strong></p><p>其缩短了微指令字长, 但增加了译码时间</p><blockquote><p>为什么缩短了控制时间? 假设有7个互斥微操作, 第一种方法需要7位, 第二种方法只需要3位, 因为 $ 2^3 &#x3D; 8&gt;7 $</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%8E%A7%E5%88%B6_%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81.png" alt="微指令控制_字段直接编码"></p><p>3.字段间接编码方式</p><p>这种方式代表 <strong>一个字段的某些微操作还需要另一个字段中的某些微命令来解释</strong> , 可以进一步缩短微指令字长, 但削弱了微指令的并行控制能力.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%8E%A7%E5%88%B6_%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81.png" alt="微指令控制_字段间接编码"></p><h4 id="10-1-4-微指令序列地址的形成"><a href="#10-1-4-微指令序列地址的形成" class="headerlink" title="10.1.4 微指令序列地址的形成"></a>10.1.4 微指令序列地址的形成</h4><p>通常有四种形成方式:</p><ul><li>下地址字段指出</li><li>根据机器指令的操作码形成</li><li>增量计数器, 即 $ (CMAR) + 1 \to CMAR $</li><li>分支转移:</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E4%B8%8B%E5%9C%B0%E5%9D%80_%E5%88%86%E6%94%AF%E8%BD%AC%E7%A7%BB.png" alt="微指令下地址_分支转移"></p><ul><li>测试网络:</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E4%B8%8B%E5%9C%B0%E5%9D%80_%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C.png" alt="微指令下地址_测试网络"></p><ul><li>直接由硬件产生: 通常常见于 <strong>第一条微指令地址的产生</strong> 以及 <strong>中断周期的中断周期微程序</strong></li></ul><h4 id="10-1-5-一些杂项"><a href="#10-1-5-一些杂项" class="headerlink" title="10.1.5 一些杂项"></a>10.1.5 一些杂项</h4><ul><li>水平型微指令: 一次能定义并执行多个并行操作</li><li>垂直型微指令: 类似机器指令操作码, 根据操作码字段规定微指令的功能</li></ul><p>相比而言, 水平型微指令 <strong>并行操作能力强, 灵活性强</strong>, 执行一条机器指令需要的水平型微指令 <strong>数目更少, 速度更快</strong> , 其用较短的微程序结构换取了较长的微指令结构.</p><hr><ul><li>静态微程序: 采用ROM, 微程序不需要改变</li><li>动态微程序: 采用EPROM, 可以通过改变微指令和微程序来改变机器指令</li></ul><hr><p>毫微程序设计</p><p>相当于对微指令进行了进一步细分, 好比微指令相对于机器指令</p><hr><p>串行微程序与并行微程序</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%B2%E8%A1%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F%26%E5%B9%B6%E8%A1%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F.png" alt="串行微程序&amp;并行微程序"></p><h3 id="10-2-微程序设计举例"><a href="#10-2-微程序设计举例" class="headerlink" title="10.2 微程序设计举例"></a>10.2 微程序设计举例</h3><p>所有微指令的涉及到的微命令都在9.1节中有所提及, 这里相当于将其整合, 根据每一条指令需要做的事情列出一个表.</p><p>具体表格见书 $ P_{419} $ , 这里强调几点:</p><ul><li>书中所有的0均省去了</li><li>书中的微指令地址是八进制, 这意味着后续顺序控制字段三位代表八进制一位字符</li></ul><h3 id="10-3-组合逻辑设计"><a href="#10-3-组合逻辑设计" class="headerlink" title="10.3 组合逻辑设计"></a>10.3 组合逻辑设计</h3><h4 id="10-3-1-组合逻辑控制单元框图"><a href="#10-3-1-组合逻辑控制单元框图" class="headerlink" title="10.3.1 组合逻辑控制单元框图"></a>10.3.1 组合逻辑控制单元框图</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A1%86%E5%9B%BE.png" alt="组合逻辑控制单元框图"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%20%26%20%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png" alt="节拍安排"></p><h4 id="10-3-2-微操作的节拍安排"><a href="#10-3-2-微操作的节拍安排" class="headerlink" title="10.3.2 微操作的节拍安排"></a>10.3.2 微操作的节拍安排</h4><p>采用 <strong>同步控制方式</strong></p><p>一个机器周期内有 <strong>3个节拍(即3个时钟周期)</strong></p><p>安排微操作时序的原则如下:</p><ul><li>微操作的先后顺序不得随意更改</li><li>被控对象不同的微操作尽量安排在一个节拍内完成</li><li>占用时间较短的微操作尽量安排在一个节拍内完成, 并允许有先后顺序</li></ul><p>具体各个周期以及执行周期各个命令的节拍安排, 见书 $ P_{396} $ ~ $ P_{398} $</p><p>各个指令在 取指 &#x2F; 间指 &#x2F; 执行阶段的不同节拍内分别干了啥, 请见书 $ P_{402} $</p><h4 id="10-3-3-组合逻辑设计步骤"><a href="#10-3-3-组合逻辑设计步骤" class="headerlink" title="10.3.3 组合逻辑设计步骤"></a>10.3.3 组合逻辑设计步骤</h4><p>1.给出操作时间表(类似书 $ P_{402} $ )</p><p>2.写出微操作命令的最简表达式:</p><p>举例而言, 对于 $ M(MAR) \to MDR $ 这条微操作, 可以写出这样的表达式:</p><p>$$ M(MAR) \to MDR &#x3D; \\<br>FE * T_1 + IND * T_1(ADD+STA+LDA+JMP+BAN) \\<br>T_1 \lbrace FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA) \rbrace $$</p><p>3.画出逻辑图</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/M%28MAR%29%20to%20MDR%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt=" $ M(MAR) \to MDR $ "></p><h2 id="Chap-5-输入输出系统"><a href="#Chap-5-输入输出系统" class="headerlink" title="Chap.5 输入输出系统"></a>Chap.5 输入输出系统</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><h4 id="5-1-1-输入输出系统概况"><a href="#5-1-1-输入输出系统概况" class="headerlink" title="5.1.1 输入输出系统概况"></a>5.1.1 输入输出系统概况</h4><ul><li>早期输入输出系统<ul><li>分散连接方式</li><li>CPU 与 I&#x2F;O 设备串行工作, 采用程序查询方式</li></ul></li><li>接口模块 &#x2F; DMA阶段<ul><li>总线连接方式</li><li>CPU 与 I&#x2F;O 设备并行工作, 采用中断方式 &#x2F; DMA 方式</li></ul></li><li>具有通道结构的阶段</li><li>具有 I&#x2F;O 处理机的阶段</li></ul><h4 id="5-1-2-输入输出系统组成"><a href="#5-1-2-输入输出系统组成" class="headerlink" title="5.1.2 输入输出系统组成"></a>5.1.2 输入输出系统组成</h4><ul><li>I&#x2F;O 软件<ul><li>I&#x2F;O 指令, 是CPU指令的一部分</li><li>通道指令, 指通道自身的指令</li></ul></li><li>I&#x2F;O 硬件<ul><li>设备 &amp; I&#x2F;O接口</li><li>设备 &#x2F; 设备控制器 &#x2F; 通道</li></ul></li></ul><h4 id="5-1-3-I-O-设备与主机的联系方式"><a href="#5-1-3-I-O-设备与主机的联系方式" class="headerlink" title="5.1.3 I&#x2F;O 设备与主机的联系方式"></a>5.1.3 I&#x2F;O 设备与主机的联系方式</h4><ul><li>I&#x2F;O 设备编址方式<ul><li>统一编址: 使用取数 &#x2F; 存数指令即可</li><li>不统一编址: 需要使用专门的 I&#x2F;O 指令</li></ul></li><li>设备选址<ul><li>用设备选择电路识别是否被选中</li></ul></li><li>传送方式<ul><li>串行传送</li><li>并行传送</li></ul></li><li>联络方式<ul><li>立即响应</li><li>异步工作, 采用应答信号(常用于IO设备与主机工作速度不匹配时)</li><li>同步工作, 采用同步时标( <strong>要求 I&#x2F;O 设备与CPU工作速度完全同步</strong> )</li></ul></li><li>连接方式<ul><li>辐射式: 每台设备有一套专门的控制线路和信号线</li><li>总线连接: 通过总线连接所有的 I&#x2F;O 设备( <strong>便于增删设备</strong> )</li></ul></li></ul><h4 id="5-1-4-I-O-设备与主机信息传送的控制方式"><a href="#5-1-4-I-O-设备与主机信息传送的控制方式" class="headerlink" title="5.1.4 I&#x2F;O 设备与主机信息传送的控制方式"></a>5.1.4 I&#x2F;O 设备与主机信息传送的控制方式</h4><ul><li>程序查询方式: CPU 和 IO 串行工作, 踏步等待;</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="程序查询方式"></p><ul><li>程序中断方式: CPU不查询, I&#x2F;O 设备准备好后向 CPU 发送中断请求, CPU 暂停当前程序, 进入中断服务程序;</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png" alt="程序中断方式"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F_%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="程序中断方式_流程图"></p><ul><li>DMA方式: 通过周期挪用(周期窃取)使得 CPU 和 I&#x2F;O 设备并行工作;</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p><h3 id="5-2-I-O-设备"><a href="#5-2-I-O-设备" class="headerlink" title="5.2 I&#x2F;O 设备"></a>5.2 I&#x2F;O 设备</h3><p>外部设备大致分为三类</p><ul><li>人机交互设备: 键盘 &#x2F; 鼠标 &#x2F; 打印机 &#x2F; 显示器</li><li>计算机信息存储设备: 磁盘 &#x2F; 光盘 &#x2F; 磁带</li><li>机-机通信设备: 调制解调器</li></ul><p>不是计组的主要讲述内容, 这里不进行详细阐述</p><h3 id="5-3-I-O-接口"><a href="#5-3-I-O-接口" class="headerlink" title="5.3 I&#x2F;O 接口"></a>5.3 I&#x2F;O 接口</h3><p>所谓 IO 接口, 指的是主机与 IO 设备之间设置一个硬件电路以及其相应的软件控制.</p><p>设置接口的目的主要是</p><ul><li>实现设备选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串-并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反应设备状态</li></ul><h4 id="5-3-1-接口的功能和组成"><a href="#5-3-1-接口的功能和组成" class="headerlink" title="5.3.1 接口的功能和组成"></a>5.3.1 接口的功能和组成</h4><p>1.总线连接方式</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/IO%E6%8E%A5%E5%8F%A3_%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.png" alt="IO接口_总线连接方式"></p><p>其组成主要为:</p><ul><li>设备选择电路</li><li>命令寄存器 &#x2F; 命令译码器<ul><li>完成触发器 D</li><li>工作触发器 B</li><li>中断请求触发器 INTR</li><li>屏蔽触发器 MASK</li></ul></li><li>数据缓冲寄存器</li><li>设备状态标记</li></ul><h3 id="5-4-程序查询方式"><a href="#5-4-程序查询方式" class="headerlink" title="5.4 程序查询方式"></a>5.4 程序查询方式</h3><h4 id="5-4-1-程序查询流程"><a href="#5-4-1-程序查询流程" class="headerlink" title="5.4.1 程序查询流程"></a>5.4.1 程序查询流程</h4><p>对于单个设备而言, 程序查询方式十分简单:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E5%8D%95%E4%B8%AA%E8%AE%BE%E5%A4%87.png" alt="程序查询_单个设备"></p><p>多个设备, 则需要将很多个这样的电路组合在一起:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87.png" alt="程序查询_多个设备"></p><p>对于程序查询这种方式, 总流程如下:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E6%80%BB%E6%B5%81%E7%A8%8B.png" alt="程序查询_总流程"></p><h4 id="5-4-2-程序查询的接口电路和具体流程"><a href="#5-4-2-程序查询的接口电路和具体流程" class="headerlink" title="5.4.2 程序查询的接口电路和具体流程:"></a>5.4.2 程序查询的接口电路和具体流程:</h4><p>见书 $ P_{191} $ ~ $ P_{192} $</p><h3 id="5-5-程序中断方式"><a href="#5-5-程序中断方式" class="headerlink" title="5.5 程序中断方式"></a>5.5 程序中断方式</h3><p>中断的概念前面有提及, 这里不再详细叙述了, 简而言之, 就是 <strong>暂存程序断点-&gt;进入中断服务程序-&gt;返回程序断点继续执行</strong> 这样的过程.</p><h4 id="5-5-1-I-O-中断的产生"><a href="#5-5-1-I-O-中断的产生" class="headerlink" title="5.5.1 I&#x2F;O 中断的产生"></a>5.5.1 I&#x2F;O 中断的产生</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/IO%E4%BA%A7%E7%94%9F%E4%B8%AD%E6%96%AD_%E4%BE%8B.png" alt="IO产生中断_例"></p><h4 id="5-5-2-中断方式的接口电路"><a href="#5-5-2-中断方式的接口电路" class="headerlink" title="5.5.2 中断方式的接口电路"></a>5.5.2 中断方式的接口电路</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF_%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png" alt="接口电路_中断方式"></p><p>由于计算机连接的 I&#x2F;O 设备肯定不止一个, 因此不同的中断请求需要被排序, 这涉及到 <strong>排队器</strong> 的设计.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F%E5%99%A8.png" alt="中断排队器"></p><p>在中断被触发后, 需要根据对应的中断请求给出相应的中断程序地址(比如打印机的中断请求需要对应打印机的中断服务程序), 因此还涉及到 <strong>中断向量地址形成部件</strong> ;</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E9%83%A8%E4%BB%B6.png" alt="中断向量地址形成部件"></p><p>关于 <strong>中断方式的完整接口电路</strong> , 见书 $ P_{196} $</p><p>此外, 有一道关于中断排队器以及中断向量地址的综合设计例题, 请看书 $ P_{196} $ 的例5.2</p><h3 id="5-5-3-I-O-中断处理过程"><a href="#5-5-3-I-O-中断处理过程" class="headerlink" title="5.5.3 I&#x2F;O 中断处理过程"></a>5.5.3 I&#x2F;O 中断处理过程</h3><ul><li>CPU相应中断的条件<ul><li>允许中断触发器 EINT &#x3D; 1;</li><li>EINT的更改可以通过: <ul><li>开中断: 1 -&gt; EINT</li><li>关中断: 0 -&gt; EINT</li><li>硬件自动复位: 0 -&gt; EINT</li></ul></li></ul></li><li>CPU相应中断的时间<ul><li>D &#x3D; 1 且 MASK &#x3D; 0;</li><li>在每条指令执行阶段的结束前CPU发送中断查询信号(相当于在上面的中断接口电路中将 INTR 置1)</li></ul></li></ul><p>关于 <strong>终端服务程序的流程</strong> :</p><ul><li>保护现场</li><li>中断服务</li><li>恢复现场</li><li>中断返回</li></ul><p>关于 <strong>单重中断与多重中断</strong> :</p><ul><li>单重中断: 一旦某一中断程序开始, 则必须运行完后才能进行下一次中断处理</li><li>多重中断: <strong>允许级别更高的中断源 中断 现行的中断服务程序</strong></li></ul><h3 id="5-6-DMA方式"><a href="#5-6-DMA方式" class="headerlink" title="5.6 DMA方式"></a>5.6 DMA方式</h3><h4 id="5-6-1-DMA方式的特点"><a href="#5-6-1-DMA方式的特点" class="headerlink" title="5.6.1 DMA方式的特点"></a>5.6.1 DMA方式的特点</h4><p>DMA方式与前两者的数据通路并不相同, I&#x2F;O 设备的DMA接口直接与主存相连.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E6%96%B9%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png" alt="DMA方式数据通路"></p><p>因此, DMA有三种与主存交换数据的方式:</p><ul><li>停止CPU访问主存: 即让CPU暂停一段时间, 把总线的控制权交给DMA</li><li>周期挪用(周期窃取): <ul><li>CPU此时不访存, 则DMA直接拿到控制权</li><li>CPU此时正在访存, DMA等待</li><li>CPU与DMA同时请求访存, 则CPU将总线控制权交给DMA;</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA_%E5%91%A8%E6%9C%9F%E7%AA%83%E5%8F%96.png" alt="DMA_周期窃取"></p><ul><li>CPU与DMA交替访问: 将CPU的工作周期分为两部分, 一部分专供DMA访存, 另一部分供CPU访存.(这种方式 <strong>不需要申请建立和归还总线的使用权</strong> )</li></ul><h4 id="5-6-2-DMA接口的功能和组成"><a href="#5-6-2-DMA接口的功能和组成" class="headerlink" title="5.6.2 DMA接口的功能和组成"></a>5.6.2 DMA接口的功能和组成</h4><p>DMA接口需要实现的功能如下:</p><ul><li>向CPU申请DMA传送</li><li>处理总线控制权的移交</li><li>管理系统总线 &#x2F; 控制数据传送</li><li>确定数据传送的首地址 &#x2F; 长度</li><li>传送结束后, 给出操作完成信号</li></ul><p>其 <strong>工作过程</strong> 主要分三步:</p><ul><li>预处理<ul><li>CPU向DMA输出指令, 预置一些必要信息<ul><li>主存起始地址</li><li>设备地址</li><li>传送数据个数</li></ul></li><li>可看作是DMA接口的初始化过程</li></ul></li><li>数据传送<ul><li>以数据块为单位传送数据</li><li>CPU此时继续执行主程序</li><li>传送结束后DMA向CPU申请中断</li></ul></li><li>后处理<ul><li>CPU停止主程序的执行, 进入中断服务程序</li><li>进行DMA的结束工作<ul><li>是否继续传送<ul><li>继续传送则初始化</li><li>否则停止外设</li></ul></li><li>检查传送过程是否出错</li></ul></li></ul></li></ul><h4 id="5-6-3-DMA方式与中断方式的比较"><a href="#5-6-3-DMA方式与中断方式的比较" class="headerlink" title="5.6.3 DMA方式与中断方式的比较"></a>5.6.3 DMA方式与中断方式的比较</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="DMA与中断方式的比较"></p><h4 id="5-6-4-DMA接口类型"><a href="#5-6-4-DMA接口类型" class="headerlink" title="5.6.4 DMA接口类型"></a>5.6.4 DMA接口类型</h4><ul><li>选择型: 物理上连接多个设备, 但逻辑上只能同时连接一个设备</li><li>多路型: 物理上连接多个设备, 逻辑上允许多个设备同时工作</li></ul><h2 id="Chap-3-系统总线"><a href="#Chap-3-系统总线" class="headerlink" title="Chap.3 系统总线"></a>Chap.3 系统总线</h2><h3 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h3><p>总线, 即 <strong>各个部件共享的传输介质</strong>, 分串行传送和并行传送.</p><p>总线结构的计算机举例:</p><p>1.面向CPU的双总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF.png" alt="面向CPU的双总线"></p><p>2.单总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%95%E6%80%BB%E7%BA%BF.png" alt="单总线"></p><p>3.面向存储器的双总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF.png" alt="面向存储器的双总线"></p><h3 id="3-2-总线分类"><a href="#3-2-总线分类" class="headerlink" title="3.2 总线分类"></a>3.2 总线分类</h3><p>大体上, 总线可分为</p><ul><li>片内总线: 即芯片内部的总线</li><li>系统总线<ul><li>数据总线: 双向, 与机器字长 &#x2F; 存储字长有关</li><li>地址总线: 单向, 与存储地址 &#x2F; I&#x2F;O 地址有关</li><li>控制总线: 有出有入</li></ul></li><li>通信总线: 用于 <strong>计算机系统之间</strong> 或 计算机系统与其它系统之间</li></ul><h3 id="3-3-总线的特性与性能指标"><a href="#3-3-总线的特性与性能指标" class="headerlink" title="3.3 总线的特性与性能指标"></a>3.3 总线的特性与性能指标</h3><h4 id="3-3-1-总线的物理实现"><a href="#3-3-1-总线的物理实现" class="headerlink" title="3.3.1 总线的物理实现"></a>3.3.1 总线的物理实现</h4><p>总线位于 <strong>主板</strong> 上, 而连接不同设备是由 <strong>插板</strong> 实现的.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0.png" alt="总线的物理实现"></p><h4 id="3-3-2-总线的特性"><a href="#3-3-2-总线的特性" class="headerlink" title="3.3.2 总线的特性"></a>3.3.2 总线的特性</h4><p>总线有以下几种值得关注的特性</p><ul><li>机械特性: 尺寸 &#x2F; 形状 &#x2F; 管脚数目 &#x2F; 排列顺序</li><li>电气特性: 传输方向 &#x2F; 有效电平范围</li><li>功能特性: 每根传输线的功能</li><li>时间特性: 信号的时序关系</li></ul><h4 id="3-3-3-总线的性能指标"><a href="#3-3-3-总线的性能指标" class="headerlink" title="3.3.3 总线的性能指标"></a>3.3.3 总线的性能指标</h4><ul><li>总线宽度: 数据线根数</li><li>总线带宽: 每秒传输的最大字节数(MBps)</li><li>时钟类型: 同步 &#x2F; 异步</li><li>总线复用: 地址线与数据线复用</li><li>信号线数: 地址线 &#x2F; 数据线 &#x2F; 控制线的总和</li><li>总线控制方式: 并发 &#x2F; 自动 &#x2F; 仲裁 &#x2F; 逻辑 &#x2F; 计数</li><li>其他指标: 负载能力等</li></ul><h3 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h3><h4 id="3-4-1-单总线结构"><a href="#3-4-1-单总线结构" class="headerlink" title="3.4.1 单总线结构"></a>3.4.1 单总线结构</h4><p>前面有所提及:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%95%E6%80%BB%E7%BA%BF.png" alt="单总线"></p><h4 id="3-4-2-多总线结构"><a href="#3-4-2-多总线结构" class="headerlink" title="3.4.2 多总线结构"></a>3.4.2 多总线结构</h4><p>1.双总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="双总线结构"></p><hr><p>2.三总线:</p><p>有两种方式.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%281%29.png" alt="三总线结构(1)"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%282%29.png" alt="三总线结构(2)"></p><hr><p>3.四总线</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9B%9B%E6%80%BB%E7%BA%BF.png" alt="四总线"></p><h3 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h3><h4 id="3-5-1-总线判优控制"><a href="#3-5-1-总线判优控制" class="headerlink" title="3.5.1 总线判优控制"></a>3.5.1 总线判优控制</h4><p>主线中的模块有优先之分:</p><ul><li>主设备(模块): 它对总线有控制权</li><li>从设备(模块): 它响应从主设备发来的总线命令</li><li>判优控制有两种方式<ul><li>集中式<ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li><li>分布式</li></ul></li></ul><hr><p>1.链式查询:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png" alt="总线判优_链式查询"></p><p>通过BS &#x2F; BR &#x2F; BG三个信号来决定总线的操作</p><p>2.计数器定时查询:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png" alt="总线判优_计数器定时查询"></p><p>通过计数器进行计时, 定时查询各个接口是否需要进行操作</p><p>3.独立请求方式:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82.png" alt="总线判优_独立请求"></p><p>在总线控制部件内部内置排队器, 接受来自各个接口的请求, 通过排队器决定处理顺序</p><h4 id="3-5-2-总线通信控制"><a href="#3-5-2-总线通信控制" class="headerlink" title="3.5.2 总线通信控制"></a>3.5.2 总线通信控制</h4><p>通信控制的目的在于解决双方的 <strong>协调配合问题</strong> .</p><p>总线传输周期有四个阶段:</p><ul><li>申请分配阶段: 主模块申请, 总线仲裁决定</li><li>寻址阶段: 主模块向从模块给出地址 &#x2F; 命令</li><li>传数阶段: 主模块和从模块交换数据</li><li>结束阶段: 主模块撤销有关信息</li></ul><p>主模块通过总线与从模块的数据通信也分四种:</p><ul><li>同步通信: 通过 <strong>统一时标</strong> 控制数据传送</li><li>异步通信: 采用 <strong>应答方式</strong> , 没有公共时钟标准</li><li>半同步通信: 同步 + 异步</li><li>分离式通信: 为了充分挖掘总线潜力而出现</li></ul><hr><p><strong>1.同步通信:</strong></p><p>通过统一时钟进行数据交互</p><p>以同步式数据输入为例:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png" alt="同步式数据输入"></p><p>这种方式使得 <strong>速度快的模块必将需要等待速度慢的模块准备完成</strong> 才能进行下一步, 因此会造成资源浪费.</p><p><strong>2.异步通信:</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1.png" alt="异步通信"></p><p>主模块发送请求信号时, 会一直等待从模块的应答信号, 而后再开始传输</p><ul><li>不互锁: 主模块确认从模块接收到请求后, 就撤销请求申请</li><li>半互锁: 主模块收到来自从模块的回答信号后, 再撤销其请求申请</li><li>全互锁: 主模块必须等待从模块回答后, 撤销其请求信号; 同时, 从模块必须等待主模块已经撤销其请求信号后, 才能撤销其应答信号.</li></ul><p><strong>3.半同步通信:</strong></p><p>增加一个 WAIT 信号, 即如果从模块速度过慢, 必须 <strong>在下一个时钟到来前给出 $ \overline{WAIT} $ 信号(低电平)</strong> , 主模块如果检测到这个低电平, 则会主动插入一个 $ T_w $ 进行等待, 直到 $ \overline{WAIT} $ 信号变为高电平了为止.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png" alt="半同步通信"></p><p><strong>4.分离式通信</strong></p><p>上述三种通信方法, 都分三个过程:</p><ul><li>主模块发地址 &#x2F; 命令(占用总线)</li><li>从模块准备数据( <strong>占用总线, 但总线空闲</strong> )</li><li>从模块向主模块发送数据(占用总线)</li></ul><p>分离式通信希望将 <strong>第二个过程浪费的总线传输也利用起来</strong> .</p><p>分离式通信将一个传输周期(总线周期)分成了两部分: </p><ul><li>$ T_1 $ : 主模块发送地址 &#x2F; 命令 &#x2F; <strong>自己的编号(在有多个主模块时, 这很重要, 涉及到从模块在下半个周期中的寻址)</strong> , 然后立即放弃总线使用权</li><li>$ T_2 $ : 从模块准备好后, 将收到主模块的编号 &#x2F; 自己的地址 &#x2F; 主模块所需数据发送到总线上, 供对应主模块接受.</li></ul><p>该方法:</p><ul><li>各模块都有权申请占用总线</li><li>采用同步方式通信, 不等对方回答</li><li><strong>在准备数据时不会占用总线(节省了时间)</strong></li><li>总线被占用时, 不会空闲, 一直在传输数据</li></ul><p>充分提高了总线的有效占用.</p><h3 id="3-6-几个名词"><a href="#3-6-几个名词" class="headerlink" title="3.6 几个名词"></a>3.6 几个名词</h3><ul><li>串行传送: 只有一条传输线, 按顺序传送表示一个数码的所有二进制位脉冲信号, 通常 <strong>第一位为最低位, 最后一位为最高位</strong> ;</li><li>位时间: 一个二进制位在传输线上占用的时间长度;</li><li>波特率: 单位时间内传送码元(要用若干个比特表示的最小单位)的数目;</li><li>比特率: 单位时间内传送有效数据比特的数目;</li></ul><hr><p>这篇博文应该是至今以来最长的一篇, 并未分片.</p><p>至此，计算机组成原理这门课的大部分内容就梳理完毕了.</p><p>希望这篇博文能对后来的读者有所帮助, 此外, 博主限于水平有限, 难免出现各种知识上的纰漏与笔误, 还请各位谅解.</p><p>在这里再次对本文引用到PPT的作者致以诚挚的谢意.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Composition Principles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安数学基础_Fin</title>
      <link href="/posts/56920.html"/>
      <url>/posts/56920.html</url>
      
        <content type="html"><![CDATA[<h1 id="信安数学基础"><a href="#信安数学基础" class="headerlink" title="信安数学基础"></a>信安数学基础</h1><blockquote><p>写在前边，本文是作者应对期末考试写的复习文, 感觉应该有点用, 就顺带着传上来, 其中有些直接标注了ppt页数, 是作者得到的课件, 读者不必太在意.</p><p>另外, 本文大量使用了Mathjax语法, 希望不会引起很多渲染错误吧…</p></blockquote><h2 id="Chap-1-整除，带余除法"><a href="#Chap-1-整除，带余除法" class="headerlink" title="Chap.1 整除，带余除法"></a>Chap.1 整除，带余除法</h2><h3 id="1-1-基础概念阐述"><a href="#1-1-基础概念阐述" class="headerlink" title="1.1 基础概念阐述"></a>1.1 基础概念阐述</h3><p>全体整数的集合Z，全体自然数的集合N</p><p>整除的记法： <strong>a|b</strong> ，称为 <strong>b被a整除</strong> ，意味着 <strong>b是a的倍数，a是b的因子</strong> 。</p><h3 id="1-2-整除的性质"><a href="#1-2-整除的性质" class="headerlink" title="1.2 整除的性质"></a>1.2 整除的性质</h3><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%95%B4%E9%99%A4%E7%9A%84%E6%80%A7%E8%B4%A8.png" alt="整除的性质"></p><h3 id="1-3-素数"><a href="#1-3-素数" class="headerlink" title="1.3 素数"></a>1.3 素数</h3><p>素数即 <strong>其正因子只有1和它自己</strong> 的整数。反之，则称为 <strong>合数</strong> 。</p><p>对于素数和合数，有几个定理：</p><ul><li>合数的最小真因子一定是素数（Chap1 P14）</li><li>素数有无穷多个（Chap1 P15）</li></ul><p>素数分布： <strong>$ \pi(x) $</strong> 表示 <strong>不超过x的素数的个数</strong> 。</p><p>比较好的估计方法——素数定理： <strong>$ \pi(x) \approx \frac{x}{lnx}, x\to\infty $</strong></p><p>具体去看Chap1 P19</p><h3 id="1-4-带余除法"><a href="#1-4-带余除法" class="headerlink" title="1.4 带余除法"></a>1.4 带余除法</h3><p>$$ b &#x3D; qa + r $$</p><p>显然，r &#x3D; 0 是 a|b 的充要条件</p><p>这里有两个取法：</p><ul><li>最小正剩余：r取值范围为 (0, a-1);</li><li>最小绝对剩余：r取值范围围绕0左右；</li></ul><p>一般都取最小正剩余。</p><hr><p>根据这种带余除法，可以根据除数对于整个整数集Z分类。即</p><p>$$ S_{a, j} &#x3D; a*k+j $$</p><p>这其中：</p><ul><li>$ j &#x3D; 0, 1, …, a-1 $</li><li>$ k &#x3D; 0, \pm 1, \pm2, … $</li></ul><p>相当于将Z分成了a类，每类中的数字除以a所得的余数就是j。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%95%B4%E6%95%B0%E5%88%86%E7%B1%BB.png" alt="整数分类的性质"></p><p>关于 <strong>进制转换，见 Chap1 P34</strong> ，这里不再赘述。</p><h2 id="Chap-2-最大公因子，欧几里得算法"><a href="#Chap-2-最大公因子，欧几里得算法" class="headerlink" title="Chap.2 最大公因子，欧几里得算法"></a>Chap.2 最大公因子，欧几里得算法</h2><h3 id="2-1-公因子-最大公因子"><a href="#2-1-公因子-最大公因子" class="headerlink" title="2.1 公因子 &amp; 最大公因子"></a>2.1 公因子 &amp; 最大公因子</h3><p>公因子： <strong>d|a 且 d|b</strong> ，则d是a、b的公因子。</p><p>最大公因子就是其中最大的那个。</p><p>记法： <strong>$ gcd(a_1, a_2, …, a_n) $</strong></p><p>性质：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BE%8B.png" alt="最大公因子性质_例子"></p><p>更严谨一点的说法：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8.png" alt="最大公因子性质"></p><p>关于这些性质的证明, 见Chap.2 P9</p><p>这其中第二条用的尤其多, 意味着最大公因子前后是可以互相加减的. </p><h3 id="2-2-互素"><a href="#2-2-互素" class="headerlink" title="2.2 互素"></a>2.2 互素</h3><p>如果 $ gcd(a_1, a_2) &#x3D; 1 $ , 则称a1, a2是互素的.</p><p>$ gcd(a_1, a_2, a_3, …, a_n) &#x3D; 1 $ , 称他们整体互素.</p><p>如果他们之间任意两个都互素, 则称 a1, a2, …, ak <strong>两两互素</strong> .</p><p>显然, 根据上面的性质5, $ 两两互素\implies整体互素 $ , <strong>反之不然</strong> .</p><hr><p>费马数:</p><p>$$ F_n &#x3D; 2^{2^n}+1 , n为非负整数$$</p><p>任意两个不同的费马数互素. 关于这个定理的证明, 见Chap2 P13</p><p>明确一点: <strong>两个合数也有可能互素, 即便它们是合数</strong> , 如8和15, 或者费马数F5(这是个合数).</p><hr><p>有关互素的最大公因子性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BA%92%E7%B4%A0%E7%9B%B8%E5%85%B3%281%29.png" alt="最大公因子性质_互素(1)"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BA%92%E7%B4%A0%E7%9B%B8%E5%85%B3%282%29.png" alt="最大公因子性质_互素(2)"></p><p>最后这一条比较重要, 欧几里得算法成立的基础就是这玩意.</p><p>更多最大公因子的性质, 见Chap.2 P18 以及 Chap.2 P21</p><h3 id="2-3-最小公倍数"><a href="#2-3-最小公倍数" class="headerlink" title="2.3 最小公倍数"></a>2.3 最小公倍数</h3><p>公倍数: a|d 且 b|d, 称d为a, b的公倍数.</p><p>最小公倍数, 即其中最小的那个, 记作 $ [a, b] $ .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E6%80%A7%E8%B4%A8.png" alt="最小公倍数性质"></p><p>有一个需要摁记住的, <strong>$ [a_1, a_2](a_1, a_2) &#x3D; |a_1a_2| $</strong></p><h3 id="2-4-最大公因子的求解-欧几里得算法"><a href="#2-4-最大公因子的求解-欧几里得算法" class="headerlink" title="2.4 最大公因子的求解-欧几里得算法"></a>2.4 最大公因子的求解-欧几里得算法</h3><p>基本思路:</p><p>$$ (a, b) &#x3D; (qb+r, b) &#x3D; (r, b) $$</p><p>将大的数字换成小的数字的带余除法形式, 而后依据最大公因子性质2, 直接将乘积去掉.</p><p>这个方法也叫做 <strong>辗转相除法</strong> .</p><p>直到没有余数为止, 此时的数字被就是二者的最大公因子.</p><hr><p>扩展欧几里得算法, 可以将 gcd(a, b) 表示成 a, b的线性组合的形式.</p><p>具体过程就是从下向上推, 每一次将余数换掉就可以了.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Euclid%E7%AE%97%E6%B3%95%E4%BE%8B.png" alt="Euclid算法例"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%89%A9%E5%B1%95Euclid%E7%AE%97%E6%B3%95%E4%BE%8B.png" alt="扩展Euclid算法例"></p><p>关于这个,可以扩展出一个性质: </p><p><strong>a, b的整系数线性组合恰好构成了 gcd(a, b)的所有整数倍.</strong></p><p>而如果a, b互素, 即gcd(a, b) &#x3D; 1, 则任何整数都可以被表示成a, b的整系数线性组合了.</p><hr><p>这里还要给一个方法, 用于给出一个整数x 如何用a, b线性组合表示出来.</p><p>首先, 如果x可以用a, b的线性组合表示, 则 gcd(a, b)|x 必定成立.</p><p>那么, 我们先用欧几里得算法以及扩展欧几里得算法算出gcd(a, b), 以及gcd(a, b)如何用a, b线性表示.</p><p>而后在式子前面乘上x与gcd(a, b)的倍数即可.</p><hr><p>关于其它的性质, 见Chap.2 P48</p><h3 id="2-5-一次不定方程的求解"><a href="#2-5-一次不定方程的求解" class="headerlink" title="2.5 一次不定方程的求解"></a>2.5 一次不定方程的求解</h3><p>一次不定方程:</p><p>$$ a_1x_1+a_2x_2+…+a_nx_n &#x3D; c $$</p><p>其有解的充要条件是, $ gcd(a_1, a_2, …, a_n)|c $</p><hr><p>主要看二元一次不定方程: $ ax+by &#x3D; c $</p><p>如果该方程已经有一组解: $ (x_0, y_0) $ , 则我们可以给出其全部解:</p><p>$$<br>\begin{cases}{c}<br>    x &#x3D; x_0+\frac{b}{(a, b)}t \\<br>    y &#x3D; y_0+\frac{a}{(a, b)}t \<br>\end{cases}<br>$$</p><p>由此, 我们明确了二元一次不定方程的求解:</p><ul><li>验证是否有解: 即 $ gcd(a, b)|c $ 是否成立</li><li>如果有解, 利用扩展欧几里得算法求出一组特解(相当于通过扩展欧几里得算法将c表达成a, b的线性组合的形式), 而后根据上面的公式给出通解.</li></ul><h3 id="2-6-算术基本定理"><a href="#2-6-算术基本定理" class="headerlink" title="2.6 算术基本定理"></a>2.6 算术基本定理</h3><p>通俗的讲, 就是 <strong>任何大于1的整数都能化为有限个素数的乘积</strong> .</p><p>利用公式表达:</p><p>$$ a&gt;1 \implies a &#x3D; p_1p_2…p_s $$</p><p>这其中, p1, p2, …都是素数</p><hr><p>推论: <strong>标准素因数分解式</strong></p><p>$$ a &#x3D; p_1^{\alpha_1}p_2^{\alpha_2}…p_n^{\alpha_n} $$</p><p>通过这个式子,我们可以给出求最大公因式以及最小公倍数的比较简单的方法:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%A0%87%E5%87%86%E7%B4%A0%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3_%E9%87%8D%E8%A6%81%E6%8E%A8%E8%AE%BA.png" alt="标准素因数分解_重要推论"></p><ul><li>最大公因数: 把每个素因子取最小值,相乘即可.</li><li>最小公倍数: 把每个素因子取最大值,相乘即可.</li></ul><p>这个玩意也能用于证明一些东西, 具体见Chap.2 P79.</p><hr><p>素因式的更多推论, 见Chap.2 P82</p><h2 id="Chap-3-同余"><a href="#Chap-3-同余" class="headerlink" title="Chap.3 同余"></a>Chap.3 同余</h2><h3 id="3-1-同余-概述"><a href="#3-1-同余-概述" class="headerlink" title="3.1 同余_概述"></a>3.1 同余_概述</h3><p>若m, a, b 满足 $ m|a-b $ , 则我们称a, b同余, 记作:</p><p>$$ a \equiv b\space (mod\space m) $$</p><p>跟前面带余除法其实挺像的, 也分非负最小剩余和绝对最小剩余, 这里一般用非负最小剩余来写.</p><hr><p>同余的性质:</p><p>显然, 既然叫同余了, 自然能得到如下定理, 即 <strong>a, b被m除后所得余数相同</strong> .</p><p>对于同余式左右而言, 加法 \ 减法 \ 乘法均成立, 但除法比较特殊. </p><p>$$ ca \equiv cb\space(mod\space m) \iff<br>a \equiv b \space (mod \space \frac{m}{(c, m)}) $$</p><p>显然, 当且仅当c, m互素, 即(c, m) &#x3D; 1时, 消去律(除法)才能成立.</p><h3 id="3-2-乘法逆元-重要概念"><a href="#3-2-乘法逆元-重要概念" class="headerlink" title="3.2 乘法逆元(重要概念)"></a>3.2 乘法逆元(重要概念)</h3><p>若 $ m&gt;1 $ , 且 $ (a, m) &#x3D; 1 $ , 如果存在 c 使:</p><p>$$ ca \equiv 1 \space(mod \space m) $$</p><p>我们就可以把c称为a对m的逆元, 记为 $ a^{-1}(mod \space m) $</p><hr><p>乘法逆元的求法?</p><p>利用欧几里得算法.</p><p>因为 (a, m) &#x3D; 1 , 则有 $ sa + tm &#x3D; 1 $ , 即1可以通过 a 和 m 的线性组合表示, 只需要取 c &#x3D; s 即满足要求.</p><p>至于怎么求解线性组合, 这是第二章的事情, 忘了往回看.</p><hr><p>乘法逆元的性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E6%80%A7%E8%B4%A8.png" alt="乘法逆元的性质"></p><hr><p>给两类典型题目:</p><p>1.分数的最小剩余:</p><p>求 $ \frac{53}{46} \space (mod \space 25) $</p><p>相当于: $ 3 * (46)^{-1} \space (mod \space 25) $</p><p>就需要算一个46关于25的乘法逆, 也就是21关于25的乘法逆.</p><p>给出过程供参考:</p><ul><li>$ (21, 25) &#x3D; 1 $</li><li>$ 1 &#x3D; 6*21 + (-5)*25 $</li><li>21关于25的乘法逆就是6</li></ul><p>因此 $ \frac{53}{46} \space (mod \space 25)  &#x3D; 3*6 &#x3D; 18 $</p><p>2.大数带余除法</p><p>求 $ 3^{1001} mod\space 13 $</p><p>利用同余式子的可乘性质(最好找一个除以模数模1的, 这样能直接消掉):</p><p>$ 3^3 \equiv 1\space(mod\space 13) $</p><p>则:</p><p>$ 3^{3*333} &#x3D; 3^{999} \equiv 1\space(mod\space 13) $</p><p>因此:</p><p>$ 3^{1001}\space(mod\space 13) &#x3D; 3^2\space(mod\space 13) &#x3D; 9 $</p><hr><p>关于换模的条件:</p><p>如果 $ d&gt;1 且 d|m $ , 并且同余式 $ a\equiv b \space (mod\space m) $ 成立;</p><p>则能推出 $ a\equiv b\space(mod\space d) $</p><p>由上面这个式子, 可以得到推论:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%8D%A2%E6%A8%A1%E6%8E%A8%E8%AE%BA.png" alt="换模推论"></p><h3 id="3-3-剩余类和剩余系"><a href="#3-3-剩余类和剩余系" class="headerlink" title="3.3 剩余类和剩余系"></a>3.3 剩余类和剩余系</h3><h4 id="3-3-1-剩余类"><a href="#3-3-1-剩余类" class="headerlink" title="3.3.1 剩余类"></a>3.3.1 剩余类</h4><p>根据除以模数 m 所得的余数对于整数集合Z进行分类.</p><p>总共m个剩余类, 每个剩余类的代表元是: 0, 1, 2, …, m-1</p><p>如果该剩余类的 <strong>代表元与模数m互素</strong> , 称这个剩余类为m的 <strong>既约剩余类</strong> , 既约剩余类的总个数即欧拉函数(Eular函数), 记作 $ \varphi(m) $</p><p>两个记法:</p><p>所有m的剩余类组成的集合:</p><p>$$ Z_m $$</p><p>所有m的既约剩余类组成的集合:</p><p>$$ Z_m^* $$</p><p>有时候为了简写, 会通过一个代表元来表示一整个集合:</p><p>$$ Z_{12} &#x3D; \lbrace 0, 1, 2, 3, …, 11\rbrace $$</p><p>$$ Z_{12}^* &#x3D; \lbrace 1, 5, 7, 11 \rbrace $$</p><blockquote><p>剩余类是一堆同余的整数组成的集合</p></blockquote><h4 id="3-3-2-剩余系"><a href="#3-3-2-剩余系" class="headerlink" title="3.3.2 剩余系"></a>3.3.2 剩余系</h4><p>从 <strong>每个剩余类中取出一个元素</strong> (即共取出m个元素), 组成一个集合, 叫做m的一个完全剩余系.</p><p>相应的, 从 <strong>每个既约剩余系中取出一个元素</strong> (即共取出 $ \varphi(m) $ 个元素), 组成一个集合, 叫做m的一个既约剩余系.</p><p>完全剩余系最简单的取法就是取 {0, 1, …, m-1}</p><p>既约剩余系最简单的取法就是取 <strong>小于m的,与m互素的元素</strong> .</p><h3 id="3-4-欧拉函数-欧拉定理-Euler定理"><a href="#3-4-欧拉函数-欧拉定理-Euler定理" class="headerlink" title="3.4 欧拉函数 &amp; 欧拉定理(Euler定理)"></a>3.4 欧拉函数 &amp; 欧拉定理(Euler定理)</h3><p>前面提到, $ \varphi(m) $ 是m的既约剩余类的个数.</p><p><strong>三条性质:</strong> </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8.png" alt="欧拉函数的性质"></p><p><strong>这三条能够解决全部整数欧拉函数的求法</strong></p><hr><p><strong>两条推论:</strong> </p><p>除了 $ \varphi(1) &#x3D; \varphi(2) &#x3D; 1 $ , 对于其余的欧拉函数, 都有:</p><p>$$ 2|\varphi(m) $$</p><p>对于任意n:</p><p>$$ \sum_{d|n} \varphi(d) &#x3D; n $$</p><p>即 <strong>n的所有因子 (包括n自己) 的欧拉函数相加等于n</strong></p><hr><p><strong>欧拉定理:</strong></p><p>如果 (a, m) &#x3D; 1(a与m互素), 则:</p><p>$$ a^{\varphi(m)} \equiv 1 \space(mod\space m) $$</p><p><strong>费马小定理:</strong></p><p>p为素数, 则:</p><p>$$ \varphi(p) &#x3D; p-1 $$</p><p>这定理挺好理解的, 就是素数有p-1个既约剩余系(把代表元为0的既约剩余系抛了就行)</p><p>结合欧拉定理, 有:</p><p>$$ a^{\varphi(p)} &#x3D; a^{p-1} \equiv 1\space(mod\space p) $$</p><hr><p>欧拉定理给出了另一种求a对于m乘法逆元的方式:</p><p>$$ a^{-1} \equiv a^{\varphi(m)-1}\space(mod\space m) $$</p><hr><p>有了欧拉带余除法, 我们再看这类题:</p><p>2.大数带余除法</p><p>求 $ 3^{1001} mod\space 13 $</p><p>利用同余式子的可乘性质(最好找一个除以模数模1的, 这样能直接消掉):</p><p>要找一个除以模数余1的就很简单: 因为 $ 3^{\varphi(13)} &#x3D; 3^{12} \equiv 1\space(mod\space 13) $</p><p>此后消去 $ 3^{12} $ 的元即可, 即:</p><p>$$ 3^{1001} &#x3D; 3^{12*83}*3^{5} $$</p><p>即计算:</p><p>$$ 3^5 \space(mod\space 13) $$</p><p>结果相同.</p><h2 id="Chap-4-同余方程"><a href="#Chap-4-同余方程" class="headerlink" title="Chap.4 同余方程"></a>Chap.4 同余方程</h2><h3 id="4-1-一元高次同余方程的概念"><a href="#4-1-一元高次同余方程的概念" class="headerlink" title="4.1 一元高次同余方程的概念"></a>4.1 一元高次同余方程的概念</h3><p>同余方程：</p><p>$$ f(x) &#x3D; a_nx^n + … + a_1x+a_0 $$</p><p>形如: </p><p>$$ f(x) \equiv 0\space(mod\space m) $$</p><p>的同余式叫做模m的同余方程.</p><p>我们将满足上面的式子的x&#x3D;c称作该方程的一个解.</p><p>显然, 如果c是上面方程的一个特解, 那么c对于m的同余类中的所有数都应当是上面这个方程的解(有关m的因子可以直接消掉)</p><p><strong>同余方程的次数就是多项式的次数</strong></p><p><strong>从本质上, 同余方程就是系数取自 $ Z_m $ 的方程</strong></p><p>接下来是两个问题:</p><ul><li>有没有解?</li><li>有多少解?</li><li>如何求解?</li></ul><hr><p>关于有没有解这个问题:</p><p><strong>同余方程 $ f(x) \equiv 0\space(mod\space m) $ 有解的必要条件是, 对于m的每个因子d (即d|m) , $ f(x) \equiv 0\space(mod\space d) $ 均有解.</strong></p><p>这个定理使得可以 <strong>通过简单的枚举来判断一个同余方程是不是无解.</strong></p><p>如: $ f(x) \equiv 0\space(mod\space 15) $</p><p>可以先枚举 $ f(1), f(2), f(3) $ , 判断 $ f(x) \equiv 0\space(mod\space 3) $ 有没有解, 如果模3都无解, 则模15必定无解.</p><hr><p>关于有多少解这个问题:</p><p>考虑模数是素数的情况:</p><p>$$ f(x) \equiv 0\space(mod\space p) $$</p><p>的解数不会超过 f(x) 的次数 n.</p><hr><p>关于如何求解这个问题:</p><p><strong>穷举法:</strong></p><p>首先, 也是最简单的方法, 直接从1到p-1穷举.</p><p><strong>多项式化简:</strong></p><p>其次, 通过多项式的性质来化简系数和次数.</p><p>1.化简系数:</p><p>如将 $ 15x^2 + 20x + 12(mod\space 11) $ 化简为 $ 4x^2+9x+1(mod\space 11) $ .</p><p>2.化简次数:</p><p>如果 $ f(x) &#x3D; q(x)h(x) + r(x) $ , 并且 $ h(x) \equiv 0(mod\space m) $ 是恒等同余式, 则可以将原方程化简为 $ r(x) \equiv 0(mod\space m) $</p><p><strong>关键在于找这个h(x)</strong></p><p>如果m是素数, 那这个式子可以用欧拉-费马小定理直接给出:</p><p>$$ x^{\varphi(p)} \equiv 1(mod\space p) $$</p><p>即(把1挪到左边, 两侧同乘x):</p><p>$$ x^{p} - x \equiv 0(mod\space p) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B_%E5%8C%96%E7%AE%80%E6%AC%A1%E6%95%B0.png" alt="同余方程_化简次数"></p><blockquote><p>上面这两个方法其实本质目的在于 <strong>把f(x)变得更简单</strong> , 从而更轻松的进行枚举.</p></blockquote><h3 id="4-2-一次同余方程"><a href="#4-2-一次同余方程" class="headerlink" title="4.2 一次同余方程"></a>4.2 一次同余方程</h3><p>一次同余方程是最简单的情况:</p><p>$$ ax \equiv b(mod\space m) $$</p><p>1.a,m同余的情况:</p><p>根据同余式的除法性质, 当(a, m) &#x3D; 1时(即a, m互素), 可以直接将a除到右边.</p><p>此时就一个解: $ x \equiv a^{-1}b(mod\space m) $</p><p>2.一般情况:</p><p>此时有解的充要条件是:</p><p>$$ (a, m)|b $$</p><p>同时, 解数也正好是 (a, m);</p><p>其通解正好是: $ x \equiv x_0 + \frac{m}{(a,m)}t(mod\space m) $</p><p>这里: t &#x3D; 0, 1, …, (a, m)-1;</p><p><strong>可以类比一次不定方程的解法, 事实上, 这俩几乎一模一样</strong></p><p>因为可以直接将上面这个同余方程等价于:</p><p>$$ ax + my &#x3D; b $$</p><p><strong>因此</strong> ,我们继续类比一次不定方程的解题过程:</p><ul><li>判断有没有解: 即(a,m)|b是否成立</li><li>如果有解, 通过扩展Euclid算法计算一个特解</li><li>利用公式给出通解</li></ul><h3 id="4-3-一次同余方程组"><a href="#4-3-一次同余方程组" class="headerlink" title="4.3 一次同余方程组"></a>4.3 一次同余方程组</h3><p>一次同余方程组的通用形式:</p><p>$$ f_i(x) \equiv 0(mod\space m_i) $$</p><p>i可以取多个值.</p><p>通过 <strong>孙子定理</strong> 可以对一次同余方程组进行刻画与求解</p><hr><p>孙子定理:</p><p>设 $ m_1, m_2, …, m_k $ <strong>两两互素</strong> , 则对于任意整数 $ a_1, a_2, …, a_k $ , 一次同余方程组:</p><p>$$ x \equiv a_i(mod\space m_i) , \space 1\leq i\leq k$$</p><p>一定有解, 并且解在模m的意义下唯一.</p><p>这个唯一解是:</p><p>$$ x \equiv a_1t_1M_1 + … + a_kt_kM_k(mod\space m) $$</p><p>其中:</p><ul><li>$ a_i $ : 就是每个方程后面的整数</li><li>$ m &#x3D; m_1 * m_2 * … * m_k &#x3D; m_i * M_i $</li><li>$ t_iM_i \equiv 1(mod\space m_i) $ , 即ti是Mi在模mi意义下的乘法逆元 (Mi的定义上面已经给出)</li></ul><hr><p>给个例子:</p><p>$$<br>    \begin{cases}{c}<br>        x \equiv 2(mod\space 3) \\<br>        x \equiv 3(mod\space 5) \\<br>        x \equiv 2(mod\space 7) \<br>    \end{cases}<br>$$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86_%E4%BE%8B.png" alt="孙子定理_例"></p><hr><p>如果 <strong>模数两两不互诉?</strong></p><p>$$<br>    \begin{cases}{c}<br>        4x \equiv 14(mod\space 15) \\<br>        9x \equiv 11(mod\space 20) \<br>    \end{cases}<br> $$</p><p>先要将其拆开, 如下:</p><p>$$<br>    \begin{cases}{c}<br>        4x \equiv 14(mod\space 3) \\<br>        4x \equiv 14(mod\space 5) \\<br>        9x \equiv 11(mod\space 4) \\<br>        9x \equiv 11(mod\space 5) \<br>    \end{cases}<br> $$</p><p>对上面的方程式一一化简即可</p><p>$$<br>    \begin{cases}{c}<br>        x \equiv 2(mod\space 3) \\<br>        x \equiv 1(mod\space 5) \\<br>        x \equiv 3(mod\space 4) \\<br>        x \equiv -1(mod\space 5) \<br>    \end{cases}<br> $$</p><p>而后, 有矛盾则无解, 无矛盾则依照正常解法求解即可</p><h2 id="Chap-5-二次剩余"><a href="#Chap-5-二次剩余" class="headerlink" title="Chap.5 二次剩余"></a>Chap.5 二次剩余</h2><h3 id="5-1-二次剩余概述"><a href="#5-1-二次剩余概述" class="headerlink" title="5.1 二次剩余概述"></a>5.1 二次剩余概述</h3><p>二次同余方程:</p><p>$$ ax^2 + bx + c &#x3D; 0(mod\space p) $$</p><p>解法如下:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B_%E8%A7%A3%E6%B3%95.png" alt="一元二次同余方程_解法"></p><p>这玩意看一眼就行, 主要为了引出二次剩余.</p><hr><p><strong>二次剩余:</strong></p><p>素数 p&gt;2 , (p, d) &#x3D; 1.</p><p>如果 $ x^2 \equiv d(mod\space p) $ 有解, 称d是模p的二次剩余.</p><p>如果无解,则称d是模p的二次非剩余.</p><p>记法:</p><p>二次剩余全体组成的集合:</p><p>$$ QR_p &#x3D; \lbrace a|a\in Z^*_p, 存在x\in Z^*_p使得x^2 \equiv a(mod\space p)\rbrace $$</p><p>二次非剩余组成的集合:</p><p>$$ QR_p &#x3D; \lbrace a|a\in Z^*_p, 任意x\in Z^*_p均有x^2 \ne a(mod\space p)\rbrace $$</p><blockquote><p>这里直接表明了a属于p的既约非剩余系, 是因为前面提到了(p, d) &#x3D; 1</p></blockquote><p>给个例子:</p><p>$$ QR_7 &#x3D; \lbrace 1, 2, 4 \rbrace $$</p><p>$$ NQR_7 &#x3D; \lbrace 3, 5, 6 \rbrace $$</p><hr><p>关于既约剩余系中二次剩余与二次非剩余的个数:</p><p><strong>二次剩余与二次非剩余各占一半, 即: $ |QR_p| &#x3D; |NQR_p| &#x3D; \frac{p-1}{2} $</strong></p><hr><p><strong>如何判别 d 是否是 模p 的二次剩余?</strong></p><p>欧拉判别法:</p><p><strong>d 是 模p 的二次剩余的充要条件:</strong></p><p>$$ d^{\frac{p-1}{2}} \equiv 1(mod\space p) $$</p><p><strong>d 是 模p 的二次非剩余的充要条件:</strong></p><p>$$ d^{\frac{p-1}{2}} \equiv -1(mod\space p) $$</p><p>推论: Chap.5 P16 P17</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99_%E4%B9%98%E7%A7%AF%E5%88%A4%E5%88%AB%E6%8E%A8%E8%AE%BA.png" alt="二次剩余_乘积判别"></p><blockquote><p>这个d的次方可能很大,具体该怎么算,参见前面的大数带余除法问题(3.4 &amp; 3.2)</p></blockquote><h3 id="5-2-Legendre符号"><a href="#5-2-Legendre符号" class="headerlink" title="5.2 Legendre符号"></a>5.2 Legendre符号</h3><p><strong>Legendre符号定义:</strong></p><p>设素数p &gt; 2, 令:</p><p>$$ (\frac{d}{p}) &#x3D;<br>    \begin{cases}{c}<br>        0, 当p|d时 \\<br>        1, 当d是p的二次剩余时 \\<br>        -1, 当d是p的二次非剩余时 \<br>    \end{cases}<br> $$</p><p>我们称 $ (\frac{d}{p}) $ 为 <strong>模p的Legendre符号</strong></p><hr><p>Legendre符号性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Legendre%E7%AC%A6%E5%8F%B7%E6%80%A7%E8%B4%A8.png" alt="Legendre符号性质"></p><blockquote><p>由第一条, Legendre符号就是欧拉判别式的另一种写法.</p></blockquote><hr><p>Legendre符号的有效计算: Gauss二次互反律</p><p>设p, q都是奇素数, 那么:</p><p>$$ (\frac{q}{p})(\frac{p}{q}) &#x3D; (-1)^{(\frac{p-1}{2})(\frac{q-1}{2})} $$</p><blockquote><p>如果p, q不是奇素数, 请利用Legendre符号的性质3, 将其转化为奇素数.<br>划出来的2, 可以用性质5求解</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Gauss%E4%BA%8C%E6%AC%A1%E4%BA%92%E5%8F%8D%E5%BE%8B_%E4%BE%8B.png" alt="Gauss二次互反律_例"></p><p>更复杂的例子, 见Chap.5 P28.</p><h2 id="Chap-6-原根与指数"><a href="#Chap-6-原根与指数" class="headerlink" title="Chap.6 原根与指数"></a>Chap.6 原根与指数</h2><h3 id="6-1-阶-原根"><a href="#6-1-阶-原根" class="headerlink" title="6.1 阶 &#x2F; 原根"></a>6.1 阶 &#x2F; 原根</h3><p>讨论：</p><p>$$ a^x \equiv b(mod\space m) $$</p><p>这方程目前不会涉及, 但一种最简单的情况需要考虑: 即</p><p>$$ a^x \equiv 1(mod\space m) $$</p><p>使得这个式子成立的 <strong>最小的正整数</strong> x 被称为 <strong>a模m的阶</strong> , 记作 $ ord_m(a) $ .</p><p>特别的, 如果 <strong>$ ord_m(a) &#x3D; \varphi(m) $</strong> 时, 称a是 <strong>模m的原根</strong> .</p><hr><p>阶的性质:</p><ul><li><strong>与代表元无关:</strong></li></ul><p>如果a和b在关于模m的同一个 <strong>既约剩余类</strong> 中, 即:</p><p>$$ b \equiv a(mod\space m) , \space (a, m) &#x3D; 1$$</p><p>则我们一定能推出:</p><p>$$ ord_m(a) &#x3D; ord_m(b) $$</p><ul><li><strong>阶的周期性:</strong></li></ul><p>即如果有:</p><p>$$ a^d \equiv 1(mod\space m) $$</p><p>则必定能推出:</p><p>$$ ord_m(a)|d $$</p><blockquote><p>相当于阶这个概念自己划定了一个周期, 每经过一个周期, 都会再次回到1.</p></blockquote><ul><li><strong>阶与欧拉函数:</strong></li></ul><p>对任何正整数m, 均有:</p><p>$$ ord_m(a)|\varphi(m) $$</p><blockquote><p>说明任何元素模m的阶, 都必定是m欧拉函数的因子.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/17%E7%9A%84%E5%8E%9F%E6%A0%B9.png" alt="17的原根"></p><ul><li><strong>性质4见Chap.6 P15(a的乘方同余, 则乘方之间有关系)</strong></li><li><strong>乘法逆元的阶:</strong></li></ul><p>有:</p><p>$$ ord_m(a) \equiv ord_m(a^{-1}) $$</p><ul><li><strong>a的k次幂的阶与a有关(Chap.6 P17)</strong></li></ul><p>有: </p><p>$$ ord_m(a^k) &#x3D; \frac{ord_m(a)}{(ord_m(a), k)} $$</p><ul><li><strong>原根个数:</strong></li></ul><p><strong>如果m有原根(这是大前提)</strong> , 则m的原根个数必然是:</p><p>$$ \varphi(\varphi(m)) $$</p><p>并且所有原根的集合:</p><p>$$ \lbrace g^i|(i, \varphi(m)) &#x3D; 1, 1\leq i&lt;\varphi(m) \rbrace $$</p><p>这其中:</p><ul><li>g是m的其中一个原根;</li><li>i是乘方数, 必须满足与m的欧拉函数互素;</li></ul><p>举例而言:(还是上面那个17的原根的例子)</p><p>17的原根个数:</p><p>$$ \varphi(\varphi(17)) &#x3D; \varphi(16) &#x3D; \varphi(2^4) &#x3D; 2^3*(2-1) &#x3D; 8 $$</p><p>最后这步是欧拉函数的性质1. (详见3.4)</p><ul><li><p><strong>性质7, 8见Chap.6 P20, 21</strong></p></li><li><p><strong>一个数有原根的充要条件:</strong></p></li></ul><p>当:</p><p>$$ m &#x3D; 2, 4, p^\alpha, 2p^\alpha $$ </p><p>时, m一定有原根.</p><p>这其中:</p><ul><li>p 是奇素数;</li><li>$ \alpha $ 是任意正整数;</li></ul><p>这条性质, 和上面那条原根个数的性质, 能够轻松的判断出 <strong>一个正整数是否有原根, 有多少原根.</strong></p><hr><p>原根的有效求解:</p><p>在m有原根的前提下, 对于 $ \varphi(m) $ 所有的素因子 $ q_1, q_2, …, q_s $ , g是模m的原根的充要条件是:</p><p>$$ g^{\frac{\varphi(m)}{q_j}} \neq 1(mod\space m), \space j &#x3D; 1, 2, …, s $$</p><p>上面这个式子其实不是一个直接计算的式子, 只能算一个检验式.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%B1%82%E5%8E%9F%E6%A0%B9_%E4%BE%8B.png" alt="求原根_例"></p><hr><p><strong>关于原根生成的剩余系:</strong></p><p>任意原根g都可以生成模m的既约剩余系, 即</p><p>$$ \lbrace g^0, g^1, …, g^{\varphi(m)-1} \rbrace $$</p><p>这时, 我们称呼g为模m既约剩余系的一个生成元.</p><blockquote><p>请务必明确, 每个原根都能生成一个既约剩余系, 但这 <strong>不代表每个既约剩余类的代表元都是原根.</strong></p></blockquote><h3 id="6-2-指数"><a href="#6-2-指数" class="headerlink" title="6.2 指数"></a>6.2 指数</h3><p>指数的概念由原根引出.</p><p>g为m的原根, 给定与m互素的元素a, 则必定存在一个指数 $ \gamma $ , 使得:</p><p>$$ a \equiv g^{\gamma}(mod\space m) $$</p><p>我们称这个 $ \gamma $ 为 <strong>a对模m的以g为底的指数</strong>.</p><p>这个概念建议结合上面原根能够生成既约剩余系的性质来理解. 因为原根必定能够生成一个剩余系, 所以这个指数必定存在(这里的a就相当于一个既约剩余类的代表元).</p><hr><p>引入指数, 主要是为了这个性质:</p><p>g是模m的原根, a与m互素(即(a, m) &#x3D; 1), 则:</p><p>$$ ord_m(a) &#x3D; \frac{\varphi(m)}{(ind_{m, g}(a), \varphi(m))} $$</p><p>这性质的推论很重要.</p><p>推论即: <strong>当模m有原根时, 对于每个正除数d| $ \varphi(m) $ , 在模的一个既约剩余系中, 恰好有 $ \varphi(d) $ 个元素的阶等于d.</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%8C%87%E6%95%B0%E6%80%A7%E8%B4%A8_%E4%BE%8B.png" alt="指数性质_例"></p><p><strong>这个结论后来证明对一般循环群也是对的.</strong></p><h2 id="Chap-7-多项式"><a href="#Chap-7-多项式" class="headerlink" title="Chap.7 多项式"></a>Chap.7 多项式</h2><blockquote><p>从这一章开始, 会将讨论范围扩大到多项式, 而不仅仅限制在整数域内</p></blockquote><h3 id="7-1-多项式的概念"><a href="#7-1-多项式的概念" class="headerlink" title="7.1 多项式的概念"></a>7.1 多项式的概念</h3><p>$$ K[x] &#x3D; \lbrace a_nx^n + a_{n-1}x^{n-1} + … + a_1x+a_0|\space a_i \in K \rbrace $$</p><p>这里的K可以指代整数Z, 有理数Q, 实数R, 复数C中的任意一个.</p><p>多项式的运算此处不再赘述, 仅定义一个多项式的次数:</p><p>$$ deg\space f $$</p><p>表示多项式f(x)中最高次项的次数.</p><h3 id="7-2-多项式上的整除-不可约-唯一分解"><a href="#7-2-多项式上的整除-不可约-唯一分解" class="headerlink" title="7.2 多项式上的整除 \ 不可约 \ 唯一分解"></a>7.2 多项式上的整除 \ 不可约 \ 唯一分解</h3><p>类似于整数域, 多项式域内也可以定义整除的概念:</p><p>$$ f(x) &#x3D; g(x)h(x) $$</p><p>记作: $ g(x)|f(x) $</p><p>相似的, 如果找不到这么个 h(x) , 那么记作: $ g(x) \nmid f(x) $ .</p><hr><p>多项式整除的性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%A4%9A%E9%A1%B9%E5%BC%8F_%E6%95%B4%E9%99%A4%E6%80%A7%E8%B4%A8.png" alt="多项式_整除性质"></p><hr><p>多项式的不可约性:</p><p>$ deg\space p \geq 1$ , 并且在K[x]这个域中仅有平凡分解(就是因子只有1和它自己), 则称p(x)是K[x]内的不可约多项式.</p><p>虽然多项式的不可约性随着K所指向的域的变化而变化, 但至少有两个域中, 可以划等号:</p><p>$$ f(x)在Z[x]中不可约 \iff f(x) 在Q[x]中不可约 $$</p><hr><p>多项式在K[x]上的唯一分解:</p><p>因为有不可约多项式的存在(可以理解为 <strong>多项式域上的素数</strong> ), 因此每个多项式也必然能够通过一系列不可约多项式表示出来.</p><p>$$ f(x) &#x3D; c * p_1(x)^{e1} * p_2(x)^{e2} * … * p_t(x)^{e_t} $$</p><h3 id="7-3-不可约多项式的判别方法"><a href="#7-3-不可约多项式的判别方法" class="headerlink" title="7.3 不可约多项式的判别方法"></a>7.3 不可约多项式的判别方法</h3><p>又称爱森斯坦判别法(Eisenstein判别法)</p><p>$$ f(x) &#x3D; a_nx^n + …+ a_0 $$</p><p>f(x)是整系数多项式, 如果存在一个素数p, 使得 $ p\nmid a_n $ , $ p^2 \nmid a_0 $ , 但对于剩余的 $ i&lt;n $, 都存在 $ p|a_i $, 则f(x)在Z(Q)上均不可约.</p><h3 id="7-4-模p约化"><a href="#7-4-模p约化" class="headerlink" title="7.4 模p约化"></a>7.4 模p约化</h3><p>将多项式f(x)的所有系数化为它们的模p剩余类的代表元(就相当于模p)的过程.</p><p>为什么要引入这个概念, 因为以下这个定理是一个非常重要的判别不可约多项式的定理:</p><p>如果f(x)的模p约化的多项式 $ \overline{f} $ 在 $ Z_p[x] $ 中不可约, 那么f(x) 在 Z[x] 中一定不可约.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%A8%A1p%E7%BA%A6%E5%8C%96%E5%88%A4%E5%AE%9A%E4%B8%8D%E5%8F%AF%E7%BA%A6%E2%80%94%E2%80%94%E4%BE%8B.png" alt="模p约化判定不可约_例"></p><h2 id="Chap-8-域上的一元多项式"><a href="#Chap-8-域上的一元多项式" class="headerlink" title="Chap.8 域上的一元多项式"></a>Chap.8 域上的一元多项式</h2><h3 id="8-1-环和域"><a href="#8-1-环和域" class="headerlink" title="8.1 环和域"></a>8.1 环和域</h3><blockquote><p>就是离散中的概念, 这里不会很详细的说明.</p></blockquote><p>(R, +)构成交换群, (R, *)构成半群, 则(R, +, *)称为环, 特别的, 如果 * 运算 <strong>也满足交换律, 则称为交换环</strong> .</p><p>显然, 对于多项式环, 就是一个很典型的交换环.</p><hr><p>域:</p><p>交换环的基础上, R中的所有元素都 <strong>乘法可逆</strong> , 则称为域.</p><ul><li>$ Z_p $ 是域, 这里p是素数</li><li>$ Z_m $ , 如果m是合数, 那就不是域, 因为并非所有的元素都有乘法逆元(乘法逆元存在的前提是必须互素, 而合数并不是跟其中所有元素都互素, 比如2在 $ Z_4 $ 中就没有乘法逆元).</li></ul><h3 id="8-2-域上的一元多项式"><a href="#8-2-域上的一元多项式" class="headerlink" title="8.2 域上的一元多项式"></a>8.2 域上的一元多项式</h3><p>我们上面介绍的多项式的整除 \ 可约 \ 不可约 均可以类似的搬下来. 不过要注意, 这里的域可能会由于带余除法的存在导致一些此前不成立的性质.</p><p>显然, K[x] 上有无穷多个首项系数为 1 的不可约多项式.</p><p>同时还有定理:</p><p>设p(x)不可约, 如果 $ p(x) | f(x)g(x)…h(x) $ , 那么p(x)至少整除它们其中之一(即p(x)至少是它们其中之一的因子).</p><blockquote><p>上面这个定理, 类比整数上由很多素数乘积组成的合数.</p></blockquote><h3 id="8-3-域上多项式的不可约性判定"><a href="#8-3-域上多项式的不可约性判定" class="headerlink" title="8.3 域上多项式的不可约性判定"></a>8.3 域上多项式的不可约性判定</h3><p>上面提到了, 只要多项式在 $ Z_m $ 域上不可约, 则多项式在Z上就是不可约的.</p><p>如何判断多项式在 $ Z_m $ 上不可约?</p><hr><p>1.当m较小时, 可以用筛法:</p><p>如 $ Z_2 $上全部小于等于三次的不可约多项式:</p><ul><li>1次多项式均不可约</li><li>2次多项式可约当且仅当它有1次多项式因子 -&gt; 将全部因子两两相乘枚举出来所有可约的, 剩下的就是不可约的.</li><li>3次多项式同理.</li></ul><hr><p>2.当m较大时, 二次多项式是否可约可以通过二次剩余解决:</p><p>由于二次多项式的形式: $ f(x) &#x3D; ax^2+bx+c $</p><p>其可约代表着: $ f(x) \equiv 0(mod\space m) $ 有解.</p><p>即令 $ X &#x3D; b^2 + 4 * a * c $ ;</p><p>如果X是模m的二次剩余, 则方程有解, f(x)可约;</p><p>如果X是模m的二次非剩余, 则方程无解, f(x)不可约;</p><p>至于X是不是模m的二次剩余, 则利用Legendre符号 $ (\frac{X}{m}) $ 来进行判断.</p><blockquote><p>Legendre符号的计算见5.2</p></blockquote><h3 id="8-4-最大公因式-欧几里得算法"><a href="#8-4-最大公因式-欧几里得算法" class="headerlink" title="8.4 最大公因式 &amp; 欧几里得算法"></a>8.4 最大公因式 &amp; 欧几里得算法</h3><p>同理, 域上的多项式也有其最大公因式, 同样可以利用欧几里得算法进行求解, 只不过要把整数带余除法变更为多项式带余除法.</p><p>比如: $ (x^2-1, x^2+x-2) $ 的求解过程:</p><ul><li>$ x^2+x-2 &#x3D; 1*(x^2-1) + (x-1) $ , 转变为求 $ (x^2-1, x-1) $</li><li>$ x^2-1 &#x3D; (x+1)*(x-1) $</li><li>最大公因式: x-1;</li></ul><p>相应的, 这个过程也可以逆推回去, 跟整数的欧几里得扩展算法一个道理, 这里不再详述.</p><blockquote><p>提一下, 每次求出结果之后别忘了根据域的范围化简, 比如在 $ Z_2 $ 中, 所有的带2的项都可以直接消掉</p></blockquote><hr><p>很显然, 当两个多项式的最大公因式为1时(类比整数互素), <strong>两个多项式可以通过扩展欧几里得算法求得一个关于另一个的乘法逆元.</strong></p><p>具体步骤与整数那里完全相同:</p><ul><li>利用欧几里得算法求出 $ (f(x), g(x)) &#x3D; 1 $ ;</li><li>利用扩展欧几里得算法将1表示成两个多项式的线性组合 $ 1 &#x3D; f(x)*h(x) + g(x)*\varphi(x) $</li><li>h(x)就是该域上f(x)关于g(x)的乘法逆元, 可以表达为: $ f(x)*h(x) \equiv 1(mod\space g(x)) $</li></ul><h2 id="Chap-9-多项式同余"><a href="#Chap-9-多项式同余" class="headerlink" title="Chap.9 多项式同余"></a>Chap.9 多项式同余</h2><h3 id="9-1-多项式同余-剩余类环"><a href="#9-1-多项式同余-剩余类环" class="headerlink" title="9.1 多项式同余 \ 剩余类环"></a>9.1 多项式同余 \ 剩余类环</h3><p>我们还是要类比整数域上的同余计算, 即</p><p>$$ f(x) \equiv g(x)(mod\space m(x)) $$</p><p>只不过这里全换成了多项式.</p><p>显然, 对于m(x), 肯定也存在很多个剩余类, 但这里的剩余类的个数与域有关:<br>比如, 在 $ Z_2[x] $ 中, $ x^2+1 $ 的所有剩余类代表元:</p><p>$$ 0, 1, x, x+1, x^2 $$</p><p>由m(x)在域K[x]上的所有剩余类构成的环, 叫做模m(x)的剩余类环, 记作:</p><p>$$ K[x] &#x2F; (m(x)) $$</p><h3 id="9-2-多项式剩余类域"><a href="#9-2-多项式剩余类域" class="headerlink" title="9.2 多项式剩余类域"></a>9.2 多项式剩余类域</h3><p>当m(x)不可约时(类比到整数域中m是素数), 此时除了0所在剩余类, 其他的剩余类均可逆.</p><p>此时这个剩余类环构成了一个域.</p><blockquote><p>关于多项式的乘法逆怎么求: 类比整数域, 通过多项式域中的扩展欧几里得算法进行计算.(见8.4)</p></blockquote><h3 id="9-3-多项式版本中国剩余定理"><a href="#9-3-多项式版本中国剩余定理" class="headerlink" title="9.3 多项式版本中国剩余定理"></a>9.3 多项式版本中国剩余定理</h3><p>当遇到多项式同余方程组时, 可以用多项式版本的中国剩余定理来求解, 具体形式与整数域完全相同.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%88%E6%9C%AC%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png" alt="多项式版本中国剩余定理"></p><ul><li>先将后面的模数改为两两互素的形式</li><li>套公式, 求逆</li><li>得到通解即可</li></ul><p>至此, 信安数学基础这门课的主要内容就结束了.</p><hr><p>这篇博文就到这里.</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematical basis of Information Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blockchain</title>
      <link href="/posts/41829.html"/>
      <url>/posts/41829.html</url>
      
        <content type="html"><![CDATA[<h1 id="区块链（Blockchain）"><a href="#区块链（Blockchain）" class="headerlink" title="区块链（Blockchain）"></a>区块链（Blockchain）</h1><blockquote><p>写在前面, 本文主要针对区块链的技术原理与实际应用进行说明.<br>当前, 区块链的技术主要应用领域仍然是加密货币, 因此不可避免地本文需要对加密货币进行一些相关的说明. 但本文完全不推荐, 或推崇无谓的挖矿行为, 烦请读者不要先入为主, 理性看待本文所描述的技术.</p><p>本文主要基于 《区块链技术与应用》(北京大学 肖臻教授) 的课程进行笔记整理与内容扩展, 文中除开视频内容外,也会涉及到一些博主自己的思考, 烦请读者理性看待. 在此也附上视频链接(<a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=1&vd_source=4565edcb254cb6582d6382ac80011294">https://www.bilibili.com/video/BV1Vt411X7JF?p=1&amp;vd_source=4565edcb254cb6582d6382ac80011294</a>), 有了他们的工作, 才能让区块链这一技术为更多人所知.</p><p>在此, 对 肖臻教授 以及 北京大学相应课程组 表达诚挚的敬意与感激!</p></blockquote><h2 id="Part1-区块链是个啥？"><a href="#Part1-区块链是个啥？" class="headerlink" title="Part1. 区块链是个啥？"></a>Part1. 区块链是个啥？</h2><p>引用一段来自维基百科的定义：</p><blockquote><p><em>A blockchain is a distributed ledger with growing lists of records (blocks) that are securely linked together via <strong>cryptographic hashes</strong>.</em></p></blockquote><p>根据这段定义我们可以得知，区块链这玩意其实就是一个账本，它可以通过哈希算法将一串东西连在一起，这也是它被称作“链”的原因。</p><p>更形象的一段话：</p><blockquote><p><em>Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data (generally represented as a Merkle tree, where data nodes are represented by leaves). Since each block contains information about the previous block, they effectively form a chain (compare linked list data structure), with each additional block linking to the ones before it.</em></p></blockquote><p>意味着这玩意大小可变，后续增加进去的“块”会附带着前一个区块的信息（包括哈希值、时间戳、交易数据）。同时这个过程事实上是不可逆的：</p><blockquote><p><em>once they are recorded, the data in any given block cannot be altered retroactively without altering all subsequent blocks.</em></p></blockquote><p>同时，区块链往往和 Web3.0 联系紧密，即分布式互联网的思想。这意味着你只违规的修改自己手中的账本是无用的，因为它并没有被大众所认可，只有遵循相应的规则，才能够在所有拥有这个账本的人的文件中，添上一笔。</p><h2 id="Part2-密码学原理"><a href="#Part2-密码学原理" class="headerlink" title="Part2. 密码学原理"></a>Part2. 密码学原理</h2><p>上方引用的定义中，有一个词还挺引人注目的： <em><strong>Cryptographic hashes</strong></em>。</p><p>事实上，我们很容易想象到这个玩意的意义，要确定一个规则不易被攻破，则自然需要一个算法（也可称为密码算法），我们称呼这个密码学标准为： <em><strong>Cryptographic hash function</strong></em> ，即加密哈希函数。</p><h3 id="2-1-哈希（Hash）"><a href="#2-1-哈希（Hash）" class="headerlink" title="2.1 哈希（Hash）"></a>2.1 哈希（Hash）</h3><h4 id="2-1-1-Collision-Resistance"><a href="#2-1-1-Collision-Resistance" class="headerlink" title="2.1.1 Collision Resistance"></a>2.1.1 Collision Resistance</h4><p>我们在排序的时候其实对哈希这个玩意做过一定的说明，这里引出一个哈希中比较重要的概念：“Collision Resistance” ，中文称为该哈希函数的抗碰撞性。哈希碰撞是一个哈希算法中常有的情况，即：给出了两个不同的输入x，y，而通过哈希函数算出的函数值H(x)，H(y) 却是相同的。很显然，我们需要尽可能降低这种情况发生的可能性。</p><blockquote><p>注意：我们需要明确，哈希碰撞理论上是不可避免的，因为哈希函数的取值范围是人为框定的，而哈希函数的输入值（或者说自变量取值）可以趋近于无穷大。因此我们说的 “Collision Resistance” 要做到的是 <em><strong>没有一个非常高效的方法来人工制造哈希碰撞</strong></em> ，这个概念其实还挺重要的。我们无法阻止攻击者采取暴力破解（Brute-force）的方式来破解哈希算法，我们能做到的是尽可能拉长他们需要花费的时间，使得它们破解这个哈希算法的行为在这个时间长度的影响下趋近于无意义。</p></blockquote><p>哈希这个玩意的另一个作用在于可以保证一个文件（message，我们简称为M）不被篡改，因为这个M里面的值一旦被改了，其哈希函数值H(M)也必定会发生改变，这就被其他人所共知了。</p><p>但很遗憾的是，Collision Resistance这么重要的性质，在数学上的严谨证明是不存在的，因此我们只能凭借现实中的经验来判断一个哈希函数的抗碰撞系数高与低。</p><blockquote><p>这一点在维基百科的 <em><strong>Collision resistance</strong></em> 词条中有一段阐述：<br><em>Cryptographic hash functions are usually designed to be collision resistant. However, many hash functions that were once thought to be collision resistant were later broken. MD5 and SHA-1 in particular both have published techniques more efficient than brute force for finding collisions. However, some hash functions have a proof that finding collisions is at least as difficult as some hard mathematical problem (such as integer factorization or discrete logarithm). Those functions are called provably secure.</em><br>这段话指出很多曾经被认为非常安全的哈希函数后来被找到了比暴力破解更加高效的破解方法，也由此被攻破（如MD5, SHA-1）</p></blockquote><h4 id="2-1-2-Hiding"><a href="#2-1-2-Hiding" class="headerlink" title="2.1.2 Hiding"></a>2.1.2 Hiding</h4><p>即隐匿的，不可知的。啥意思呢，就是哈希函数的计算过程是单向的，完全不可逆的。这意味着我们可以通过一个输入x来求解一个H(x)，但通过H(x)却完全不能确定x的任何信息。</p><p>当然，我们上面提到了，由于暴力破解（Brute-force）这种方法的存在，因此完全不可逆的哈希函数是不存在的，顶到天上，我们可以把所有自变量枚举一遍，而后哪个自变量算出的哈希函数值与H(x)相同，则哪个值就是原函数值即可。</p><p>这就代表着，要写出一个尽可能 “Hidding” 的算法，首先需要输入空间（自变量取值）足够大，其次需要哈希函数值分布比较均匀。这才能尽可能加大攻击者破解这个算法的难度。</p><h4 id="2-1-3-Digital-Commitment"><a href="#2-1-3-Digital-Commitment" class="headerlink" title="2.1.3 Digital Commitment"></a>2.1.3 Digital Commitment</h4><p>这个概念也被称为 <strong>Digital Equivalent of a sealed envelope</strong></p><p>这玩意不是很好理解，东西可以看成一个电子密封信封，信封外的东西是完全公开的，而信封内的东西我们并不知道。但是我们又可以通过信封外公开的信息来确保信封内的东西没有被篡改过。</p><p>具体怎么达成的呢？<br>利用我们上方提到的 <strong>Hiding</strong> 特性，达成了通过公开内容（哈希值）无法得到私密内容（原输入）<br>利用上方的 <strong>Collision Resistance</strong> 特性，保证了只要私密内容被篡改了，则公开内容必然发生变化。</p><p>当然，上述两个目标是任何一个哈希算法都要兼顾的，但有些哈希算法的输入控件不够大，那就不满足 <strong>Hiding</strong> 这个基本要求。<br>此时我们常常采用附加随机数的方法，即在原输入后方加一个足够大的随机数，然后一并算出它们的哈希值。我们一般用 <strong>H(x||nonce)</strong> 来表示这个值。</p><ul><li>H:哈希函数</li><li>x:原输入</li><li>nonce:附加随机值</li></ul><h4 id="2-1-4-Puzzle-Friendliness"><a href="#2-1-4-Puzzle-Friendliness" class="headerlink" title="2.1.4 Puzzle Friendliness"></a>2.1.4 Puzzle Friendliness</h4><blockquote><p>注意，这个性质，是比特币（Bitcoin）中所额外要求的性质。</p></blockquote><p>维基百科上这样描述这个性质：</p><p><em>Puzzle friendliness is a property of cryptographic hash functions. Not all cryptographic hash functions have this property.</em></p><p><em>Informally, a hash function is puzzle friendly if no solution exists, which is better than just making random guesses and the only way to find a solution is the brute force method. Although the property is very general, it is of particular importance to proof-of-work, such as in Bitcoin mining.</em></p><p>其意义为这个哈希算法目前为止不存在有效预测方法（只能 Brute-force）。它要求这个哈希值的计算是不能准确预测的，即我希望得到一个特定的哈希值，我只能通过枚举自变量来确定其正确输入。</p><p>看到这里，如果此前的内容都理解了，读者大概率会碰到这么个问题： Hidding 和 Puzzle Friendliness 这俩不是一个东西吗？</p><hr><p>Difference between Hidding &amp; Puzzle Frientliness</p><p>我们给出一个哈希值：y &#x3D; H(x|r)，这里 y 是输出， x; r 是输入</p><p>对于Hiding而言，我们干的是这么一件事：</p><p>Given an output of a hash function (y), it is infeasible to find an input (x).</p><p><em><strong>Note, r is not given.</strong></em></p><p>而对于Puzzle Frientliness而言，我们干的是另一件事：</p><p>Given an output of a hash function (y) and part of the input (r), it is difficult to find an input (x).</p><p><em><strong>Note, r is given.</strong></em></p><p>所以 Hiding 希望你无法高效的找到完整的输入，而 Puzzle Frientliness 是已经给了你一部分输入，希望你无法高效的找到另一部分的输入。</p><hr><p>好的，现在我们搞明白了两个性质的区别，那这又跟 Bitcoin 有啥关系呢？</p><p>我们在这里简要的讲述一下 Bitcoin 的获取方法（即挖矿过程）</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Total%20space%20%26%20Target%20space.png" alt="Total space &amp; Target space"></p><p>如上图所见，Total space 其实就是你能取到的所有哈希值（函数值域），而 Target space 是我们的目标，我们需要找到一个特定的输入，使得这个输入在进行哈希运算后取到的值恰好处于 Target space 内。</p><p>而在 Bitcoin 中，给出的输入格式是这样的：H(Block Header)，这其中，Block Header 内有很多的 <strong>域</strong> ，这茫茫多的 域 中有一个名叫 <strong>nonce</strong> ，它就是我们能够设置的随机数。</p><p>挖矿的过程就是通过 Brute Force 的方法，持续不断的取随机数，算哈希，并找到了符合要求的哈希值的过程。而我们上面说的 Puzzle Friendliness 这个性质，就意味着这个过程没有捷径，只能暴力求解。</p><p>这种没有捷径的过程能够提供 <strong>工作量证明</strong> ，即 <strong>Proof of work</strong> ，代表着你确实做出了足够的工作量来得到这样一个输入。</p><h4 id="2-1-5-Difficult-to-Solve-Easy-to-Verify"><a href="#2-1-5-Difficult-to-Solve-Easy-to-Verify" class="headerlink" title="2.1.5 Difficult to Solve &#x2F; Easy to Verify"></a>2.1.5 Difficult to Solve &#x2F; Easy to Verify</h4><p>通过上面的性质，我们很容易就能理解这个条目在讲什么。</p><p>我寻找一个有效的随机数 nonce 的过程是非常难的，需要大量的工作量。但我只要找到了这个 nonce ，别人要验证这个 nonce 是否正确是很容易的，因为验证过程仅仅需要一次哈希运算即可</p><hr><p>额外提一嘴：</p><p>SHA-256 是 Bitcoin 中所采用的哈希算法。其全称为 <strong>Secure Hash Algorithm</strong> 。</p><hr><h3 id="2-2-签名（Digital-Signature）"><a href="#2-2-签名（Digital-Signature）" class="headerlink" title="2.2 签名（Digital Signature）"></a>2.2 签名（Digital Signature）</h3><h4 id="2-2-1-Symmetric-Encryption-Algorithm"><a href="#2-2-1-Symmetric-Encryption-Algorithm" class="headerlink" title="2.2.1 Symmetric Encryption Algorithm"></a>2.2.1 Symmetric Encryption Algorithm</h4><p>即 <strong>对称的加密体系</strong> ，也称 <strong>Symmetric-key algorithm</strong> 。</p><p>这个体系的目的很明确，在于加密，保证信息传输过程中不被窃取或篡改。</p><p>它采用的方法是：收发两端采用相同（或者经过简单的转化）的密钥来进行加密 &#x2F; 解密操作。</p><p><em>Symmetric-key algorithms are algorithms for cryptography that use the same cryptographic keys for both the encryption of plaintext and the decryption of ciphertext. The keys may be identical, or there may be a simple transformation to go between the two keys.</em><br>—— Wikipedia</p><p>这种方法的前提在于有一个安全的渠道，能够将密钥安全的由 发送方 送给 接收方。这也是对称加密体系的弱点之一，密钥的分发非常不方便。</p><h4 id="2-2-2-Asymmetric-Encryption-Algorithm"><a href="#2-2-2-Asymmetric-Encryption-Algorithm" class="headerlink" title="2.2.2 Asymmetric Encryption Algorithm"></a>2.2.2 Asymmetric Encryption Algorithm</h4><p>即 <strong>非对称的加密体系</strong> ，也称 <strong>Asymmetric cryptography</strong> 。</p><p>非对称的加密体系采用了一对钥匙，即 <strong>公钥</strong> 和 <strong>私钥</strong> 。加密使用公钥，而解密使用私钥。在信息传输时，发送方 利用 <strong>接收方的公钥</strong> 来加密信息，并传给接收方，而后接收方再用自己的私钥来解密发送方传来的信息。</p><p>显然，公钥是公开的，而私钥必须要保管好，自己留着。</p><p>通过这个模式，解决了对称加密体系中密钥分发过于繁琐的问题。</p><h4 id="2-2-3-与-Bitcoin-的关联？"><a href="#2-2-3-与-Bitcoin-的关联？" class="headerlink" title="2.2.3 与 Bitcoin 的关联？"></a>2.2.3 与 Bitcoin 的关联？</h4><p>在 Bitcoin 中，由于其采用 <strong>去中心化</strong> 的思想，因此是没有所谓的 银行 来管理你的账户的，一个(公钥；私钥)对就是一个账户。</p><p>我们形象的理解一下，公钥相当于你的账号，这是可以公开的，别人给你转账必须要得知你的公钥。而私钥相当于你的密码，只有知道你的密码的人才能够取出这个账户上的钱。</p><p>但是问题来了， Bitcoin 中好像并不需要这个对？因为它的哈希算法是完全公开的。</p><p>这就要引出这一主题的概念： <strong>签名</strong> 。</p><h4 id="2-2-4-签名"><a href="#2-2-4-签名" class="headerlink" title="2.2.4 签名"></a>2.2.4 签名</h4><p>签名这一概念是为了保证一笔交易是真正由 <strong>署名的发起方</strong> 发起的，而不是有人冒名顶替的。</p><p>那这里如何保证这个发起方就是我呢？答案是我利用 私钥 来进行签名，而后所有人看到这笔交易之后都有权利利用我所公开的公钥来验证这个签名。</p><p><em>Two main properties are required:<br>First, the authenticity of a signature generated from a fixed message and fixed private key can be verified by using the corresponding public key.<br>Secondly, it should be computationally infeasible to generate a valid signature for a party without knowing that party’s private key. A digital signature is an authentication mechanism that enables the creator of the message to attach a code that acts as a signature.</em><br>—— Wikipedia</p><p>在 Bitcoin 中，一般是先对 message 进行哈希，而后对产生的哈希值进行签名。</p><h2 id="Part3-数据结构"><a href="#Part3-数据结构" class="headerlink" title="Part3. 数据结构"></a>Part3. 数据结构</h2><h3 id="3-1-哈希指针（Hash-Pointers）"><a href="#3-1-哈希指针（Hash-Pointers）" class="headerlink" title="3.1 哈希指针（Hash Pointers）"></a>3.1 哈希指针（Hash Pointers）</h3><p>指针这玩意我们很熟悉了，在C和C++里面用的很多。</p><p>哈希指针概念与其类似，但额外加了点东西。它不仅要存储一个结构体的地址，同时要存储 <strong>这个结构体对应的哈希值</strong> ，我们用 <strong>H()</strong> 来表示一个哈希指针。</p><p><em>A regular pointer gives you a way to retrieve the information. A hash pointer will let us ask to get the information back and verify that the information hasn’t changed. So a hash pointer tells us where something is and what it’s value was.</em></p><p>上面这段话很好的描述了哈希指针的好处，它不光可以获得信息存储的位置，同时也可以检测存储的信息是否遭到了修改。（具体方式可以回顾此前的 <strong>密码学原理</strong> 部分）</p><p>为什么我们要提到哈希指针呢？我们需要引出 <strong>区块链</strong> 这个重要内容。</p><h3 id="3-2-哈希链表"><a href="#3-2-哈希链表" class="headerlink" title="3.2 哈希链表"></a>3.2 哈希链表</h3><p>字如其名，区块链本身是由一个个区块组成的链表。但这个链表有其特殊之处。其中一个最显著的特点，区块链中使用的指针是哈希指针。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Blockchain_chain.png" alt="HashChain"></p><p>我们这里着重强调几个概念：</p><ul><li>Genesis Block: 即起始区块</li><li>H(): 后续每个区块中都会有的哈希指针，这个哈希指针的哈希值是通过对它前面一整个区块的 <strong>所有内容（包括里面的哈希指针）</strong> 运算得到的。</li><li>Most recent Block: 整个链条的最后一个区块，这个区块的哈希指针被保存在系统中。</li><li>Tamper-evident log: 区块链能够实现的一个性质，我们能够看出，这一整个链条中无论哪个块的内容被篡改了，都会导致最终存储在系统内的哈希值发生更改。这代表着我们只要 <strong>记住最后的这个哈希值</strong> ，就能够检测 <strong>一整个链表</strong> 是否被篡改过。</li></ul><p>这种存储方式还有个好处：区块链是很长的，因此一个节点内不可能存储一整个链表的内容，这就表示如果我需要一个我没有保存的节点（我们称之为 节点1 ）的内容，则我需要向别的保存过 节点1 的节点（我们称之为 节点2 ）索取相应的信息。而哈希指针能够保证 节点2 给我的内容是正确的，而非经过篡改的。</p><blockquote><p>我们需要额外提一嘴，哈希链表 <strong>不能是循环链表</strong> ，因为如果带有环状结构，则会出现循环依赖，一个节点被篡改了，最终哪个节点的哈希值都定不下来。</p></blockquote><h3 id="3-3-Merkle-Tree-Binary-hash-Tree"><a href="#3-3-Merkle-Tree-Binary-hash-Tree" class="headerlink" title="3.3 Merkle Tree (Binary hash Tree)"></a>3.3 Merkle Tree (Binary hash Tree)</h3><p>我们应该比较熟悉 Binary Tree，就是普通的二叉树。</p><p>这里我们看到括弧里面的名字应该能想个大概，即哈希二叉树。</p><p><em>A hash tree, also known as a Merkle tree, is a tree in which each leaf node is labeled with the cryptographic hash of a data block, and each non-leaf node is labeled with the cryptographic hash of its child nodes’ labels.</em></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Merkle%20Tree.png" alt="Merkle Tree"></p><p>我们还是说几个概念：</p><ul><li>Data block: 即 <strong>数据块</strong> ，指整个 Merkle Tree 最底层的节点。</li><li>Hash block: 即 <strong>指针块</strong> ，指 Merkle Tree 上层的节点，每个节点内储存了其左右孩子的哈希指针。</li><li>Root hash: 即 <strong>根哈希值</strong> ，指对整个 Merkle Tree 最上面的节点取哈希，保存在系统中。</li></ul><p>我们可以发现，与哈希链表很相似的是，只要整个 Merkle Tree 中哪一个节点被篡改了，最上面我们保存的哈希值就会发生改变。这也可以让我们很方便的得知整个数据是否遭到过篡改。</p><hr><p>在Bitcoin中，每个区块之间利用哈希指针连接在一块，而每个区块内所包含的交易则通过一颗Merkle Tree进行组织。而每个区块内的 Block Header 内存放着这棵 Merkle Tree 的 Root Hash ；每个区块内的 Block Body 中存放着各项交易的交易记录。</p><hr><h3 id="3-4-Merkle-Proof（Proof-of-Membership-Proof-of-Inclusion）"><a href="#3-4-Merkle-Proof（Proof-of-Membership-Proof-of-Inclusion）" class="headerlink" title="3.4 Merkle Proof（Proof of Membership &#x2F; Proof of Inclusion）"></a>3.4 Merkle Proof（Proof of Membership &#x2F; Proof of Inclusion）</h3><p>我们说回 Merkle Tree 。</p><p>Merkle Tree 的一大作用是提供 <strong>Merkle Proof</strong> 。这个玩意的意思是我需要证明 <strong>某一笔交易确确实实的发生了</strong> 。</p><p>在Bitcoin中，节点被分为 <strong>全节点</strong> 与 <strong>轻节点</strong> ，全节点中包含了 Block Header 与 Block Body，这使得查询某一笔交易是否发生变得十分可行。</p><p>但轻节点中只保存了 Block Header（即只保留了哈希值），我们应该怎么证明这笔交易发生了呢？</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Merkle%20Proof.png" alt="Merkle Proof"></p><p>具体过程是这样：</p><ul><li>首先，这个轻节点向某一个全节点发送请求，并附上它需要查询的交易位置（即图中的黄色块）。</li><li>此后，这个全节点计算出一条从这个底层交易节点一直连接到 Merkle Tree 的根节点的路径，这一条路径叫做 <strong>Merkle Proof（即图中红色箭头附加的路径）</strong> 。</li><li>全节点将路径上 <strong>未涉及到的全部哈希值（即图中红色的哈希值）</strong> 发送给轻节点。</li><li>轻节点接收到这些哈希值，从底层开始进行哈希运算【算出 <strong>指定交易的哈希（即第二层中的蓝色哈希值）</strong> -&gt; 与第二层的红色哈希值 <strong>（在第三步中由全节点发给轻节点）</strong> 拼接起来，再次进行哈希运算，算出再上一层的蓝色哈希 -&gt; 以此类推，直到 Merkle Proof 路径到头后，最后求一次哈希，与自己的 Block Header 中的内容相比较，判断出这笔交易是否发生过。</li></ul><p>上面这个过程，就是从底向上进行验证的一个过程。</p><p>我们回头捋一下，这个从下向上的过程，时间复杂度是多少？<br>不难看出，是log(N)。</p><hr><p>既然说了 Proof of membership ，那读者有没有想过，是否存在一种证明 Proof of non-membership （即证明某个交易并不存在）的方法？</p><p>有一种比较简单的证明方法是直接将整棵树发给轻节点，让轻节点验证一下这棵树没错，而后就完成了证明。但很显然，这种方法的时间复杂度是线性的。</p><p>我们需要申明，如果我们 <strong>对叶节点的排列不做任何假设</strong> 的话，是没有更高效的方法的。</p><p>但当我们能够对叶结点的排列做假设的时候，这个问题有一个很巧妙的解法。</p><p>我们假设叶节点是按照它们的哈希值进行有序排列的，现在要证明一笔交易（我们称之为交易1）并不存在。</p><ul><li>我们先对 交易1 求一个哈希值，找到如果它在这棵 Merkle Tree 中时应当所在的位置。并根据这个位置找到其两侧的交易（我们称之为 交易0 和 交易2 ）。</li><li>而后轻节点向全节点发出请求，进行 交易0 与 交易2 的 Merkle Proof ，如果最终获得的结果是正确的，则说明 交易0 与 交易2 之间并没有插入一个 交易1 ，这就证明了 交易1 其实是不存在的。</li></ul><p>上面这个过程通过两次 Merkle Proof 达成了 Proof of non-membership ，时间复杂度仍然是 log(N)。其代价是必须要对叶子节点（交易）进行基于哈希值的排序。</p><p>我们称这种针对哈希值排序的 Merkle Tree 为 <strong>Sorted Merkle Tree</strong> 。</p><p>在Bitcoin中，并没有采用 Sorted Merkle Tree ，因为 Bitcoin 中并没有 Proof of non-membership 的需要。</p><hr><h2 id="Part4-共识协议"><a href="#Part4-共识协议" class="headerlink" title="Part4. 共识协议"></a>Part4. 共识协议</h2><h3 id="4-1-Double-spending-attack"><a href="#4-1-Double-spending-attack" class="headerlink" title="4.1 Double spending attack"></a>4.1 Double spending attack</h3><p>我们先来考虑一下数字货币与实体货币的区别：</p><p>实体货币很简单，一手交钱，一手交货。因此交易双方只需要考虑这个货币究竟是不是真的，即现实中各种验钞机、货币上的各种防伪证明干的事情。</p><p>但数字货币不太一样。我们之前提到过非对称的密码体系（即公私钥体系），通过在货币上利用私钥签名，可以保证每个人都能通过公钥来对货币的真实性进行验证（如果读者对这个点不熟悉，请返回2.2.4）。但我们需要明确，数字货币是可以 <strong>被复制的</strong> ，如果仅仅通过公私钥进行保护，那不能阻止某些人无限复制手中的这一份货币。因此这显然不能作为完整的货币体系。</p><p>我们称这种问题为 “双花攻击” ，即 <strong>double spending attack</strong> 。</p><p>这个问题在中心化的系统中也不算难解决，给每一份数字货币一个唯一的编号，并让唯一的一个中心机构维持一个数据库，里面记录一下当前这份货币在谁手里。双花问题看似很方便的被解决了。</p><p>但很遗憾，我们需要的数字货币是 <strong>分布式的</strong> ，是 <strong>去中心化的</strong> 。</p><p>由此，我们转变一下思路，需要思考两个主要的问题：</p><ul><li>在去中心化的货币系统中，谁有权力发行数字货币？</li><li>在去中心化的货币系统中，如何保证一个交易的有效性？</li></ul><h3 id="4-2-交易有效性保证"><a href="#4-2-交易有效性保证" class="headerlink" title="4.2 交易有效性保证"></a>4.2 交易有效性保证</h3><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Hashchain%26double%20spent.png" alt="hashchain&amp;double_spend"></p><p>在Bitcoin中，存在两种哈希指针：</p><ul><li>区块指针</li><li>交易源指针</li></ul><p>其中，区块指针与我们此前讲解的区块链大相径庭，它负责指向上一个区块。</p><p>而交易源指针需要指向这笔交易的货币来源。比如：上图中A希望向B和C各转5个虚拟货币，则需要有一个指针指向A这10个虚拟货币的来源。</p><p>通过交易源指针，能够很好的防范双花问题，假设A再次尝试向外转账时，系统会进行交易回溯，从而查询到A手中的货币已经被花出去了，进而阻止这一次交易的发生。</p><p>好了，基本的原理我们搞明白了，我们现在需要详细的考虑一下一次交易的过程。</p><p>我们就以 A转给B 5个虚拟货币为例：</p><ul><li>A需要知道B的地址（也可以理解为账号），在Bitcoin中，这个账号是通过对B的公钥进行哈希，此后再进行一系列处理得到的。</li><li>B要验证这笔交易是否合法，因此需要通过A的公钥验证A的签名，意味着B也需要知道A的公钥。</li><li>进一步思考，Bitcoin中全部用户都有权利验证一个交易的合法性（因为这是个去中心化的系统，这一步交易需要得到全部节点的认可），因此其实所有节点都需要知道A的公钥。</li></ul><p>我们得知了上述三点要求后，需要引出区块链中每一笔交易的 <strong>输入与输出</strong> 。</p><p>其中，输入要求给出两点：</p><ul><li>发起交易者虚拟货币的来源（即交易源指针）</li><li>发起交易者的公钥</li></ul><p>输出要求给出一点：</p><ul><li>收款人公钥的哈希</li></ul><hr><p>这里可能会有读者想到些安全问题，因为一个交易的公钥是由交易的发起人自己给出的，那如果B想要冒充A，但他通过自己的私钥进行 <strong>B的签名</strong> 并附上了 <strong>B的公钥</strong> ，伪造了一个 <strong>由A向B的交易</strong> 呢，应该如何判别出这种窃取行为？</p><p>我们可以发现输入的要求中不仅要求一个公钥，还要求虚拟货币的来源。而这个来源也必定是一个区块，即 <strong>它也会有相应的输出</strong> 。</p><p>我们想想这个输出是什么？</p><p>这个输出必定是 <strong>A公钥的哈希</strong> 。</p><p>因此，防范上面的那种安全问题，只需要保证 <strong>这笔交易中提供的公钥</strong> 与 <strong>这笔交易中货币来源提供的输出（公钥哈希）</strong> 相匹配 即可。</p><p>（这地方有点绕，读者可以对着上面的图示比划比划）</p><hr><h3 id="4-3-区块"><a href="#4-3-区块" class="headerlink" title="4.3 区块"></a>4.3 区块</h3><h4 id="4-3-1-Block-Header-Block-Body"><a href="#4-3-1-Block-Header-Block-Body" class="headerlink" title="4.3.1 Block Header &amp; Block Body"></a>4.3.1 Block Header &amp; Block Body</h4><p>我们上面提到的案例，是一个非常简化的样例，因为我们假设每个区块内仅仅存在一个交易。显然，现实中一个区块内有很多交易，它们被存储在Merkle Tree中（关于这部分的内容，读者可以前往3.3进行回顾）。</p><p>我们还讲了，一个区块中一般包括区块头（Block Header）与区块主体（Block Body）。下面，我们详细给出其中的内容：</p><p>Block Header需要包括以下内容：</p><ul><li>Version: 使用的比特币协议版本</li><li>Hash of previous Block Header: 指向前一个区块头的哈希指针</li><li>Merkle Root Hash: 当前区块Merkle Tree根节点的哈希值</li><li>Timestamp: 当前区块的时间戳，表示当前区块被挖出来的时间</li><li>Target: 难度目标阈值</li><li>Nonce: 随机数</li></ul><p>Block Body需要包括以下内容：</p><ul><li>Transaction list: 交易列表</li></ul><p>这其中，最后两个域是与挖矿相关的，读者可以回顾 2.1.4 部分的内容进行回顾，这里先不详述。</p><p>Version 的含义很简单明了。</p><p>Hash of pervious Block Header 需要强调一下，它指的是前一个 <strong>区块头</strong> 的哈希指针，并不包含区块主体。至于区块主体是否被篡改，则通过每个头中的 Merkle Root Hash 来进行保证。</p><h4 id="4-3-2-Full-node-Light-node"><a href="#4-3-2-Full-node-Light-node" class="headerlink" title="4.3.2 Full node &amp; Light node"></a>4.3.2 Full node &amp; Light node</h4><p>在此之上，我们进一步明确一个在 3.4 中提到过的概念，即 <strong>全节点(Full node)</strong> 与 <strong>轻节点(Light node)</strong> ，全节点又称为 <strong>Fully validating node</strong> ，轻节点又称为 <strong>Light weight node</strong> 。</p><p>全节点与轻节点的区别在于是否存储了 Block Body 中的内容。</p><p>因此，一般而言，轻节点是无法仅仅依靠自己来进行各种验证的，它需要向全节点进行查询请求，依靠全节点给出的各种信息来辅助验证。但由于轻节点比较节省空间，因此一个区块链内大部分的节点其实都是轻节点。</p><p>我们这里给出一个更合理，更详细的区块链图：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Blockchain_detailed.png" alt="Blockchain_detailed"></p><h3 id="4-4-Distributed-Consensus"><a href="#4-4-Distributed-Consensus" class="headerlink" title="4.4 Distributed Consensus"></a>4.4 Distributed Consensus</h3><p>该概念即 <strong>分布式共识</strong> 。由于区块链是个分布式账本，那这个账本应该如何决定一个区块 <strong>是否应该写入</strong> ，以及 <strong>按照什么顺序写入</strong>，又应当如何保证 <strong>各个本地系统上能够保存相同的一个链条</strong> ？这就是区块链内需要解决的分布式共识的问题。</p><p><em>A fundamental problem in distributed computing and multi-agent systems is to achieve overall system reliability in the presence of a number of faulty processes. This often requires coordinating processes to reach consensus, or agree on some data value that is needed during computation.</em><br>—— Wikipedia</p><hr><p>这里得稍微提一嘴分布式共识的一些知识，有一个理论叫 <strong>CAP Theorem</strong> ，描述了分布式系统的三个希望能够达成的性质，但很可惜，三者之中至多只能选择两个。</p><p>这三个性质为：</p><ul><li>Consistency: 一致性 (Every read receives the most recent write or an error.)</li><li>Availability: 可用性 (Every request receives a (non-error) response, without the guarantee that it contains the most recent write.)</li><li>Partition tolerance: 分区可用性 (The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes.)</li></ul><p><em>In database theory, the CAP theorem, also named Brewer’s theorem after computer scientist Eric Brewer, states that any distributed data store can provide only two of the three guarantees.</em><br>—— Wikipedia</p><p>这个理论其实挺重要，但在区块链的文章中，我们不会过于详述。</p><hr><h3 id="4-5-Consensus-in-Bitcoin"><a href="#4-5-Consensus-in-Bitcoin" class="headerlink" title="4.5 Consensus in Bitcoin"></a>4.5 Consensus in Bitcoin</h3><p>在Bitcoin中，我们需要基于一个最基本的假设，即 <strong>有恶意的节点永远是少数</strong> 来实现分布式共识。</p><h4 id="4-5-1-Sybil-Attack"><a href="#4-5-1-Sybil-Attack" class="headerlink" title="4.5.1 Sybil Attack"></a>4.5.1 Sybil Attack</h4><p>一种实现分布式共识的方法是基于所有节点的投票结果，即每个节点都进行对当前区块的合法性验证，如果判断它合法则投赞成票，如果赞成票过半，将当前区块写入链中。</p><p>这种方法是有很明确的破解方法的，我们此前提及过（2.2.3），在Bitcoin中，一个(公钥, 私钥)对就是一个账户，那恶意节点完全可以生成茫茫多的恶意账户，对于自己希望加入的非法区块（illegal block），让自己能够控制的所有恶意账户全部投赞成票。如果这些恶意账户数目足够多，则可以轻易破解这种投票机制。</p><p>我们称呼这种攻击方式为 <strong>Sybil Attack(女巫攻击)</strong> 。</p><p><em>Sybil attack is a type of attack on a computer network service in which an attacker subverts the service’s reputation system by creating a large number of pseudonymous identities and uses them to gain a disproportionately large influence.</em><br>—— Wikipedia</p><p>很显然，仅仅依据账户数目来进行简单投票的方案，是不行的。</p><h4 id="4-5-2-算力优先"><a href="#4-5-2-算力优先" class="headerlink" title="4.5.2 算力优先"></a>4.5.2 算力优先</h4><p>简单的投票方案不成立，并不能意味着我们就要放弃投票。</p><p>在Bitcoin中，采取的是一种很巧妙的限制方式。</p><p>我们此前提及，挖矿时需要通过取nonce值，计算nonce与Block Header其他部分拼接过后的哈希值来决定我们是否找到了正确的随机数。显然，这个计算过程需要大量的算力，而当我们找到了正确的随机数后，我们就得到了 <strong>记账权</strong> ，即 <strong>向Bitcoin这个去中心化的账本中写入下一个区块的权力</strong> 。</p><p>显然，算力越强大，每秒钟能够尝试的nonce数目就越多（我们称这个数目为 <strong>Hash Rate</strong>），得到正确nonce的可能性自然越高，也就意味着我们有更大的权值来 “记账” 了。</p><p>这个机制在Bitcoin乃至Blockchain中都是极其重要的，因为它保证了，只要一个区块链的大部分Miner都是 <strong>诚实的</strong> ，那么这一整个区块链的安全性就能得到相当程度上的保证。</p><hr><p>当然，我们算出了正确的nonce，还是需要接受其他用户的验证的。因此我们需要将这个区块发布出来，让其他用户来检查我的nonce是正确的，并且我放进去的交易列表都是合法的。</p><hr><h4 id="4-5-3-Forking-Attack"><a href="#4-5-3-Forking-Attack" class="headerlink" title="4.5.3 Forking Attack"></a>4.5.3 Forking Attack</h4><p>读者大概第一次读到这里还是一头雾水，上面这个原则看起来还是不十分严谨。比如：我如果挖出的区块不在主干上，额外挖到一个小分支呢？这账本不久分叉了吗？</p><p>事实上，有这种攻击方式，即 <strong>Forking Attack(分支攻击)</strong> ，通过专门在Bitcoin这个帐本上附加分支来达到对交易的回滚目的。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Forking%20Attack.png" alt="Forking Attack"></p><p>我们可以看到，图中的链条出现了一条全新的分支，而显然，这条分支上 <strong>A-&gt;C的这笔交易与原链条④上A-&gt;B的交易是冲突的</strong> ，但在写入区块时，如果不加限制，它们都会被判定为合法的，因为 <strong>两者都能通过回溯查询到有②中D-&gt;A的交易发生</strong> 。</p><p>这种情况显然是不应当发生的，它相当于对已经发生过的交易进行了一次 <strong>回滚</strong> 。因此Bitcoin中有相应的规定，称最长的那个链条为 <strong>Longest valid chain(最长合法链)</strong> ，并人为限制，每次新写入Bitcoin中的区块，都应当是在扩展最长合法链。</p><hr><p>当然，还有一种合法的分叉可能性出现，即两个用户同时发现了正确的区块，并立即发布了出来，在这种情况下，其他用户都将暂时保留这两个区块，使得区块链变成下面这个样子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Forking%20valid.png" alt="Valid Forking"></p><p>这时，处理方法就是看谁快了，Block1 与 Block2 的哪个区块的下一个区块被先挖出来，系统就保留哪个。而另一个区块则被舍弃，被称为 <strong>Orphan Block</strong> 。</p><hr><h3 id="4-6-Block-Reward"><a href="#4-6-Block-Reward" class="headerlink" title="4.6 Block Reward"></a>4.6 Block Reward</h3><p>我们说完了记账权的争夺规则，但问题来了，这玩意又费电又费资源， <del>（甚至搞得很多人为了这件事疯狂的去挖矿）</del> ，图个啥，就图在那个账本里面记一笔嘛？</p><p>不知道读者还记不记得在Part4最开始提及的两个问题，我们现在只解决了第二个，即如何保证交易有效性。</p><p>现在要明确的，就是第一个问题，即 <strong>谁有权力发行货币</strong> 。</p><p>在Bitcoin中，发行新的比特币，只有唯一的方法，称为 <strong>Coinbase transaction</strong> ，除此之外的任何交易，都是将已有的比特币从一个账户上转到另一个账户上的过程。</p><p>相对应的，这个产生速度是在浮动的，在最开始的阶段，甚至达到了 50BTC per Block 。根据协议中的规定，每当21万个区块被发现过后，就需要将区块奖励减半。目前，这个产生速度已经降低至 3.125 BTC per block （May, 2024）。</p><p>在这里，还需要明确一点，对于Bitcoin而言，其产生新区块的速度为 <strong>10 minutes per block</strong> ，因此我们可以大概算出 Block Reward 减半一次所需的时间： <strong>大约4年左右</strong> 。</p><p>我们可以通过 <a>blockchain.info</a> 这个网站对于当前各类虚拟货币的情况进行查询，这里给出一个区块的例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Block%20Example%28%23842278%29.png" alt="Block Example #842278"></p><p>同样，区块内所有的交易都会被公示：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Transaction%20Example.png" alt="Transaction Example"></p><p>有兴趣的读者可以自己前往上面提到的网站上看一看。</p><h2 id="Part5-实现"><a href="#Part5-实现" class="headerlink" title="Part5. 实现"></a>Part5. 实现</h2><p>经过上面的描述，我们应该能够理解Bitcoin的大体原理，也能明白这是一个以交易为基础（ <strong>Transaction-based Ledger</strong> ）的虚拟货币类型。</p><hr><p>这里还需要提一下，另一种虚拟货币，以太坊(Ethereum)采用的并非与比特币相同的 交易基础模型 ，而是以账号为基础的另一种类型，我们称之为 <strong>Account-based Ledger</strong> 。这种模型我们会在后文中提及。</p><hr><h3 id="5-1-UTXO"><a href="#5-1-UTXO" class="headerlink" title="5.1 UTXO"></a>5.1 UTXO</h3><p>我们先介绍一个概念， <strong>UTXO</strong> ，即 <strong>Unspent Transaction Output</strong> 。</p><p><em>In cryptocurrencies, an unspent transaction output (UTXO) is a distinctive element in a subset of digital currency models. A UTXO represents a certain amount of cryptocurrency that has been authorized by a sender and is available to be spent by a recipient.</em><br>—— Wikipedia</p><p>简单的来讲，Bitcoin中具有很多的交易（包括 转账交易 以及 铸币交易），这一堆交易中，有些交易的交易额 <strong>已经被接收方再次花出去了</strong> ，而另一些交易额 <strong>仍然可被接收方所支配</strong> 。我们称这些还未被花出去的交易额所构成的集合为 <strong>UTXO</strong> 。</p><p>UTXO中的每一个条目，都需要给出两部分内容：</p><ul><li>产生当前交易的哈希值</li><li>这个输出是当前交易中的第几个输出</li></ul><p>写到这可能有点产生歧义，我们给个图：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/UTXO%20Example.png" alt="UTXO Example"></p><p>我们看到，在第二个区块中，A转给了B &#x2F; C 各 5BTC ，而B在这之后将其花掉了，但C并未花掉。因此B在UTXO中就不存在一个条目来记录它（或者说，是原先记录的那个条目被删掉了），而对于C则存在一条UTXO（如图中红色框内所示）。</p><p>上述例子说明，每一次交易，都意味着删除一部分UTXO，同时又新产生一部分UTXO。同时，对于整个UTXO而言，总输入应当始终等于总输出，即 <strong>Total inputs &#x3D; Total outputs</strong> 。</p><p>当然，在现实状况中，Total inputs &gt;&#x3D; Total outputs 的情况要更常见一些。这是由于区块链本身是个账本，而一笔笔交易（一条条账目）想要放入这个账本的话，是应当交一笔手续费的。而这笔手续费，就交给当前区块的记账权拥有者（把这个区块挖出来的人）。</p><p>这个机制被称作 <strong>Transaction fee</strong> 。</p><p><em>A Blockchain transaction fee is an amount that a user has to pay to the miners to have their transaction validated on the Blockchain.</em></p><p>到此，我们已经明确了Bitcoin中除转账外获得BTC的两种方式：即 <strong>Block Reward</strong> 以及 <strong>Transaction fee</strong> 。</p><hr><p>读者可能会疑惑于后续的手续费应该如何收取？难不成再单开一个交易嘛？</p><p>事实上， Transaction fee 是与 Block Reward 一同通过区块中的铸币交易（Coinbase Transaction）一并转给记账权拥有者的。</p><p>在Bitcoin中，所有没有被确认的交易会放在一个单独的池子里面（暂且按照池子来理解吧），这个池子叫做 <strong>mempool</strong> ，而后一个矿工挖出了一个区块，系统会挑选合法的交易放入这个区块中（交易数额越大，优先级越高），而后再将这个区块发布出来，供所有人验证。</p><p>因此，当这个区块被发布出来后，意味着里面有什么交易已经定下来了，因此总共的 Transaction fee 也就被算出来了。</p><hr><hr><p>为什么要维护这个UTXO呢，这与我们此前在4.1 &#x2F; 4.2中所说的 对于Double Spending Attack的防范工作有关。</p><p>每次交易之前，都需要查询这个UTXO，确保发起交易者的账户上有相应的金额，即UTXO中有相应的条目。否则这笔交易就不会通过。显然，有UTXO的存在，可以快速检测Double Spending。</p><p>由于Bitcoin是个分布式系统，因此UTXO的维护是每一个全节点的任务（应该还记得这个概念吧）。</p><hr><h3 id="5-2-难度升格"><a href="#5-2-难度升格" class="headerlink" title="5.2 难度升格"></a>5.2 难度升格</h3><h4 id="5-2-1-Block-Header的数据结构"><a href="#5-2-1-Block-Header的数据结构" class="headerlink" title="5.2.1 Block Header的数据结构"></a>5.2.1 Block Header的数据结构</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public:    &#x2F;&#x2F; header    int32_t nVersion;    uint256 hashPrevBlock;    uint256 hashMerkleRoot;    uint32_t nTime;    uint32_t nBits;    uint32_t nNonce;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码块给出了Bitcoin中Block Header所包含的数据类型。</p><h4 id="5-2-2-如何提升难度？"><a href="#5-2-2-如何提升难度？" class="headerlink" title="5.2.2 如何提升难度？"></a>5.2.2 如何提升难度？</h4><p>显然，在当前这个时代，算力膨胀，挖矿者的数目也膨胀，这代表着仅仅调整一个32位无符号的随机数nonce所带来的挖矿难度已经远远不够了。</p><p>Bitcoin需要尽可能控制挖矿难度使得每个新区块的发布时间在10分钟左右。因此，人们找到了另一个可以更改的内容，即上述结构中的 <strong>hashMerkleRoot</strong> 。</p><p>这玩意的数据类型叫 <strong>uint256</strong> 。</p><p><em>uint256 is an unsigned integer that can hold a maximum value of 2^256-1</em></p><p>那问题来了，这玩意不是MerkleTree的根节点哈希吗，怎么改？</p><p>我们应该还记得，Bitcoin中有一种交易是在区块被挖出来的时候由获得记账权的人自动得到的，即 <strong>铸币交易</strong> （详见4.6）。这个交易内有一个单独的域被称为 Coinbase 域, 这个域内想些啥都无所谓, 而铸币交易也被包含在区块内的MerkleTree中, 因此可以通过进一步调整 Coinbase 域中的值来划定 hashMerkleRoot.</p><p>我们通常称呼这个 Coinbase 域内可调整的部分为 extra nonce, 在历史上, 它曾经取过 $ 2\space bytes &#x2F; 4 \space bytes &#x2F; 8 \space bytes $</p><p>因此，我们可以要求挖矿者在需要额外调整 extra nonce 的前提下来提高挖矿者的操作难度，进而一定程度上控制区块生成时间。</p><h3 id="5-3-交易合法性验证"><a href="#5-3-交易合法性验证" class="headerlink" title="5.3 交易合法性验证"></a>5.3 交易合法性验证</h3><p>我们在 (4.2) 中提及，一笔交易合法需要提供交易发起者的公钥，以及此前的货币来源（一笔交易）的输出。前者就是一个公钥，后者则是一个公钥哈希。只需要保证二者配对，交易发起者再利用自己的私钥进行签名，即可保证这笔交易是合法的。</p><p>具体这个公钥和公钥哈希该如何配对呢？</p><p>在Bitcoin的区块公示中，每一笔交易的输入与输出都会有一个脚本，在我们上文提到的网站 <a>blockchain.info</a> 中长这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Inputscript.png" alt="Inputscript"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Outputscript.png" alt="Outputscript"></p><p>当然，上面两个图片仅仅是举个例子，并不是配对的一组。</p><p>具体验证时，会将两个脚本（一个输入脚本，另一个输出脚本）拼在一起，尝试运行，如果能够成功跑通，则代表这笔交易的货币来源与交易发起者没问题。</p><h3 id="5-4-简要的数学分析"><a href="#5-4-简要的数学分析" class="headerlink" title="5.4 简要的数学分析"></a>5.4 简要的数学分析</h3><p>我们对于挖矿的过程稍微分析一下。</p><p>每次取随机数，都可以看做一次 <strong>伯努利试验(Bernoulli trial)</strong> ，而挖矿的长期过程（一系列的尝试）可以看作一个 <strong>伯努利过程(Bernoulli process)</strong> 。</p><p><em>a Bernoulli trial (or binomial trial) is a random experiment with exactly two possible outcomes, “success” and “failure”, in which the probability of success is the same every time the experiment is conducted.</em></p><p><em>a Bernoulli process (named after Jacob Bernoulli) is a finite or infinite sequence of binary random variables, so it is a discrete-time stochastic process that takes only two values, canonically 0 and 1.</em><br>—— Wikipedia</p><p>而由于挖矿这个过程所需要尝试的次数实在过多，这个伯努利过程可以通过 <strong>泊松分布(Poisson process)</strong> 来进行近似估计。</p><p>与此同时，对于Bitcoin，系统设计的出块时间为10分钟，而出块所遵从的概率模型，为 <strong>指数分布(Exponential distribution)</strong> 。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/f%28x%29%20for%20Exponential%20distribution.png" alt="f(x) for Exponential distribution"></p><p>至于为什么要按照指数分布来设计出块时间，是为了达成一个叫做 <strong>Progress Free</strong> 的性质。</p><h4 id="5-4-1-Progress-Free-Memoryless"><a href="#5-4-1-Progress-Free-Memoryless" class="headerlink" title="5.4.1 Progress Free (Memoryless)"></a>5.4.1 Progress Free (Memoryless)</h4><p>这个性质的意义是： <strong>此前做过的工作并不能影响此后工作所需要花费时间的期望值</strong> 。</p><p>无情地说，此前如果未能挖出一个区块，那么此后挖出这个区块所需要花费的期望时间还是10分钟。</p><p>其实这个概念在概率论中叫做两次实验之间 <strong>相互独立</strong> 。说明上一次实验不会影响下一次实验成功的机率。</p><p>我们想想，如果没有这个性质，则算力高的人会理所应当的有不成比例的优势，因为他们失败的次数更多，会使得他们挖出新区块的概率相比于算力低的人们高十分多。事实上，这个性质恰恰是挖矿公平性的体现。</p><h4 id="5-4-2-Geometric-series"><a href="#5-4-2-Geometric-series" class="headerlink" title="5.4.2 Geometric series"></a>5.4.2 Geometric series</h4><p>关于Bitcoin的总量，也可以通过数学的方法进行推导，这由Bitcoin中不断减半的铸币交易额度来决定。</p><p>具体来说，Bitcoin的发型会形成一个无限长的序列，前21万个数为50，随后21万个数为25，接下来12.5，6.25，3.125，…</p><p>上述数值持续相加：得到 <strong>210000 * 50 * (1+0.5+0.25+0.125+…)</strong></p><p>最终有一个极限：两千一百万BTC(21 million)，这是Bitcoin设计的极限值。</p><p>当Block Reward最终减少到一定程度时，Bitcoin就相当于达到了其发行极限。</p><h3 id="5-5-安全性说明"><a href="#5-5-安全性说明" class="headerlink" title="5.5 安全性说明"></a>5.5 安全性说明</h3><p>我们上面提到过 <strong>算力优先（4.5.2）</strong> 这个概念，并且在其中提到过这个机制极大程度上确保了区块链的安全性。</p><p><strong>Bitcoin is secured by mining.</strong></p><p>我们现在假使 <strong>诚实的节点拥有大部分算力</strong> ，有恶意的节点仍然占有小部分算力。</p><p>可能会有读者产生疑惑，这意味着有恶意的节点仍然有几率挖出一个区块并获得其记账权，这也不安全啊？</p><p>因此，我们不妨考虑当有恶意的节点获得了区块记账权后，会发生些什么。</p><h4 id="5-5-1-能偷走别人的货币吗？"><a href="#5-5-1-能偷走别人的货币吗？" class="headerlink" title="5.5.1 能偷走别人的货币吗？"></a>5.5.1 能偷走别人的货币吗？</h4><p>假使，这个有恶意的节点希望从别人的账目上将货币转到自己账目上。</p><p>我们在 4.2 以及 5.3 中了解到了相应的保护机制，通过对应的机制，这个恶意节点永远无法 <strong>以合法交易的形式将别人账目上的货币转走</strong> 。</p><p>那假设恶意节点破罐子破摔了，我就是要把非法交易写进我这个账本中，会发生什么？</p><p>结果是，当他将非法交易写入时，由于这个过程是公开的，其它的诚实节点都能够检测到这个区块中的非法交易，因此，这个区块 <strong>不会被诚实节点所接受</strong> ，又由于诚实节点占大多数，因此，这个含有非法交易的节点会如同 4.5.3 节中的 Orphan Block 一样被直接放弃掉。</p><p>显然，这样的攻击方式不仅无法让攻击者得到额外的货币，反而让他将原本能够拿到手的 Block Reward 也丢掉了。因此这种攻击手段并不成立。</p><h4 id="5-5-2-Irrevocable-Ledger"><a href="#5-5-2-Irrevocable-Ledger" class="headerlink" title="5.5.2 Irrevocable Ledger"></a>5.5.2 Irrevocable Ledger</h4><p>我们在这一部分中考虑一种很偷鸡的Double Spending。</p><p>之所以说它偷鸡，是因为我们这里所提及的 Double Spending 指的并非前面简单的双花，因为那种情况下，会很容易被系统检测出来，并判断为非法区块。</p><p>我们这里所指的 Double Spending ，是现实中通过比特币交易获利，而后通过分支攻击（Forking Attack）回滚那一笔比特币转账，最终达成不付出任何代价却现实中获利的效果。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Forking%20Attack%26Double%20spending.png" alt="Forking Attack&amp;Double Spending"></p><p>举例来说，M先在上方的区块内向A发起了交易，相应的，A在现实中也给予M相应的代价，而后M转头又挖出了底下那个区块，并使得底下那个区块变成了最长合法链（我们假设M有这个能力）。这使得M未支付相应的比特币就在现实中获取了相应的利益。</p><p>Bitcoin考虑到了这一点，并做出了相应的限制，即 <strong>只有交易发起的区块后方跟了5个区块后（即加上交易本身所在区块总共6个区块），才能算做交易成功</strong> 。这代表着即使M挖出了下侧的区块，由于上方的链条已经有一定的长度，因此进行上述的Forking Attack的难度大大增加（几乎不可能）。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Confirmation.png" alt="Confirmation"></p><p>我们管这种接在交易所在区块以及后方后面防范Forking Attack的区块统一取了个名字，叫该交易的 <strong>Confirmation</strong> 。显然，一笔交易的 Confirmation 需要等待长达1小时。但同样可以得到的是，这个确认的过程，能够使得交易的风险呈指数式的降低。</p><hr><p>我们这里需要额外提一嘴，由于铸币交易(Coinbase Transaction)的特殊性(铸币交易产生了新的BTC)，它所需的Confirmation数目要远远高于正常的交易，它需要100个确认，即记账权拥有者需要等待接近1000分钟后才能真正将他通过一个区块铸币交易所获得的BTC花出。</p><hr><p>当然，如果Bitcoin的交易非得让用户停在交易界面等一个小时，那未免太不便了一点。</p><p>一般而言，收款方收到交易通知与其发货之间是天然有时间间隔的。这意味着收款方只需要一直监听着区块的情况，等到最长合法链持续延伸，够长之后发货即可，这个过程可以完全由算法完成，不需要付款方或收款方一直等待。</p><h4 id="5-5-3-控制交易写入"><a href="#5-5-3-控制交易写入" class="headerlink" title="5.5.3 控制交易写入"></a>5.5.3 控制交易写入</h4><p>5.5.1 与 5.5.2 的目的是让这个有恶意的节点自己获利，现在我们都封死了。</p><p>那有没有一种可能，这个有恶意的节点故意不把某一部分合法交易写入来达成破坏呢？</p><p>答案是，应该不会，因为交易既然是合法的，则势必能被写入某个区块内（除非恶意节点能获得后方所有的区块的记账权，这几乎是不可能的），而恶意节点这么做的话，反而使得自己无法获得这笔交易的手续费（Transaction fee，详见5.1），降低了自己的收益。</p><h4 id="5-5-4-Selfish-Mining"><a href="#5-5-4-Selfish-Mining" class="headerlink" title="5.5.4 Selfish Mining"></a>5.5.4 Selfish Mining</h4><p>有读者可能会有大胆的想法，我就摁想实现上面的那种 Double Spending ，我往前猛猛挖，挖出来6个块然后不发布，然后等到别人挖到相应的区块了，我一股脑把6个块的链条甩出来，直接使得最长合法链转移到我这里，不就实现了Forking Attack了吗。</p><p>显然，这种攻击的可能性在理论上存在，但需要考虑，挖出区块的可能是与算力成正相关的，因此，恶意节点算力占比如果比诚实节点低，则这种攻击的成功可能性仍然很低，因为理论上来讲，恶意节点挖的不可能比诚实节点快。</p><p>如果恶意节点占了大多数算力，这种攻击的成功概率才比较高。 <del>（一种货币让恶意节点在投票基础中占据了大多数的权重，那这种货币离报废也不远了…）</del></p><h2 id="Part6-网络"><a href="#Part6-网络" class="headerlink" title="Part6. 网络"></a>Part6. 网络</h2><blockquote><p>这一部分的内容涉及到一些计算机网络原理的内容，不会太深</p></blockquote><h3 id="6-1-Basic-description"><a href="#6-1-Basic-description" class="headerlink" title="6.1 Basic description"></a>6.1 Basic description</h3><p>Bitcoin的协议运行在应用层（ <strong>Application Layer</strong> ），也是整个计算机网络七大层中的最上层。</p><p>而由于Bitcoin基于分布式系统进行工作，因此在最底层的应用层原理上, 运行着一个 P2P 协议.</p><p>至于更下层的传输层和网络层, 则是常规的 TCP &#x2F; IP 协议</p><hr><p>关于 Peer to Peer overlay network</p><p><em>A peer-to-peer overlay network is a computer network built on top of an existing network, usually the Internet. Peer-to-peer overlay networks enable participating peers to find the other peers not by the IP addresses but by the specific logical identifiers known to all peers. Usually, peer-to-peer overlays have the advantage over the traditional client-server systems because of their scalability and lack of single-point-of-failure. Peer-to-peer overlays are commonly used for file sharing and realtime data streaming.</em></p><p>P2P 协议与传统的 客户端-服务器协议并不一致，在该协议中，所有的终端的地位是对等的，而他们也不需要通过传统的IP来寻找对方，而是可以更便捷的通过特别的逻辑标识符在互相之间建立连接通道。</p><p>需要特殊说明的一点是， <strong>有些P2P网络</strong> 并非 <strong>完全的去中心化</strong> ，在它们的网络中，还存在着 <strong>Super Node(Master Node)</strong> 这种核心节点。</p><hr><p>在Bitcoin中，是完全去中心化的，即每个节点的地位 <strong>完全对等</strong> 。用户想要加入这个网络，只需向一个种子节点( <strong>Seed Node</strong> )发送连接请求，而后种子节点就会将它已知的所有节点告知这个新人节点，周而复始。</p><p>这一过程中，通常在介于 <strong>Application Layer</strong> 与 <strong>Network Layer</strong> 之间的 传输层( <strong>Transport Layer</strong> )上，使用的是TCP协议，这一方面是保证连接稳定性，另一方面目的也在于更好的穿透防火墙（如果读者对于计网的知识有一定的了解，应该听说过很多防火墙是拦截UDP流量的）。</p><p>至于退出整个区块链网络，则不需要用户做些什么事情，当别的节点长时间未能从你这里获得报文时，会自动将你从网络中删除。</p><h3 id="6-2-Simple-Robust-but-not-Efficient"><a href="#6-2-Simple-Robust-but-not-Efficient" class="headerlink" title="6.2 Simple, Robust but not Efficient"></a>6.2 Simple, Robust but not Efficient</h3><p>如标题所言，Bitcoin的网络的设计原则是： <strong>简单，鲁棒但并不高效</strong> 。</p><p>我们这样说的原因如下：</p><ol><li><p>TCP, not UDP: 显然，TCP中要求的三次握手过程相比于UDP的尽力而为，在时延上要慢很多。</p></li><li><p>Flooding Network: Bitcoin中的信息传输采取泛洪策略，即每个节点向他周边的节点发送它新收到的消息。</p><p>具体而言，一个节点收到了一个合法的交易，它会向所有与它相邻的节点发送这条交易，以便于让所有节点将这笔交易放入当前区块中。同时，每个收到这条交易的节点都会对这笔交易进行相应的标记，这是用于防止交易重复记录的。</p><p>当然，还需要说明的是， <strong>与它相邻的节点</strong> 并不意味着地理意义上的相邻，Bitcoin中的相邻是不考虑底层的拓扑结构的，这意味着很可能两个相邻的节点所处的位置相隔大洋两岸。</p></li></ol><hr><p><strong>Gossip Protocol</strong></p><p>这玩意是比特币使用的泛洪协议，简单描述如下：</p><p><em>A gossip protocol or epidemic protocol is a procedure or process of computer peer-to-peer communication that is based on the way epidemics spread. Some distributed systems use peer-to-peer gossip to ensure that data is disseminated to all members of a group.</em></p><hr><p>上述两个原因也决定了，Bitcoin中区块的大小是有严格限制的，这个限制值是 1M 。</p><p>看起来很小对吧，但是由于以上的网络设计，即使是 1M 大小的区块，要传遍大多数节点，也需要10s以上的时间。</p><h2 id="Part7-挖矿难度"><a href="#Part7-挖矿难度" class="headerlink" title="Part7. 挖矿难度"></a>Part7. 挖矿难度</h2><h3 id="7-1-系统定义"><a href="#7-1-系统定义" class="headerlink" title="7.1 系统定义"></a>7.1 系统定义</h3><p>我们在这一部分再对挖矿的难度进行一定的说明。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Total%20space%20%26%20Target%20space.png" alt="Total space &amp; Target space"></p><p>我们还是搬出这张图，明确以下条件，成功发现区块的条件是H(block header)&lt;&#x3D;target，并且再强调一下，Bitcoin使用的是SHA-256的哈希算法，这意味着它的哈希输出空间只有 2^256 这么大。</p><p>显然，有一种关系很好理解，即挖矿难度与目标阈值的取值是成反比的。</p><p>用一种更加严谨的定义来说：</p><p>$$ difficulty &#x3D; \frac{difficulty \ 1 \ target}{target} $$</p><p>上式中我们解释几个量：</p><ul><li>difficulty: 挖矿难度，最低为1</li><li>target: 目标阈值</li><li>difficulty 1 target: 难度为1时的目标阈值(即目标阈值的最大值)</li></ul><p>因此我们明确了调整难度的方法，对target目标阈值进行调整即可。</p><p>我们在5.2中提及过难度升格的问题，由于算力膨胀，设备先进程度的上涨，如果不对挖矿难度进行调整，则必定会使出块时间不断变短。</p><h3 id="7-2-为什么要划定出块时间？"><a href="#7-2-为什么要划定出块时间？" class="headerlink" title="7.2 为什么要划定出块时间？"></a>7.2 为什么要划定出块时间？</h3><p>我们不妨思考一下，出块时间太短会发生什么。</p><p>我们前方提到过一个概念，叫做分支(Forking)。而有一种分支是合法的，即在很相近的时间内，两个节点同时挖出了当前区块的后续区块(详见4.5.3)。</p><p>如果出块时间太短，显然出现这种合法分支的可能性会大大增加。而每一个分支都必定会有一定的算力分配到上面进行进一步的挖掘工作（这取决于节点先收到哪个分支的声明，详见6.2），这意味着诚实节点的算力被更大程度上的分散了。</p><p>算力分散会发生什么事情？</p><p>我们考虑Forking Attack，原先二分支的情况下，恶意节点想要回滚交易，如果需要保证成功率，需要占据51%的算力总额（这样它才有把握挖的比诚实节点快，抢走最长合法链条），但出块时间过快，导致诚实节点算力分散了，分配到每个分支上的算力只占总算力的10% ~ 15%，那么，恶意节点只需要20% ~ 30%的总额算力，就能极大程度上保证分支攻击的成功率。</p><p>这很大程度上降低了安全性。</p><h3 id="7-3-怎么调整目标阈值"><a href="#7-3-怎么调整目标阈值" class="headerlink" title="7.3 怎么调整目标阈值"></a>7.3 怎么调整目标阈值</h3><p>首先，我们得明确目标阈值的调整间隔。</p><p>具体而言，对于Bitcoin，规定为每隔2016个区块，要调整一次目标阈值（换算下来大概两个星期调一次）</p><p>具体怎么调整呢：遵循这个公式：</p><p>$$ target &#x3D; target * \frac{Actual \ Time}{Expected \ Time} $$</p><p>这个公式我们解释一下：</p><ul><li>ActualTime: 指的是系统最近产出2016个区块花费的时间</li><li>ExpectedTime: 指的是系统期望的产出2016个区块应当花费的时间，即 2016*10 min(almost 2 weeks)</li></ul><p>通过这样的设置，我们实现了令target阈值与当前算力的微妙同步。</p><p>在实际代码中，为了避免一些意外情况，ActualTime比8个星期还大，抑或是比半个星期还小，系统中也只会将其控制在 [1&#x2F;2weeks, 8weeks] 这个区间内。即target的变动阈值在 [1&#x2F;4target, 4target]之间。</p><hr><p>请注意甄别： <strong>挖矿难度</strong> &amp; <strong>阈值</strong></p><p>对于Bitcoin而言，挖矿难度与阈值负相关的，即阈值越小，挖矿难度越高。（读者可以对照着2.1.4的图理解一下这句话）</p><p>我们给出另一个公式，也是正确的，不过这次我们的主元是挖矿难度 <strong>difficulty</strong> ：</p><p>$$ next \ difficulty &#x3D; previous \ difficulty * \frac{Expected \ Time}{Actual \ Time} $$</p><p>可以发现，后面的分数反过来了，这正是挖矿难度与阈值负相关的证明。</p><p>至于为啥要再写个概念呢，因为实际代码里用的是目标阈值target，但这个东西有点反直觉，因此又设置了一个挖矿难度，方便理解，量化。</p><hr><h2 id="Part8-关于挖矿本身"><a href="#Part8-关于挖矿本身" class="headerlink" title="Part8. 关于挖矿本身"></a>Part8. 关于挖矿本身</h2><h3 id="8-1-挖矿设备"><a href="#8-1-挖矿设备" class="headerlink" title="8.1 挖矿设备"></a>8.1 挖矿设备</h3><p>随着事件发展, 挖矿的设备逐渐趋于专业化, 这是因为传统的PC与挖矿的需求并不相同.</p><p>传统PC的部件中有一大部分的部件都用做与挖矿无关的方向, 如 <strong>显示方面, 意外处理方面等</strong> , 但挖矿显然并不需求这些方面的专业性, 挖矿的唯一标准, 在于 <strong>算力</strong> .</p><p>最初的挖矿是利用 <strong>CPU</strong> 进行挖矿, 但很显然, 挖矿这个对于随机值的计算过程, 使得CPU只有数值运算的相关部件(详见 <strong>计算机组成原理 章节</strong> )在全程运转, 而其余很多部件都处于闲置状态, 效率不高.</p><hr><p>而后, 挖矿这个过程使用的设备, 就走向了GPU的方向. GPU相比于CPU, 尤其擅长 <strong>通用并行计算</strong> , 这就代表着它确实更加长于挖矿.</p><p>但仍然需要明确, 即使利用 <strong>GPU</strong> , 仍然是一种相当程度上的资源浪费, 这是因为GPU里面很多的部件仍然处于闲置状态, 一个典型案例即 <strong>GPU中的浮点计算模块</strong> , 这个模块在机器学习等过程中是相当重要的, 但对于BTC挖矿(只涉及到整数运算的各种操作), 则几乎无用.</p><hr><p>为了进一步提升资源利用率, 有一类专门的芯片被设计出来, 它被称为 <strong>ASIC(Application-specific integrated circuit)</strong> :</p><p><em>An application-specific integrated circuit (ASIC &#x2F;ˈeɪsɪk&#x2F;) is an integrated circuit (IC) chip customized for a particular use, rather than intended for general-purpose use, such as a chip designed to run in a digital voice recorder or a high-efficiency video codec.</em></p><p>这一类芯片是专门针对某一类型的应用特化的芯片, 它没有多余的运算部件, 仅仅针对于应用需求最重的领域进行特化, 可以达到相当高的利用率, 性价比是最高的.</p><p>当然, 不同的加密货币可能注重的计算方面也不同, 这代表着针对某一种加密货币设计的ASIC芯片, 也只能挖这一特定的加密货币(说明其通用性不高). 因此, 如果读者对于前些年的矿潮有所了解, GPU仍然是最火热的挖矿设备.</p><p>当然, 使用ASIC芯片挖矿的群体仍不在少数, 这就代表着通用性也是某些新型加密货币所需要考虑的内容. 因此, 有些新的加密货币会使用与此前火热的加密货币(如BTC) <strong>相同的 Mining Puzzle</strong> , 这使得本来设计出用于挖传统加密货币的ASIC也可以用于挖这种全新的货币. 这通常用于 <strong>新型加密货币打开市场, 提升人气的时期</strong> 使用.</p><h3 id="8-2-挖矿规模"><a href="#8-2-挖矿规模" class="headerlink" title="8.2 挖矿规模"></a>8.2 挖矿规模</h3><p>挖矿的另一种趋势, 是 <strong>矿池</strong> 的出现.</p><p>这种现象的本质原因在于, 如果所有矿工均以个体作战, 则对于每一个个体, 这种收益是非常不稳定的. <del>(三年不开张, 开张吃三年)</del></p><p>而为了保证收益的稳定, 出现了一种团体, 它将很多矿机集体集合起来统一调配.</p><p>在明确矿池的出现的根本原因前, 我们需要回顾一下 <strong>全节点</strong> 与 <strong>轻节点</strong> 的概念:</p><ul><li>全节点<ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存中维护UTXO集合, 便于快速检验交易的正确性</li><li>监听BTC网络中的交易信息, 验证每个交易的合法性</li><li>决定哪些交易会被打包到区块中</li><li>监听别的矿工挖出来的区块, 验证其合法性</li><li>挖矿<ul><li>决定沿着哪条链挖下去?</li><li>出现等长分叉时, 选择哪一个分叉?</li></ul></li></ul></li><li>轻节点<ul><li>偶尔在线</li><li>只保存每个区块的块头(Block Header)</li><li>只保存与自己相关的交易</li><li>只能检验与自己相关的那些交易的合法性</li><li>可以验证挖矿的难度</li><li>可以检测哪个是最长链, 但没有判断最长合法链的能力</li></ul></li></ul><p>显然, 如果想要挖矿, 则必须保证全节点的稳定性.</p><p>我们前面在挖矿设备中提到了, ASIC芯片只能从事挖矿本身需要的计算功能, 只有ASIC是无法维护全节点的其余功能的.</p><p>因此, 我们上面的挖矿团体, 即 <strong>矿池</strong> 就出现了:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/%E7%9F%BF%E6%B1%A0.png" alt="矿池"></p><ul><li>Pool manager<ul><li>也称矿主</li><li>负责除了计算之余的全节点内容</li><li>负责组装区块, 将需要计算的哈希值任务通过特定的通讯协议分配给矿工</li></ul></li><li>Miner<ul><li>也称矿工</li><li>负责哈希值相关的计算</li><li>当运算出对应的结果后, 通过特定的通讯协议将结果回馈给矿主</li><li>当出块后, 参与分红</li></ul></li></ul><p>这带来的一种隐性好处在于, 每个个体只需要购买相应的设备, 加入矿池, 然后让矿主控制所有矿机的调度即可, 很简单. 此外, 如果一个人的收益过于不稳定, 那就一群人一块挖, 挖到了大家分红, 由于总算力的大幅提升, 这就使得收益稳定了不少.</p><hr><p>那么, 问题又来了, 如何分红? </p><p>读者应该能想到, 这里又涉及到了我们此前提到的 <strong>工作量证明</strong> 这个概念. 矿池中的所有矿工需要向矿主提交自己的工作量证明, 以达到在最终分红环节中拿到更多的份额.</p><p>这个工作量证明如何提交呢?</p><p>我们回到最初矿池的建立根源上, 即找到区块当前要求的 nonce 的难度太高了, 这个限制区域太小了, 很难找到.</p><p>因此有一种很简单的工作量证明, 即矿主 <strong>人工划定一个较低的难度区间, 它比原区块要求的nonce的要求要低不少(我们称之为 share ) , 符合这个 share 要求的区块被称作 Almost valid Block</strong> , 同时矿主维护一个 <strong>每个矿工挖到 Almost valid Block 数目的列表</strong> , 当一个矿工挖到了一个符合 share 的随机数后, 它向矿主提交这个值, 矿主将其对应列表中的值+1. 最终出块奖励按照这个列表中的值进行分配.</p><p>需要明确, 这种Almost valid Block除了作为工作量证明之外, 是完全无用的. 换言之, 它只能作为一种分红凭证在矿池的机构中起作用.</p><p>此外, 为了保证矿工 <strong>挖出区块后会如期交给矿主, 而不会自行发布</strong> , 矿主会在组装的区块中的铸币交易的收款人地址中填入自己的地址.(铸币交易以及相应的更改见 5.2.2)</p><p>这里也给出当前矿池的国家分布:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Mining%20pool%20concentartion.png" alt="矿池分布(2024/6/28)"></p><p>—— From <a href="https://www.buybitcoinworldwide.com/mining/pools/">https://www.buybitcoinworldwide.com/mining/pools/</a></p><hr><p>矿池的出现固然有其好处, 但它本质上其实是一种对 <strong>去中心化</strong> 的破坏, 想象一下, 有一个矿池吸引了足够多的矿工, 使得这个矿池的算力总和达到了51%以上, 那么他其实可以很容易的发起各种各样的攻击, 因为他占据了大部分的算力. (更恐怖的是, 其下属的矿工甚至不会意识到这一点, 这是因为下属矿工 <strong>只会接收到具体任务, 而并不知道这个任务是在以什么为目的</strong> . 举例而言, 矿主可以很轻易的将下属的所有算力都转向另一条链, 达成分支攻击)</p><p>同时, 矿池的矿主是需要收取一定的管理费的, 他们经营矿池也需要盈利手段. 而矿池的火热程度, 很大程度上取决于矿主收取管理费的多少.</p><h2 id="Part9-BTC的脚本语言"><a href="#Part9-BTC的脚本语言" class="headerlink" title="Part9. BTC的脚本语言"></a>Part9. BTC的脚本语言</h2><p>谈及脚本, 可能大部分读者会想到C, C++等编程语言, 与之不同, 比特币的脚本语言相当简单, 其唯一能够访问的对象就是一个堆栈, 这也意味着它不存在所谓 “全局变量” , “局部变量” 等概念. 也由于BTC的脚本主要基于堆栈, 因此也称之为 <strong>Stack based Language</strong> .</p><h3 id="9-1-BTC的交易结构"><a href="#9-1-BTC的交易结构" class="headerlink" title="9.1 BTC的交易结构"></a>9.1 BTC的交易结构</h3><pre class="line-numbers language-none"><code class="language-none">result&#123;  txid: \\Transaction id  hash: \\Transaction hash  version:  size:  locktime: \\Could be included in a block after ...  vin: \\Input  vout: \\Output  blockhash: \\The hash of its Block&#39;s Head  confirmations:  time: \\the time when this transaction appears  blocktime:  \\the time when its block appears&#125;vin&#123;  txid:  vout: \\this transcation spent which output of last transaction  \\(one transaction may conclude many output)  scriptSig&#123; &#x2F;&#x2F;or input_script    asm:    hex:  &#125;&#125;vout&#123;  value: &#x2F;&#x2F;the amount of BTC this output spent  n: &#x2F;&#x2F;output number  scriptPubKey&#123; &#x2F;&#x2F;or output_script    asm:    hex:    reqSigs: &#x2F;&#x2F;number of Signature which is required in this output    type:    addresses:  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-2-BTC交易脚本的执行方式"><a href="#9-2-BTC交易脚本的执行方式" class="headerlink" title="9.2 BTC交易脚本的执行方式"></a>9.2 BTC交易脚本的执行方式</h3><h4 id="9-2-1-交易脚本执行顺序"><a href="#9-2-1-交易脚本执行顺序" class="headerlink" title="9.2.1 交易脚本执行顺序"></a>9.2.1 交易脚本执行顺序</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/BTC%E2%80%98s%20script.png" alt="How to run a BTC&#39;s Script"></p><p>这幅图的原理其实在 4.2 节中有所提及, 读者如有遗忘可以再次前去复习一下;</p><p>实际执行中, 通常将输入脚本放在输出脚本的前方, 分别执行(为了安全性考虑).</p><h4 id="9-2-2-几种具体的交易脚本"><a href="#9-2-2-几种具体的交易脚本" class="headerlink" title="9.2.2 几种具体的交易脚本"></a>9.2.2 几种具体的交易脚本</h4><p>BTC中, 有以下几种十分常用的交易脚本:</p><ul><li>P2PK: Pay to Public Key</li><li>P2PKH: Pay to Public Hash <strong>(Most Common)</strong></li><li>P2SH: Pay to Script Hash</li></ul><p>我们一个个来看</p><hr><p><strong>1.P2PK</strong></p><p>这种最简单的脚本中:</p><ul><li>input script:<ul><li>Signature</li></ul></li><li>output script:<ul><li>Public Key</li><li>CheckSig</li></ul></li></ul><blockquote><p>请注意, 这里的output script 是 <strong>这笔交易使用的货币来源的输出, 并不是这笔交易本身的输出</strong> !</p></blockquote><p>按照堆栈的方法, 该类型脚本会将签名先压入栈底, 随后将交易来源的输出(即对应的公钥)压入栈顶, 最后利用CheckSig压入栈顶进行验证, 返回值只会是 True 或 False, 对应合法或不合法.</p><hr><p><strong>2.P2PKH</strong></p><p>这种脚本中:</p><ul><li>input script:<ul><li>Signature</li><li>Public Key</li></ul></li><li>output script:<ul><li>DUP(Duplicated)</li><li>Hash160</li><li>Public Key Hash</li><li>EqualVerify</li><li>CheckSig</li></ul></li></ul><p>与P2PK不同, 这种脚本的输入既需要给出签名, 还需要给出本人的公钥, 而输出脚本给出的是 <strong>收款人公钥的哈希</strong></p><p>从上往下看:</p><blockquote><p>由于这种方式其实是最常用的, 因此这里会详细解释一下整个验证过程. 我们用Bottom表示栈底, Top表示栈顶</p></blockquote><p>首先, 签名入栈, 公钥紧随其后入栈, DUP代表将栈顶元素复写一份, 即当前:</p><p>$$ Bottom \leftarrow Sig \leftarrow Pub Key \leftarrow Pub Key \leftarrow Top $$</p><p>Hash160表示将栈顶元素取哈希:</p><p>$$ Bottom \leftarrow Sig \leftarrow Pub Key \leftarrow Pub Key Hash(from \space input) \leftarrow Top $$</p><p>下面将输出脚本中的公钥哈希压入栈:</p><p>$$ Bottom \leftarrow Sig \leftarrow Pub Key \leftarrow Pub Key Hash(from \space input) \leftarrow Pub Key Hash(from \space output) \leftarrow Top $$</p><p>这里需要再次明确, 此处 <strong>靠近栈顶的公钥哈希, 是来自输出脚本的</strong> (即别人把这个钱转给你的时候写的公钥哈希); 而 <strong>它下面的公钥哈希, 是来自输入脚本的</strong> (即你要花这个钱了, 你自己给出的公钥通过哈希算法求出来的)</p><p>随后EqualVerify, 代表弹出栈顶两个元素, 比较两者是否相等.</p><p>最后一条CheckSig, 给出最终返回结果.</p><blockquote><p>读者如果有兴趣, 可以返回 5.3 节看看我们在那里给出的脚本, 使用的就是P2PKH.</p></blockquote><hr><p><strong>3.P2SH</strong></p><p>这种方式是最复杂的一种方式, 其结构如下:</p><ul><li>input script<ul><li>…</li><li>Signature</li><li>…</li><li>serialized Redeem script</li></ul></li><li>output script<ul><li>HASH 160</li><li>Redeem script Hash</li><li>EQUAL</li></ul></li></ul><p>本处, 输出脚本中给出的不再是公钥或公钥哈希, 而是一种特殊的脚本的哈希, 该脚本名为 <strong>赎回脚本</strong> , 而输入脚本中给出的是 <strong>赎回脚本的具体内容</strong> , 以及 <strong>能使这个赎回脚本正确运行所需要的签名</strong> .</p><p>当验证时首先验证输入脚本中的赎回脚本是否能与输出脚本中的哈希匹配(即 Serialized Redeem script 与 Redeem script Hash 的匹配), 随后还需要验证赎回脚本是否能够正确运行. 只有两步验证都通过, 该交易才能够视作合法.</p><p>至于这个赎回脚本的方式, 可能是前面提到的P2PK, P2PKH其中之一.</p><p>这种方式有点类似于编程语言中的函数封装, 将前两种验证方法封装成了一个单独的赎回脚本.</p><hr><h3 id="9-3-MultiSig-多重签名"><a href="#9-3-MultiSig-多重签名" class="headerlink" title="9.3 MultiSig(多重签名)"></a>9.3 MultiSig(多重签名)</h3><p>三种方式讲完了, 现在我们来说说这第三种到底干嘛使的, 因为P2SH这东西实在是有点复杂, 看起来很不必要.</p><p>第三种P2SH的最主要应用在于 <strong>实现多重签名(MultiSig)</strong> .</p><h4 id="9-3-1-多重签名的概念与最初实现"><a href="#9-3-1-多重签名的概念与最初实现" class="headerlink" title="9.3.1 多重签名的概念与最初实现"></a>9.3.1 多重签名的概念与最初实现</h4><p>所谓多重签名, 即一个账户中的钱由多个主体共同管理, 比如3个人管理同一个账户中的钱, 只需要两个人的签名, 就能够将钱取出. 最早的BTC所支持的多重签名如下:</p><ul><li>input script<ul><li>False</li><li>Sig_1</li><li>Sig_2</li><li>…</li><li>Sig_M</li></ul></li><li>output script<ul><li>M</li><li>PubKey_1</li><li>PubKey_2</li><li>…</li><li>PubKey_N</li><li>N</li><li>CheckMultiSig</li></ul></li></ul><p>其中 M 代表所需要的签名数, N 代表总共有几个签名. 至于Input script中的False, 那是Bitcoin最初设计MultiSig时的代码错误, 但由于其完全分布式的特性, 导致通过系统更新的方式修正它又显得代价过大, 因此采取的一种补偿措施.</p><p>这种方式在运行上没有任何问题, 但很明显, output script实在是过于冗余了, 同时我们考虑一下, output script通常是别人给你转账的时候需要使用的, 因此这就显得十分不方便.</p><h4 id="9-3-2-利用P2SH实现多重签名"><a href="#9-3-2-利用P2SH实现多重签名" class="headerlink" title="9.3.2 利用P2SH实现多重签名"></a>9.3.2 利用P2SH实现多重签名</h4><p>如何利用P2SH实现多重签名? 即将上述内容中的输出脚本单独封装:</p><ul><li>redeem script<ul><li>M</li><li>PubKey_1</li><li>PubKey_2</li><li>…</li><li>PubKey_N</li><li>N</li><li>CheckMultiSig</li></ul></li><li>input script<ul><li>False</li><li>Sig_1</li><li>Sig_2</li><li>…</li><li>Sig_M</li></ul></li><li>output script<ul><li>Hash160</li><li>Redeem script Hash</li><li>Equal</li></ul></li></ul><p>此时, 输出脚本变得十分的简单, 这个Redeem script可以直接通过收款方主动公布得知, 因此大大提升了用户生成转账交易的便利性. 同时, 也对收款方的转账策略有了更高的保密性.</p><h3 id="9-4-Proof-of-Burn-BTC销毁证明"><a href="#9-4-Proof-of-Burn-BTC销毁证明" class="headerlink" title="9.4 Proof of Burn(BTC销毁证明)"></a>9.4 Proof of Burn(BTC销毁证明)</h3><p>这是一种非常特殊的BTC输出脚本, 该脚本中有一行语句:</p><ul><li>output script<ul><li>RETURN</li><li>…(nothing or more operations or text)</li></ul></li></ul><p>在BTC的机制中, 当脚本运行识别到 <strong>RETURN</strong> 这个语句时, 会无条件返回False, 而其后方的操作, 或任何文字都不会被执行. 这就意味着, 如果有一笔交易的输出脚本包含了 RETURN, 那么这笔钱就永远花不出去了, 也就代表着这一部分 BTC 被 <strong>销毁</strong> 了.</p><p>为啥要销毁比特币呢?</p><p>第一种可能是以一定的代价来换取某一些小币种(AltCoin, or Alternative Coin), 这些小币种通常需要你付出一定的代价来获取一定量的它们的货币.</p><p>第二种可能, 这种方式可以用来永久存储一些信息, 这是因为RETURN后方的一切内容都不会执行, 但也不会被删除(区块链的不可篡改性). 典型的例子比如Digital Commitment(详见2.1.3节) , 你可以将你所拥有的任何信息的哈希值写入这笔交易输出脚本RETURN的后方, 当需要证明你的所有权时, 只需要公布该交易内容以及相应的原件即可.</p><p>这种证明代表着, 任何一个用户, 哪怕是一个普通的使用者, 都可以以及其小额的代价, 换取在区块链中记上一笔, 写一些东西的机会.</p><h2 id="Part10-BTC中的分叉"><a href="#Part10-BTC中的分叉" class="headerlink" title="Part10. BTC中的分叉"></a>Part10. BTC中的分叉</h2><p>在此前的章节中曾经提及过多次 <strong>分叉(Forking)</strong> 这个概念, 在本章中我们进一步明确分叉的各种类型与作用.</p><p>分叉, 一般分为:</p><ul><li>State Fork: 对于区块记账权的争夺, 或由于本身区块链状态导致的分叉<ul><li>Normal Fork: 两个节点几乎同时挖到了符合要求的区块, 这种分叉是合理的</li><li>Forking Attack(Deliberate Fork): 即有意产生的意见分歧导致的分叉(见4.5.3)</li></ul></li><li>Protocol Fork: 由于协议本身需要更新导致了分歧, 导致的分叉<ul><li>Hard Fork: 即 <strong>硬分叉</strong></li><li>Soft Fork: 即 <strong>软分叉</strong></li></ul></li></ul><p>由于此前我们对于第一种 <strong>State Fork</strong> 的内容已经有了比较详细的解释, 因此我们这里主要针对 <strong>Protocol Fork</strong> 进行阐述. Protocol Fork 针对着对区块链本身的协议进行更新.</p><h3 id="10-1-Hard-Fork"><a href="#10-1-Hard-Fork" class="headerlink" title="10.1 Hard Fork"></a>10.1 Hard Fork</h3><p>所谓 <strong>硬分叉(Hard Fork)</strong> 即当比特币的协议需要进行根本性改变(即不认可这个更新的节点, 我们称之为 <strong>旧节点</strong> 对于新协议是不兼容的), 但有一部分节点对这种新的更新不认同时, 就会产生所谓的硬分叉.</p><p>一个非常典型的案例即 <strong>增加BTC中划定的区块大小上限</strong> . 显然, 不认可大区块的旧节点无法认可新产生的链条.</p><hr><p><strong>为啥要增加区块大小</strong> ?</p><p>比特币的区块大小最初被规定为 <strong>1MB</strong> , 即 $ 1 * 10^{6} \space byte $ , 这是什么概念? 传统一笔交易的平均大小约 $ 250 \space byte $ .</p><p>这代表着一个区块内可以包含的交易数目:</p><p>$$ \frac{10^6}{250} \approx 4000 $$</p><p>我们将其平摊到 10分钟 之内, 可以算出每秒钟的平均交易数目:</p><p>$$ \frac{4000}{10 * 60} \approx 7 \space tx&#x2F;sec $$</p><p>显然, 这个每秒交易量太少了, 也代表着比特币的交易效率其实相当的低下.</p><p>因此, 有人提出需要增加BTC的区块大小.</p><hr><p>我们现在想一想增加区块大小的具体情况:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Hard%20Fork.png" alt="Hard Fork Example"></p><p>即使有大部分节点同意这个决定, 即增大区块大小, 但少数保守派不配合, 始终不认可这个决策, 那么这部分节点永远不会沿着上面的链条挖掘(因为在他们看来, 上面的链条是非法的), 而是继续沿着下侧链条继续工作. 这就形成了一个 <strong>硬分叉</strong> .</p><p>需要明确, 这种分叉是无法消除的, 因为意见分歧一般无法统一(分布式系统就是会产生这种情况), 那么上下两侧的区块奖励怎么算?</p><p>一般而言, 出现硬分叉后, 会出现币种分裂, 即挖上侧链条的人们任何上面的记账人, 下侧同理, 长此以往, 两条链条就分家了.(一个很典型的案例是 ETH 与 ETC).</p><p>很遗憾, 还有大问题, 因为币种分家后, 只有协议发生了改变, 而每个账户的公钥 &#x2F; 私钥都没有变化, 这会导致本来只想被囊括在上侧链条中的交易被重复囊括在下侧链条中. 这就又会可能导致各种各样的双花攻击.</p><p>有一种简单的处理方法即在两侧分家后的交易中都加上 <strong>chain ID</strong> 这个变量, 这能使得两侧的链条均得知一个交易是应当在哪一个链条上进行的.</p><h3 id="10-2-Soft-Fork"><a href="#10-2-Soft-Fork" class="headerlink" title="10.2 Soft Fork"></a>10.2 Soft Fork</h3><h4 id="10-2-1-软分叉概念"><a href="#10-2-1-软分叉概念" class="headerlink" title="10.2.1 软分叉概念"></a>10.2.1 软分叉概念</h4><p>所谓 <strong>软分叉(Soft Fork)</strong> 指的是旧节点能够兼容新的更新改动. 举一个假设, 比如 <strong>降低比特币区块大小上限</strong> (注意, 这只是个例子, 现实中没有发生过)</p><p>为什么叫做软分叉, 我们还是假设多数人认可这个更新, 因此从算力投票的角度, 必定是小区块产生的速率更快一些(链条更长一些).</p><p>此时, <strong>由于旧节点认可新链条</strong> , 根据最长合法链原则, 它会自动抛弃当前链条, 而转向新的小区块链条.</p><p>这代表着, 如果它坚持不更新, 它的收益会受损(它挖出的所有大区块都白挖了), 而整个区块链仍然会长时间保持一条最长合法链, 也就代表着此时的分支是 <strong>暂时的</strong> .</p><h4 id="10-2-2-软分叉实例"><a href="#10-2-2-软分叉实例" class="headerlink" title="10.2.2 软分叉实例"></a>10.2.2 软分叉实例</h4><p>一种比较典型的案例即对某些目前协议中未曾规定的域赋予一些新的含义(规则). 比如我们之前提到的 Coinbase Transaction 中的 Coinbase 域(详见5.2.2).</p><p>我们提及过, Coinbase 域内有一部分可能被作为 extra nonce , 但 Coinbase 域很大, 只用作这个多少有点浪费, 因此有人曾经提及, 剩余的部分可以用于存储 UTXO 集合的根哈希值, 这就是一个典型的软分叉.(但最终未被实行)</p><p>比特币中一个很著名的软分叉加入的功能, 就是 <strong>Pay to Script Hash</strong> 功能(详见 9.2.2 和 9.3)的加入, 这个脚本功能在最初的 BTC 中是不存在的, 但后续通过软分叉进行加入.</p><p>另一个十分著名的通过软分叉加入的功能被称作 <strong>隔离见证(SegWit &#x2F; Segregated Witness)</strong> , 这个功能使得每一笔交易中的 <strong>签名(Signature)</strong> 和 <strong>交易本身的信息(Tx Information)</strong> 被隔离开来, 将所有的签名相关信息放入 Coinbase Transaction 中. 这个更新 <strong>显著降低了交易平均大小</strong> , 使得比特币的交易效率大幅提升.</p><h2 id="Part11-BTC中的匿名性"><a href="#Part11-BTC中的匿名性" class="headerlink" title="Part11. BTC中的匿名性"></a>Part11. BTC中的匿名性</h2><p>所谓 <strong>匿名性(Anonymity)</strong> , 指的是一个人的身份在其进行某个事项时可以不被泄露, 进而他在现实中的身份不会公开, 也无法被攻击.</p><p><em>Anonymity describes situations where the acting person’s identity is unknown. The important idea here is that a person be non-identifiable, unreachable, or untrackable.</em></p><p>从这个角度来理解, 现金的匿名性其实是最好的, 因为当钱花出之后, 无人能够得知这张钱曾经经过你的手中. 当然, 现金的局限性也很高, 因为它不好管理, 不好存储.</p><p>BTC的匿名性体现在任何人只需要创建一个 <strong>&lt; 公钥 , 私钥 &gt;</strong> 对, 就可以成为一个用户, 而无需实名制. 但相对应的, 其账本是公开的.</p><p>现今社会中银行的匿名性体现在其账本不公开, 只有交易双方能得知这笔交易的存在, 但需要对一个中心管理机制实名.</p><h3 id="11-1-输入地址-输出地址之间的关联"><a href="#11-1-输入地址-输出地址之间的关联" class="headerlink" title="11.1 输入地址 &#x2F; 输出地址之间的关联"></a>11.1 输入地址 &#x2F; 输出地址之间的关联</h3><p>这里所说的输入地址 &#x2F; 输出地址通常指的是一笔交易中输入货币的原账户与输出货币的目的账户. 我们通过本节的论述可以发现其中有一些特殊情况下, 二者是可以建立联系的.</p><p>我们假设一笔交易有四个账户</p><ul><li>输入账户(Input Address): $ Add_1(spend \space 4 \space BTC), Add_2(spend \space 5 \space BTC)$</li><li>输出账户(Output Address): $ Add_3(receive \space 6 \space BTC), Add_4(receive \space 3 \space BTC) $</li></ul><hr><p>为什么需要有多个输出账户呢? </p><p>因为通常而言, 一个BTC账户上的钱很少能够等于商品的价格, 因此, 通常输入的BTC数量是要高于商品价格的, 至于剩余的BTC怎么处理, 则由支付方再额外提供一个 <strong>找零账户</strong> , 将多余的BTC单独创建一个输出, 转到那个找零账户上.</p><hr><p>我们考虑上面举的例子, 通常的情况下, 上面的情况都代表着:</p><ul><li>$ Add_3 $ 应当是收款方的账户, 而 $ Add_4 $ 应当是付款方的找零账户.(如果后者是收款方账户, 则无需两个付款账户一并付款)</li><li>某些情况, $ Add_1, Add_2 $ 这两个账户可能有关联, 甚至干脆属于同一个人.</li></ul><p>显然, 通过这一个交易就能分析出一些 <strong>交易用户之间的关联信息</strong> , 这本身就是对交易匿名性的一种破坏(更甚, 可以系统的分析大量的交易记录, 从而得到一些确定性较高的信息, 虽然这难度颇高).</p><h3 id="11-2-与个人实际身份的关联"><a href="#11-2-与个人实际身份的关联" class="headerlink" title="11.2 与个人实际身份的关联"></a>11.2 与个人实际身份的关联</h3><p>我们考虑, 当比特币一旦与现实生活中的某些行为产生关联, 比如大额法币 &#x2F; 比特币的转入 &#x2F; 转出时, 显然会引起司法部门的关注, 而由于最终都要置换为现实生活中有实际消费价值的法定货币, 因此这代表着个人肯定能被某些手段推测到的. 这从一定意义上讲, 也是对匿名性的一种破坏.</p><p>从这个角度上来讲, 参与比特币这个链条最久的, 比特币的发明者 <strong>中本聪</strong> , 是保证自己匿名性最好的人, 因为他从始至终从未花费自己的任何比特币财产, 也就意味着他从始至终没有将自己的账户与任何现实生活中的行为产生任何关联.</p><p>上述两个章节, 主要目的在于说明比特币的匿名性并没有达到十全十美, 请各位读者不要有什么危险的想法(笑)</p><h3 id="11-3-保证匿名性的手段"><a href="#11-3-保证匿名性的手段" class="headerlink" title="11.3 保证匿名性的手段"></a>11.3 保证匿名性的手段</h3><p>我们此前(6.1)提及过, 比特币是基于传统的TCP &#x2F; IP协议进行协议设计的. 这就意味着, 要想增强其匿名性, 需要从应用层的协议设计入手.</p><blockquote><p>至于为何不急于传统的传输层与网络层进行进一步工作, 这是因为传输层的TCP &#x2F; IP协议的设计已经相对完备, 并且加密手段也已经比较完善, 这里不会将重点放在它上.</p></blockquote><h4 id="11-3-1-Coin-Mixing"><a href="#11-3-1-Coin-Mixing" class="headerlink" title="11.3.1 Coin Mixing"></a>11.3.1 Coin Mixing</h4><p>所谓Coin Mixing, 指的是 <strong>对一定量的货币进行多次操作(即使这些操作是不必要的), 以使得最终交易双方转出 &#x2F; 收到的货币无法被溯源</strong> 的一种方式.</p><p><em>Coin mixers allow users to mix up transactions between different cryptocurrency addresses, so they become untraceable and cannot be followed back to the initial sender or receiver.</em></p><p>Coin Mixing这个功能通常以协议的方式被设计出来, 被广泛采用, 如各类货币交易所 &#x2F; 虚拟货币钱包APP等.</p><p>当然, Coin Mixing本身是存在风险的, 因为这个操作本质上是一种货币的支出 &#x2F; 收入, 因此如果参与者所选择的中介不值得相信, 则很容易造成严重的个人损失.</p><h3 id="11-4-Zero-Knowledge-Proof"><a href="#11-4-Zero-Knowledge-Proof" class="headerlink" title="11.4 Zero-Knowledge Proof"></a>11.4 Zero-Knowledge Proof</h3><p><em>In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that a given statement is true, while avoiding conveying to the verifier any information beyond the mere fact of the statement’s truth.</em></p><p>通俗而言, <strong>零知识证明</strong> 指的是 <strong>证明者向验证者证明一个陈述是正确的, 但又无需向验证者透露任何除了该陈述是正确的之外的任何信息</strong> .</p><p>比特币采用的思想有点类似这里的思路, 在比特币中, 如果证明者A希望证明一个账户是自己的, 往往需要发布一个 <strong>自己私钥的签名</strong> , 而其余的验证者可以通过该签名能否与对应账户的公钥相匹配来验证 <strong>账户属于证明者A</strong> 这个命题是真实的.</p><p>这一整个过程中, 证明者A达成了 <strong>不将自己的私钥透露出去的同时, 也能够证明账户属于自己</strong> 的目的.</p><h2 id="Part12-总结-一些细碎的具体化工作"><a href="#Part12-总结-一些细碎的具体化工作" class="headerlink" title="Part12. 总结 &#x2F; 一些细碎的具体化工作"></a>Part12. 总结 &#x2F; 一些细碎的具体化工作</h2><h3 id="12-1-区块链究竟是如何存储的-哈希指针怎么实现的"><a href="#12-1-区块链究竟是如何存储的-哈希指针怎么实现的" class="headerlink" title="12.1 区块链究竟是如何存储的 &#x2F; 哈希指针怎么实现的?"></a>12.1 区块链究竟是如何存储的 &#x2F; 哈希指针怎么实现的?</h3><p>我们在此前的叙述中, 一直通过 <strong>哈希指针(Hash Pointer)</strong> 这个比较抽象的概念对区块链进行数据结构化工作, 但这个过程并不十分具体.</p><p>事实上, 在大部分全节点处, 一个个的区块被存储在 <strong>数据库</strong> 中, 存储形式是键值对, 即&lt;key, value&gt;形式(一个相当出名的数据库被称作Level DB).</p><ul><li>key: 区块的哈希值</li><li>value: 区块内容(Block Header &#x2F; Block Body)</li></ul><p>在实际系统中, 所谓的哈希指针, 就是一个哈希值, 因为可以通过哈希值来借由全节点查找到相应的区块内容, 这也就变相实现了指针的功能.</p><h3 id="12-2-共享账户的实现方式"><a href="#12-2-共享账户的实现方式" class="headerlink" title="12.2 共享账户的实现方式?"></a>12.2 共享账户的实现方式?</h3><p>曾经有一些人采用过一种风险相当大的方式进行共享账户, 即 <strong>私钥切割</strong> , 每个人保管私钥中的其中一部分.</p><p>这是一种风险相当大的方式, 比特币的私钥采用SHA-256哈希算法, 有256位, 我们假设一人保管128位, 两个人的共享账户, 这意味着另一个人 <strong>破解这个私钥</strong> 的难度大大降低, 因为他只需要尝试 $ 2^{128} $ 种可能就可以了, 这远远小于比特币最初设计的 $ 2^{256} $ . 这个破解难度会随着合伙人增加而显著降低.</p><p>因此, 如果存在合伙人共享账户的情况, 请务必 <strong>使用多重签名(MultiSig)</strong> 的方式!</p><h3 id="12-3-比特币中的有限共识"><a href="#12-3-比特币中的有限共识" class="headerlink" title="12.3 比特币中的有限共识"></a>12.3 比特币中的有限共识</h3><p>我们此前提及分布式系统共识时, 提及过CAP, 即一个共识系统是无法保证 <strong>一致性(Consistency) &#x2F; 可用性(Availability) &#x2F; 分区可用性(Partition tolerance)</strong> 同时满足的, 那比特币怎么还能通过共识的形式成立?</p><p>事实上, 比特币系统中实现的也是 <strong>有限共识</strong> , 它并没有打破学术界的已知结论, 但它做到了在一些额外机制的参与下尽可能维护这个系统的持续运行. 一个典型的 <strong>有限共识</strong> 例子即分支攻击, 当分支攻击发生时, 原先已经被建立的共识也会被推翻.</p><hr><p>我们对于区块链第一部分(Bitcoin)的概述就到这里.</p><p>再次对北京大学对应课程组表达感激与敬意!</p><p>希望本篇博文能对读者系统的了解区块链的原理有一定的作用, 同时也权当对于知识的记录, 以供再度查阅.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part6</title>
      <link href="/posts/5693.html"/>
      <url>/posts/5693.html</url>
      
        <content type="html"><![CDATA[<h1 id="元素显示的进一步优化"><a href="#元素显示的进一步优化" class="headerlink" title="元素显示的进一步优化"></a>元素显示的进一步优化</h1><h2 id="元素层级"><a href="#元素层级" class="headerlink" title="元素层级"></a>元素层级</h2><h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><blockquote><p>上一节结尾我们留了一个问题，即一堆元素仍在一个HTML里面，这些玩意的层级怎么控制？需要记很多的结论嘛？</p></blockquote><p>我们在这里给出答案，完全不必要。</p><p>我们在Css中有这样一个属性， <strong>z-index</strong> 其存在最重要的意义就是调整页面中一堆元素的显示层级。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">z-index</span><span class="token punctuation">:</span> 100<span class="token punctuation">;</span><span class="token comment">/* 后面跟一个整数，这数越大，显示的就越靠上，默认值为0 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提一嘴，这个玩意是可以设置成负值的，全看读者的习惯。</p><p>当然，这玩意必须是用于定位（position）存在的情况下的，毕竟如果没有position的属性，页面上的元素压根不会相互遮挡是不是。</p><h3 id="父子关系-vs-元素层级？"><a href="#父子关系-vs-元素层级？" class="headerlink" title="父子关系 vs 元素层级？"></a>父子关系 vs 元素层级？</h3><p>有的读者可能挺好奇的，那我们平常子盒子总会默认显示在父盒子的上侧，我们有没有可能通过这个元素层级来让父盒子完全盖住子盒子？</p><p>答案是肯定的，但需要一定的方法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.father</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.son</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哎，我们一看，挺成功，就显示了父盒子的颜色。</p><p>但需要说明的是，如果我们这样设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">.father&#123;    ...    z-index:100;&#125;.son&#123;    ...    <span class="token comment">&lt;!-- z-index: --></span>    <span class="token comment">&lt;!-- 即子盒子不写z-index属性，仅通过父盒子设置 --></span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会发现没法子，子盒子还是在父盒子上边。<br>所以，这位置需要读者记忆一下。</p><h2 id="定位（确实，还是定位）"><a href="#定位（确实，还是定位）" class="headerlink" title="定位（确实，还是定位）"></a>定位（确实，还是定位）</h2><h3 id="居中，彻彻底底的居中！"><a href="#居中，彻彻底底的居中！" class="headerlink" title="居中，彻彻底底的居中！"></a>居中，彻彻底底的居中！</h3><p>此前第五部分说过了定位的事，为什么这里还要提？</p><p>这是因为通过定位，我们可以实现一个之前没试过的效果： <strong>让元素垂直居中</strong> 。</p><p>我们知道，让元素水平居中是很容易做到的：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但我们现在学了定位了，竖直居中就可以通过 <strong>绝对定位</strong> 来实现。</p><p>我们首先想到的应该是这个：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">position</span><span class="token punctuation">:</span> absoulte<span class="token punctuation">;</span><span class="token property">top</span><span class="token punctuation">:</span>50%<span class="token property">left</span><span class="token punctuation">:</span>50%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>读者可以试一下，我们会发现，这样搞的话就移大劲了，它移到了页面的中间偏右下方，这是由于两个50%分别是 <strong>页面顶部距离上边框的距离</strong> 和 <strong>页面左侧距离左边框的距离</strong> 。</p><p>那咋办捏？<br>好办，我们在说margin的时候单独提了一嘴，这玩意是支持负值的设置的，这时候就显出作用了。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absoulte<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哎，我们把这玩意通过负的margin再给它拽回来就完事了嘛。</p><p>相似的，我们如果要实现子盒子在父盒子里面的居中，自然也可以使用这种方法，无非是在父盒子里面设定一个 <strong>position: relative</strong> 而已。</p><h3 id="绝对定位-vs-浮动"><a href="#绝对定位-vs-浮动" class="headerlink" title="绝对定位 vs 浮动"></a>绝对定位 vs 浮动</h3><p>这俩玩意相信很多读者都懵的慌。</p><p>这里笔者仅仅给出一个不十分严谨的说法，即浮动是 <strong>半脱离文档流</strong> ，而绝对定位是 <strong>完全脱离文档流</strong> 。</p><p>这会造成一个什么差别捏？</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token comment">/* float: left; */</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Iusto debitis expedita delectus. Voluptates odit recusandae earum praesentium, quia incidunt suscipit expedita magni labore nemo velit animi molestias, odio voluptate aliquam!    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 ⬆ ，展现了绝对定位的情况，我们发现这绝对定位的盒子是一点面子也不给，直接碾着下面盒子里的内容。</p><p>如果我们改成:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box2</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.box1</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token comment">/* position: absolute; */</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会发现下边的盒子虽然上来了，但其内部的文字会绕着上面浮动的盒子走。形成了一个非常初步的 <strong>文字环绕</strong> 的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS 杂项</title>
      <link href="/posts/65424.html"/>
      <url>/posts/65424.html</url>
      
        <content type="html"><![CDATA[<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><blockquote><p>本部分是一个很杂乱的整理，目的在于收集一些博主学习HTML，CSS，JS这一套内容时看到的，值得写下来的花里胡哨的玩意。</p></blockquote><h2 id="画三角画三角"><a href="#画三角画三角" class="headerlink" title="画三角画三角"></a>画三角画三角</h2><p>我们常常在网页上看到三角形，而这玩意在CSS中就能实现，通过边框的重叠。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">text-indent</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1 .triangle_icon</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid transparent<span class="token punctuation">;</span>            <span class="token property">border-top</span><span class="token punctuation">:</span> 5px solid <span class="token function">rgb</span><span class="token punctuation">(</span>55<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 255<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> 2.5px        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1:hover .triangle_icon</span><span class="token punctuation">&#123;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid transparent<span class="token punctuation">;</span>            <span class="token property">border-bottom</span><span class="token punctuation">:</span> 5px solid <span class="token function">rgb</span><span class="token punctuation">(</span>55<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 255<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> -2.5px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        导航        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>triangle_icon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子展示了通过空盒子，加上仅对一边的边框进行设置，来进行三角形的实现。<br>同时，利用hover状态来实现鼠标移上去后的三角形变化。</p><h2 id="行内元素-块元素"><a href="#行内元素-块元素" class="headerlink" title="行内元素-&gt;块元素"></a>行内元素-&gt;块元素</h2><p>这玩意其实正文里面说过，但是还有几种 <del><em>歪门邪道</em></del></p><ul><li>display: block; 这是最平常的一种</li><li>float属性 当给一个行内元素设置上浮动属性的时候，会发现它会直接变成块元素</li><li>position: absolute 当设置绝对定位时，行内元素也会直接转为块元素</li></ul><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>即在页面内实现跳转的功能（有点类似于本博客右边栏的目录，只不过不加动画，仅用css实现）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">*</span><span class="token punctuation">&#123;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">ul</span><span class="token punctuation">&#123;</span>            <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>            <span class="token property">right</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">li</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black        <span class="token punctuation">&#125;</span>        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 1000px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#Part1</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#Part2</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#Part3</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> chartreuse<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">a</span><span class="token punctuation">&#123;</span>            <span class="token property">text-decoration-line</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#Part1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#Part2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#Part3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Part1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Part2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Part3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现方式是通过为跳转目标设定id，而后通过页面内a链接，将href设定为id选择器即可。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part5</title>
      <link href="/posts/6013.html"/>
      <url>/posts/6013.html</url>
      
        <content type="html"><![CDATA[<h1 id="溢出-元素显示"><a href="#溢出-元素显示" class="headerlink" title="溢出 元素显示"></a>溢出 元素显示</h1><blockquote><p>上一部分重点讲述了盒子模型，并了解了一些相关的性质，相信读者目前已经能够做出一些初级的网页了。</p></blockquote><h2 id="溢出属性"><a href="#溢出属性" class="headerlink" title="溢出属性"></a>溢出属性</h2><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>本部分首先需要了解的，是一个叫 <strong>溢出属性</strong> 的玩意，这东西的存在意义是当你的内容过多了，盒子放不下了的时候，提供一个美观的解决方法，我们用属性 <strong>overflow</strong> 来进行控制。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">overflow: visible / hidden / scroll / auto / inherit;<span class="token comment">&lt;!-- 表示正常显示（接在盒子后面） / 隐藏溢出内容 /  --></span><span class="token comment">&lt;!-- 增加滚动条（即使没有溢出也会有） / 自动（只有超出边界才会出现滚动条） / 继承父元素的设置--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，如果我们只想要某一方向单独设置滚动条，那可以这样做：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">overflow-x: auto;overflow-y: hidden;<span class="token comment">&lt;!-- 只在x方向上自动生成滚动条，y方向上超出部分直接隐藏 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="空余空间"><a href="#空余空间" class="headerlink" title="空余空间"></a>空余空间</h3><p>与上面的属性相似，这个属性是用于设置如何处理元素内的空白的，即 <strong>white-space</strong> 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">white-space: normal / nowrap / pre / pre-wrap / pre-line;默认值(浏览器直接忽略空白地区) / 不折行，占满空白(忽视本身盒子的限制) / 预格式化文本 / 预格式化+可折行 / 预格式化+不显示空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以提一嘴的是，pre这个玩意同时也是个标签，可以保留你在编辑器中文本的格式。</p><p>之所以要讲这个空余空间，是为了进一步实现让浏览器自动省略溢出内容的效果（即在后方加…）</p><p>我们可以这样设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">white-space: nowrap;overflow: hidden;text-overflow: ellipsis;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后这个玩意， <strong>text-overflow</strong> 是专门应对文本溢出的属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-overflow: clip / ellipsis;表示裁切 / 省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上，我们就达成了使浏览器自动处理溢出的文本的目的。</p><h2 id="元素显示类型"><a href="#元素显示类型" class="headerlink" title="元素显示类型"></a>元素显示类型</h2><blockquote><p>有的读者看到这标题可能挺疑惑的，为啥还要接着讲元素的显示？</p><p>事实上，如果读者尝试的次数比较多，尝试的元素类别也比较多的话，可以发现有些玩意加属性的时候，是成功不了的，比如给一个 <strong>span标签加宽高</strong> ，这就涉及到了我们接下来要聊一聊的元素显示相关的问题。</p></blockquote><p>css中将元素分为了三类：</p><ul><li>块元素</li><li>行内（内联）元素</li><li>行内块元素</li></ul><p>咱还是，一类一类来：</p><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>所谓块元素，就是通常而言以 <strong>矩形</strong> 的形式展示在HTML中的元素，它们是可以定义自己的宽高的，同时会按照书写顺序自上而下排列。</p><p>也正因为这种元素比较规矩，所以它们一般会作为其他元素的容器。</p><p>比较典型的块元素有：</p><ul><li>div</li><li>p</li><li>ul-li</li><li>ol-li</li><li>dt-dd</li><li>h(标题)</li></ul><p>当然，我们想要辨别一个网页里面什么是块元素也比较简单，我们可以通过浏览器的 <strong>检查</strong> 功能，选中该元素，而后在它的Style属性中查看到它的所有样式，其中应该会有这么一条:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">display: block;<span class="token comment">&lt;!-- 额外说一嘴，在ul的li中，会显示 display: list-item; --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里还有一点要提，p标签（段落标签）中，只能放文本以及行内元素， <strong>不能在里面嵌套块元素</strong> 。这里不进行理由的详述，读者可以自行尝试以下在p中嵌套一个块状元素会发生什么。</p><h3 id="行内元素（内联元素）"><a href="#行内元素（内联元素）" class="headerlink" title="行内元素（内联元素）"></a>行内元素（内联元素）</h3><p>内联元素与块元素不同，它们可以不经过浮动设置就呈现在浏览器的同一行，因为它们本身是没有自己的形状的，也正因如此，无法定义它们的宽高，它们的宽高是被内容撑起来的，包括内外边距也无法设置。</p><p>典型的行内元素有：</p><ul><li>a</li><li>b</li><li>em</li><li>i</li><li>span</li><li>strong</li></ul><p>(里面可能有些玩意读者忘了，可移步至本部分Part.1进行再次复习)</p><p>跟上边那块元素一样，这玩意在扔到浏览器里面也会默认自动加一行属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">display: inline;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3><p>这种玩意比较特殊，它具有行内元素和块元素两者的部分特点，它们可以设置宽高，但还是会优先在同一行内显示。</p><p>典型的行内块元素有：</p><ul><li>img</li><li>input</li></ul><p>这位，就跟之前那两位不是很一样。在img这个标签里，如果你不设置，它的element-style中啥都不写，而input（表单）标签会在它的样式里加一个：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">display: inline-block;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="元素类型转换"><a href="#元素类型转换" class="headerlink" title="元素类型转换"></a>元素类型转换</h3><blockquote><p>这玩意如果有一定编程基础应该挺好理解的，就很类似强转嘛</p></blockquote><p>有想法的读者估计又要说了，既然元素的类型是通过style设置的，我们是不是可以手动设置它的类型？</p><p>答案是肯定的。</p><p>我们可以通过在任何一个元素的style中加display属性，来实现它们元素类型的强制转化。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 再写一遍 --></span>display: block / inline / inline-block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这玩意有啥用呢？</p><p>我们假设一种情况，我们要做一个上边栏，里面插几个超链接，那我们如果不进行强转，直接就摁堆上去，会是种什么效果？</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">a</span><span class="token punctuation">&#123;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> 18px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>分区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>类别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>状况<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>实际<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>咱们会发现它们挤在一个小疙瘩里面，非常的不美观。</p><p>那我们学了盒子模型了，我们就寻思要不然给他加个外边距，内边距之类的，肯定能更好看一些。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">a</span><span class="token punctuation">&#123;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> 18px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>分区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>类别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>状况<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>实际<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者把上面这俩都运行一下，会发现下面这个明显要好看一些。<br>当然，可以在对a的hover之类的属性进行编辑，在外边再套一个div之类的，这里就不细讲了。此处仅仅是为了说明元素类型强制转化的作用。</p><h3 id="元素的隐藏"><a href="#元素的隐藏" class="headerlink" title="元素的隐藏"></a>元素的隐藏</h3><p>既然咱提到了display，咱就再聊一聊这东西还能干啥。</p><p>我们在有些网页里面经常看到一种效果，你把鼠标移上去的时候，它会在一侧弹出一个菜单，或者二级分类，这种效果我们其实现在能够简易的实现一下（因为咱们还没说JS，动画搞不了）：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">div:hover ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>这是个类别        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>二级菜单-类别1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>二级菜单-类别2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>二级菜单-类别3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <strong>display: none;</strong> 这个属性，可以使得原本写在页面上的元素先不显示出来，而我们在对其从属的盒子加一个鼠标移动上去的效果，即 <strong>hover</strong> ，就可以简单的达成我们的目的。</p><h2 id="二级菜单"><a href="#二级菜单" class="headerlink" title="二级菜单"></a>二级菜单</h2><blockquote><p>好嘞，咱说到了 display: none; 这玩意，那我们继续扩展一下子，用这个属性搞点切实有用的菜单出来呗。</p></blockquote><p>咱首先定下一个大框架：菜单的样式是横着排列的，当鼠标移上去，需要产生相应的颜色变更，此外，还需要在其下侧产生相应的二级选项。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">*</span><span class="token punctuation">&#123;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box .item</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 148px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> #00f2ffa2<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #00f2ffa2<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">ul</span><span class="token punctuation">&#123;</span>            <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aliceblue<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item:hover</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> #24c1caa2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item:hover ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item li:hover</span><span class="token punctuation">&#123;</span>            <span class="token property">color</span><span class="token punctuation">:</span> #24c1caa2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Category-1            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token punctuation">></span></span>Study Notes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Review<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Blog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Category-2            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>tag1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>tag2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>tag3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里其实没啥好讲的，因为用的都是之前说过的玩意，读者有遗忘的话可以善用本博客的搜索功能 <del>（笑）</del> 。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>咱继续往深了延申，我们目前已经实现了对于一个页面的二级菜单实现，但是很明显，我们搞出来的那玩意十分的不美观，它会很严重的挤压掉原先的内容（表现为直接使原先内容进行平移），这是令我们很不爽的事情。</p><p>我们当然首先想到的是将一个盒子直接摁死在页面的一个位置，在此前的内容中，我们会尝试着使用外边距 &#x2F; 内边距等属性进行实现，但其实css中对于这类情况单独给定了一个属性，即 <strong>position</strong> 。</p><h3 id="静态定位-相对定位"><a href="#静态定位-相对定位" class="headerlink" title="静态定位 &amp; 相对定位"></a>静态定位 &amp; 相对定位</h3><p>其实静态定位就是咱们之前不进行定位时达成的效果，其原则在于最大化的利用浏览器窗口空间，让一个个元素以其元素类型进行相应的位置放置。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: static;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而相对定位也比较简单，其效果为 <strong>使当前元素在相对于自己原先位置的基础上进行移动</strong> ，其标志物是自身原先的位置。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: relative;<span class="token comment">&lt;!-- 表示相对定位，常常会跟top，left等元素一并使用 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种定位方式的共同点在于，它们都 <strong>不会脱离文档流</strong> 。<br>啥意思呢？就是虽然你的这个元素可能看上去没有显示在原先的位置，但这个位置实际上被它占据着，后方的元素不会挤占这个元素最初始的位置。</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>所谓绝对定位，就是被设置这个属性的元素，会在 <strong>父盒子有定位的基础上</strong> <strong>在相对于其父元素的绝对位置进行显示</strong> （如果没有父元素则为浏览器窗口的 <strong>第一屏</strong>）。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: absolute;<span class="token comment">&lt;!-- 代表绝对定位 --></span>top: 100px;left: 100px;<span class="token comment">&lt;!-- 相对于父元素下偏100px，右偏100px --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言，我们如果想要实现一个子盒子在相对于父盒子的某一个位置显示，则可以 <strong>将父盒子设置为相对定位，再将子盒子设置为绝对定位，即 “子绝父相”</strong> 。</p><p>需要明确的是，绝对定位会使得当前元素脱离文档流，即其它的元素会直接占据它原本的位置。</p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>固定定位，目的在于实现一个无论什么时候都显示在浏览器一个固定位置的元素。</p><p>有的人要问了，这玩意应该能用之前的绝对定位轻而易举地实现啊？<br>答案是否定的，我们再度会看此前绝对定位的说法：</p><blockquote><p>如果没有父元素则为浏览器窗口的 <strong>第一屏</strong></p></blockquote><p>读者应该理解我在说什么了，即绝对定位只能使得我们在浏览器不进行滚动时看到固定在那个位置的元素，而当我们浏览器中内容过多，一屏放不下，需要进行滚动下滑时，原先利用绝对定位固定的元素也会跟着一块划走。这是不符合我们所需要的效果的。</p><p>因此，产生了固定定位这个玩意：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: fixed;<span class="token comment">&lt;!-- 代表固定定位，后续也需要相应的位置说明，这里不再详述 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样的，固定定位也会使得当前元素脱离文档流。</p><h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><p>粘性定位是相对而言比较新的一个玩意，这东西能使得一个元素在 <strong>滑动过它之后一直黏在窗口的某一个位置上</strong> 。</p><p>要举例的话，比如本博客的导航栏，它会在你下滑过后一直黏在上面，不随着页面滚动而消失。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: sticky;<span class="token comment">&lt;!-- 代表粘性定位，后面也需要相应的位置说明 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，其实吧，这种顶部粘性导航栏其实用JavaScript来做更好。 <del>（那当然了，一个傻大框子一直摁在上面确实比较难看哈）</del></p><hr><p>到这，读者可能就意识到一个关于HTML中层级显示的问题。即各种什么浮动，什么粘性显示、定位之类的玩意到底怎么判断显示方法。我们搁到下一篇博文说。</p><p>至此，我个人认为这篇博文差不多了。</p><p>这篇写的比较杂，没什么章法，烦请读者见谅。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part4</title>
      <link href="/posts/51901.html"/>
      <url>/posts/51901.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-4-CSS属性详述（2）"><a href="#Part-4-CSS属性详述（2）" class="headerlink" title="Part.4 CSS属性详述（2）"></a>Part.4 CSS属性详述（2）</h1><blockquote><p>在第三部分中，我们了解了文字属性，列表属性以及背景属性，在这一部分，咱们继续将css中的属性说完。</p></blockquote><h2 id="浮动属性"><a href="#浮动属性" class="headerlink" title="浮动属性"></a>浮动属性</h2><p>相信各位应该已经有所疑惑了，HTML中纵向排列貌似是一件非常简单的事情，但我们如果想要让一些元素在标签页上横向排列，就需要涉及到另一种css的内容， <strong>浮动属性</strong> 。</p><p>浮动属性在HTML中主要起两个作用：</p><ul><li>定义网页中的其它元素围绕某一特定元素显示</li><li>让原先纵向排布的元素横向排列</li></ul><blockquote><p>这里希望读者先理解为什么这玩意叫做 <strong>浮动</strong> ，它的意思是你可以让一个元素上浮到浏览器的另一个图层上（笔者其实也不确定图层这个说法准不准确，权且这么叫着吧），而下方的元素会顺次上移到原图层空出的位置，以此达到两个元素在同一个x轴的位置显示的效果。</p></blockquote><p>我们首先介绍一下最基本的浮动属性：</p><h3 id="浮动属性：float"><a href="#浮动属性：float" class="headerlink" title="浮动属性：float"></a>浮动属性：float</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">float: left / center / right;<span class="token comment">&lt;!-- 分别表示浮动于左侧 / 中间 / 右侧 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此，我们如果尝试着利用浮动属性，来让三个div横向显示：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.red</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.green</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.blue</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者可以将这段代码运行尝试一下，我们会发现，我们成功的使得三个色块从左至右的显示了出来，顺序为红 &#x2F; 绿 &#x2F; 蓝。</p><h3 id="清浮动"><a href="#清浮动" class="headerlink" title="清浮动"></a>清浮动</h3><p>问题来了，我们如果将上面代码中最后一个蓝色的div的浮动属性去掉，读者可以想象一下会产生什么效果？</p><p>答案是蓝色由于补上了红色和绿色空出的原图层的位置，它会被更高图层的红色方块挡住，这显然是有些难以接受的，它影响了我们后续内容的布局，这个问题在HTML中被称为 <strong>高度塌陷</strong> 。我们如果不希望蓝色被遮挡，这里有三种解决方案：</p><ul><li>固定代码</li><li>清浮动</li></ul><p>我们一种一种讲：</p><hr><p>第一种，所谓固定代码，即将横向布局的内容外再套上一层容器，给这个容器固定一个高度和宽度，使得这个容器能够在原图层占据浮动起来的高度，从而达到解决高度塌陷的目的。</p><p>以上面的例子做改动：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.red</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.green</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.blue</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.floating_area</span><span class="token punctuation">&#123;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>floating_area<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们对需要横向排列的两个玩意单独框了起来，而后对最外层的容器进行了高度设置。</p><hr><p>第二种，所谓清浮动，是css中提供的一个属性 <strong>clear</strong> ，它可以使得一个元素左侧或右侧没有浮动元素与它重叠，从而达到解决高度塌陷的效果。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">clear: none / left / right / both<span class="token comment">&lt;!-- 代表允许有浮动对象 / 不允许左侧有浮动对象 / 不允许右侧有浮动对象 / 不允许有浮动对象 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个属性要正确使用，需要加给 <strong>原先被遮挡的元素</strong> ，我们还是以上面的例子做修改：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.red</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.green</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.blue</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">clear</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 这里其实也可以在蓝色方块上直接加一个什么都没有的div，单独写一个行内样式： --></span>    <span class="token comment">&lt;!-- &lt;div style="clear: left;">&lt;/div> --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们为蓝色的方块加上了clear属性，使得它不再被遮挡了。</p><hr><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote><p>上面说完了浮动属性的一些基础内容，但我们现在如果想让两个div之间产生一些距离，可能还是有些无能为力（当然，读者可以直接加空的div设置宽度，但多少显得有些繁琐），这时，需要引入css中一个充当基石的模型， <strong>盒子模型</strong> 。</p></blockquote><p><strong>盒子模型</strong> ，即把每个内容都看作是一个盒子，这个模型主要包含四部分的内容：</p><ul><li>内容模块：盒子内需要显示些什么</li><li>内间距：内容模块与边框之间的距离</li><li>边框：一个盒子的外壳（有点类似于表格的最外层）</li><li>外间距：盒子与盒子之间的距离</li></ul><p>我们可以很轻易地想到，在HTML网页这个2D平面内，盒子自然是有上下左右四个方向的，因此，内间距 &#x2F; 边框 &#x2F; 外间距都可以进一步细分成四个量。</p><p>关于内容模块，其实没什么可说的，就是咱们要展示给读者的内容，在此略过不表。</p><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>在盒子模型中，内边距用属性 <strong>padding</strong> 进行控制，我们举个例子：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Et id, minus unde ad cumque, at animi modi dolorem voluptatibus, delectus voluptates ullam! Facilis autem illo vero distinctio nulla corrupti a!    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者可以跑一下试试，我们可以很清晰的看到，文字和边框是有一个很明显的间隔的，这就是内边距。</p><p>这时，我们又更挑剔了，我们希望能够分别设置内边距，即上下左右分别设置，也有方法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">padding: 20px 30px;<span class="token comment">&lt;!-- 只写两个值，代表上下，左右的两个值 --></span>padding: 20px 30px 10px;<span class="token comment">&lt;!-- 写三个值，代表上，左右，下的三个值 --></span>padding: 10px 20px 30px 40px<span class="token comment">&lt;!-- 写四个值，代表上，右，下，左的四个值（其实就是顺时针） --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们如果就想拿一个属性来控制某一个方向的内边距，也有相应的设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">padding-top: 20px;padding-bottom: 20px;padding-left: 20px;padding-right: 20px;<span class="token comment">&lt;!-- 分别代表上下左右的内边距 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提一嘴的时，当设置padding时，会导致盒子本身的大小有相应的增大。因此背景色是可以蔓延到内边距的位置的。</p><p>与此同时，如果我们需要手动设置某些元素的内边距为0 （比如ul中的左内边距），我们也可以通过这种方式达成目的。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>我们继续外延，在内边距的外侧紧跟着一圈边框，也是可以设置的属性，利用 <strong>border</strong> 进行控制。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">border: 5px solid red;<span class="token comment">&lt;!-- 第一个属性是边框的宽度 --></span><span class="token comment">&lt;!-- 第二额属性是边框的样式，有实线（solid）、双实线（double）、虚线（dashed）、点状线（dotted） --></span><span class="token comment">&lt;!-- 第三个属性是边框的颜色 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与内边距相似的，边框也可以对四个方向分别进行设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">border-topborder-bottomborder-leftborder-right<span class="token comment">&lt;!-- 后续跟的值与上述单写border时的形式完全相同 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，也有另一种写法，即将 border 拆分成 <strong>border-width border-style border-color</strong> ，而后在每个属性后多写几个值，也能达成分别控制四周的效果，具体逻辑与上文中相同，即：</p><ul><li>两个值：上下，左右</li><li>三个值：上，左右，下</li><li>四个值：上，右，下，左</li></ul><p>额外提一嘴，背景色是同样可以延伸到边框处的</p><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>咱们继续外延，紧接着边框的，就是外边距。利用 <strong>margin</strong> 进行控制。</p><p>这里的设置方式与padding几乎一致，同样的紧跟一个宽度；也可以设置1，2，3，4个值，控制的边框也与上方的原则相同；也可以分成 <strong>margin-top margin-bottom margin-left margin-right</strong> 四个属性进行书写。因此在这里不再详细叙述了，读者可参考上面的padding的写法。</p><p>二者明显的不同是背景色无法延伸至外边距处，此外，margin是支持负值的设置的：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">padding-top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-right</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid red<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>            <span class="token property">padding-top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-right</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid red<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们将第二个盒子的上侧外边距设置成了-50px，运行过后可以发现两个盒子纵向重叠到一块了。</p><p>除此之外，我们还有一种很常用的横向居中方案：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">margin:0 auto;<span class="token comment">&lt;!-- 上下外间距为0，左右外间距自动（即居中） --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>好了，我们已经大体搞明白了外边距这个玩意的作用，现在我们需要明确两个很容易碰到的问题：</p><ul><li>兄弟关系的盒子的垂直 &#x2F; 水平外边距问题</li><li>父子关系的盒子的外边距问题</li></ul><p>咱一个个说：</p><hr><p>所谓兄弟关系，就是这俩玩意在html中的地位是相同的，而俩盒子又在水平或竖直方向上相邻。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1, .box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上面的这两个盒子为例，我们原本的想象是，第一个盒子下外边距为100px，第二个盒子上外边距为50px，俩盒子应该距离150px才对，但我们发现最终俩盒子只隔了100px。</p><p>这个位置就需要额外记忆一下： <strong>竖直方向外边距取最大值</strong></p><p>但这个结论对于水平方向并不成立：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1, .box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">margin-right</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">margin-left</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们改成这个水平相邻的状况，会发现它们俩之间确实隔了150px，这证明了另一个结论： <strong>水平方向外边距会合并</strong> 。</p><hr><p>接下来我们谈父子关系的盒子，即外面一个大盒子包着里面一个小盒子。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这边，我们将一个小盒子包在一个大盒子里面，为小盒子设置一个上边距，我们本来想着应该可以达到小盒子与大盒子的边框之间相隔一个距离，但很遗憾，最终显示结果是大盒子距离上边界隔了一段距离，而小盒子仍然显示在大盒子的左上角。</p><p>要解决这个问题，有三种方法：</p><ul><li>变通方法，给父盒子加一个内边距（padding），缺点在于padding本身会扩大盒子的大小。</li><li>给父盒子设置边框，缺点同上，仍然会扩大盒子的大小。（可以把颜色设置为transparent，即透明的）</li><li>给子盒子 &#x2F; 父盒子添加浮动属性，使二者不在同一个图层上。</li><li>在父盒子的属性中加入overflow: hidden; 这个方法涉及到BFC相关的内容，在将来的博文中会进一步讲解。</li></ul><hr><p>好了，本篇博文主要针对浮动与盒子模型进行了对应的讲解。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part3</title>
      <link href="/posts/2300.html"/>
      <url>/posts/2300.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-3-CSS属性详述（1）"><a href="#Part-3-CSS属性详述（1）" class="headerlink" title="Part.3 CSS属性详述（1）"></a>Part.3 CSS属性详述（1）</h1><blockquote><p>从这一部分开始，我们来了解CSS中具体有哪些属性，各个属性的具体写法，具体作用。</p></blockquote><p>CSS中大体的属性类别有以下几类：</p><ul><li>文本属性</li><li>列表属性</li><li>背景属性</li><li>边框属性</li><li>浮动属性</li></ul><h2 id="CSS文本属性"><a href="#CSS文本属性" class="headerlink" title="CSS文本属性"></a>CSS文本属性</h2><p>写在前面，文本属性，目的在于对页面内的各类文本进行各种各样的修饰。</p><h3 id="大小和字体"><a href="#大小和字体" class="headerlink" title="大小和字体"></a>大小和字体</h3><p>在css中，文本大小用属性 <strong>font-size</strong> 来进行调整，其单位为 px ，即像素；而字体则通过属性 <strong>font-family</strong> 来进行调整：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">p</span><span class="token punctuation">&#123;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>        <span class="token comment">/* 16px是默认值，设计图中常用12px */</span>        <span class="token property">font-family</span><span class="token punctuation">:</span> 宋体<span class="token punctuation">;</span>        <span class="token comment">/* 直接写字体名字，默认值是微软雅黑 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    Lorem.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意，当字体名称中有空格时，两侧需要加引号。</p><p>还有一种为了兼容性考虑的写法，即font-family属性后可以写多个字体，两两用逗号相隔开，这时系统会从第一个字体开始逐个加载，直到找到成功加载的字体为止。</p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>在css中，字体颜色用属性 <strong>color</strong> 来进行调整。这个属性其实此前的博文有提及过，就不再赘述，但有几个别的写法可以在这里提一嘴：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">color: rgb(0, 0, 255);<span class="token comment">&lt;!-- 利用rgb的强度来混合颜色，三种颜色的强度值由0~255 --></span>color: #0000ff;<span class="token comment">&lt;!-- 利用16进制来进行rgb调色，六位数每两位分别代表red，green，blue的强度值。 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加粗和倾斜"><a href="#加粗和倾斜" class="headerlink" title="加粗和倾斜"></a>加粗和倾斜</h3><p>加粗，用属性 <strong>font-weight</strong> 进行控制；倾斜，用属性 <strong>font-style</strong> 进行控制。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">font-weight: bolder / bold / normal / lighter;<span class="token comment">&lt;!-- 三个可取值分别代表 更粗 / 加粗 / 正常 / 最细--></span>font-style: italic / oblique / normal;<span class="token comment">&lt;!-- 三个可取值分别代表 斜体字 / 微微倾斜 / 正常 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以再提一句：font-weight其实可以进一步细化调整，即后面直接跟数字，取值范围为100 ~ 900，100是最细的细体，400为正常，700为加粗，900为最粗</p><h3 id="文本水平的对齐-居中"><a href="#文本水平的对齐-居中" class="headerlink" title="文本水平的对齐 &#x2F; 居中"></a>文本水平的对齐 &#x2F; 居中</h3><p>文本的水平对齐通常利用 <strong>text-align</strong> 这个属性进行编辑</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-align: left / center / right / justify;<span class="token comment">&lt;!-- 左对齐 / 居中 / 右对齐 / 两端对齐--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但我们如果想让一段文本显示在一个中靠左的位置呢？<br>答案是先通过width来对一个单元占用的总宽度进行设置，而后再进行text-align的操作即可：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">width: 500px;text-align: right;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，只有左右对齐还不是很够，我们如果希望让文本两端都整整齐齐的，则需要利用到 justify，即两端对齐。</p><h3 id="文本的行高"><a href="#文本的行高" class="headerlink" title="文本的行高"></a>文本的行高</h3><p>说完文本的水平对齐，读者可能想着能否对竖直方向上的属性也进行一定的编辑，这里给出一种比较初级的方法，即调整行高：<br>在css中，行高通过 <strong>line-height</strong> 这个属性进行调整。单位为px，即我们很熟悉的像素。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">height: 100px;lineheight: 100px;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以先通过height设置区域的总高度，而后对行高进行对应的设置，即可达到文本居中显示的效果。</p><p>当然，这种方法在多行文本显示时显然就不是那么的友善了，这就要看此后提及的另一种方法了。</p><h3 id="文本间距"><a href="#文本间距" class="headerlink" title="文本间距"></a>文本间距</h3><p>在css中，文本间距由两部分组成：</p><ul><li>词间距</li><li>字符间距</li></ul><p>字符间距，即字符之间相隔的距离。我们通过 <strong>letter-spacing</strong> 这个属性进行调整，单位为px。</p><p>而对于英文，还有一个词间距的概念，即两个单词之间的距离。我们通过 <strong>word-spacing</strong> 这个属性进行调整，单位同样为px。</p><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p>首行缩进，这玩意其实可以通过我们在 Part1 中提到的 <strong>&amp;emsp</strong> 这个玩意实现，但是多少有点麻烦，因此css提供了另一种方式，即 <strong>text-indent</strong> 属性，这个属性可以手动控制你网页的首行缩进大小，单位仍然是px。</p><p>额外提一嘴，还有个单位可以用，即 <strong>em</strong> ，意为全角空格（可以理解为当前字体的单位大小）。这个单位存在主要是为了防止当字体大小被改变后原先设置的缩进值看起来不合适这一现象。<br>举个例子，中文缩进两个字符，就可以这么写：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-indent: 2em;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文本修饰线"><a href="#文本修饰线" class="headerlink" title="文本修饰线"></a>文本修饰线</h3><p>css中，也有相对应的文本修饰线的写法，利用 <strong>text-decoration</strong> 这个属性进行控制：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-decoration: underline / overline / line-through / none<span class="token comment">&lt;!-- 分别对应下划线 / 上划线 / 删除线（中划线） / 无线--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>读者应该会有些好奇none的意义，这个玩意主要用于修饰a链接，它可以使得一个超链接不带有下划线。</p><p>同时，其实可以同时设置多条线，即在一个text-decoration中写多个值，两个值之间用空格分隔即可。</p><h3 id="大小写检索"><a href="#大小写检索" class="headerlink" title="大小写检索"></a>大小写检索</h3><p>在css中，提供了一个对文本字母进行快速编辑的方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-transform: capitalize / lowercase / uppercase / none;<span class="token comment">&lt;!-- 代表单词首字母大写 / 全部字母小写 / 全部字母大写 / 不设置 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="文字混合属性-font"><a href="#文字混合属性-font" class="headerlink" title="文字混合属性 font"></a>文字混合属性 font</h3><p>font这玩意是为了偷懒用的，目的在于所见文本编辑时需要的代码量，它是 <strong>fong-style font-weight font-size&#x2F;line-height font-family</strong> 这一大串的缩写。</p><p>这上面的一串在使用时顺序不能改变，并且必须同时指定font-size和font-family。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">font: italic bolder 20px/1em 宋体; <span class="token comment">&lt;!-- 创建了一个斜体加粗，20像素大，一单位高的宋体文本格式 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="CSS列表属性"><a href="#CSS列表属性" class="headerlink" title="CSS列表属性"></a>CSS列表属性</h2><blockquote><p>接下来，咱们进入下一个部分，谈一谈列表的相关属性。</p></blockquote><p>我们还记得，在HTML中，列表（list）前方显示的分类标志可以进行初步的自定义，这是通过列表本身带有的属性 <strong>type</strong> 达成的。</p><p>而相似的，在css中，列表的分类符号也有自定义的方法。</p><h3 id="基本分类符"><a href="#基本分类符" class="headerlink" title="基本分类符"></a>基本分类符</h3><p>类似的，css也能实现HTML本身能够实现的几种基本图像，我们通过属性 <strong>list-style-type</strong> 进行编辑：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">ul</span><span class="token punctuation">&#123;</span>        <span class="token property">list-style-type</span><span class="token punctuation">:</span> disc / circle / square / none<span class="token punctuation">;</span>        <span class="token comment">/* 分别代表实心圆 / 空心圆 / 实心方块 / 不设置 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，都进入css这个领域了，再只能实现这样子的分类符，就显得有点简陋了。</p><h3 id="图片分类符"><a href="#图片分类符" class="headerlink" title="图片分类符"></a>图片分类符</h3><p>利用css，我们可以实现将列表前的分类符改为图片的效果，我们通过属性 <strong>list-style-image</strong> 进行控制：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">list-style-image: url()<span class="token comment">&lt;!-- 括号里放图片的存储位置 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里提一下，可以对ul里面的每个li分别进行设置，从而达到出现不同的分隔符的效果。</p><h3 id="列表项标记的放置位置"><a href="#列表项标记的放置位置" class="headerlink" title="列表项标记的放置位置"></a>列表项标记的放置位置</h3><p>css中还提供了一个属性，可以用于控制分类符的位置，但它其实只有两个取值：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">list-style-position: outside / inside<span class="token comment">&lt;!-- 分别代表显示在列表外 / 显示在列表内 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>html的默认值是outside，但这个属性用的非常少，读者了解即可。</p><h3 id="列表混合属性-list-style"><a href="#列表混合属性-list-style" class="headerlink" title="列表混合属性 list-style"></a>列表混合属性 list-style</h3><p>与文本属性类似，列表也给了一个偷懒的写法，即 <strong>list-style</strong> ，它是 <strong>list-style-type list-style-image list-style-position</strong> 的简写，当使用它时，只需要把上面三个属性用空格分开书写即可，并且在这里位置可替换。</p><p>其实上述提到的列表属性，用的最多的还是直接写一个：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">list-style: none;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为list-style-image这个属性插入的图片可定义程度不高，因此通常还是仅仅去除分类符即可。</p><h2 id="CSS背景属性"><a href="#CSS背景属性" class="headerlink" title="CSS背景属性"></a>CSS背景属性</h2><p>背景，即我们之前接触过的background，在此前的简要描述中，我们常用background-color这个属性，它就属于背景属性的一种。</p><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>如我们很熟悉的，css中编辑背景颜色利用属性 <strong>background-color</strong> 来进行。</p><p>值得提一嘴的是，这里的颜色同样支持利用此前提过的三种写法进行书写，同时，介绍第四个写法，它比此前的写法多了一个透明度的数字：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-color: red / rgb(255, 0, 0) / #ff0000 / rgba(255, 0, 0, 0.5);<span class="token comment">&lt;!-- rgba是带透明度的写法，最后一个值取值范围在0~1之间，代表透明度 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="背景颜色渐变"><a href="#背景颜色渐变" class="headerlink" title="背景颜色渐变"></a>背景颜色渐变</h3><p>这里其实css提供了一种背景颜色渐变的方法，可以用属性 <strong>gradient</strong> 来进行设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background: linear-gradient(black, white);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，这只是最基础的渐变方法，这里给出一个说明链接，读者自行查看即可：</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients</a></p></blockquote><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>类似，我们可以给一个区域贴上一个图片，这就可以通过 <strong>background-image</strong> 这个属性进行实现：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-image: url()<span class="token comment">&lt;!-- 括号里填图片地址 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，图片本身占用像素与我们设定的区域很大可能并不相同，这就需要另一个属性来进行协调，即图片平铺。</p><h3 id="图片显示方法"><a href="#图片显示方法" class="headerlink" title="图片显示方法"></a>图片显示方法</h3><p>我们可以更改背景图片的显示模式，从而达到更好的预览效果，通过属性 <strong>background-repeat</strong> 来达成：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-repeat: repeat / repeat-x / repeat-y / no-repeat;分别代表正常平铺 / 在x轴平铺 / 在y轴平铺 / 不平铺<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="图片显示位置"><a href="#图片显示位置" class="headerlink" title="图片显示位置"></a>图片显示位置</h3><p>相对应的，当区域大于图片大小，或者区域小于图片大小时，我们可以通过对属性 <strong>background-position</strong> 进行定义，从而实现图片展示位置（或区域的不同）：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 默认置于左上角 --></span>background-position:20px 20px<span class="token comment">&lt;!-- 距离左上角多少像素 --></span>10% 10%<span class="token comment">&lt;!-- 距离左上角的距离占整个区域的大小百分比 --></span>left/center/right top/center/bottom<span class="token comment">&lt;!-- 水平位置和竖直位置 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图片显示大小"><a href="#图片显示大小" class="headerlink" title="图片显示大小"></a>图片显示大小</h3><p>此后，我们还可以通过调节图片显示在区域内的大小来实现更好的显示效果，用 <strong>background-size</strong> 进行编辑：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-size: 500px 500px;100% 100%;cover;<span class="token comment">&lt;!-- 这个值代表等比例放大，直到它能够完全覆盖整个区域为止 --></span>contain;<span class="token comment">&lt;!-- 这个值代表等比例放大，直到再放大就会导致图片不能完整展示为止 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于对图片进行了拉伸。</p><h3 id="背景图片的固定"><a href="#背景图片的固定" class="headerlink" title="背景图片的固定"></a>背景图片的固定</h3><p>css额外提供了一个属性叫 <strong>background-attachment</strong>，它用于控制背景是否会随着鼠标滚轮的滚动而随网页一起滑动。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-attachment: scroll / fixed;<span class="token comment">&lt;!-- 分别代表正常滚动 / 不随网页一起滚动 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当设置成fixed时，相当于在当前页面呼出了一个独立页面单独显示这个背景，而相应的这个背景就被你固定在了网页的那个位置。</p><p>这个属性常常用于制作视差效果。</p><p>这里给出一个简要的例子：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 3000px<span class="token punctuation">;</span>            <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>../image/test_image1.webp<span class="token punctuation">)</span></span><span class="token punctuation">;</span>            <span class="token property">background-size</span><span class="token punctuation">:</span> 500px 300px<span class="token punctuation">;</span>            <span class="token property">background-repeat</span><span class="token punctuation">:</span> no-repeat<span class="token punctuation">;</span>            <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 3000px<span class="token punctuation">;</span>            <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>../image/test_image2.jpg<span class="token punctuation">)</span></span><span class="token punctuation">;</span>            <span class="token property">background-size</span><span class="token punctuation">:</span> 500px 300px<span class="token punctuation">;</span>            <span class="token property">background-repeat</span><span class="token punctuation">:</span> no-repeat<span class="token punctuation">;</span>            <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 上面的图片地址读者可以自行替换成自己的图片地址 */</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用上述方法，我们放了两个fixed的背景图片，会显示在浏览器窗口的同一个位置，而只有当滚轮滚到这个图片属于的区域时，这个图片才会显示出来，这就实现了随着滚轮下滑，第一个图片消失，而第二个图片同时出现的效果。</p><h3 id="背景混合属性-background"><a href="#背景混合属性-background" class="headerlink" title="背景混合属性 background"></a>背景混合属性 background</h3><p>同理，与文字 &#x2F; 列表类似，背景的属性也是可以被混合书写的，就是简单的 <strong>background</strong> ，它里面可以包含 <strong>background-color background-image background-repeat background-position background-attachment</strong> 等等一系列属性，只需要使其中间利用空格分隔开即可。</p><blockquote><p>background-size是不能扔进去的，必须单独写。</p></blockquote><blockquote><p>另外，background这个玩意只要写了，它会把此前除了background-size之外对background进行的一系列设置全部覆盖掉。</p></blockquote><h3 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h3><p>这里可以还需要加一栏，关于透明度的说明。</p><p>css中单独提供了一个属性，即 <strong>opacity</strong> 来对相应元素的透明度进行控制，取值范围为 0 ~ 1 ，1为完全不透明，0为完全透明。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">opacity: 0.7;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>这篇博文将博主目前能想到的都写上了，至于后续如果看到一些别的属性，也会相应的在这里进行更新。</p><p>至此，还差浮动属性和边框属性没写，咱们留给后续的博文吧。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part2</title>
      <link href="/posts/54588.html"/>
      <url>/posts/54588.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-2-进入CSS"><a href="#Part-2-进入CSS" class="headerlink" title="Part.2 进入CSS"></a>Part.2 进入CSS</h1><blockquote><p>第一部分中，我们谈完了html的一些基本标签，但是它们的样式多少还有些简朴，要想加点花里胡哨的玩意，就还得看css的内容</p></blockquote><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><p>读者如果进行了一些尝试的话，可以发现HTML的表格，表单都十分的简朴，甚至简陋， <del>不够花里胡哨</del> ，这在前端设计中是不可接受的，因此我们这里引出CSS的样式表。</p><blockquote><p>CSS，cascading style sheets，译为层叠样式表，是web中的表现标准语言，可以达成修改网页显示信息的样式的目的，目前遵循CSS3.0的标准</p></blockquote><h3 id="CSS的组成部分"><a href="#CSS的组成部分" class="headerlink" title="CSS的组成部分"></a>CSS的组成部分</h3><p>CSS的基本组成部分有 <strong>选择符</strong> 和 <strong>声明</strong> ，而每条声名内又由 <strong>属性</strong> 与 <strong>属性值</strong> 组成</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">选择符</span><span class="token punctuation">&#123;</span>    <span class="token property">属性</span><span class="token punctuation">:</span> 属性值<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要说明的是，css的书写是和html同时存在的，但显然直接把css的玩意扔到body中，显得就有些突兀，也很杂乱，因此，我们通常利用html中的 <strong>style</strong> 标签框住css的内容。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        这是个例子        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">h1:</span><span class="token punctuation">&#123;</span>                <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>第一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过上述的例子实现了将所有的第一级标题都更改为红色。</p><p>这里有个众人一块规定的事情，因为文中出现太多style有点影响观感，也不方便阅读，因此我们一般将style写到head中。</p><h3 id="内部样式-外部样式"><a href="#内部样式-外部样式" class="headerlink" title="内部样式 &amp; 外部样式"></a>内部样式 &amp; 外部样式</h3><p><strong>内部样式</strong> ，即 <strong>将对当前html文件起作用的css直接通过style标签写在html内部</strong> ，也就是上方咱们进行css引入的方法。</p><p>但这种方式对于html结构很复杂，内容很繁多的情况就不是很友好，每次想要修改标签还需要翻到文件最上方，不方便。</p><p>因此 <strong>外部样式</strong> 是更常用的一种方法，即在文件外单独写一个css，在需要使用这个css的html中利用 <strong>链接</strong> 来告知html文件需要套用的css内容。</p><p>关于外部样式的链接方式，通常有以下两种：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 第一种 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">herf</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>Css文件路径<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 第二种 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    @import <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>      <span class="token comment">/* 括号里是Css文件的路径 */</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两种方式还是有一定的区别的：</p><ul><li>link标签是XHTML提供的标签，而@import是css提供的方式</li><li>当一个页面被加载时，link引用的css会被同时加载，但@import引用的css会等待页面加载完成后再进行加载，这会导致使用@import引用的css在网速比较慢时页面会出现闪烁</li><li>@import在较老的浏览器（IE5以下）是不兼容的</li></ul><p>因此，在引入标签时，还是建议更多的使用link标签的方式。</p><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><p><strong>行内样式</strong> ，即在html中的某一行单独运用style属性对该标签的样式进行个性化编辑</p><p>像这样：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token special-attr"><span class="token attr-name">style</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>11111111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这玩意尽量不要用太多，因为这东西还是会影响文件可读性的。</p><h3 id="样式表的优先级"><a href="#样式表的优先级" class="headerlink" title="样式表的优先级"></a>样式表的优先级</h3><p>上面讲了三种样式：内部样式、外部样式、行内样式，如果这仨全都存在，则它们总归会有一个顺序优先级的问题。</p><p>这里给出明确结论，内部样式和外部样式的作用取决于谁在head标签更靠下的位置（即谁最后加载），但一般html的书写习惯是将link标签写在style标签上方。</p><p>同理，外部标签与内部标签的优先级都不如行内标签高。</p><p>因此基本上可以说：行内样式 &gt; 内部样式 &gt; 外部样式</p><p>当然，还有一种特殊情况，即 <strong>!important</strong> 标签的存在会使当前指向的样式优先生效。</p><p>总结一下：!important &gt; 行内样式 &gt; 内部样式 &gt; 外部样式</p><p>这里推荐以代码的自上而下的执行顺序来对优先级进行理解。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p><strong>选择器</strong> 的存在是为了实现对html内元素的一对一，一对多的控制。</p><p>存在以下几种类别：</p><ul><li>元素选择器</li><li>类选择器</li><li>id选择器</li><li>通配符选择器</li><li>群组选择器</li><li>包含选择器</li><li>伪类选择器</li></ul><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p>元素选择器就是之前咱们css的写法，即通过选择某一类的元素并添加相应的样式。</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>元素选择器的范围有些太广了，因此我们还需要进行进一步的细分，这就催生了 <strong>类选择器</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* 在指定样式时需要前方加. */</span>    <span class="token selector">.type1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.type2</span><span class="token punctuation">&#123;</span>        <span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 一个标签可以有多个类，中间用空格分隔 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>type1 type2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以理解为，类选择器就是人工将各种标签重新进行了分类。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器与类选择器有些相似，但是id选择器是一对一的，相当于对一个单独的玩意起一个单独的id，在css文件中单独开一片区域来对其进行单独的样式设置。（有点类似身份证号）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* 在指定id之前加# */</span>    <span class="token selector">#box1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 一个标签相应的只能有一个id --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>111111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p><strong>通配符</strong> 顾名思义，即选择所有元素的意义，在html中用 * 进行表示。</p><p>这种选择器会直接选择到一个html中所有的标签，通常用于对所有标签的属性进行整体调试，比如间距等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">*</span><span class="token punctuation">&#123;</span>        <span class="token comment">/* 外边距 */</span>        <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token comment">/* 内边距 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="群组选择器-包含选择器"><a href="#群组选择器-包含选择器" class="headerlink" title="群组选择器 &amp; 包含选择器"></a>群组选择器 &amp; 包含选择器</h3><p>其实群组选择器这玩意就是偷懒用的，如果一个html中存在多个不同的标签，但是想要设置成一个样式，一方面可以用类，但更方便的方法则是利用群组选择器：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">div, p, h1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 当然，也可以直接把类也写进去 */</span>    <span class="token selector">div, .class1, h1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token comment">/* 相当于所有的class1类也都设置了背景颜色 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们可以直接将不同的标签一块写，用逗号隔开即可。</p><p>由此，我们又衍生出了一个叫做包含选择器的玩意（也叫后代选择器），其意义在于选择一个包含在一个标签内的标签。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">div p</span> <span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>        <span class="token comment">/* 在div内的p都会受到影响 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>2222222222    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is first paragraph.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器主要针对标签进行个性化编辑。主要有四种语法，对应标签具有的四种状态：</p><ul><li>a:link{} 标签的初始状态</li><li>a:visited{} 标签被访问后的状态</li><li>a:hover{} 鼠标悬停在标签上的状态</li><li>a:active{} 标签被激活（即鼠标按下标签时其状态）</li></ul><p>这里需要明确，即这四个状态在css中的顺序是固定的，即上方列举的顺序，请务必注意。</p><h3 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h3><p>上边讲了一堆选择器，针对的是不同的标签，但当多个选择器选中了一个标签，并且它们的属性发生了冲突的时候，就涉及到了一个选择器的权重的问题（即哪个选择器中的样式真正对其起作用）</p><p>从尝试结果上来讲，规律为：</p><p>!important &gt; id选择器 &gt; 类选择器 &gt; 元素选择器</p><p>至于包含选择器，其权重为层级权重之和，此后再根据上方的规则进行生效判断。</p><p>当然，上述除了important之外的玩意，在行内样式面前，都无法生效（即在标签内直接写一个style）</p><p>这里额外说一句，上面写过 <strong>样式表的优先级</strong> ，那只是一个大致叙述，而这里则细化到了 <strong>选择器的权重</strong> 。一个样式表是可以包括很多选择器的。</p><hr><p>至此，我们算是初步了解了css的作用，并明确了css应当如何书写，如何与html相关联。这时候读者大概率会想大展宏图，对自己的html网页一同改头换面了。</p><p>下一节，将进入各种css中各种属性的详细设置。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part1</title>
      <link href="/posts/54396.html"/>
      <url>/posts/54396.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-1-概述-一些基础"><a href="#Part-1-概述-一些基础" class="headerlink" title="Part.1 概述 &amp; 一些基础"></a>Part.1 概述 &amp; 一些基础</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（HyperText Markup Language）是一种用于创建网页的标准标记语言，这种语言与此前的C，Java并不十分相同，它的用处主要停留在前端开发的层面上，不会像先前的两门那样那么复杂。</p><p>相应的，目前的浏览器支持的主流格式也以相应的语言后缀进行命名，即（）.html</p><h3 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h3><p>浏览器千千万，不同的浏览器对HTML的标记支持也不尽然相同，这就催生了一群大佬在一块商讨了一个标准出来，规定web的格式规范等等内容，即我们说的 <strong>W3C</strong> 万维网联盟</p><p>这个联盟制定了相应的标准，使得同样的HTML文件在大部分浏览器下能够正常，正确的显示。</p><p>当然，总有个例，在目前已经停用的IE6浏览器中，由于当年微软独树一帜地决定不遵循W3C的标准，因此导致当年写HTML时还要专门对IE6进行一定的适配工作，也是导致IE6名声很臭的原因之一。<del>（后续微软没办法还是在后续的IE版本中进行了W3C的支持）</del></p><h3 id="Web的组成部分"><a href="#Web的组成部分" class="headerlink" title="Web的组成部分"></a>Web的组成部分</h3><p>总而言之，前端的需求内容有三部分：</p><ul><li>HTML结构</li><li>CSS表现</li><li>JS（JavaScript）行为</li></ul><p>HTML规定了网页的结构，但它局限于静态，不好看。<br>CSS可以对网页进行进一步的布局，配色，以及动画制作<br>Javascript则负责一些网页行为的实现，比如点按操作，动画播放，暂停等等。</p><h2 id="第一个HTML文件"><a href="#第一个HTML文件" class="headerlink" title="第一个HTML文件"></a>第一个HTML文件</h2><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt; &lt;!--    我的第一个网页--&gt;&lt;html lang &#x3D; &quot;en&quot;&gt;    &lt;head&gt;        &lt;title&gt;My first HTML pages&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;center&gt;            Hello,&lt;br&#x2F;&gt;World.        &lt;&#x2F;center&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;!--    html: 最外层标签    head: 头部标签    body: 主体标签    常规标记：类似上述的，有头有尾的    单标记（空标记）：&lt;标记&#x2F;&gt;，可以没尾    这里的&lt;br&#x2F;&gt;是换行的意思--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的玩意大伙看一眼就成，下面会分块的进行基本概述</p><h2 id="标签详述"><a href="#标签详述" class="headerlink" title="标签详述"></a>标签详述</h2><h3 id="文档声明与字符编码"><a href="#文档声明与字符编码" class="headerlink" title="文档声明与字符编码"></a>文档声明与字符编码</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在html中，第一步要做的永远是先声明文档类型，即告诉你的浏览器你写的是个什么玩意，在2024年的今天，主流的文档类型是HTML5。</p><p>而后，可以选择性的写入你这个文档的编码类型，由于不同的字符编码规则不同，因此声明编码类型可以帮助浏览器了解应该按照哪种原则进行解码，解决一些兼容性问题。</p><p>需要保证你写的编码格式与你编写HTML程序时的编码类型相同。</p><h3 id="文本的语义化"><a href="#文本的语义化" class="headerlink" title="文本的语义化"></a>文本的语义化</h3><blockquote><p>读一段文字，我们必然希望文字是有重点，有分隔的，而并非是杂糅成一团来进行呈现，这一过程就叫做 <strong>文本的语义化</strong></p></blockquote><p>这里，给出一些常用的语义化标签：</p><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>三级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>四级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span><span class="token punctuation">></span></span>五级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>额外说一嘴，一级标题的数量不建议过多，这是因为网页爬虫会将一级标题放到权重最大的位置，因此一级标题应该是你书写HTML时最简练，最精准的内容概括。</p><h4 id="段落-换行-水平线"><a href="#段落-换行-水平线" class="headerlink" title="段落 &#x2F; 换行 &#x2F; 水平线"></a>段落 &#x2F; 换行 &#x2F; 水平线</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>段落文本内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三者中，换行与水平线是两个空标记。</p><h4 id="加粗-倾斜-各种线"><a href="#加粗-倾斜-各种线" class="headerlink" title="加粗 &#x2F; 倾斜 &#x2F; 各种线"></a>加粗 &#x2F; 倾斜 &#x2F; 各种线</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 加粗 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>加粗的内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>突出的文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 倾斜 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>强调文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">></span></span>斜体内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 删除线 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>s</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>s</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 下划线 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">></span></span>下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 上下标 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sub</span><span class="token punctuation">></span></span>下标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sub</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sup</span><span class="token punctuation">></span></span>上标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sup</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了便于爬虫处理，在处理时推荐使用</p><ul><li>strong</li><li>em</li><li>del</li></ul><h3 id="关于属性值的一些说明"><a href="#关于属性值的一些说明" class="headerlink" title="关于属性值的一些说明"></a>关于属性值的一些说明</h3><p>我们可以看到HTML给了我们很大的操作空间，但同时也有问题，如果我们希望更改一条线的颜色，长度这一类的 <strong>属于其标记本身的属性</strong> ，那这时， <strong>标记的属性值</strong> 就显得尤为重要了。</p><p>我们回到两类标记上：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 双标记 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标记</span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>标记</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 单标记 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标记</span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到标记本身后方是可以附加属性的。</p><p>我们拿很常见的分割线 hr 来举例</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">color</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>green<span class="token punctuation">"</span></span> <span class="token attr-name">width</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">align</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">noshade</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过第一个操作，我们可以达成：</p><ul><li>线的颜色为绿色: color</li><li>线的长度为300px（像素）: width</li><li>线的位置在右侧: align</li></ul><p>通过第二个操作，可以达成：</p><ul><li>去除默认分割线的阴影效果</li></ul><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>由于HTML本身是个标签语言，在我们需要用到标签内的字符是，这是就涉及到了特殊符号的问题<br>（其实这个玩意挺像C里面想要打反斜杠&#x2F;时候的办法）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 左尖角 --></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span><span class="token comment">&lt;!-- 右尖角 --></span><span class="token entity named-entity" title="&gt;">&amp;gt;</span><span class="token comment">&lt;!-- 空格 --></span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span> //这玩意受到字体的影响，可能会导致一些问题<span class="token entity named-entity" title="&emsp;">&amp;emsp;</span> //稍微好一些<span class="token comment">&lt;!-- 当然，其实用CSS进行空格的书写才是更应当推广的方式，这里先权且这样放着 --></span><span class="token comment">&lt;!-- 版权符 --></span><span class="token entity named-entity" title="&copy;">&amp;copy;</span><span class="token comment">&lt;!-- 商标 --></span><span class="token entity named-entity" title="&trade;">&amp;trade;</span><span class="token entity named-entity" title="&reg;">&amp;reg;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="div-span"><a href="#div-span" class="headerlink" title="div &amp; span"></a>div &amp; span</h3><blockquote><p>这两个标签是没有具体意义的，但这二者对于一个HTML页面的分割，划分很有作用</p></blockquote><p>div在直接使用时，会独占一行，作为一个区域的元素。</p><p>span在使用时，能实现内容多宽，就占用多宽的空间距离，常用于独立修饰文本。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>I like <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>gray<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 我们实现了一个标题中对于一个单词的单独修饰 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要提一嘴的是，span单独写是没什么用的，span一般而言需要配合各类属性，样式来进行使用</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><blockquote><p>列表常用于对分类的事物进行罗列</p></blockquote><p>在HTML中，列表有这么几类：</p><ul><li>无序列表：前面没有标号</li><li>有序列表：前面有相应的行号</li><li>自定义列表：形式更加多样</li></ul><p><del>(这玩意尝试写过markdown的看官应该会比较熟悉)</del></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表的标签：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- orderlist --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ol</strong> 标签里面只能包含 <strong>li</strong> 标签，而 li 标签里面就可以加一些花里胡哨的玩意了。</p><p>此外，ol标签本身也可以加一些属性：</p><ul><li>type属性：有序列表前方的标号从什么符号开始：<ul><li>“a” : 小写字母开始</li><li>“A” : 大写字母开始</li><li>“i” : 小写罗马数字开始</li><li>“I” : 大写罗马数字开始</li><li>“1” : 数字1开始</li></ul></li><li>start属性：有序列表从哪个位置开始计数，其取值只能是一个数字</li></ul><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表本身没有顺序之分，因此比有序列表相对简单一些</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- unorderlist --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，ul标签里面也只能放li标签，至于花里胡哨的玩意请放在li内搞</p><p>无序列表前面默认是一个黑色实心圆，其样式可以通过type属性来进行更改：</p><ul><li>“disc” : 黑色实心圆</li><li>“circle” : 黑色空心圆</li><li>“square” : 黑色实心正方形</li><li>“none” : 隐藏，什么都不显示</li></ul><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>这里可以放图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>这里可以放文字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>自定义列表通常整体进行复制，从而方便对每个自定义列表进行单独的样式编辑</p><h3 id="一种缩写"><a href="#一种缩写" class="headerlink" title="一种缩写"></a>一种缩写</h3><p>当我们需要进行多个标签的书写时，可以通过Emmet缩写进行快捷写入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">ol>li&#123;Part&#125;*3<span class="token comment">&lt;!-- 一个具有三个项的有序列表，每个项的内容都是Part --></span>dl>dt&#123;图片&#125;+dd&#123;文字&#125;<span class="token comment">&lt;!-- 一个自定义列表 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片在html中使用 <strong>img</strong> 标签进行插入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>图片的相对路径<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，一般进行html的图片插入时，使用 <strong>相对路径</strong> 。（绝对路径在服务器中不起效果）</p><p>具体相对路径的写法，建议读者自行上网进行了解，这其中涉及到一些Linux的相关知识。</p><h3 id="图片的属性"><a href="#图片的属性" class="headerlink" title="图片的属性"></a>图片的属性</h3><p>对于图片，主要有以下属性：</p><ul><li>src : 即图片的路径（通常为相对路径）</li><li>title : 即鼠标悬停到图片上会显示什么信息</li><li>alt : 图片如果加载不出来会显示的提示信息</li><li>width : 宽度</li><li>height : 高度</li></ul><p>当我们需要让图片自动缩放时，可以只对宽度或高度中一个属性进行预设，可以达到自动缩放的效果。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>超链接，目的在于在不同的html界面中进行跳转</p><p>其具体写法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">title</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">target</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>超链接内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这其中：</p><ul><li><strong>超链接内容</strong> 表示这个跳转链接的显示内容（就是哪个蓝底字的具体内容）</li><li><strong>herf</strong> 表示链接路径</li><li><strong>title</strong> 表示鼠标悬停上去后的显示信息</li><li><strong>target</strong> 表示在哪个位置打开文档<ul><li>“_self” : 默认值，在当前窗口打开新页面</li><li>“_blank” : 在新窗口打开跳转页面</li></ul></li></ul><p>还需要说个事，就是超链接的内容可以是多种多样的，可以是文字，也可以是个图片（利用img标签），这样可以实现点击图片跳转的效果，思路要打开。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这部分就顾名思义，就是咱们平常常见的表格了，其有 <strong>行</strong> ， <strong>列</strong> 等等属性。</p><p>在HTML中，表格的创建如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- tr表示行 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- td表示单元格 --></span>            1        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>            2        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表格-table-的相关属性"><a href="#表格-table-的相关属性" class="headerlink" title="表格(table)的相关属性"></a>表格(table)的相关属性</h3><p>表格总共有8个属性：</p><ul><li>边框线：border &#x3D; “1” ，后方这个数字是表格外边框的像素大小</li><li>宽度：width &#x3D; “500”，同理（也可以写成width &#x3D; “50%”，表示相对于父元素的百分比，直接写的话就是窗口）</li><li>高度：height &#x3D; “500”，同理（同上，也可以通过百分比，但是高度的父元素（即body部分）是由内容决定的，因此不会达到直接占据页面一半这么高的效果）</li><li>位置：align &#x3D; “left &#x2F; center &#x2F; right”，表示表格在横向占据的位置</li><li>背景颜色：bgcolor &#x3D; “blue”</li><li>边框颜色：bordercolor &#x3D; “red”</li><li>单元格之间的间距：cellspacing &#x3D; “0”</li><li>单元格与内容之间的间距：cellpadding</li></ul><h3 id="表格行-tr-的相关属性"><a href="#表格行-tr-的相关属性" class="headerlink" title="表格行(tr)的相关属性"></a>表格行(tr)的相关属性</h3><p>表格行总共有4个属性：</p><ul><li>高度：height</li><li>颜色：color &#x3D; “yellow”，在表格本身有颜色时，这一行会相应的覆盖掉之前的颜色</li><li>文字对齐相关：<ul><li>水平对齐：align &#x3D; “left &#x2F; right &#x2F; center”，同理</li><li>竖直对齐：valign &#x3D; “top &#x2F; middle &#x2F; bottom”，同理</li></ul></li></ul><h3 id="表格单元格-td-的相关属性"><a href="#表格单元格-td-的相关属性" class="headerlink" title="表格单元格(td)的相关属性"></a>表格单元格(td)的相关属性</h3><p>表格单元格总共有5个属性：</p><ul><li>宽度：width，这里要注意，一个单元格设置了宽度，会影响一整列的宽度</li><li>高度：height，同理，一个单元格设置了高度，也会影响一整行的高度</li><li>颜色：bgcolor</li><li>文字对齐相关：<ul><li>水平对齐：align</li><li>竖直对齐：valign</li></ul></li></ul><h3 id="表格的合并列-合并行"><a href="#表格的合并列-合并行" class="headerlink" title="表格的合并列 &amp; 合并行"></a>表格的合并列 &amp; 合并行</h3><p>表格合并列 &#x2F; 行通常这样写：</p><ul><li>colspan &#x3D; “2”，合并列，后方的值即合并后其占据的单元格数目</li><li>rowspan &#x3D; “3”，合并行，后方的值同理</li></ul><p>这里要注意，在合并后，需要将被合并的单元格注释掉，否则会呈现出一种被合并的单元格被 <strong>挤出去</strong> 的感觉。</p><p>咱们要想了，咱这表格都整出来了，是不是该进行一点点自定义化，比如说能在里面输入各种各样的东西之类的？</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单，其最重要的目的，就在于收集信息。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span> <span class="token attr-name">action</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    用户信息：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里咱们得一个个讲：</p><ul><li>form的属性：<ul><li>method &#x3D; “get &#x2F; post”</li><li>action &#x3D; “向何处发送数据”</li></ul></li><li>input内的属性：<ul><li>type &#x3D; “text &#x2F; password &#x2F; submit &#x2F; button &#x2F; reset” 他们分别表示文本输入区，密码输入区，提交按钮，常规按钮，重置功能</li><li>placeholder &#x3D; “显示的简短提示信息”</li><li>name 必须设置，表示提交给后端时能被识别到的名字</li><li>value 常常与按钮一并使用，可以表示按钮上显示的内容</li><li>outline 表示输入框外侧是否会存在一圈边框</li></ul></li></ul><p>我们需要明确，既然要收集信息，就必定有发射端与接收端，而接收端就在form的action属性内进行说明，而 get &#x2F; post 目的在于提交过后不会对你提交的信息在网址框内进行明确显示。</p><p>在后面的工作中，我们常常使用 “input type &#x3D; button” ，这意味着我们创建了一个完全可自定义的按钮，会在此后的JS行为中对其进行进一步的定义（如校验密码之类的操作可以在这个过程内完成）</p><hr><p>这个坑开的十分的突然，其实主要是博主有了相应的需求，需要了解一下前端相关的知识，因此权且作为一个栏目放在博客中吧。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-7</title>
      <link href="/posts/55458.html"/>
      <url>/posts/55458.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote><p>这标题看着多友善~<br>话说在前，其实从博主的学习顺序上来看，这第七章应该是 图 这一部分的内容，但一来认为刚刚说完树，应该让读者（也是让博主）缓一缓节奏，二来排序这一章在C语言的章节中就想着要进一步扩展一下，正好在此直接说完了事。<br>好嘞，咱正式开始。</p></blockquote><p>在我们C语言的章节中，曾经提过 <strong>冒泡排序</strong> 这一种最基础，最简单的排序方式。诚然，这种排序方式清晰且易懂，但还是那个问题，耗时太长了，时间复杂度太高。因此本章会介绍更多种排序方式，权当为读者扩展思路。</p><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><p>虽然读者应该大体了解了，但这里为了仪式感还是提一嘴。</p><p><strong>排序</strong> 指的是将一个 <strong>无序</strong> 的记录序列调整为 <strong>有序</strong> 的记录序列的过程。</p><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><p><strong>排序的稳定性</strong> 指的是排序算法对于 <strong>相同关键字</strong> 进行排序前后的 <strong>相对次序</strong> 是否有改变。</p><p>这个词算是个新词，咱举个例子说一下，比如有如下这么个数组：</p><p>2, 1, 5<sub>(1)</sub>, 8, 7, 5<sub>(2)</sub></p><p>可以看出，这个序列中有两个 <strong>5</strong> ，而在排序之前，这俩元素是有先后顺序的。<br>如果通过一种排序算法，本来在前面的5<sub>(1)</sub>还会稳定的处于5<sub>(2)</sub>的前侧，我们则称这种排序算法是 <strong>稳定的</strong> ，反之，如果排完序不确定哪个5在前，我们则称这种排序算法是不稳定的。</p><h3 id="内排和外排"><a href="#内排和外排" class="headerlink" title="内排和外排"></a>内排和外排</h3><p><strong>内排</strong> 是 <strong>内部排序</strong> 的简称，其意义为将数据存储在计算机的内存中直接进行排序过程。</p><p>相对应的， <strong>外排</strong> 是 <strong>外部排序</strong> 的简称，其意义为当需要排序的纪录很多时，内存无法全部一次性容纳，则我们在排序的过程中还需要多次访问外存来完成排序的全过程。</p><p>在本章中，我们探讨的主要内容为内部排序。</p><h3 id="内部排序的方法"><a href="#内部排序的方法" class="headerlink" title="内部排序的方法"></a>内部排序的方法</h3><p>本章中主要涉及到的排序方法有：</p><ul><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>基数排序</li></ul><p>它们进行排序的方法有区别，进而导致了其时间复杂度的区别，但总归，内部排序的目标，都在于 <strong>逐步扩大有序序列长度</strong> 。</p><p>与以往不同的是，我们这里先对待排序的数据类型进行定义，这是因为不同排序的方法操作的对象总是需要统一的，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span> </span><span class="token comment">//顺序表长度</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span> <span class="token comment">//你需要定义的关键词类型（也可以直接写，这里不必要太纠结）</span><span class="token comment">//待排序的数据类型定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span> <span class="token comment">//关键字</span>    InfoType otherinfo <span class="token comment">//其他数据</span><span class="token punctuation">&#125;</span>RcdType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    RcdType r<span class="token punctuation">[</span>MAXSIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//在排序中，往往第一个存储区域（即r[0]）处于闲置状态</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//顺序表长度</span><span class="token punctuation">&#125;</span>SqList<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，接下来我们正式进入算法部分。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序的基本思想"><a href="#插入排序的基本思想" class="headerlink" title="插入排序的基本思想"></a>插入排序的基本思想</h3><p><strong>插入排序</strong> ，简称插排，基本思想在于将待排序区域划分为已排序区域(R<sub>1</sub>, R<sub>2</sub>, …, R<sub>i-1</sub>)以及未排序部分(R<sub>i</sub>, R<sub>i+1</sub>, …, R<sub>n</sub>)，我们在涉及到 R<sub>i</sub> 这个元素时，会先找到其在这个有序序列中应当插入的位置，将其插入，同时其原位置上的元素至原先的已排序区域结尾元素顺序后移一位。</p><p>根据上述思路，我们可以将 <strong>一趟插入排序</strong> 分为以下三步：</p><ul><li>在有序区域找到插入位置</li><li>后移后续的有序区元素</li><li>将设计元素插入到该位置上</li></ul><p>与此同时，基于实现方法的不同，插排还有进一步的细分：</p><ul><li>直接插入</li><li>折半插入</li><li>希尔排序</li><li>表插入</li></ul><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序是最简单的，它直接从后往前找，并每次都进行一次比较，直到找到应当插入的位置为止：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertionSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//第一个元素不用进行插排，因为它肯定在第一轮时在第一个位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//还记得之前定义待排序列空出的下标为0的位置吗，这个位置叫做监视哨。</span>            <span class="token comment">//每次排序时会先将待插入的元素赋给监视哨</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//当没到达插入位置时，将该位置的元素往后移一位</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//for跑完了，就到达插入位置了</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//再把监视哨的内容插入到这个位置即可</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码应该注释的很清楚了，读者只需要注意一下这个叫做 <strong>监视哨</strong> 的玩意，这东西在后续的排序算法中会有很广泛的应用。</p><p>这种排序的时间复杂度其实还是挺高，因为其相当于每一次都还得跑两层循环，为O(n<sup>2</sup>)，正因如此，它也还是只适用于排序的元素非常少的情况。</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>我们一寻思了，本来前面的序列就是有序的，那我们干脆用折半查找的方式来找插入位置多好，确实，这就是折半插入排序的基本思路。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//折半插入排序</span><span class="token keyword">void</span> <span class="token function">BiInsertionSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//下面需要通过折半查找找到插入位置</span>        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> high <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//折半</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                high <span class="token operator">=</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//插入点在前半部分</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                low <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//插入点在后半部分</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//当找到插入点时，会将low变到high+1（或将high变到low-1），此时不满足循环条件，退出循环</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录后移</span>        <span class="token punctuation">&#125;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//插入</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，这种排序算法其实时间复杂度总体还是O(n<sup>2</sup>)，但好在当数据很多时，其寻找插入位置比此前直接插入的方式要快很多，因此还是很值得考虑的。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的思路跟此前两者的思路并不相同，它意图先对待排序序列做出 <strong>宏观</strong> 的调整，此后再将调整范围逐步缩小至 <strong>微观</strong> 层面。</p><p>这个思路确实非常令人眼前一亮，其具体实现方式为先进行 <strong>跳跃式的插入排序</strong> ，比如我们将整个序列分为 <strong>d个子序列</strong>：</p><p>R[1], R[1+d], R[1+2d], …, R[1+kd];<br>R[2], R[2+d], R[2+2d], …, R[2+kd];<br>…<br>R[d-1], R[2d-1], R[3d-1], …, R[(k+1)d-1];<br>R[d], R[2d], R[3d], …, R[(k+1)d];</p><p>这个 <strong>d</strong> 被称为排序过程的增量，而这个量是在逐渐减小的，直到最后一趟排序时它会变成1。</p><p>我们在每次排序时，先对每一组中的元素进行排序，最后将d降为1时，就相当于对整体再进行一次直接插入排序。</p><p>到这读者可能会问了，这有啥用呢？最后反正都得进行一次插排？</p><p>别忘了希尔排序的思想，这个方式使得我们在进行最后的整体插排时，整个序列已经 <strong>基本有序</strong> 了，这使得最后的直接插排耗时大幅度降低，这就是希尔排序在前面对宏观顺序的调整的价值。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.7/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p><p>理解了方式，我们给代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//希尔排序</span><span class="token keyword">void</span> <span class="token function">ShellInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//每一趟希尔排序的函数，该趟增量为d</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//对于增量为d的每一组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span>d<span class="token punctuation">;</span> j<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">+=</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//遍历这一组中的每个元素</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将当前元素放在哨兵位</span>            <span class="token keyword">int</span> t<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>t <span class="token operator">=</span> j<span class="token operator">-</span>d<span class="token punctuation">;</span> t<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">>=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> t<span class="token operator">-=</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//对每一个元素，找到其插入位置</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//每个插入位置之后的每个元素后移一位</span>            <span class="token punctuation">&#125;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将该元素插入到这一组的适当位置上</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> dlta<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//dlta数组用于存放每一趟希尔排序的增量，而t用于存储dlta数组的大小</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;</span>t<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">ShellInsert</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> dlta<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对每一趟希尔排序单写函数</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，希尔排序的时间复杂度是一个关于dlta序列（即增量序列）的函数。</p><hr><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>这种排序咱们很熟悉了，在C语言的篇章中就提及过，但是问题在于效率太低了。</p><p>其具体思想在于每一轮排序会逐次进行前后元素的比较并交换，达到每一次将最大元素 &#x2F; 最小元素放到数组最后的效果，这样进行n-1轮，就能够将数组排序完成。</p><blockquote><p>提一嘴，冒泡排序是可以进行改进的，即单独设置一个变量在每次进行排序时检测是否有交换次数的产生，如果没有交换则可以直接退出该次排序进程（数列已有序）</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//冒泡排序</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//flag用于标记是否有交换现象产生</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//在每一轮冒泡之前将标记位置0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">Swap</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        i<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//如果有交换现象则继续</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序（Qsort）"><a href="#快速排序（Qsort）" class="headerlink" title="快速排序（Qsort）"></a>快速排序（Qsort）</h3><p>快排的思想也是分轮的，其思想在于分轮排序：</p><ul><li>一轮快速排序：</li></ul><p>目标在于选出一个枢轴，将比它小的元素放到它的左边，再将比它大的元素放到它的右边：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//单轮快速排序</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivotkey <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>    <span class="token comment">//这个元素作为枢轴</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pivotkey<span class="token punctuation">;</span> <span class="token comment">//放入哨兵位置</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">>=</span>pivotkey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            high<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//如果high指向的元素比枢轴大，则继续搜索</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//当此时high指向的元素比枢轴小了，将high的元素与low的元素交换</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;=</span>pivotkey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//最终low会与high相同，停止循环，此时low / high的位置就是枢轴应该放到的位置</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span> <span class="token comment">//把最后枢轴所在的位置返回</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>快速排序</li></ul><p>有了一轮排序，我们可以通过多轮快排进行对一整个数组的快排：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//多轮快排</span><span class="token keyword">void</span> <span class="token function">QSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//对L.r的s至t的位置进行快速排序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&lt;</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//当前需要排序的长度序列大于1</span>        pivotloc <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对s到t进行一次划分</span>        <span class="token function">QSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s<span class="token punctuation">,</span> pivotloc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对比pivotloc小的序列进行递归</span>        <span class="token function">QSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> pivotloc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对比pivotloc大的序列进行递归</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排的时间复杂度为nlog(n)。</p><p>但还存在一个问题，当快速排序要处理的对象本身就有序时，这就势必导致快排效率的退化（因为每次都拿第一个元素当枢轴），这时，快排会退化为冒泡的时间复杂度。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>简单排序的思路很简单，我们将数组分为一部分有序序列以及另一部分无序序列，将无序序列中最小 &#x2F; 最大的元素挑出来，放到有序序列与无序序列分界处的位置。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//简单选择排序</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//j存储数组中第i小的元素</span>        <span class="token comment">//此时前[1, i]的数组已经排序完成，因此在[i+1, L.length]之间寻找最小值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                j <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//交换到位</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其时间复杂度为O(n<sup>2</sup>)</p><h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p>树形选择排序的主要优化点在于将 <strong>选择最小值</strong> 这一过程的时间复杂度降低了。</p><p>其采用类似于锦标赛的思路，在无序序列中先让元素两两一组，互相比较，记录两者之间最小的那个，而后在挑选出来的新一组中继续两两一组，如此循环，直至最后只剩下一个元素时，这时就是最小的那个。</p><p>这种算法，每一次选出最小值的复杂度是log<sub>2</sub>(n)，而显然我们需要进行n次这样的选择，故整体算法的时间复杂度为nlog<sub>2</sub>(n)</p><blockquote><p>注：log<sub>2</sub>(n)其实就是一棵完全二叉树的深度。</p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>这块咱得重点说一下，因为涉及到了一个全新的玩意，叫 <strong>堆</strong></p><p>堆的定义为满足如下规定的数组：</p><ul><li>r<sub>i</sub> &lt;(&gt;) r<sub>2i</sub></li><li>r<sub>i</sub> &lt;(&gt;) r<sub>2i+1</sub></li></ul><p>这样的数组可以被称为 <strong>小顶堆（大顶堆）</strong></p><p>其实形象地了解一下，我们借助一下上一章中讲的二叉树的知识，就是将一个数组写成一个二叉树，而其每个双亲结点都要比其子节点要小（大）</p><p>那这玩意又跟排序怎么扯上关系呢？</p><p>我们拿小顶堆举例子，显然，小顶堆虽然后面的元素顺序不确定，但是其最顶部的元素则很显然是整个数组中最小的那个。</p><p>那么，我们只需要对这个数组的n个元素先进行建堆操作，将其调整成小顶堆，而后将最小的那个元素扔到最后边，在对前面的n-1个元素继续进行建堆操作，如此循环往复，就能将这个数组变成一个从大到小的有序数组了。</p><p>到这里，就可以引出我们要解决的两个问题了：</p><ul><li>怎么建堆？</li><li>堆顶元素扔到最后去了，那我们怎么对剩余元素建立新堆？</li></ul><p>咱先说第二个：</p><hr><p>我们假设有一个大顶堆：</p><p>98, 81, 49, 73, 36, 27, 40, 55, 64, 12</p><p>现在把最大的那个元素扔到最后面（即98与12交换）<br>数组变为：</p><p>12, 81, 49, 73, 36, 27, 40, 55, 64, 98</p><p>现在要对前n-1个元素继续建堆，其实是一个自上而下 <strong>筛选</strong> 的过程：<br>我们先比较12与其两个子节点81，49；<br>因为要建大顶堆，因此肯定要把最大的元素放到最上边，这三个元素显然81最大，因此将81放到12的位置，交换：</p><p>81, 12, 49, 73, 36, 27, 40, 55, 64, 98</p><p>好的，继续筛选，12现在下标为2，对应的子结点为4、5，即比较12，73，36；<br>显然，73要和12换位置：</p><p>81, 73, 49, 12, 36, 27, 40, 55, 64, 98</p><p>继续筛选，12的下标为4，对应的子节点为8、9，即比较12，55，64；<br>继续，64和12换位置：</p><p>81, 73, 49, 64, 36, 27, 40, 55, 12, 98</p><p>好了，目前我们发现12没数可比了，就结束调整，我们发现此时前n-1个元素又变成了一个大顶堆。</p><blockquote><p>注：别忘了在排序中，数组下标从1开始哦（0号元素是哨兵位）。</p></blockquote><p>通过这种方式，我们可以达成调整大顶堆的目的。</p><hr><p>那再回到第一个问题，我们就可以用与第二个问题类似的思路继续往下走：</p><p>我们想到了，其实建堆的过程就是一个逐层递进，一层一层建立堆的过程：</p><p>上面的过程中根结点的两棵子树其实没有变，这就意味着我们如果能把根结点的两棵子树分别调整成大顶堆，就可以再进行一次上面的算法，将整棵树都变成大顶堆。</p><p>这就形成了一个循环的思路。</p><p>给出代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//调整大顶堆</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token comment">//哨兵位暂存堆顶元素</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>s<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span> i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>m <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//将i指向子节点中最大的那个元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">>=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//如果堆顶元素比两个元素都大</span>            <span class="token comment">// 说明这个当前位置就是堆顶元素应该插入的位置，退出循环</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> s <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//否则将比较大的那个元素移到顶部，继续下一轮判断</span>        <span class="token comment">//这里之所以不是交换是因为L.r[0]已经暂存了我们要调整的元素</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//结束循环后，s会指向堆顶元素需要插入的位置</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//堆排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//从底层树开始一层层调整为大顶堆</span>        <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">,</span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//将整个数组建成大顶堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//将最前面的元素（最大的元素）与未经排序的最后一个元素交换</span>        <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调整成大顶堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>堆排序的时间复杂度为O(nlogn);</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的思路又不一样了，其思路在于逐次排序，并两两合并。</p><p>比如一个数组有8个元素，归并排序是 12 &#x2F; 34 &#x2F; 56 &#x2F; 78 ，将元素分为四组，先将这四组都改为有序列，而后两两合并，即变为 1234 &#x2F; 5678，再对这两组元素分别排成有序序列，而后继续合并为 12345678，并排序。最终变为有序序列。</p><p>每一趟归并的时间复杂度是O(n)，而归并排序总共需要进行O(log<sub>2</sub>n)趟</p><p>因此归并排序的总时间复杂度为O(nlogn)</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序针对多关键字，同时根据关键字数位不同，需要进行多次 <strong>分配-收集</strong> 的过程。</p><p>咱举个例子</p><hr><p>假如说，有如下这些关键字：<br>209, 386, 768, 185, 247, 606, 230, 834, 539</p><p>我们如果想要将其进行有序排列，除了可以直接进行数字之间的比较外，我们还可以将其看为一个个的个体，即由个位数，十位数，百位数三个部分组成的一个整体。</p><p>那我们只需要对三个部分按照合适的顺序分别进行排序即可成功将这个序列变为有序序列。</p><p>我们先按个位数来一遍：<br>230, 834, 185, 386, 606, 247, 768, 209, 539</p><p>在个位数的基础上，再按十位数进行排序：<br>606, 209, 230, 834, 539, 247, 768, 185, 386</p><p>而后，在以上两次排序排出序列的基础上，我们再按百位数进行排序：<br>185, 209, 230, 247, 386, 539, 606, 768, 834</p><p>会发现数组已经有序。</p><hr><p>以上，是基数排序的一个经典的案例，这个例子很恰当的说明了这种排序方法在多关键字的情况下的适用性。</p><p>时间复杂度是O(d(n+rd));</p><p>d是 <strong>分配-收集</strong> 的趟数，rd是 <strong>基数的取值范围</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK，这么多种排序过去，咱做个总结。</p><h3 id="时间性能："><a href="#时间性能：" class="headerlink" title="时间性能："></a>时间性能：</h3><ul><li>O(nlogn) : 快速排序（QSort），堆排序（HeapSort），归并排序（MergeSort）</li><li>O(n<sup>2</sup>) : 直接插入排序，冒泡排序，简单选择排序</li><li>O(n) : 基数排序（有限制）</li></ul><p>如果本来待排序列就有序，则直接插入排序，冒泡排序的时间复杂度进化为 O(n)，而快速排序退化为 O(n<sup>2</sup>)</p><h3 id="空间性能："><a href="#空间性能：" class="headerlink" title="空间性能："></a>空间性能：</h3><p>空间性能指排序过程中需要的辅助空间大小：</p><ul><li>O(1) : 所有简单排序（插入，冒泡，选择），堆排序</li><li>O(logn) : 快速排序（递归过程占用的栈空间）</li><li>O(n) : 归并排序（需要复制一个数组进行归并的操作）</li></ul><h3 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h3><p>在文章开头介绍了稳定性的概念。</p><p>像快速排序，直接选择排序，堆排序，希尔排序这种有 <strong>频繁元素交换操作</strong> 的排序方法往往是不稳定的。</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-6</title>
      <link href="/posts/6243.html"/>
      <url>/posts/6243.html</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><blockquote><p>本节，是数据结构的第一部分重难点 <strong>树</strong> 的知识梳理。其涉及到的知识体系极其繁杂，同时会常常与前面的数据结构有所联系。</p></blockquote><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树——概述"><a href="#树——概述" class="headerlink" title="树——概述"></a>树——概述</h3><blockquote><p>我们首先需要了解，树这个玩意到底是个啥？</p></blockquote><p>我们在学习前面的数据结构时，往往其结构都是 <strong>线性的</strong> ，这意味着其结构中的每一个元素都只有一个前驱，也只有一个后继。</p><p><strong>树</strong> 与之不同，树中的每个节点（除根结点外）只有一个前驱，但其可以包含多个后继，这就是其与此前的数据结构在根本上的区别。</p><h3 id="树——常用术语"><a href="#树——常用术语" class="headerlink" title="树——常用术语"></a>树——常用术语</h3><p>由于树的结构复杂性，我们需要先做出一些术语上的约定，以防止此后我们在进行描述时，产生歧义。</p><ul><li>树的 <strong>根</strong> ：一棵树中的第一个元素，它没有前驱，只有后继</li><li>树的 <strong>结点</strong> ：包含一个元素，以及若干个指向其子树（后继）的分支；</li><li>结点的 <strong>度</strong> ：一个节点所连接的子树的数目；</li><li>树的度：这棵树里面所有结点度的最大值；</li><li><strong>叶子结点</strong> ：没有子树的结点；</li><li>分支节点：有子树的结点；</li><li><strong>孩子结点</strong> ：一个结点的两个子树的根；</li><li><strong>双亲结点</strong> ：一个结点的前驱结点；</li><li><strong>兄弟结点</strong> ：两个具有相同双亲结点的结点互相称为兄弟；</li><li><strong>堂兄弟结点</strong> ：两个双亲结点在同一层的结点互相称为堂兄弟；</li><li>结点的 <strong>层次</strong> ：从根结点到该结点的路径长度+1；</li><li>树的 <strong>深度</strong> ：树中所有叶子结点的层次的最大值；</li></ul><p>相信看到这一堆名词已经能让一部分读者感到头疼了…<br>别着急，我们先从最简单的树——二叉树讲起。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>二叉树</strong> 是最简单的树，其特殊性在于规定了每个结点最多只能有两棵子树，这这两棵子树被称为 <strong>左 &#x2F; 右子树</strong> 。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>二叉树的形式非常特殊，因此在这里我们浅谈一下其具体性质：</p><ul><li>在二叉树的第 i 层上至多有 2<sup>i-1</sup> 个结点</li><li>深度为 k 的二叉树上至多有 2<sup>k</sup> - 1 个结点<blockquote><p>注：考虑结点最多的情况，即 2<sup>0</sup> + 2<sup>1</sup> + … + 2<sup>k-1</sup> &#x3D; 2<sup>k</sup> - 1</p></blockquote></li><li>对任意的一棵二叉树，若其度为0的结点（叶子结点）的数目为N，度为2的结点的数目为N<sub>2</sub>，则N &#x3D; N<sub>2</sub> + 1<blockquote><p>注：这里我们不给严谨证明，我们只给一个思路，即在任意一棵二叉树中，多一个度为2的结点就必定意味着多出了一个叶子节点，而一棵二叉树在只有根结点的时候叶子节点数量为1，因此可以推出上式</p></blockquote></li></ul><p>在叙述第四个性质之前，我们需要先了解两类特殊的二叉树：</p><hr><ul><li>满二叉树：深度为k，且含有 2<sup>k</sup> - 1 个结点的二叉树<blockquote><p>顾名思义，这个二叉树里面除了叶子结点之外，所有的结点的度都是2，因此得名</p></blockquote></li><li>完全二叉树：树中所含的n个结点和满二叉树编号为 1 -&gt; n 的结点一一对应。<blockquote><p>啥意思呢，这里得给两个图来解释一下：</p></blockquote></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><hr><p>好的，了解完这两种特殊的二叉树，我们接下来回到此前性质的学习中：</p><ul><li>具有n个结点的 <strong>完全二叉树</strong> 的深度为：[log<sub>2</sub>n] +1<blockquote><p>证：我们设完全二叉树的深度 k ；由于第二条性质的存在，得到 2<sup>k-1</sup> &lt; 2<sup>k</sup> ，对该式进行化简，即可得到 k-1 &lt; [log<sub>2</sub>n] &lt; k ，同时k又只能是整数，因此得到这个性质。</p></blockquote></li><li>对于任意的 <strong>完全二叉树</strong> ，我们对其进行从上至下，从左至右的编号（就类似上图的编号方式），可以得到如下性质：<ul><li>若结点编号 i &#x3D; 1 ，则这个结点是其根结点，否则编号为 [i&#x2F;2] 的结点就是其双亲结点。</li><li>对于任意结点，如果对于其编号 i 满足 <strong>2i &gt; n</strong> ，则该结点没有左孩子。否则，编号为 <strong>2i</strong> 的结点是其左孩子。</li><li>对于任意结点，如果对于其编号 i 满足 <strong>2i +1 &gt; n</strong> ，则该结点没有右孩子。否则，编号为 <strong>2i + 1</strong> 的结点是其右孩子。</li></ul></li></ul><p>关于二叉树的性质，大体就这么些，其中大部分的性质是比较容易就能推出来的，最后两个关于完全二叉树的性质也可以在读者对于完全二叉树的理解加深之后轻易写出。 <del>（实在不行咱画一个图看一眼，举例嘛，不寒碜）</del></p><h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><blockquote><p>说了挺多，现在咱来看看这东西在计算机里面该怎么实现</p></blockquote><h4 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h4><p>相信挺多读者一看顺序存储应该挺诧异，觉着不是很好实现。确实，顺序存储（即利用数组的方式存储二叉树）仅比较适用于完全二叉树，这是因为其标号是有规律可循的（详见上面的最后一条性质）。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="完全二叉树的顺序存储"></p><p>如果想在非完全二叉树的基础上进行顺序存储，那我们为了保持结构以及访问的便利性，只能先创建一个与之相对的完全二叉树的数组，而后将其不存在的结点值赋值为0。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="非完全二叉树的顺序存储"></p><p>读者应该看出来了，如果这样存储二叉树，会产生极大的内存浪费，因为需要占用很大的空间来存储中间的0元素，这是得不偿失的。</p><h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><ul><li>二叉链表</li></ul><p>非常自然地，加入二叉树的每一个结点都最多有两个孩子，那我们自然可以利用一个链表结构，只不过这个链表中的每个结点都有两个指针，分别指向其左孩子以及右孩子。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span> <span class="token comment">//节点内存储的内容</span>    BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment">//分别指向其左孩子与右孩子</span><span class="token punctuation">&#125;</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li>三叉链表</li></ul><p>有二叉链表，我们又想了，能不能达成一个通过子节点能够找到它双亲结点的结构呢？当然可以，无非就是加一个指针的事情：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TriTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    TriTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    TriTNode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">//新增一个指向双亲结点的指针，但是维护起来会更费时</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>三叉链表的存储比二叉链表更加清晰一些，但是维护起来明显更加费时，这里的选择可以由读者自行决定，本文中大部分的代码演示会通过二叉链表来进行。</p></blockquote><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><blockquote><p>我们说完了这玩意该怎么在计算机里面实现存储，现在就需要说一说它的一些基础操作了。</p></blockquote><p>我们首先需要明确遍历的原则，即二叉树中的每个结点均 <strong>被访问且仅被访问一次</strong> 。</p><p>对于二叉树而言，有两种遍历思路可选：</p><ul><li>深度优先遍历：先进行左（右）子树的遍历，待这一过程完毕后，再遍历右（左）子树。</li><li>广度优先遍历：从上至下按照树的层次一层层遍历。</li></ul><p>我们从广度优先的先左后右的遍历说起。</p><h4 id="先左后右的深度优先遍历算法"><a href="#先左后右的深度优先遍历算法" class="headerlink" title="先左后右的深度优先遍历算法"></a>先左后右的深度优先遍历算法</h4><p>这种思路又分为三种子思路，即我的根结点应该在什么时候进行访问：</p><ul><li>先序遍历：即先访问根结点，再依次访问左子树，右子树</li><li>中序遍历：即先访问左子树，再访问根结点，最后访问右子树</li><li>后序遍历：即先访问左子树，右子树，最后访问根结点</li></ul><p>这里额外说一句，构建二叉树的时候，我们是可以通过不同的遍历方式作为依据的，具体来说，我们可以通过中序遍历以及其余任意一种遍历方式来唯一确定一棵二叉树。</p><hr><ul><li>递归遍历算法</li></ul><p>由于二叉树的特殊性，我们很容易想到递归的遍历方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//先序遍历</span><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印当前节点的值</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分别先后利用递归遍历左子树与右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//中序遍历</span><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先遍历左子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印当前节点的值</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后遍历右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//后序遍历</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先遍历左子树</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//再遍历右子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后打印当前节点的值</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种遍历算法利用递归，写起来简单明了，但存在效率问题。<br>相信写C语言递归的读者经常遇到递归深度过深的问题，我们试想一下，如果有一棵树，其深度达到100，那几乎不用考虑，这种算法肯定直接报错退出。</p><p>这也就需要引出我们的第二种算法。</p><hr><ul><li>非递归遍历算法</li></ul><p>在这种算法中，我们使用此前我们学过的 <strong>栈</strong> 这种结构来对树进行遍历。</p><p>我们先把思想搞明白，然后再上代码，以中序遍历为例：</p><p>这种算法的思路为：</p><ul><li>我们先从根结点一直向左下找，途中只要遇到一个结点，我们就将其入栈；</li><li>直到我们找到了NULL结点，这说明它上一个结点是整棵树最靠左下的结点了，这时我们将其出栈，并访问它，而后继续访问其右子树；</li><li>访问其右子树的过程与上述过程相同，直到整棵右子树被访问完毕。</li><li>此后，我们可以继续出栈一个结点，重复上述过程。</li><li>当栈空时，整棵二叉树就被我们遍历完毕了</li></ul><p>上面的文字描述比较晦涩难懂，这里给出一棵具体的树作为例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%20%E5%AE%9E%E4%BE%8B%E6%A0%91.png" alt="实例树"></p><p>我们将遍历过程写一遍：</p><ul><li>对于这一棵二叉树，我们单独设置一个栈，初始为空。</li><li>从根结点找到最左下的结点，路径上所有的结点均入栈。即 1入栈 、 2入栈 、 4入栈；<ul><li>现在栈中的元素：1, 2, 4;</li></ul></li><li>到达4的左孩子，发现是NULL，因此此时出栈一个元素（4），访问它，并遍历它的右子树。</li><li>我们发现4的右子树是NULL，因此直接退出遍历，此时再次检测栈中是否有元素，发现栈不空，再次出栈一个元素（2），访问它，并遍历它的右子树。<ul><li>此时根结点是5，同样的向左下找，路径上所有的结点均入栈。即5入栈 、 6入栈；<ul><li>此时栈中的元素：1, 5, 6;</li></ul></li><li>到达6的左子树，发现是NULL，因此此时出栈一个元素（6），访问它，遍历它的右子树（NULL）；</li><li>检测栈中是否有元素，发现栈不空，出栈一个元素（5），访问它，遍历其右子树</li><li>此时根结点是7，向左下找，路径上元素入栈。即7入栈；<ul><li>此时栈中元素：1, 7;</li></ul></li><li>到达7的左孩子，发现是NULL，出栈一个元素（7），访问它，遍历其右子树（NULL）；</li></ul></li><li>此时再次检测栈中元素，栈非空，出栈一个元素（1），访问它，遍历其右子树；</li><li>3入栈；<ul><li>此时栈中元素：3;</li></ul></li><li>3的左孩子是NULL，3出栈，同时遍历3的右子树（NULL）；</li><li>检测栈中元素，栈空，退出算法</li></ul><p>上述过程就是这种算法进行遍历的方式，请读者务必理解，下面我们给出具体代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//中序遍历——非递归算法</span><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BiTNode <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m根据你的树的深度来决定，足够大就行</span>    BiTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//来表示栈顶的位置</span>    p <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//p入栈</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment">//p指向其左孩子</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//这个循环在p指向的左孩子是NULL的时候会停止</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//判断栈不空</span>            p <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>            top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//出栈一个元素</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问刚刚出栈的元素（打印）</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//继续扫描右子树，开始下一层循环</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//当 p不空或者栈不空时，继续该循环</span>    <span class="token comment">//额外提一嘴，这里最外层的do_while循环的停止条件是p为NULL，并且栈空，此时才会退出循环</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在读者能够看明白上述代码的时候，我们可以继续将先序遍历以及后序遍历的非递归算法给出。</p><p>下面是先序遍历的算法，其思路为：</p><ul><li>检测栈中是否为空</li><li>双亲结点出栈访问；</li><li>检测该结点有没有左右孩子，按照先右后左的顺序入栈；</li><li>回到第二步继续循环，直到栈空，算法结束</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//先序遍历——非递归算法</span><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BiTNode<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//类似的，m可以由读者自行决定，够大就可以</span>  BiTNode<span class="token operator">*</span> p<span class="token punctuation">;</span>  <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//b不空，开始遍历</span>    stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">//根结点入栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//当栈不空时，循环</span>      p <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//先将一个结点出栈（先序遍历的特点）</span>      top<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//p有右孩子</span>        top<span class="token operator">++</span><span class="token punctuation">;</span>        stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//p的右孩子先入栈</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//p有左孩子</span>        top<span class="token operator">++</span><span class="token punctuation">;</span>        stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment">//p的左孩子后入栈</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//当栈空时，所有的结点均被访问完毕</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个先序遍历算法有一点需要额外说明一下：在访问完当前结点，随后入栈当前结点的左右孩子时，为了保证程序能 <strong>先访问左孩子，再访问右孩子</strong> ，我们需要 <strong>先将右孩子入栈，随后再将左孩子入栈</strong> 。这是由栈的后进先出原则决定的。</p><p>最后是后序遍历，这是三种遍历中最难写的一种。</p><p>这玩意涉及到了一个重复访问的问题：即我们先找到左节点，随后返回其双亲结点，再访问双亲结点的子树，再返回双亲结点，这就产生了问题：<br>我们如何判断返回双亲结点时，这是从左子树返回过来的，还是从右子树返回过来的？</p><p>因此，很遗憾的，我们可能又需要写一个辅助栈，来额外设置一个标记位，便于我们判断返回情况。</p><p>还是先给出大体思路：</p><ul><li>沿着根结点一直向左下走，直到走到NULL，途中所有的结点入栈，同时辅助栈相应的位置添加标记0；</li><li>走到NULL后，检测当前栈顶结点，并将其对应标记位设置为1，开始访问其右子树；</li><li>右子树的访问规则与第一步相同；</li><li>当我们访问完右子树再次返回这个结点时（即总有一次我们检测栈顶元素，发现这个结点的标记位已经被我们之前置成1了），我们将其出栈，并打印。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//后序遍历——非递归写法</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BiTNode<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  BiTNode<span class="token operator">*</span> p <span class="token operator">=</span> b<span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token operator">*</span> sub <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//辅助栈</span>  <span class="token keyword">int</span> top<span class="token punctuation">;</span> <span class="token comment">//由于辅助栈的栈顶与主栈栈顶同步，因此只需要设置一个表示栈顶的变量即可</span>  <span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      top<span class="token operator">++</span><span class="token punctuation">;</span>      stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>      tag<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//第一次入栈时，将其标志位置为0</span>      p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//向左下一直找到NULL</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sub<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//如果当前栈顶元素的左右子树都被访问过了</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//出栈</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sub<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//当前栈顶元素的右子树还没被访问过</span>      p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//把p指向右子树，用于下一次的循环</span>      tag<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//将其标志位置成1</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">||</span> top<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//当p为NULL且栈空时才停止循环</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="按层次遍历的广度优先算法"><a href="#按层次遍历的广度优先算法" class="headerlink" title="按层次遍历的广度优先算法"></a>按层次遍历的广度优先算法</h4><p>相对于深度优先算法而言，广度优先的算法要显得友好许多。</p><p>我们采用队列这种数据结构来遍历这棵二叉树，其思路为：</p><ul><li>创建一个队列；</li><li>先将二叉树的根结点入队；</li><li>对任意一个队列中的结点，我们先将其出队并打印，同时将其左孩子和右孩子入队列。</li><li>依照上述过程循环，直到队列空为止</li></ul><p>读者可以依照上面给过的二叉树的例子试着手过一遍这种算法，写过一遍的理解总是要比直接看代码要清晰许多，下面我们给出代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//广度优先遍历</span><span class="token keyword">void</span> <span class="token function">TransLevel</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">Queue</span><span class="token punctuation">&#123;</span>    BiTree<span class="token operator">*</span> vec <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一个道理，m够大就行</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">//指示队列头尾的变量</span>  <span class="token punctuation">&#125;</span>q<span class="token punctuation">;</span>  BiTree<span class="token operator">*</span> temp<span class="token punctuation">;</span>  q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//树空，则直接返回</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token comment">//否则，树根入队</span>    q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>    q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>front<span class="token operator">!=</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//当队列不空时，循环</span>    temp <span class="token operator">=</span> q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span>front<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> temp<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//队头的元素出队并打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-></span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//出队的元素有左孩子</span>      q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token operator">-></span>lchild<span class="token punctuation">;</span>      q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-></span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//出队的元素有右孩子</span>      q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token operator">-></span>rchild<span class="token punctuation">;</span>      q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>好的，二叉树的遍历至此，就差不多讲完了。这部分难度不小，读者可以缓口气。</p><p>之所以这么重视这一部分，并且花费很大的篇幅来讲解，是为了下一个部分，二叉树的基础应用来做铺垫，没有二叉树的遍历，我们没法进入下一部分。</p><blockquote><p>注：如果深度遍历的非递归算法读者未能理解，可以暂时跳过，递归算法先用着嘛，不寒碜。</p></blockquote><h3 id="二叉树的基础应用"><a href="#二叉树的基础应用" class="headerlink" title="二叉树的基础应用"></a>二叉树的基础应用</h3><h4 id="统计叶子结点的个数"><a href="#统计叶子结点的个数" class="headerlink" title="统计叶子结点的个数"></a>统计叶子结点的个数</h4><p>这应用在咱说完遍历算法之后应该不算很难了，我们只需要在算法中加入一个计数器，再把打印那一步改成一个判断语句，即如果这个结点没有左右孩子，则计数器+1即可。</p><p>这里就不写代码了，读者照着上面的代码自行改一改就好。</p><h4 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h4><p>求深度这一算法类似于后序遍历，我们根据二叉树的定义，应该能看出来树的深度等于其左子树与右子树深度的最大值+1；因此，这算法用递归相当好写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> depthval<span class="token punctuation">,</span> depthleft<span class="token punctuation">,</span> depthright<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//树空，返回0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    depthleft <span class="token operator">=</span> <span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    depthright <span class="token operator">=</span> <span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    depthval <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>depthleft<span class="token operator">></span>depthright<span class="token operator">?</span>depthleft<span class="token operator">:</span>depthright<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> depthval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><blockquote><p>线索二叉树这玩意其实笔者没找到非常具体的应用场景，但是无可奈何这东西确实在数据结构的书上有，这里稍微提一嘴</p></blockquote><p><strong>线索二叉树</strong> 是为了提高遍历速度而建立的一种类似于链表的结构，因此也被称为线索链表，主要用于深度遍历，也分为以下三类：</p><ul><li>先序线索链表</li><li>中序线索链表</li><li>后序线索链表</li></ul><p>其与二叉树的具体区别在于，二叉树中的空节点就是空节点，但线索二叉树并不，它将所有的空结点连接上了它遍历时的前驱与后继。</p><p>但这里又产生了一个问题，即我们如何区分一个结点的左右指针指向的是孩子还是线索呢？<br>对喽，引入了两个标记位，它们一个用于标记左指针，另一个用于标记右指针，当标记位为0时，它正常指向左 &#x2F; 右孩子，但当标记位为1时，则代表着它指向相应遍历顺序中的前驱与后继。</p><p>这里举一例：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%20%E5%AE%9E%E4%BE%8B%E6%A0%91.png" alt="线索二叉树例图"></p><p>我们还是拿这棵树来举个例子，其中序遍历时的顺序为：</p><p>4, 2, 6, 5, 7, 1, 3</p><p>正常而言，6没有左右孩子，其两个指针都是NULL，但在线索二叉树中，6这个结点的两个标记位都为1，即其左右指针均指向其前驱与后继，在这里即6的左指针指向了2，右指针指向了5</p><p>线索链表的具体结点结构为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span><span class="token punctuation">&#123;</span>  TElemType data<span class="token punctuation">;</span>  BiThrNode<span class="token operator">*</span> lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token keyword">int</span> Ltag<span class="token punctuation">,</span> Rtag<span class="token punctuation">;</span> <span class="token comment">//新增加的左右标记位</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线索二叉树的相关内容我们就写这么些。</p><h2 id="树——回归"><a href="#树——回归" class="headerlink" title="树——回归"></a>树——回归</h2><blockquote><p>前面的二叉树是树的一种最基础的表现形式，现在让我们回到树，继续谈树的一些存储和应用。</p></blockquote><h3 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h3><p>与二叉树相似，树的表示方式也有很多种，但其复杂性在于一个结点可能有多个孩子。这里介绍几种常见的存储方式。</p><h4 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h4><p>我们可以把每一个结点的孩子结点排列起来，以单链表作为存储结构。这也就代表着，一棵树有n个结点，也就有n个孩子链表。</p><p>又由于这n个头指针又形成了一个线性表，因此我们可以采取线性存储结构。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%A0%91%20%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子链表表示法"></p><p>在这种表示方式中，显然我们需要定义两种结点类型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> child<span class="token punctuation">;</span> <span class="token comment">//表示这个孩子所在的下标</span>  CTNode<span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//指向下一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//孩子结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  CTNode<span class="token operator">*</span> firstchild<span class="token punctuation">;</span> <span class="token comment">//指向第一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//双亲结点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们希望在双亲结点中能够直接找到自己的双亲结点，我们只需要在PTNode中增加一个变量即可：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%B8%A6%E5%8F%8C%E4%BA%B2%E7%9A%84%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8.png" alt="带双亲的孩子链表"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  <span class="token keyword">int</span> parent<span class="token punctuation">;</span> <span class="token comment">//存储双亲结点的下标</span>  CTNode<span class="token operator">*</span> firstchild<span class="token punctuation">;</span> <span class="token comment">//指向第一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//双亲结点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="树的二叉链表表示法（孩子-兄弟表示法）"><a href="#树的二叉链表表示法（孩子-兄弟表示法）" class="headerlink" title="树的二叉链表表示法（孩子-兄弟表示法）"></a>树的二叉链表表示法（孩子-兄弟表示法）</h4><p>前面铺垫了半天二叉树，这里肯定得用一下子。</p><p>我们如果想将一棵多叉树转换成一棵二叉树，应该怎么做呢？</p><p>比较通用的做法是将二叉树的左指针指向自己的第一个孩子，右指针指向自己下一个兄弟。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  CSNode <span class="token operator">*</span>firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>nextsibling<span class="token punctuation">;</span> <span class="token comment">//分别存储自己的第一个孩子和下一个兄弟</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，上图的树，我们如果利用这种方式进行存储：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%A0%91%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8.png" alt="树的二叉树存储"></p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>类似于二叉树，树也有不同的遍历法：</p><ul><li>先根遍历（对应二叉树的先序遍历）：先访问根根结点，然后依次访问各棵子树</li><li>后根遍历（对应二叉树的中序遍历）：先依次访问各棵子树，再访问根结点</li><li>按层次遍历：类似于二叉树的广度优先遍历</li></ul><p>这里先根遍历与对应二叉树的先序遍历对应；但后根遍历是与其对应二叉树的中序遍历对应的，举个例子：</p><p>我们还是以上面这棵树为例：</p><p>后根遍历的顺序：<br>B G E F C D A</p><p>我们再用之前讲的中序遍历二叉树顺序对上面转化完的二叉树来一遍：<br>B G E F C D A</p><p>可以发现完全一致。</p><h3 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h3><h4 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h4><p>树的深度写起来其实跟求二叉树的深度那个算法差别不大，我们需要先将树转化为二叉树（即孩子-兄弟表示），此后对这个二叉树求深，但需要额外考虑到走兄弟这条道路时深度不变。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//求树的深度</span><span class="token keyword">int</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>CSTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> h1<span class="token punctuation">,</span> h2<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    树为空，则返回<span class="token number">0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    h1 <span class="token operator">=</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>firstchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//走左侧第一个孩子时，深度+1；</span>    h2 <span class="token operator">=</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>nextsibling<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//走右侧兄弟结点时，深度不变</span>    <span class="token keyword">return</span> h1<span class="token operator">></span>h2<span class="token operator">?</span>h1<span class="token operator">:</span>h2<span class="token punctuation">;</span> <span class="token comment">//返回其中最大的那个</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树是一种在查找时尽可能减少查找所用时间的优化树，其思路在于将查找频次最低的值放在最远端，将频次较高的值放在尽可能近的位置。</p><p>博主在这里实在谈不上很擅长，就不在这里详细叙述了。</p><hr><p>至此，树的相应章节应该算是基本结束了。</p><p><del>真费劲啊，我靠</del></p><p>博主的水平有限，文中的某些代码或文本难免会有些谬误，已经尽可能的加上了注释，希望能对读者的理解有所裨益。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-5</title>
      <link href="/posts/6435.html"/>
      <url>/posts/6435.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组与广义表"><a href="#数组与广义表" class="headerlink" title="数组与广义表"></a>数组与广义表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>C语言中，我们已经多次接触过 <strong>数组</strong> 这一概念，这里我们给出数组的具体概念。</p></blockquote><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>在数据结构中， <strong>数组</strong> 指有限个数据元素的集合，这些数据元素具有相同的特性，并都有与之相对应的下标来表征它们的位置。</p><p>一维数组，与我们在第一章中介绍的 <strong>线性表</strong> 几乎是同一个东西。但这里，我们数组的维数理论上可以无限延申。</p><p>但向外延伸的复杂度则也带来了些许不便，即数组的删改操作会变得极其复杂（尤其在维数过多的情况下），因此我们不妨一刀切掉，数据结构中定义的数组，除了初始化与销毁两种操作之外，只有两种运算：</p><ul><li>给定下标，存储相应的元素</li><li>给定下标，修改相应下标内元素的值</li></ul><blockquote><p>很多读者可能会想起C中的relloc操作，但relloc操作常见于一维数组，即线性表的范畴内，因此这里不再对数组的删改进行叙述。</p></blockquote><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><p>如上所述，数组仅仅包含以下几种操作：</p><ul><li>InitArray：初始化</li><li>DestroyArray：销毁</li><li>Value：取出数组的元素值</li><li>Assign：给数组赋值</li></ul><h3 id="数组的顺序表示"><a href="#数组的顺序表示" class="headerlink" title="数组的顺序表示"></a>数组的顺序表示</h3><blockquote><p>以二维数组为例</p></blockquote><p>数组既然是多维的，则必然存在存储顺序优先级的问题，由于普遍已经适应了 <strong>以行序为主序</strong> 的存储方法，因此本文中会采用行序主序的映像方式进行说明。</p><blockquote><p>上面的说法有点抽象，举个例子：<br>存在一个2*3的数组，如果使用行序主序的方式，则在计算机内存中的存储顺序即：0 0、0 1、0 2、1 0、1 1、1 2。<br>相反的，如果使用列序主序的方式，则在计算机内存中的存储顺序即：0 0、1 0、0 1、1 1、0 2、1 2</p></blockquote><p>因此，一个m行n列的数组采用行序主序的形式时，存储a<sub>ij</sub>的位置时，其位置即：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + (n*i + j) * L;</p><p>如果以列序为主序，则：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + (m*j + i) * L;</p><p>这里，LOC(0, 0)被称为基地址（即数组第一个元素所在的地址），L则是数组一个元素所占有的内存大小。</p><h3 id="矩阵相关"><a href="#矩阵相关" class="headerlink" title="矩阵相关"></a>矩阵相关</h3><p>了解过高等数学的读者可能看出来了，我们拿来举例子的二维数组，在数学上有个另外的名字，叫 <strong>矩阵</strong> 。</p><p>但我们又想了，这矩阵里面可能有很多 <strong>值相同的元素</strong> 或 <strong>0元素</strong> ，显然，它们用处不大，但是占据了很大一部分的存储空间，这就显得很浪费。因此，我们需要研究一下压缩存储的相关问题。</p><p>那首先，我们讨论一下压缩的基本规则：</p><ul><li>多个值相同的元素，我们只分配一个存储空间</li><li>0元素，我们不分配存储空间</li></ul><p>我们先看一些特殊的矩阵：</p><h4 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h4><p><strong>对称矩阵</strong> ，即 a<sub>ij</sub> &#x3D; a<sub>ji</sub> ，我们可以只为每对对称的元素分配一个存储空间，即我们可以只存储其下三角（包括对角线）中的元素。</p><blockquote><p>说的详细点，在内存中的下标存储方式：0 0、1 0、1 1、2 0、2 1、2 2、……、n-1 0、n-1 n-1。</p></blockquote><p>由这个规律，我们得出对称矩阵压缩存储时其下标计算公式：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + [i*(i+1)&#x2F;2 + j] * L;</p><blockquote><p>i*(i+1)&#x2F;2 是一个从1到i，公差为1的等差数列的求和公式，读者自己推一下即可。</p></blockquote><h4 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h4><p><strong>三角矩阵</strong> 即一个矩阵中只有其上（下）三角的位置有元素，其余部分为0元素或常数C。</p><p>因此，其实与对称矩阵非常类似，我们留出相应的三角矩阵的存储空间，而后增加一个存储常数C的存储空间即可</p><h3 id="稀疏矩阵相关"><a href="#稀疏矩阵相关" class="headerlink" title="稀疏矩阵相关"></a>稀疏矩阵相关</h3><p><strong>稀疏矩阵</strong> 即矩阵中零元素的出现没有规律的矩阵</p><p>在了解它如何压缩之前，我们先来了解一个概念—— <strong>稀疏因子</strong> 。<br>其定义为如果m行n列的矩阵中含有t个非零元素，我们称：</p><p>d &#x3D; t &#x2F; m*n</p><p>为稀疏因子，即数组中非零元素个数与非零元素个数的比。</p><p>如果这个稀疏因子的大小小于0.05，则我们称这个矩阵为稀疏矩阵。<br>这种稀疏矩阵造成了两种问题：</p><ul><li>零元素占据空间过大</li><li>进行运算时（除法 &#x2F; 取余），需要频繁的判断当前的除数是否为0</li></ul><p>这就代表着压缩存储的操作非常的必要</p><h4 id="三元组表示法"><a href="#三元组表示法" class="headerlink" title="三元组表示法"></a>三元组表示法</h4><p>这种压缩方法大概是最容易想到的了，即我们用一个线性表来表示稀疏矩阵，这个线性表中每个元素都是一个结构体，结构体里有三个元素，分别为非零元素的行下标、列下标、值。</p><p>相应的，习惯使然，我们在存储它时也已行下标优先的存储方法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment">//行、列下标</span>    Elemtype v<span class="token punctuation">;</span> <span class="token comment">//非0元素的值</span><span class="token punctuation">&#125;</span>Triple<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Triple data<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> num<span class="token punctuation">;</span> <span class="token comment">//矩阵的行数、列数、非零行个数</span><span class="token punctuation">&#125;</span>TSMatrix<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三元素表示法的加、减都挺简单，但一旦涉及到矩阵的 <strong>转置</strong> ，则事情就变得有些复杂。</p><hr><ul><li>三元组的转置——常规转置</li></ul><p>我们知道，常规矩阵的转置：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>line<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>col<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>放到三元组里面，我们可以采如下的转置方法：</p><ul><li>将矩阵的行、列值互相调换</li><li>将三元组存储行、列下标的变量互换</li><li>将三元组重新排成以行序为主序的顺序表</li></ul><p>这前两步非常简单，但第三步的实现需要琢磨一下，我们这里也给出两种方法：</p><ul><li>按照原先三元组列序的顺序查找（因为原先三元组的列序就是转置后三元组的行），而后按照顺序进行转置，转置后依次添加进一个新的三元组里面。</li><li>直接按照原先三元组中的顺序进行转置，此后将转置的每个元素置入与之对应的新位置里。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第一种方法</span><span class="token function">Trans</span><span class="token punctuation">(</span>TSMatrix M<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//M是需要被转置的矩阵，N是一个全新的矩阵</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//M非空</span>        N<span class="token punctuation">.</span>line <span class="token operator">=</span> M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>col <span class="token operator">=</span> M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>num <span class="token operator">=</span> M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> line <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//从M的第一列开始转置</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>                    <span class="token comment">//行列互换，值直接赋入新三元组</span>                    temp<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种方法非常清晰明了，但是显然效率不够，因为我们需要将三元组所有的元素都扫描很多遍，这显然不是很优雅。</p><p>这种转置方法存在循环的嵌套，因此其时间复杂度为：</p><p><strong>O(M.num * M.col);</strong></p><p>我们再想一想，我们如果能知道M中每一列的 <strong>第一个非零元</strong> 在N中应该存储的位置，那么我们在对M中的元素进行转置时，我们就可以直接将相应的元素放到N中合适的位置上，这就显得非常的理想。</p><p>问题来了，这法子需要怎么实现呢？</p><hr><ul><li>三元组的转置——快速转置</li></ul><p>我们想知道新矩阵每一行开始的位置，我们自然需要对原数组先进行一次遍历，通过这次遍历的结果得到我们想要的数据并进行储存。</p><p>因此，我们再设置两个数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">nums<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token comment">//表示原矩阵中第col列中含有多少个非零元素</span>cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token comment">//表示原矩阵中第col列的第一个非零元素在新矩阵中的起始位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：这里需要再啰嗦一嘴，原矩阵中的第col列其实就是新矩阵中的第col行，因此cpot[col]中的元素就是新矩阵里面第col行的起始下标。</p><p>我们可以通过以上的关系得到这个式子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cpot<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//第一行的第一个非零元的起始下标为1</span>cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> cpot<span class="token punctuation">[</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//第col行的第一个非零元的起始下标 = 上一行的起始下标 + 上一行的元素数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果将上述式子写成代码也非常简单，只需要用for循环遍历一遍，就能将nums数组中的所有元素得到，而后再通过nums遍历一遍得到cpot数组即可：</p><p>得到这个cpot数组后，转置的工作就很简单了，这里给出具体的转置代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第二种方法</span><span class="token function">Trans</span><span class="token punctuation">(</span>TSMatrix M<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//M非空</span>        N<span class="token punctuation">.</span>num <span class="token operator">=</span> M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>line <span class="token operator">=</span> M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>col <span class="token operator">=</span> M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> nums <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> copt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里之所以每个数组都多分配一个空间是因为想让下标从1开始，与三元组统一</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//初始化nums数组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//遍历M中每一个元素，该元素是哪一列，就把nums相应下标的值+1</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//nums数组赋值完成</span>        cpot<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cpot<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cpot<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//通过遍历得到cpot每一个值</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//cpot数组赋值完成</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>p<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> col <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>            <span class="token keyword">int</span> place_in_N <span class="token operator">=</span> cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">+</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>            <span class="token comment">//在新三元组N中的下标为：行起始下标+新矩阵中的列下标（也就是原矩阵中的行下标）</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>            <span class="token comment">//行，列下标互换，值不变</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述完整方法其实理解起来有一定难度，主要是因为需要定义以及捋清楚的变量非常多，如果读者暂时无法理解全部，也可以先放一放，或者跟着此前的梳理顺序再来一遍。</p><p>我们再来看这个算法的时间复杂度：</p><p>我们通过分别对M的列以及M的所有元素进行遍历，实现了这个算法，其时间复杂度为</p><p><strong>O(M.num + M.col);</strong></p><p>这个加式可比之前那个乘方式好看多了</p><hr><h4 id="行逻辑链接表示法"><a href="#行逻辑链接表示法" class="headerlink" title="行逻辑链接表示法"></a>行逻辑链接表示法</h4><p>三元组表示法的优点在于其内每个非零元素的行下标与列下标都非常清晰，可以直接提取出来，但是如果我们需要随机存取某一行中的非零元，则三元组需要从头开始遍历，不是非常的优雅。</p><p>我们参考三元组快速转置中的思路，直接将一个数组rpos添加到压缩后矩阵的结构体的定义中，其代表的就是每一行第一个非零元在三元组中的下标。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Triple data<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> num<span class="token punctuation">;</span> <span class="token comment">//矩阵的行数、列数、非零行个数</span>    <span class="token keyword">int</span><span class="token operator">*</span> rpos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>RLSMatrix<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话，我们如果给定一组下标(r, c)，我们就可以直接通过以下的算法进行取值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Elemtype <span class="token function">value</span><span class="token punctuation">(</span>RLSMatrix M<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//r:行数; c:列数</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> M<span class="token punctuation">.</span>rpos<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">==</span> r <span class="token operator">&amp;&amp;</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">&lt;</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">==</span> r <span class="token operator">&amp;&amp;</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="行-列链接存储表示法"><a href="#行-列链接存储表示法" class="headerlink" title="行 &#x2F; 列链接存储表示法"></a>行 &#x2F; 列链接存储表示法</h4><p>如果我们想用指针来对稀疏矩阵进行存储，思路也很简单：<br>我们可以以每行 &#x2F; 每列为单位，存储一个链表的头节点，在其后面存储每一个不为0的元素为一个节点。</p><p>这里以行链接表示法为例，给出具体定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">&#123;</span>    Elemtype v<span class="token punctuation">;</span>    <span class="token keyword">int</span> col <span class="token comment">// 每一个元素的列数</span>    LinkNode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CpMatrix</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> num<span class="token punctuation">,</span> line<span class="token punctuation">,</span> col<span class="token punctuation">;</span>    LinkNode<span class="token operator">*</span> Head<span class="token punctuation">;</span> <span class="token comment">//链表的头指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用图示表示一下：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.5/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A1%8C%E9%93%BE%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="行链接存储"></p><p>看到这里，有些读者可能就有些 <del>大胆的想法</del> ，哎？我如果行与列都加上一个链表来存储呢？当然可以，不过这种玩意维护起来就显得有亿点点麻烦了，有需求的读者可以自行尝试实现，这里权当抛砖引玉。让我们在读者的思想变得更危险之前进入下一个话题…</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><blockquote><p>广义表这个玩意其实目前用的已经很少了，因为它的定义方式决定着这玩意哪怕是用手画都很难理解，并且捋清楚层次，更别提用真正的计算机来实现它了，其实这玩意的思路跟后面要叙述的 <strong>多叉树</strong> 非常的接近，占用空间又比树大，所以嘛…</p></blockquote><p>说了这么多，毕竟这玩意也是数据结构的考点，还是在这里大体捋一下。</p><p><strong>广义表</strong> 是用递归形式定义的线性结构，是线性表的推广，它的元素可以是一个单元素，也可以是一个子表。</p><p>LS &#x3D; (α<sub>1</sub>, α<sub>2</sub>, α<sub>3</sub>, …, α<sub>n</sub>);</p><p>以上是它的书写形式，LS是其表名，而其中的α<sub>1</sub>, α<sub>2</sub> 等元素，可以是一个元素，也可以是又一个表 <del>（这不纯纯tm套娃吗）</del></p><p>上面的定义决定了广义表这玩意有以下性质：</p><ul><li>广义表里的元素是有顺序的</li><li>广义表的长度：最外层的表含有的元素个数</li><li>广义表的深度：广义表所含括弧的重数，即其最深的一枝能深到第几层</li><li>广义表可以是递归的</li></ul><h3 id="广义表的分解"><a href="#广义表的分解" class="headerlink" title="广义表的分解"></a>广义表的分解</h3><p>这里咱单开一块来说一说广义表分解这一茬事情，因为这玩意的定义方式使得分解很容易把人绕晕喽。</p><p>我们通常认为，任何一个广义表，都可以被分解成表头和表尾：</p><ul><li>表头是广义表的第一个元素</li><li>表尾是广义表的 <strong>剩余元素组成的新广义表</strong></li></ul><p>请希望学习这一部分的读者提高重视，表头是一个元素，而表尾必定是一个 <strong>广义表</strong> 。这个分解方式在学习时已经坑了笔者很多次了，希望读者能够不要像笔者一样踩这么多坑。</p><p>我们举个例子：<br>有个广义表：</p><p>D &#x3D; (E, F);<br>其中E &#x3D; (a, b, c); F &#x3D; z;</p><p>那么 <strong>D的表头</strong> 就是 <strong>E</strong> ，而 <strong>D的表尾</strong> 是 <strong>(F)</strong> 。<br>再写一个，加深一下印象：<strong>E的表头</strong> 是 <strong>a</strong> ，而 <strong>E的表尾</strong> 是 <strong>(b, c)</strong> 。</p><p>在读者能够清晰地分辨出表头和表尾的区别后，我们进入下面的章节。</p><h3 id="广义表的表示"><a href="#广义表的表示" class="headerlink" title="广义表的表示"></a>广义表的表示</h3><blockquote><p>由于广义表的定义过于复杂，拆解也很复杂，因此广义表的表示通常只能用链表这一结构来实现。</p></blockquote><p>我们首先明确一下，广义表中，存在两类节点：</p><ul><li>表节点（表示这里面是另一个表）</li><li>原子节点（表示这里面只有一个元素）</li></ul><p>这两类节点通过一个额外的表示符 <strong>tag</strong> 来区分。</p><p>我们这里只说一种表示方法</p><h4 id="表头、表尾分析法"><a href="#表头、表尾分析法" class="headerlink" title="表头、表尾分析法"></a>表头、表尾分析法</h4><p>这法子挺自然的，刚刚说了拆分方式嘛，所以我们干脆直接将节点中拆出两个玩意来，一个指向表头，一个指向表尾。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">GenNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//表节点</span>    GenNode<span class="token operator">*</span> ListHead<span class="token punctuation">,</span> ListTail<span class="token punctuation">;</span> <span class="token comment">//分别指向表头以及表尾</span><span class="token punctuation">&#125;</span>GenList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Atom</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//原子节点</span>    Elemtype value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里举一个相对复杂的例子来让读者再次理解这个分析的方法</p><p>A&#x3D;( ) ; B&#x3D;(e) ; C&#x3D;(a,(b,c,d)) ; D&#x3D;(A,B,C)</p><p>我们把D用这种方法来表示出来：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.5/%E5%B9%BF%E4%B9%89%E8%A1%A8%20%E8%A1%A8%E5%A4%B4%E8%A1%A8%E5%B0%BE%E5%88%86%E6%9E%90%E6%B3%95.png" alt="D 表头表尾分析法"></p><p>可以得见，这玩意真要表示需要耗费多少空间…</p><blockquote><p>其实这玩意还有另一种表示方式叫 <strong>子表分析法</strong> ，这种法子相对而言比较节省空间，但是把这玩意写出来的话想必读者会更混乱，这里有需求的读者可以自行查阅其他资料。</p></blockquote><h3 id="广义表的相关算法"><a href="#广义表的相关算法" class="headerlink" title="广义表的相关算法"></a>广义表的相关算法</h3><p>这里我们只写一个广义表求深度的算法，我们利用递归的思想来求一个广义表的深度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">GetDepth</span><span class="token punctuation">(</span>GenList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//L是空表，深度为1</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//L是原子节点，返回深度0</span>    <span class="token punctuation">&#125;</span>    GenNode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>L<span class="token punctuation">;</span>    <span class="token keyword">int</span> max<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>ListTail<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> dep <span class="token operator">=</span> <span class="token function">GetDepth</span><span class="token punctuation">(</span>p<span class="token operator">-></span>ListHead<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dep <span class="token operator">></span> max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//当前表头的深度比此前得到的深度更深</span>            max <span class="token operator">=</span> dep<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>至此，数组与广义表的内容就阐述的差不多了。</p><p>额外提一嘴，广义表的相关概念，考虑到日常生活中的应用概率较低，可以不必过于在意，但如果是因为数据结构考试的话，建议还是深入思考一下（苦笑</p><p>好啦，这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-4</title>
      <link href="/posts/55778.html"/>
      <url>/posts/55778.html</url>
      
        <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><blockquote><p>本章是 <strong>串</strong> 这种结构的大体梳理</p></blockquote><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p><strong>串</strong> 是由零个或多个字符组成的有限序列。</p><p>由于串实在过于常见，因此大多数语言都提供了一些基础的对串格式的支持，如C中的字符串拼接、复制、分割函数；C++中的string类，Java中的String类等。</p><p>很显然，不同的语言对串的支持程度不尽相同，因此这里仅仅提一个概念， <strong>串的最小操作子集</strong> ，即可以用这个集合里的函数实现任何想要对串进行的操作。</p><ul><li>串赋值（CharAssign）</li><li>串复制（Strcopy）</li><li>串比较（StrCompare）</li><li>求串长（StrLength）</li><li>串连接（Concat）</li><li>求子串（SubString）</li></ul><p>可以看出，其实串跟我们第一章所了解的 <strong>线性表</strong> 是很相似的，只不过，串存储的是一个个字符，同时串也常常以 <strong>一组字符</strong> 为单位进行增删改查，而不像线性表一样以 <strong>单个单元</strong> 为单位进行。</p><h2 id="串的存储"><a href="#串的存储" class="headerlink" title="串的存储"></a>串的存储</h2><h3 id="串的堆分配存储"><a href="#串的堆分配存储" class="headerlink" title="串的堆分配存储"></a>串的堆分配存储</h3><p>这种存储方式是串最常见的存储方式。其利用动态内存分配进行存储管理。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HString<span class="token punctuation">;</span><span class="token comment">//当需要进行内存分配时</span>ch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>length<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他存储方式"><a href="#其他存储方式" class="headerlink" title="其他存储方式"></a>其他存储方式</h3><p>读者读到这里可能会产生两个疑惑：</p><ul><li>直接用数组不行吗</li><li>想用链表存储</li></ul><p>用数组，即被称为 <strong>串的定长顺序存储</strong> ，其弊端在于无法改变串的长度，当进行操作时很容易产生长度过长的问题，这种情况下，数组存储只能进行截断操作，这导致了串内容的丢失。</p><p>用链表，即被称为 <strong>串的块链存储</strong> ，其可以通过链表对串进行连接，同时链表每个节点中需要存储多少字符也可以由个人决定，但是这种存储方式使原本十分简单的复制、连接等操作变得极为复杂，一般不会采取这种存储方式。</p><h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h2><p>通常，字串的定位操作被称为 <strong>串的模式匹配</strong> ，表示为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">INDEX</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其意义表示为：如果主串S中存在与字串T相同的串，则返回其在字串下标pos后第一次出现的位置。<br>这定义听着挺拗口的，读者不妨把它理解成字串查找即可。</p><p>我们现在想一想，如果要实现这个功能，该如何设计？</p><h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>这是我们大概第一眼就会想到的算法，主串从前往后循环，遇到与字串相同的字符则开始一个子循环流程，子循环能跑完，则代表着串匹配了，返回当前主串循环的下标。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">INDEX</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> S<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            i <span class="token operator">=</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//匹配失败，指针回退</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//说明子循环跑完了，有字串</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种算法固然清晰，但其时间复杂度为O(m*n)，即字串与主串的长度的乘积，这太长了。</p><h3 id="首尾匹配算法"><a href="#首尾匹配算法" class="headerlink" title="首尾匹配算法"></a>首尾匹配算法</h3><p>这种算法算得上一种折中，即每次比较时，优先比较首尾的元素，再比较中间的剩余元素，但由于这种算法并算不上真正降低了时间复杂度，这里不再详述。</p><h3 id="KMP算法（重点）"><a href="#KMP算法（重点）" class="headerlink" title="KMP算法（重点）"></a>KMP算法（重点）</h3><h4 id="KMP概述"><a href="#KMP概述" class="headerlink" title="KMP概述"></a>KMP概述</h4><p>我们再次甚至暴力求解的第一个算法，发现其实主要的重复计算时间来源，是主串中 <strong>每次字符失配时的指针回退</strong> 。如果我们能够达到一种主串中指针永远不回退的算法，那将大大降低我们的算法耗时。</p><p>我们这里举一个例子：</p><p>主串的内容：A B A B A B C</p><p>字串的内容：A B A B C</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-1.png" alt="初始情况"></p><p>如果按照暴力求解的算法，第一次匹配，字串匹配到了C，发现与主串的A不相同，则主串指针回退至B，字串指针回退至A，再次匹配。</p><p>但我们想的理想情况是将字串的A与主串中第三个A齐平，同时可以跳过重复的AB，直接从第三个字符开始比较。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-2.png" alt="理想情况"></p><p>要实现这个跳跃过程，我们需要借助一个数组，这个数组的作用是当字串与主串的字符发生失配现象了，下一次比较时主串需要与哪一个字串中的字符相比较。</p><p>我们用具体的程序来表达一下这个算法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">INDEX_KMP</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> S<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//当主串中的字符与字串的第一个字符失配，或者主串与字串还未失配时，继续向后比较</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//此时失配，则j回退至next[j]所指向的位置，i不变</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>那么现在的问题就从如何降低时间复杂度变为这个next数组该怎么求了。</p><p>这里原理不进行详细叙述，给出公式：<br>next[j] &#x3D; 此前已成功匹配的字串中最长的相同前后缀+1</p><p>前缀，即不包含最后一个字符的字串（从前往后看）<br>后缀，即不包含第一个字符的字串（从后往前看）</p><p>特殊的，next[1] &#x3D; 0</p><p>比如上例：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-3.png" alt="next"></p><ul><li>第一个字符A: next[1] &#x3D; 0</li><li>第二个字符B: 不存在相同的前后缀，next[2] &#x3D; 0+1 &#x3D; 1</li><li>第三个字符A: 不存在相同的前后缀，next[3] &#x3D; 0+1 &#x3D; 1</li><li>第四个字符B: 前缀”A”与后缀”A”相等，next[4] &#x3D; 1+1 &#x3D; 2</li><li>第五个字符C: 前缀”AB”与后缀”AB”相等，next[5] &#x3D; 2+1 &#x3D; 3</li></ul><h4 id="nextval数组"><a href="#nextval数组" class="headerlink" title="nextval数组"></a>nextval数组</h4><p>next数组已经可以达到主串指针不回溯的目的了，但是还有最后一点点小遗憾：</p><p>我们假设字串为：A A A A B</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-4.png" alt="next"></p><p>我们假设程序在比较时，恰巧在B这一点失配了。接下来我们应该干什么？</p><p>根据我们此前的讲述：程序会根据 <strong>next[5] &#x3D; 4</strong> 来将主串指针当前字符与字串的第四个字符A比较。</p><p>如果能够匹配还好，如果不匹配呢？</p><p>那就会出现，继续根据 <strong>next[4] &#x3D; 3</strong> 、 <strong>next[3] &#x3D; 2</strong> …等等语句，与字串的第三个字符A，第二个字符A，第一个字符A，比了三次，然后发现，哦，第一个都对不上，那主串的指针往后移动一位。</p><p>发现问题了吗？ 字串的前几位其实都一样，那么如果我跟第四个字符A比完之后，其实再跟第三个、第二个、第一个A比较的过程完全可以省去，因为一定会失配。</p><p>这就是为什么我们会再引入一个数组，叫nextval，这个数组就是为了防止上述问题的发生而出现的。<br>其具体方法为：如果 <strong>next[j] &#x3D;&#x3D; k</strong> ，同时字串中 <strong>T[j] &#x3D;&#x3D; T[k]</strong> ，那么我们就不用让主串S再跟字串中T[k]比较了，因为必定失配，我们让S当前位置的字符直接跟 <strong>T[next[k]]</strong> 进行比较。</p><p>nextval的具体求法是通过next数组来的：</p><ul><li>如果T[k] &#x3D;&#x3D; T[j] : 则nextval[j] &#x3D; nextval[k]</li><li>如果T[k] !&#x3D; T[j] : 则nextval[j] &#x3D; next[j]</li></ul><p>我们还是拿刚才那个例子来举例：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-5.png" alt="nextval"></p><ul><li>第一个元素A：照常，nextval[1] &#x3D; 0</li><li>第二个元素A：next[2] &#x3D; 1, 并且T[1] &#x3D;&#x3D; T[2] &#x3D;&#x3D; ‘A’, 因此nextval[2] &#x3D; nextval[1] &#x3D; 0</li><li>第三个元素A：next[3] &#x3D; 2, 并且T[2] &#x3D;&#x3D; T[3] &#x3D;&#x3D; ‘A’, 因此nextval[3] &#x3D; nextval[2] &#x3D; 0</li><li>第四个元素A：next[4] &#x3D; 3, 并且T[3] &#x3D;&#x3D; T[4] &#x3D;&#x3D; ‘A’, 因此nextval[4] &#x3D; nextval[3] &#x3D; 0</li><li>第五个元素B：next[5] &#x3D; 4, 但(T[4] &#x3D;&#x3D; ‘A’) !&#x3D; (T[5] &#x3D;&#x3D; ‘B’), 因此nextval[5] &#x3D; next[5] &#x3D; 4</li></ul><p>至此，nextval这个next的改进版数组也讲解完毕了，我们实现了一个线性时间复杂度的串模式比对算法。</p><hr><p>至此，串的各种事项大致梳理完毕，该部分的重点就是KMP算法的理解。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数电-Chap.1</title>
      <link href="/posts/33374.html"/>
      <url>/posts/33374.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：本课程会着重于半导体器件、逻辑代数以及逻辑门的学习，达到基本能够进行组合电路，时序电路以及运放（运算与放大）电路的识别、设计等操作。</p></blockquote><h1 id="数字逻辑基础"><a href="#数字逻辑基础" class="headerlink" title="数字逻辑基础"></a>数字逻辑基础</h1><h2 id="1-计数体制"><a href="#1-计数体制" class="headerlink" title="1. 计数体制"></a>1. 计数体制</h2><h3 id="1-1-数制"><a href="#1-1-数制" class="headerlink" title="1.1 数制"></a>1.1 数制</h3><p>我们将日常生活中由低位数向高位进位的规则称为 <strong>数制</strong> 。</p><p>在数字系统中，常用的数制包括：</p><ul><li>十进制（Decimal）</li><li>二进制（Binary）</li><li>八进制（Octal）</li><li>十六进制（Hexadecimal）</li></ul><p>它们分别表示逢几进一。</p><h3 id="1-2-进制的转换"><a href="#1-2-进制的转换" class="headerlink" title="1.2 进制的转换"></a>1.2 进制的转换</h3><h4 id="其他进制-十进制"><a href="#其他进制-十进制" class="headerlink" title="其他进制 -&gt; 十进制"></a>其他进制 -&gt; 十进制</h4><p>按权相加：将非十进制的各位权重乘以对应位的权重，再相加。<br>如：(10011.011)<sub>2</sub> -&gt; (?)<sub>10</sub><br>其计算过程为：1 * 2<sup>4</sup> + 1 * 2<sup>1</sup> + 1 * 2<sup>0</sup> + 1 * 2<sup>-2</sup> + 1 * 2<sup>-3</sup></p><h4 id="十进制-其他进制"><a href="#十进制-其他进制" class="headerlink" title="十进制 -&gt; 其他进制"></a>十进制 -&gt; 其他进制</h4><p>一般会将十进制的整数部分与小数部分分别转换并相加。<br>整数部分采用 <strong>除基取余法</strong> ，小数部分采用 <strong>乘基取整法</strong> 。<br>如：(25.25)<sub>10</sub> -&gt; (?)<sub>2</sub><br>整数25部分：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E9%99%A4%E5%9F%BA%E5%8F%96%E4%BD%99.png" alt="除基取余"></p><p>小数0.25部分：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E4%B9%98%E5%9F%BA%E5%8F%96%E6%95%B4.png" alt="乘基取整"></p><h4 id="其他进制之间的互相转换"><a href="#其他进制之间的互相转换" class="headerlink" title="其他进制之间的互相转换"></a>其他进制之间的互相转换</h4><ul><li><p>二进制 -&gt; 八进制 &#x2F; 十六进制：<br>通常可以采用三位 &#x2F; 四位二进制转为一位八进制 &#x2F; 十六进制的方法进行快速转化</p></li><li><p>八进制 &#x2F; 十六进制 -&gt; 二进制：<br>通常可以采用一位八进制 &#x2F; 十六进制转为三位 &#x2F; 四位二进制的方法进行快速转化</p></li></ul><p>注：上述方法运用时从小数点开始往左 &#x2F; 右进行转化，别忘记高位补0</p><h2 id="2-编码"><a href="#2-编码" class="headerlink" title="2. 编码"></a>2. 编码</h2><p>由于在计算机内，处理、存储、传输的都是二进制数据，因此将外界信息通过二进制进行表示这一过程就显得尤为重要，这一过程被称为 <strong>编码</strong></p><p>常见的编码有：</p><ul><li>BCD码</li><li>ASCⅡ</li></ul><h3 id="BCD编码"><a href="#BCD编码" class="headerlink" title="BCD编码"></a>BCD编码</h3><p>利用四位二进制数来表示一位十进制数的过程被称为 <strong>BCD编码</strong></p><p>常用的BCD编码有：</p><ul><li>8421码</li><li>余3码</li><li>2421码</li></ul><p>其中8421码尤为常用，其名称代表着各个位次上二进制数字的权值</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/BCD%E7%A0%81.png" alt="8421"></p><h3 id="ASCⅡ"><a href="#ASCⅡ" class="headerlink" title="ASCⅡ"></a>ASCⅡ</h3><p>ASCⅡ（American National Standard Code for Information Interchange）用于通过八位二进制数来表示生活中常用的数字与符号，其中低七位用于表示，最高一位用于奇偶校验。</p><p>具体图片烦请读者自行上网搜索。</p><h2 id="3-逻辑代数基础"><a href="#3-逻辑代数基础" class="headerlink" title="3. 逻辑代数基础"></a>3. 逻辑代数基础</h2><p>与现实中不尽相同，计算机由于采用二进制，因此其逻辑判断也仅有两种状态，即1（真）与0（假），在数字系统中，我们又常常将电位与真假相关联，即高电位（也称高电平）表示1，低电位（也称低电平）表示0。</p><h3 id="3-1-基本逻辑运算与基本逻辑门"><a href="#3-1-基本逻辑运算与基本逻辑门" class="headerlink" title="3.1 基本逻辑运算与基本逻辑门"></a>3.1 基本逻辑运算与基本逻辑门</h3><h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><p><strong>与运算</strong> 表示参与某一事件的全部条件都为真时，该事件才能发生。</p><h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><p><strong>或运算</strong> 表示参与某一事件的某一条件为真时，该事件就能发生。</p><h4 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h4><p><strong>非运算</strong> 表示将某一事件原本的真值倒置，1变0，0变1。</p><h4 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h4><p><strong>同或运算</strong> 表示参与某一事件的两个条件相同时，该事件才能发生。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%90%8C%E6%88%96%E8%BF%90%E7%AE%97.png" alt="同或运算真值表"></p><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p><strong>异或运算</strong> 表示参与某一事件的两个条件不同时，该事件才能发生。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.png" alt="异或运算真值表"></p><h3 id="3-2-常用化简公式"><a href="#3-2-常用化简公式" class="headerlink" title="3.2 常用化简公式"></a>3.2 常用化简公式</h3><p>数电中的化简方式繁多，这里给出一些常用的公式与定律，仅供参考<br><del>（有卡诺图谁用公式啊）</del></p><ul><li><strong>摩根定律</strong> ：$\overline{\text{A * B}}$ &#x3D; $\overline{\text{A}}$ + $\overline{\text{B}}$<br>注：该公式来源于 <strong>反演率</strong> ，即将公式中所有的乘加互换，01互换，原变量反变量互换，就可以得到原逻辑函数的反函数</li><li><strong>吸收率</strong> ：A * (A + B) &#x3D; A</li><li><strong>对偶规则</strong> ：若两个逻辑函数相等，则它们的对偶式也对应相等。（对偶式的写法与摩根定律反演率相同）</li></ul><h3 id="3-3-逻辑函数的表示"><a href="#3-3-逻辑函数的表示" class="headerlink" title="3.3 逻辑函数的表示"></a>3.3 逻辑函数的表示</h3><p>逻辑函数通常有以下五种表达方式：</p><ul><li>真值表</li><li>逻辑表达式</li><li>逻辑图</li><li>波形图</li><li>卡诺图</li></ul><p>这其中，在手动化简时，以卡诺图最为常用：<br>具体表示为一个表格，表格横坐标与纵坐标均表示一个或多个逻辑变量，在相应的最小项处标记0 &#x2F; 1表示假 &#x2F; 真，而后利用偶数对画圈法将所有的1都圈起来，根据圈写出逻辑表达式。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%9B%9B%E5%8F%98%E9%87%8F%E5%8D%A1%E8%AF%BA%E5%9B%BE.png" alt="四变量卡诺图"></p><p>这里举个例子：<br>假如m0, m1, m12, m13, m15, m14均为1，其他项均为0，则m0, m1为一组，表示为：$\overline{\text{A}}$ * $\overline{\text{B}}$ * $\overline{\text{C}}$ 。而剩余四个为一组，表示为： A * B<br>整体表达式为：<br>（$\overline{\text{A}}$ * $\overline{\text{B}}$ * $\overline{\text{C}}$ ）+ （A * B）</p><hr><p>这篇博文就到这里~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.4</title>
      <link href="/posts/35903.html"/>
      <url>/posts/35903.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><blockquote><p>上一篇博文中，我们大致对类及其特点进行了些许介绍，本文中将更进一步介绍一些常用的操作与注意事项</p></blockquote><h2 id="类方法中参数的传递"><a href="#类方法中参数的传递" class="headerlink" title="类方法中参数的传递"></a>类方法中参数的传递</h2><h2 id="类中的静态成员"><a href="#类中的静态成员" class="headerlink" title="类中的静态成员"></a>类中的静态成员</h2><p>试想一下，如果一个类中有这样的语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Text</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        number<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然，上述语句中count与number的性质并不同，count是一个静态变量，只能进行一次初始化，而number是一个普通变量，可以多次初始化。</p><p>正由于这种区别的存在，我们称如count这种的变量为静态变量，其生命周期与类相同，而number这样的变量的生命周期则与其对象相同。也可以说，静态变量属于类，而常规变量属于对象。</p><p>这样的变量很特殊，在java中，可以直接通过类名在外部访问这个变量，如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>类似的，如果static加在方法前，则称为 <strong>类的方法</strong> ，它也可以通过 类名.方法名 的形式进行外部访问。比如java中的math类，就有相关的特点。</p></blockquote><h2 id="单态设计模式-Singleton"><a href="#单态设计模式-Singleton" class="headerlink" title="单态设计模式(Singleton)"></a>单态设计模式(Singleton)</h2><p>在java中常见一种特殊的类，为了保障数据的一致性，这种类的实例，在一次编译过程中仅有一个，我们称之为 <strong>单例类</strong> ，构造一个单例类的过程我们称之为 <strong>单态设计模式</strong> 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Company</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Company</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Vehicle</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fleet<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Company</span> <span class="token function">getCompany</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种构造方法是私有的，保证了从外部无法访问相关的构造方法，此外其通过另一个静态函数getCompany来传入参数，间接进行唯一一个的Company的初始化。这样就保证了一个程序内只存在一个Company类。</p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final在java中用途繁多，主要有以下三种：</p><ul><li>final加在变量前，表示常量，只能进行一次赋值</li><li>final加在方法前，表示该方法无法被重写</li><li>final加在类前，表示该类是最终类，无法被继承（没有子类）</li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>类似于C，java中也存在枚举类型，其定义方法为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Red</span><span class="token punctuation">,</span> <span class="token class-name">Green</span><span class="token punctuation">,</span> <span class="token class-name">Blue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="抽象类-Abstract-class"><a href="#抽象类-Abstract-class" class="headerlink" title="抽象类(Abstract class)"></a>抽象类(Abstract class)</h2><p>java中涉及到一些类，它们没有具体的参数值，仅有一些方法，具体的参数需要在其子类下进行定义，我们称这种类型为 <strong>抽象类</strong> 。</p><p>这样的类定义需要加入 <strong>abstract</strong> 关键字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>抽象类常用于定义同一类型的对象的相似方法。</p><blockquote><p>其实，抽象类也可以没有抽象方法，如果这样的话，这种类就只能进行子类派生操作。</p></blockquote><h2 id="接口-Interfaces"><a href="#接口-Interfaces" class="headerlink" title="接口(Interfaces)"></a>接口(Interfaces)</h2><blockquote><p>上文中提到了利用抽象类来定义同一类型的实体的相似方法，但如果对象类型不同，就需要利用接口了</p></blockquote><p>接口用于定义不同对象的相同行为，其定义中仅有函数声明与静态常量，没有具体实现代码，需要在不同的类中重写。</p><p>接口的定义通常如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token generics"><span class="token punctuation">&lt;</span>interface_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> function1 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> function2 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可见，接口的定义与C中的函数声明很相似，仅声明出这个函数的存在，不给出具体方法。</p><p>而具体需要使用接口的函数时，需要这样写出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token generics"><span class="token punctuation">&lt;</span>interface_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token comment">//对接口函数进行重写</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h3><p>从jdk-8开始，接口中引入了默认方法，用default关键字修饰，这样的方法可以有具体的实现代码，这种特性使得接口在添加方法时不需要对所有应用接口的类进行重写，主要目的在于提高兼容性。</p><hr><p>关于面向对象的内容肯定不仅仅这么多，上述博文会在进一步了解java后继续完善。</p><p>目前，本篇博文就到这里～</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.3</title>
      <link href="/posts/20094.html"/>
      <url>/posts/20094.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-类与方法"><a href="#Java-类与方法" class="headerlink" title="Java 类与方法"></a>Java 类与方法</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类是什么"><a href="#类是什么" class="headerlink" title="类是什么"></a>类是什么</h3><p><strong>类</strong> 有些类似C中的结构体，不过Java中的类除了变量外，也可以包含函数，我们称之为 <strong>方法</strong> 。</p><blockquote><p>如果读者接触过C++，那么可以将类理解为一种 <strong>模板</strong> ，而每个实例都是对于模板的一种创建过程。</p></blockquote><h3 id="类的特点与必要性"><a href="#类的特点与必要性" class="headerlink" title="类的特点与必要性"></a>类的特点与必要性</h3><p>类的代码可重用，这极大程度上降低了代码语言的重复性，同时有效提高了便捷度。<br>通常而言，Java中的类具有以下三种特点：</p><ul><li>继承性</li><li>多态性</li><li>封装性</li></ul><p>这三种特点的具体表现将在以下详细阐述。</p><h3 id="类的定义-实例的声明"><a href="#类的定义-实例的声明" class="headerlink" title="类的定义 &amp; 实例的声明"></a>类的定义 &amp; 实例的声明</h3><p>Java是面向对象的编程语言，这就意味着类是Java中的基础构成部分，任何一个Java程序均离不开类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token keyword">public</span> <span class="token operator">/</span> <span class="token keyword">private</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">abstract</span> <span class="token operator">/</span> <span class="token keyword">final</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token punctuation">[</span><span class="token keyword">extends</span> class_name<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>property_type<span class="token punctuation">></span></span> var1<span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>property_type<span class="token punctuation">></span></span> var2<span class="token punctuation">;</span>        function1 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    function2 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//若在编写中需要使用这个类，则利用以下语句进行声明：</span><span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token generics"><span class="token punctuation">&lt;</span>var_name<span class="token punctuation">></span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句能够表示一个Java类的定义，其中public &#x2F; private 表示类的访问权限，abstract &#x2F; final表示类是否为抽象类 &#x2F; 是否能被继承，内部的var1 表示变量声明，而后的function表示方法（具体函数）。</p><p>如同我们此前讲过的那样，Java类中可以声明所有的数据类型，但在声明过后，如果不进行初始化，Java会使用 <strong>默认值自动对其进行初始化操作</strong> ，默认值如下：</p><ul><li>int: 0</li><li>double &#x2F; float: 0.0</li><li>char: “\u0000”</li><li>boolean: false</li><li>数组: NULL</li></ul><p>除此之外，Java中的类允许 <strong>方法</strong> 的定义，类似于C中的一个函数，可以进行这种类中可能涉及的操作，并返回相应的值。</p><p>与此同时，Java的类，类中的变量声明，类中的方法定义，均可以在前方添加 <strong>访问控制符</strong> 具体请看下文对于访问控制符的内容。</p><p>需要注意的是，类的名称通常使用大写字母开头，请尽可能养成这样的习惯，这有利于我们的程度可读性。</p><h3 id="类中的构造函数与this关键字"><a href="#类中的构造函数与this关键字" class="headerlink" title="类中的构造函数与this关键字"></a>类中的构造函数与this关键字</h3><p>在Java中的类中，常见用private对其内变量进行修饰，以此保证类的运行安全性。这种定义方式被称为 <strong>类的封装</strong> 。但这样做的后果是，无法从类的外部对类内部的变量直接进行更改，因此，Java的类提供了一种 <strong>构造函数</strong> 的方法，它与类同名，可以接受外部参数并以此根据其规则改变内部参量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看出，在这里，从外部传入的参数叫age，name，但对象内也有叫做同样名字的参量。因此，Java引出了 <strong>this</strong> 关键字，在变量名前方加入this. ，则表示指向 <strong>当前对象内的参数</strong> 。我们能通过这样的特性，对类内的私有参量进行赋值。</p><p>对类的封装能够使编译者或程序使用者在对类进行操作时更有条理，也避免了外部随意修改类内部代码的情况。</p><p>此外，在一个类中的一个方法需要利用其所在类内的另一个方法时，可以使用&lt;this.method_name&gt;来对其进行调用。</p><h3 id="类中方法的重载"><a href="#类中方法的重载" class="headerlink" title="类中方法的重载"></a>类中方法的重载</h3><p>Java中的类允许存在多个重名的方法，这被称为 <strong>重载(Overload)</strong> ，而重载的要求为两个同名函数的参数列表必须有区别。</p><h3 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h3><p>Java类中的方法允许传入多个同类型的参数，具体定义方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setnames</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> names<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用这样的定义，可以直接传入多个String。</p><p>这里提供另一种写法，其用途与上述定义相似，区别在于其基于数组传入参数，因此从外部调用时需要先行构造数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setnames</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>为了考虑一个文件，一个类在其他位置的访问权限，Java中提出了 <strong>访问控制修饰符</strong> 的概念。</p><p>Java有4类访问控制修饰符：</p><ul><li>private：仅仅允许同一个类中的方法来访问。</li><li>default：同一个包里文件都可以访问。</li><li>protected：不仅仅同一个包中，只要是它的子类，均可以访问。</li><li>public：完全公开。</li></ul><p>此外，Java中规定了，在一个源文件中（.java）， <strong>允许且仅允许</strong> 一个 <strong>public</strong> 类的存在，请在编写中注意这一点。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>当两个类具有相同的属性时，我们往往可以使用 <strong>继承</strong> 的方法进行定义。<br>这种情况下，有父类与子类之分，子类具有父类的全部属性和方法，同时也可以进行相应更具体属性、方法的添加。</p><p>这种方法常用 <strong>extends</strong> 关键字来进行操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Java中，所有后方没有进行extend的类，都会在编译时自动扩展为 <strong>extends Object</strong> ，这是因为Object类是java中所有类的父类，是个默认定义。因此，Java中除了Object类之外，严格来说其他的类均有父类。</p><p>当然，这其中也必然涉及到一些父类的属性我们不希望继承到子类中，或者希望在子类中对父类的方法进行覆盖，这就涉及到修饰符的问题了。</p><blockquote><p>额外提一句，其实C++中有继承的方法，并且允许多亲继承，即一个子类有多个父类，但这种方法在两个父类的方法名相同时会引起冲突。Java考虑到了这一点，并不允许多亲继承。</p></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们也会遇到，在子类中已经对父类的方法进行覆盖，但我们仍然希望调用父类中的特定方法的情况，我们常用 <strong>super</strong> 来进行操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> x <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"Manager"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h3><p>Java基于子类必须基于父类这一原则，声明了子类的构造方法必须首先调用父类的构造方法，这种构造可以是显性的，也可以是隐性的。</p><p>这就代表着子类的构造函数必定会对父类的构造函数进行引用，而这里也常常出现一个很不容易发现的问题：<br>如果父类中没有无参的构造方法，而子类中的构造方法内又没有明确声明要使用父类的哪种有参构造方法，则每次构造子类对象时，都会默认先调用父类的无参构造方法，这就导致了编译错误。</p><p>这段话听起来有点绕腾：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Preson</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上的代码是会报错的，因为其子类的构造方法在编译过程中会默认在最前方加一句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于先对父类的构造方法进行访问。而这里父类没有无参构造方法。</p><p>因此，请在父类中写出无参构造方法，或者在子类中申明一个构造方法，使用super关键字，对父类的含参构造方法进行调用。</p><h3 id="final-sealed-permits"><a href="#final-sealed-permits" class="headerlink" title="final &#x2F; sealed &amp; permits"></a>final &#x2F; sealed &amp; permits</h3><p>Java中，可以用final或sealed来对类进行修饰，分别表示 <strong>该类不允许进一步继承</strong> 以及 <strong>只允许指定类继承</strong> 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">permits</span> <span class="token class-name">Student</span><span class="token punctuation">,</span> <span class="token class-name">Teacher</span><span class="token punctuation">&#123;</span>    <span class="token comment">//表示Person类只允许Student以及Teacher类进行继承</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>    <span class="token comment">//表示Student类不允许再进一步被继承</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向上转型-Upcasting-向下转型-Downcasting-instanceof"><a href="#向上转型-Upcasting-向下转型-Downcasting-instanceof" class="headerlink" title="向上转型(Upcasting) &amp; 向下转型(Downcasting) &amp; instanceof"></a>向上转型(Upcasting) &amp; 向下转型(Downcasting) &amp; instanceof</h3><p>由于Java中子类具有父类的全部功能，因此在Java中定义一个父类对象，让其指向子类，这是 <strong>被允许的</strong> 。</p><p>比如，拿上文中的类举例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p <span class="token operator">=</span> s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是可以的。</p><p>但是，当我们想反过来的时候，这个操作就不一定能成了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> s3 <span class="token operator">=</span> s1<span class="token punctuation">;</span> <span class="token comment">//允许，因为s1实质上指向的是一个Student对象</span><span class="token class-name">Student</span> s4 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">//不允许，因为s2实质上指向的是一个Person对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此，为了确保向下转型不会出错，java提供了一种操作符叫 <strong>instanceof</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">s1 <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述语句可以判断s1对象指向的到底是不是Student，并返回相应的布尔变量。</p><p>从Java 14开始，可以直接在判断的类后面加名字，从而达成直接转型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>s1 <span class="token keyword">instanceof</span> <span class="token class-name">Student</span> stu1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，如果s1是Student，会直接转型为stu1，并执行输出语句。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="子类对父类方法的覆写-Override"><a href="#子类对父类方法的覆写-Override" class="headerlink" title="子类对父类方法的覆写(Override)"></a>子类对父类方法的覆写(Override)</h3><p>在子类中，如果希望对父类中的某个方法进行重写，可以进行 <strong>Override</strong> 操作。</p><p>具体方法为：在子类中定义一个与父类的某一个方法</p><ul><li>方法名相同</li><li>返回类型相同（也可以返回该类型的子类型）</li><li>参数列表相同</li></ul><p>的方法。</p><blockquote><p>子类中覆盖父类的方法，其访问限制必须要比父类的相应方法更宽泛。如：</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这种定义是不被允许的。</p></blockquote><h3 id="覆写与转型"><a href="#覆写与转型" class="headerlink" title="覆写与转型"></a>覆写与转型</h3><p>我们不妨设想这样一种情况：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stuent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不妨想一想这时候调用的是哪一个get_age方法？</p><p>事实证明，Java中调用方法是根据对象的实际类型来调用的，而非其声明类型。</p><p>这就引出了一个很重要的概念。</p><h3 id="多态是个啥"><a href="#多态是个啥" class="headerlink" title="多态是个啥"></a>多态是个啥</h3><p>上文中，我们知道了Java在调用方法时，会根据对象的实际类型决定调用什么方法。</p><p>这就是多态的重要特性， <strong>针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</strong> 。</p><p>这使得，如果我们定义某个函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_all_name</span><span class="token punctuation">(</span><span class="token class-name">Person</span> s1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s1<span class="token punctuation">.</span><span class="token function">get_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样的一个函数可以传入Person类，也同样可以传入Person的子类Student类，而在调用它们的get_name()方法时，Java会自动根据其实际类型来决定调用什么方法，这为我们省去了很多麻烦。</p><h3 id="异构集合体"><a href="#异构集合体" class="headerlink" title="异构集合体"></a>异构集合体</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">;</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Manager 是Employee的子类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种定义是合法的。</p><p>可以看出，这个集合中不仅仅存在Employee类型，还存在其子类Manager类型。<br>但当我们需要对其进行操作时，我们需要得知当前操作的对象到底是什么类型，此时，我们常用前文中的 <strong>instanceof</strong> 关键字来确定一个对象到底是否是某个类型。</p><hr><p>这篇博文写的比较仓促，可能会存在诸多不足之处，博主会在后续空闲时间尽力补足。</p><p>下一篇博文会涉及到更深入一些的面向对象的操作，这篇博文先到这里~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-3</title>
      <link href="/posts/7075.html"/>
      <url>/posts/7075.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈是什么"><a href="#栈是什么" class="headerlink" title="栈是什么"></a>栈是什么</h3><p><em><strong>栈</strong></em> 是另一种数据结构，其插入 &#x2F; 删除操作仅能在表的端点进行。</p><p>我们将允许进行插入 &#x2F; 删除操作的一端称为 <strong>栈顶</strong> ， 另一端称为 <strong>栈底</strong> 。<br>可以看出，栈的操作规则代表着其先进入的元素会被压在栈中，若想删除，则只能等到比其后进入的元素全部删除后才能进行。我们称这种规则为 <strong>后进先出</strong> 。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p>栈含有以下几种基本操作：</p><ul><li>InitStack：初始化</li><li>StackLength：求长</li><li>GetTop：获得栈顶元素</li><li>Push：入栈</li><li>StackTraverse：遍历</li><li>Pop：出栈</li><li>ClearStack：置空</li><li>StackEmpty：判空</li><li>DestoryStack：销毁</li></ul><h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>我们常用一组地址连续的存储单元来对栈进行存储，即C中的数组。<br>数组的上界（maxsize）用于表示栈的最大容量，而单独设置一个指针Top用来指向当前栈顶在数组中的位置。</p><p>需要注意的是，栈底的位置往往是固定的，但栈顶的位置会随着入栈 &#x2F; 出栈的操作而变化。</p><p>定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> Maxsize n<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Elemtype stack<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里同时也对栈的各类操作进行一些说明：</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>；<span class="token comment">//直接将栈顶的指针定为-1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">Push</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>top<span class="token operator">></span>Maxsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//此时栈满，即将上溢出</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        s<span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>s<span class="token punctuation">.</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出栈的操作与入栈相似，只需要考虑是否下溢出即可，这里不再详述。</p><h5 id="取顶"><a href="#取顶" class="headerlink" title="取顶"></a>取顶</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">GetTop</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> Elemtype <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>top<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//此时栈空</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        e <span class="token operator">=</span> s<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>s<span class="token punctuation">.</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其余操作在此不再详述。</p><h4 id="基于动态存储的栈管理"><a href="#基于动态存储的栈管理" class="headerlink" title="基于动态存储的栈管理"></a>基于动态存储的栈管理</h4><p>上文中基于数组的栈管理方法无法得心应手的进行栈扩容，而由此我们引出基于动态内存管理的方法。</p><p>它的定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">Stack_Int_Size</span> <span class="token expression"><span class="token number">100</span><span class="token punctuation">;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">Stack_Increment</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token operator">*</span>base<span class="token punctuation">;</span> <span class="token comment">//指向栈底</span>    Elemtype <span class="token operator">*</span>top<span class="token punctuation">;</span> <span class="token comment">//指向栈顶的下一个元素</span>    <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的管理方法使得每次当栈满时，我们可以进行realloc操作重新扩容栈：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base<span class="token operator">>=</span>S<span class="token punctuation">.</span>stacksize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//栈满，追加存储空间</span>    S<span class="token punctuation">.</span>base <span class="token operator">=</span> <span class="token punctuation">(</span>Elemtype<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>stacksize <span class="token operator">+</span> Stack_Incerment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elemtype<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span>top <span class="token operator">=</span> S<span class="token punctuation">.</span>base <span class="token operator">+</span> S<span class="token punctuation">.</span>stacksize<span class="token punctuation">;</span> <span class="token comment">//先将栈顶定出来</span>    S<span class="token punctuation">.</span>stacksize <span class="token operator">+=</span> Stack_Increment<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这种定义方法，判断栈满和栈空的语句分别为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">S<span class="token punctuation">.</span>top <span class="token operator">-</span> S<span class="token punctuation">.</span>base <span class="token operator">></span> S<span class="token punctuation">.</span>stacksize<span class="token punctuation">;</span> <span class="token comment">//栈满</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> S<span class="token punctuation">.</span>base <span class="token comment">//栈空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="多个栈共享空间"><a href="#多个栈共享空间" class="headerlink" title="多个栈共享空间"></a>多个栈共享空间</h4><p>在实际运用栈时，我们通常为了节省空间，防止空间浪费，会让多个栈同时使用一片存储空间，这通常表现为分配一个足够大的数组给多个栈，而后利用栈的动态存储特性，来对其进行存储空间的扩充。</p><p>以下，对两个栈的空间共享方法进行简要说明：</p><p>总体思路在于将两个栈的栈底至于 <strong>数组的两端</strong> ，而后在两个栈需要扩充空间时，将其栈顶向数组中间移动。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype stack<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top1<span class="token punctuation">,</span> top2<span class="token punctuation">;</span> <span class="token comment">//分别用于指向两个栈的栈顶位置</span><span class="token punctuation">&#125;</span> dustack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果用指针来表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token operator">*</span>m<span class="token punctuation">;</span> <span class="token comment">//整片区域的头指针</span>    Elemtype <span class="token operator">*</span>top1<span class="token punctuation">,</span> <span class="token operator">*</span>top2<span class="token punctuation">;</span>     <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span>  <span class="token comment">//整片区域的大小</span><span class="token punctuation">&#125;</span> dustack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种结构的栈，要判断是否上溢，则需要用到以下语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>top1 <span class="token operator">==</span> top2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//上溢</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里给出入栈的写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>top1 <span class="token operator">==</span> top2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"上溢"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        top1<span class="token operator">++</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>top1<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        top2<span class="token operator">--</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>top2<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="链式栈存储结构"><a href="#链式栈存储结构" class="headerlink" title="链式栈存储结构"></a>链式栈存储结构</h4><p>在栈的大小并不能确定时，采用链式存储结构能够更加轻松的扩栈，缩栈。</p><p>具体在C语言中，即链表的存储方式，但有所不同的是，此处链表的 <strong>头结点</strong> 指向的是栈的 <strong>栈顶</strong> ，因此每次对栈进行操作，相当于是对头结点的位置进行相关的改变。</p><p>链栈的定义方式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">snode</span><span class="token punctuation">&#123;</span>    Elemtype data<span class="token punctuation">;</span>    snode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> linkstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>链栈的进栈操作在这里给出：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>linkstack top<span class="token punctuation">,</span> Elemtype x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    snode<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>snode<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>snode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//内存满，栈上溢</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        t<span class="token operator">-></span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>        t<span class="token operator">-></span>next <span class="token operator">=</span> top<span class="token punctuation">;</span> <span class="token comment">//t的指针域指向原先的头节点</span>        top <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">//将头结点改成t的位置</span>        <span class="token keyword">return</span> OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，只要内存不爆满，链栈是不会有上溢这种错误出现的，这也是为什么链栈更加灵活的原因。</p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><blockquote><p>讲了一堆，现在该看看栈这种后进先出的玩意到底有什么用了</p></blockquote><h4 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h4><p>算法原理：</p><p><strong>N &#x3D; (N div d)×d + N mod d</strong></p><p>其中，d是进制数</p><p>举例：<br>（1348）<sub>10</sub> &#x3D; (2504) <sub>8</sub><br>具体计算为：  </p><ul><li>1348&#x2F;8 &#x3D; 168; 1348%8 &#x3D; 4;</li><li>168&#x2F;8 &#x3D; 21; 168%8 &#x3D; 0;</li><li>21&#x2F;8 &#x3D; 2； 21%8 &#x3D; 5；</li><li>2&#x2F;8 &#x3D; 0；2%8 &#x3D; 2；</li></ul><p>将每次取余计算的结果逆序链接，则能得到2504的结果</p><p>抽象为实现代码即：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">conversion</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化一个栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//N不得0时，持续循环</span>        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> N<span class="token operator">%</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        N <span class="token operator">=</span> N<span class="token operator">/</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//栈不空，则循环</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取出栈顶元素，存在e中</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，如果涉及到16进制的转换操作，需要对相应的字母与数字之间的关系进行建立，然后再进行算法的进一步优化，这里不再详述</p><h4 id="括号检验"><a href="#括号检验" class="headerlink" title="括号检验"></a>括号检验</h4><p>在表达式中，括号的对应是十分重要的一环，往往这种工作编译器会帮我们做完，如果需要我们自己进行编写，则需要借助栈这种结构。</p><p>如下的括号，都是符合书写格式的：<br>（ [ ] [ ] ）, ( ( [ ] ) )</p><p>但当出现如：<br>( [ ) ]<br>这一类的括号时，如何判断其是否符合要求，就是我们的任务。</p><p>总结一下，我们在检验括号时，出现的不匹配的现象，往往有三种可能：</p><ul><li>到来的右括号并不是 <strong>被期待的</strong></li><li>到来的是 <strong>不速之客</strong></li><li>直到最后，被 <strong>期待</strong> 的括弧也没到来。</li></ul><p>由此，我们可以设计出这样的算法：</p><p>从表达式左侧开始逐字符扫描，如果遇到左括弧，则入栈。<br>当遇到右括弧时：</p><ul><li>如果栈空：则右括弧必定多余，报错</li><li>如果栈非空，则将右括弧与栈顶元素比较：<br>  · 如果栈顶元素能与右括弧匹配，则栈顶元素出栈<br>  · 如果栈顶元素不匹配，则正常入栈</li></ul><p>当表达式扫描完成时，如果此时栈空，则表达式无误，若非空，则报错。</p><h4 id="行编辑程序问题"><a href="#行编辑程序问题" class="headerlink" title="行编辑程序问题"></a>行编辑程序问题</h4><p>如果让我们设计一个输入编辑器，我们应当如何设计？</p><p>一个最简单的设计思路是，用户输入一个字符，则存入一个字符。但这样显然是不合理的，如果用户输入错误，我们也应当给用户相应的挽回余地，对吧。</p><p>因此，至少需要有退格（backspace）的机制。<br>这里举一个例子，如果以“#”作为退格符号，用户输入的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">whli##ilr#e（s#*s)    putchar(*s&#x3D;#++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>则有效的输入内容为：</p><pre class="line-numbers language-none"><code class="language-none">while (*s)    putchar(*s++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此，这种方式十分符合栈的存储方式，思路为：<br>我们接收到一个字符，如果字符不是退格符，则压入栈顶；<br>如果字符是退格符，则令一个栈顶元素出栈。</p><blockquote><p>上述例子只是一个最简单的行编辑程序，更多的符号如回车（enter），上档（shift）等可以自行思考。</p></blockquote><h4 id="表达式求值问题"><a href="#表达式求值问题" class="headerlink" title="表达式求值问题"></a>表达式求值问题</h4><p>我们向程序中输入一个表达式，我们希望能够输出它的结果，这是如何被计算出来的？</p><p>要理解这个问题，我们首先应当介绍一下 <strong>算符优先法</strong> 。</p><p>我们先将一个表达式分成三部分：</p><ul><li>界限符：即左括号，右括号，表达式终止符等</li><li>运算符：即算术运算符，逻辑运算符，关系运算符等</li><li>操作数：常数，变量等</li></ul><p>本文中仅仅以简单算术表达式的例子做抛砖引玉作用。<del>（其实是博主水平不够）</del></p><p>要实现这个算法，我们需要设计两个栈，即：</p><ul><li>运算符栈：OPTR栈</li><li>操作数栈：OPND栈</li></ul><p>算法基本思想如下：</p><ul><li>我们首先将操作数栈为空栈，将起始符#入栈</li><li>依次读入字符，如果是操作数，则存入OPND栈，如果是运算符，我们就将当前读入的操作符与栈顶的操作符做优先级比较，并根据比较结果决定要不要进行相关的运算。直到我们的运算符栈里面只有两个#为止。</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Chap.3/%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p><blockquote><p>这里可以看出，相同的运算符，优先级默认是前者大于后者的，这点是为了使得“&#x3D;”这个优先级仅在括号的判断中出现，防止歧义。</p></blockquote><p>操作符之间的优先级很重要：</p><ul><li>如果读入的操作符优先级大于栈顶的操作符优先级：则该操作符入栈。</li><li>如果读入的操作符优先级等于栈顶的操作符优先级：则该操作符必定是括号。</li><li>如果读入的操作符优先级小于栈顶的操作符优先级：则直接取操作数栈的栈顶两个元素进行运算。</li></ul><p>这里给出一个运算式例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Chap.3/%E8%BF%90%E7%AE%97%E4%BE%8B%E5%AD%90.png" alt="例：3*(7-2)"></p><blockquote><p>更多的应用有迷宫求解，递归的实现，地图染色等等，这里不再详述。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>只允许在表的一端进行插入，在另一段进行删除的线性表<br>先进先出</p><h3 id="队列的基本操作："><a href="#队列的基本操作：" class="headerlink" title="队列的基本操作："></a>队列的基本操作：</h3><ul><li>EnQueue(&amp;Q, e) 入队</li><li>DeQueue(&amp;Q, &amp;e) 出队</li><li>InitQueue(&amp;Q) 初始化</li><li>QueueEmpty(Q) 判空</li><li>DestoryQueue(&amp;Q) 销毁</li><li>QueueLength(Q) 求长</li><li>ClearQueue(&amp;Q) 置空</li><li>GetHead(Q, &amp;e) 求头</li><li>QueueTraverse(Q, visit()) 遍历</li></ul><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>采用数组进行存储：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token function">queue</span><span class="token punctuation">(</span>maxsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">//front表示队头，rear表示队尾</span><span class="token punctuation">&#125;</span>queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>入队，改变队尾指针<br>出队，改变队头指针</p><p>队空：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">==</span> rear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>队满：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rear <span class="token operator">==</span> maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="顺序存储-改进"><a href="#顺序存储-改进" class="headerlink" title="顺序存储-改进"></a>顺序存储-改进</h3><p>显然，总有一个时刻，front指针与rear指针均指向数组的maxsize处的元素，但整个数组并没有被填满，反而前面空余了很多空间。这种情况被称为 <strong>假溢出</strong> 。</p><p>假溢出一般有两种解决方式：</p><ul><li>出队后，令整个队列左移。（涉及大量元素的移动）</li><li>将Queue[0]接到Queue[maxsize-1]的后方，形成队列环（参考上一章中循环链表的思想）</li></ul><p>入队时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rear <span class="token operator">=</span> <span class="token punctuation">(</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出队时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">=</span> <span class="token punctuation">(</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方法中，还有个问题，即队满和队空的判断语句均为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">==</span> rear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于这个问题，有两种解决方法：</p><ul><li><p>可以采用 <strong>设置标志位</strong> 的方法进行改进：<br>队空的情况只能由出队操作引起<br>队满的操作只能由入队操作引起<br>因此，加一个标志位 <strong>flag</strong> ，将其初始化为“delete”， 进行入队时，更改其为“enter”。由此判断队空还是队满。</p></li><li><p>可以少用一个存储空间<br>这时，队空则仍然由front &#x3D;&#x3D; rear来判断，队满则可使用front &#x3D;&#x3D; rear-1的方式来进行判断。</p></li></ul><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>顾名思义，使用链表对队列进行存储</p><p>当然，对于队列的链表而言，我们需要有队头与队尾两个指针来对整个队列进行维护</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    node<span class="token operator">*</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>链队列初始化时，只需要分配出头结点即可，此后利用rear &#x3D; front来进行初始化<br>销毁时，从队头开始遍历，分次释放所有的结点  </p><p>入队：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">node<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>本篇仅对栈和队列的基础定义与一些简单应用做出了阐述，后续有时间会补充更多的细节。</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.2</title>
      <link href="/posts/36543.html"/>
      <url>/posts/36543.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-程序设计基础"><a href="#Java-程序设计基础" class="headerlink" title="Java 程序设计基础"></a>Java 程序设计基础</h1><blockquote><p>本章将正式步入Java的内容，但说在前面，由于此前有C语言的基础章节，而Java的语法又跟C语言极其相似，因此在谈到某些具体语句时，博主将不再讲述的过于详细，请读者自行查找C语言章节中的内容。</p></blockquote><h2 id="有关引入包"><a href="#有关引入包" class="headerlink" title="有关引入包"></a>有关引入包</h2><p>上述语句中 <strong>import</strong> 语句相当于Java中的引入语句，它的作用是引入一个 <strong>包(Package)</strong> ，用于在本文件中使用。类比C语言，这类似于C中的引入头文件操作。</p><p>至于具体的包，我们将在后续的文章中具体提及。</p><h2 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h2><p>Java中有三种注释：</p><ul><li><p>单行注释：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 这是一条单行注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>多行注释</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*这是一个多行注释*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>文件注释</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**&#x2F;*这是一个文件注释&#x2F;*用于在文件头部对文件的具体功能进行说明*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="关于数据类型"><a href="#关于数据类型" class="headerlink" title="关于数据类型"></a>关于数据类型</h2><h3 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h3><p>类似于C语言，Java中也有多种数据类型：</p><ul><li>整数：<br>byte, short, int, long</li><li>浮点数：<br>float, double</li><li>字符型：<br>char</li><li>布尔型：<br>boolean</li></ul><p>在C中，对short，int， long的定义并不明确，只有笼统的：long&gt;int&gt;short （这里指的是内存占用大小），这就导致不同的编译器，不同的系统上可能会导致很严重的兼容性问题。<br>Java看到了这一点，为了兼容性，其对每个数据类型的大小进行了准确的定义。</p><ul><li>byte: 1</li><li>short: 2</li><li>int: 4</li><li>long: 8</li><li>float: 4</li><li>double: 8</li><li>char: 2</li><li>boolean: 4</li></ul><p>在这里，还需要进行三点说明：</p><ul><li>Java中不允许直接进行低精度类型赋予高精度类型的操作。这就代表着<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> x1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>是不被允许的。</li></ul><p>如果要强行赋值，请利用强制类型转化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>x1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Java中，byte类，short类在运行后所得到的类型， <em><strong>均为int型</strong></em> ，因此请注意这种类型的编译错误：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">byte</span> x3 <span class="token operator">=</span> x1 <span class="token operator">+</span> x2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>虽然x1, x2均为byte型，但其两者相加时，自动转为了int型，这时候将其值赋给x3，会发生溢出报错。</p><ul><li>在Java中定义float类型时，需要在值后方加一个f。</li></ul><h3 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h3><p>Java中定义常量时，需要在定义语句前加 <strong>final</strong> 语句。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">double</span> <span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="关于-var-关键字"><a href="#关于-var-关键字" class="headerlink" title="关于 var 关键字"></a>关于 var 关键字</h3><p><strong>var</strong> 关键字是一种用于偷懒的方法，当类型名过长时，可以在定义语句中使用var关键字来代替前方的类型名。</p><h3 id="关于数据类型的运算"><a href="#关于数据类型的运算" class="headerlink" title="关于数据类型的运算"></a>关于数据类型的运算</h3><h4 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h4><p>Java中的运算规则，与C大体上相同，在此前没有提过的有一种叫做 <strong>位移运算</strong> 的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 0111</span>n<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 1110</span>n<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 0011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述语句被称作位移运算，可以看出，这种运算方式是以整数的二进制表示方法为基础的。<br><strong>左移加倍，右移减半</strong></p><p>需要注意的是，右移操作并不会移动符号位，如果想要把符号位一并移动，请使用 <strong>&gt;&gt;&gt;</strong> 关键字</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>与位移运算相似的在数字二进制表达式上进行操作的还有一种，称为 <em><strong>位运算</strong></em> 。</p><p>其包括四种类型：</p><ul><li>位与运算符：&amp;<br>如果参与运算的两个数字的某一个二进制位同时取1，其结果该位上才为1，否则置0</li><li>位或运算符：｜<br>如果参与运算的两个数字的某一个二进制位同时取0，其结果上该位才取0，否则为1</li><li>位异或运算符：^<br>如果参与运算的两个数字的某一个二进制位不同，其结果上该位才取1，否则置0</li><li>位取反运算符：~<br>将一个数字的每一个二进制位上的数都取其相反数。</li></ul><h2 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h2><p><strong>字符串</strong> 是Java中的一种引用类，在Java中十分常用，因此在这里单独提一句：</p><p>字符串可以用 <strong>+</strong> 进行连接定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于多行字符串，可以使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> <span class="token string">""</span>" <span class="token class-name">Hello</span><span class="token punctuation">,</span><span class="token class-name">Java</span><span class="token class-name">Programming</span><span class="token class-name">World</span> <span class="token string">""</span>"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>来进行定义。</p><p>字符串还可以是一个空值，即：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要知道的是，字符串是不可以直接改变的，因为其是一种引用变量（关于引用，会在下文中提及），往往需要StringBuilder类进行修改。</p><h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p><strong>数组</strong> 同样是Java中的一种引用对象，其定义方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intarray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，Java中的数组与C语言中的数组并不是一回事，其意义为定义一个引用变量，这个引用变量会指向一个长度为26的数组变量.</p><p>相当于， <strong>intarray</strong> 只是一个变量，而这个数组是一个对象，用 <strong>new</strong> 关键字来创建，它被存在另一个位置，而intarray 仅仅是指向了它。</p><p>相似的，如果我定义了一个字符串数组，则事情更加复杂一些。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str_array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，str_array指向了一个长度为10的字符串数组，这个数组在另外一个位置，但由于字符串也是一种对象，在定义字符串时，也是通过引用的方式进行定义的，因此相当于这个长度为10的数组，里面是10个引用变量，这10个引用变量会各自指向一个字符串，它们也不一定存储在同一片区域。</p><p>这同样也代表着，一旦你创建了这个数组对象，你就不能更改这个对象的大小了。如果需要扩容，你只能重新创建一个更大的对象，然后把这个引用对象指向这个全新的对象。</p><p>这里，希望读者尽力理解，辅以网络上的其他资料对 <em><strong>引用</strong></em> 的机制进行了解。</p><p>了解后，我们可以在此引入另一个概念：</p><h2 id="关于多维数组"><a href="#关于多维数组" class="headerlink" title="关于多维数组"></a>关于多维数组</h2><p>在C中，我们定义二维数组必定是一个整齐的，如2＊5的，它每个次级数组的长度必须是一致的。</p><p>但由于Java中，数组是一种引用变量，我们其实可以定义不整齐的二维数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> two_dim_arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//代表定义了一个有四个子变量的数组</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//次级数组的长度可以不同，因为它们可以并不存储在同一片区域中，不需要考虑到对齐问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-2</title>
      <link href="/posts/56162.html"/>
      <url>/posts/56162.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-Chap-2-线性表"><a href="#数据结构-Chap-2-线性表" class="headerlink" title="数据结构 Chap.2 线性表"></a>数据结构 Chap.2 线性表</h1><h2 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h2><p>线性表是一种最简单的数据结构，其表现为一系列有顺序的元素集合。<br>自然，线性表需要满足如下标准：</p><ul><li>有 <strong>第一元素</strong> 与 <strong>最后元素</strong></li><li>除了第一元素之外，每个元素都有它的 <strong>后继</strong> ，除了最后元素之外，每个元素都有它的 <strong>前驱</strong> 。</li><li>同一线性表内的元素必定具有相同的特性。</li></ul><h2 id="线性表的相关操作"><a href="#线性表的相关操作" class="headerlink" title="线性表的相关操作"></a>线性表的相关操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>首先，我们来了解一些线性表的基本操作。<br>它们包括：</p><ul><li>初始化: InitList</li><li>销毁: DestoryList</li><li>判断是否为空: ListEmpty</li><li>求长度: ListLength</li><li>求指定元素的前驱: PriorElem</li><li>求指定元素的后继: NextElem</li><li>提取指定元素: GetElem</li><li>定位: LocateElem</li><li>遍历: ListTraverse</li><li>置空: ClearList</li><li>改变指定元素的值: PutElem</li><li>插入元素: ListInsert</li><li>删除元素: ListDelete</li></ul><p>这里对定位操作进行些许说明：<br>该操作的意义为在线性表中找到第一个符合某个条件的元素，并返回其位置。<br>一般而言，若未找到，则返回-1。</p><p>需要明确的是，上述表述仅仅关系了这些操作是 <strong>做什么的</strong> ，并没有深究应当如何实现这种操作，具体应当如何实现，应当依靠读者使用的语言，采用的具体结构而定。</p><p>上述基础运算也可以构成更进一步的应用，如线性表的有序合并，拆分，排序等。</p><h3 id="应用事例"><a href="#应用事例" class="headerlink" title="应用事例"></a>应用事例</h3><h4 id="两个线性表-LA-与-LB-的合并"><a href="#两个线性表-LA-与-LB-的合并" class="headerlink" title="两个线性表 LA 与 LB 的合并"></a>两个线性表 LA 与 LB 的合并</h4><p>该操作可以分为三步：</p><ul><li>从LB中依次取出每个元素</li><li>观察LB中取出的元素在LA中是否存在</li><li>若不存在，则存入LA中</li></ul><p>若写成代码块：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span>List <span class="token operator">&amp;</span>LA<span class="token punctuation">,</span> List LB<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LA_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LA<span class="token punctuation">)</span><span class="token punctuation">;</span>    LB_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LB_len <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">GetElem</span><span class="token punctuation">(</span>LB<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取第i个元素赋予e</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> e<span class="token punctuation">,</span> equal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">ListInsert</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> LA_len<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将e插入LA的最后</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处，给出了一个很基础的操作代码块，后续在无必要的情况下，将不会这样详细的给出具体步骤。</p><p>回归正题，这个算法需要在遍历LB内每个元素的同时也遍历LA中的每个元素来进行查重，因此我们可以计算出其时间复杂度：<br><em><strong>O(ListLength(LA) * ListLength(LB))</strong></em></p><h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><blockquote><p>前面讲的内容比较概括性，也相对抽象，以下将具体讲述线性表的表示方法。</p></blockquote><h3 id="什么是顺序表示"><a href="#什么是顺序表示" class="headerlink" title="什么是顺序表示"></a>什么是顺序表示</h3><p><em><strong>顺序表示</strong></em> 正如其名，线性表中的数据结构在内存中的表示也是有顺序的，具体表现为前一个元素紧挨着后一个元素。再简单一点，顺序表示可以通俗的理解为C中的 <strong>数组</strong> 。</p><h3 id="用C语言实现线性表的顺序存储"><a href="#用C语言实现线性表的顺序存储" class="headerlink" title="用C语言实现线性表的顺序存储"></a>用C语言实现线性表的顺序存储</h3><h4 id="线性表的初始化：InitList"><a href="#线性表的初始化：InitList" class="headerlink" title="线性表的初始化：InitList"></a>线性表的初始化：InitList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">L<span class="token punctuation">.</span>Elem <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> List_Elem_Size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的容量扩展：ExtendList"><a href="#线性表的容量扩展：ExtendList" class="headerlink" title="线性表的容量扩展：ExtendList"></a>线性表的容量扩展：ExtendList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">NewBase <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>List_Elem_Size <span class="token operator">+</span> Expand_Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的元素定位：LocateElem"><a href="#线性表的元素定位：LocateElem" class="headerlink" title="线性表的元素定位：LocateElem"></a>线性表的元素定位：LocateElem</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>statment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//定位到符合statment语句的元素</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="线性表的元素插入：ListInsert"><a href="#线性表的元素插入：ListInsert" class="headerlink" title="线性表的元素插入：ListInsert"></a>线性表的元素插入：ListInsert</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">>=</span>q<span class="token punctuation">;</span> p<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将插入位置后方的元素分别向后移动一位</span><span class="token operator">*</span>p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//插入元素e</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>线性表的删除操作与插入操作类似，在此不再详述。</p><h3 id="顺序存储线性表的优劣"><a href="#顺序存储线性表的优劣" class="headerlink" title="顺序存储线性表的优劣"></a>顺序存储线性表的优劣</h3><p>顺序存储的优点主要表现在以下两方面：</p><ul><li>存储时不需要为了表述元素之间的关系而额外花费内存空间</li><li>可以实现元素的随机读取</li></ul><p>顺序存储的缺点主要表现在以下两方面：</p><ul><li>必须分配连续存储空间给线性表，在内存连续片段较小时，有初始化失败的可能性</li><li>在插入 &#x2F; 删除元素时，需要大量移动元素，造成不便</li></ul><h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><h3 id="什么是链式表示"><a href="#什么是链式表示" class="headerlink" title="什么是链式表示"></a>什么是链式表示</h3><p><em><strong>链式表示</strong></em> ， 每个数据元素单独存储，它们在内存中可以是连续的，也可以是分散的，它们之间的关系通过每个数据元素附带的一个指针域进行连接。说的更具体化一些，即用结构体将指针于数据元素包装在一起，它们链式存储中的一个数据元素。在C语言中常常通过链表表示。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>这里需要对 <strong>链表</strong> 这一概念进行引入。<br>链表即指代如同上述表达中提及的，一个数据域附带一个指针域形成的结构。其主要分为以下几类：</p><ul><li>单链表</li><li>双链表</li><li>循环链表（单 &#x2F; 双）</li><li>静态链表</li></ul><p>让我们先从最基础的单链表讲起</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>顾名思义，单链表的连接方式是单向的，即我们只能通过前一个元素的指针域找到它的后继，而无法通过后一个元素找到其前驱。<br>其通常在C语言中以这样的方式进行结点定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    ElemType Elem<span class="token punctuation">;</span>    Node<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以得知，只要得知第一个结点，就可以通过每个结点指针域中的指针得知其下一个结点，从而实现链表的一系列操作，因此，我们一般称单链表的第一个结点为 <strong>头结点</strong> 。</p><p>注：有时为了方便，头结点的数据域中不进行存储。</p><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><h5 id="单链表的元素提取：List-GetElem"><a href="#单链表的元素提取：List-GetElem" class="headerlink" title="单链表的元素提取：List_GetElem"></a>单链表的元素提取：List_GetElem</h5><p>不同于顺序存储，链式存储在提取元素时必须通过头结点分部向后寻找指定位置的元素。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_GetElem</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    e <span class="token operator">=</span> p<span class="token operator">-></span>Elem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h5 id="单链表的元素插入：List-Insert"><a href="#单链表的元素插入：List-Insert" class="headerlink" title="单链表的元素插入：List_Insert"></a>单链表的元素插入：List_Insert</h5><p>同样，链式存储的元素插入与顺序存储差异极大。<br>我们需要先找到插入位置的前一个元素，这之后只需要改变这个元素与被插入元素的指针域即可。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_Insert</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//链表的每次插入都需要手动创建一个新结点</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_node<span class="token operator">-></span>ElemType <span class="token operator">=</span> e<span class="token punctuation">;</span>    new_node<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> new_node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>单链表的元素删除相比元素插入仅仅多了一个free（释放内存）的操作，即将删除的结点释放掉，这里不再详述。</p><h5 id="单链表的置空操作：ClearList"><a href="#单链表的置空操作：ClearList" class="headerlink" title="单链表的置空操作：ClearList"></a>单链表的置空操作：ClearList</h5><p>与删除操作类似。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ClearList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>        L<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="单链表的改进"><a href="#单链表的改进" class="headerlink" title="单链表的改进"></a>单链表的改进</h4><p>从上述应用中我们可以看出，单链表的运用很依赖于链表本身的一些特殊结点与位置，那我们不妨改进一下单链表，单独为它设置一个结构体，用于存储这些特殊的位置和个数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sruct List<span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> Head<span class="token punctuation">,</span> Tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种定义，我们可以清晰的明确一个链表的头、尾结点，以及其元素总个数。</p><h4 id="单链表：注意事项"><a href="#单链表：注意事项" class="headerlink" title="单链表：注意事项"></a>单链表：注意事项</h4><p>可以看到，在以上操作中，我们在函数内对单链表进行操作，往往不会直接使用其头结点，而是单独定义一个指针，再通过移动这个指针来操作链表内的元素。<br>这是因为，如果直接对头结点的Head指针进行移动，由于函数的参数是Head的地址，因此在函数中你对Head的每一次移动都是永久性的，函数结束后Head指针的地址并不会还原，你会丢失前面的元素。<br>因此，请务必注意这一点。</p><h3 id="其他形式的链表"><a href="#其他形式的链表" class="headerlink" title="其他形式的链表"></a>其他形式的链表</h3><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p><strong>双链表</strong> 是对单链表的改进，其相比于单链表，一个数据元素占用的内存更大，这是因为它不仅仅能通过一个元素找到它的后继，同时也能找到它的前驱。</p><p>我们常常这样定义一个双链表的结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">DuNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token comment">//数据域</span>    DuNode<span class="token operator">*</span> prior<span class="token punctuation">;</span>    DuNode<span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们通过prior来指向元素的前驱，通过next来指向元素的后继。</p><p>由于指针域的增加，对一个双向链表进行操作时的指针域更改会更加复杂一些，但道理总归相似，请读者自行类比即可。<br>需要特殊说明的是，双向链表在进行插入、删除操作时，需要更改其前驱的next指针，也需要更改其后继的prior指针。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表</strong> 是将链表最后一个元素指向了这个链表的头结点，从而实现了让这个链表首尾相接的效果。<br>此时，判断元素是否是最后一个元素的依据也不是其后继是不是 NULL ，而变成了是不是头结点。</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p><strong>静态链表</strong> 是在某些没有指针这个设定的高级语言中应用的，它通常这样定义一个结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">StaticNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述链表是通过数组来实现的，数组中的一个元素就是一个结点，同时其通过游标cur来表示其结点在链表中的位次。<br>这种链表通过游标来指示其下一个元素的位置，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这就是链表的第1个元素所在的下标位置</span>S<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这是链表第2个元素所在的下标位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>虽然这种链表仍然需要一个相对较大的存储空间，但其在插入 &#x2F; 删除元素时，仍然只需要改变指针，而不用移动元素，因此其仍然具备链式存储结构的主要优点。</p><p>这种链表的顺链查找通常会这样写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i <span class="token operator">=</span> S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span> <span class="token comment">//S[0]相当于头结点</span><span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i <span class="token operator">=</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链式存储的优劣"><a href="#链式存储的优劣" class="headerlink" title="链式存储的优劣"></a>链式存储的优劣</h3><p>链式存储的优势体现在：</p><ul><li>插入 &#x2F; 删除时，无需大量移动元素</li><li>不需要一大块连续的存储空间</li><li>扩充表的规模很容易</li></ul><p>链式存储的主要劣势：</p><ul><li>无法随机访问表内元素，访问时间长短与元素在表内的位置相关。</li></ul><p>至此，关于线性表的大致内容梳理完成。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.1</title>
      <link href="/posts/36863.html"/>
      <url>/posts/36863.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h1><blockquote><p>本文旨在让读者大致了解Java，并对其中的一些基本内容进行说明</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在学习Java之前，我们首先应当了解Java的一些细节</p></blockquote><h3 id="Java是什么？"><a href="#Java是什么？" class="headerlink" title="Java是什么？"></a>Java是什么？</h3><p>Java是由SUN公司开发的一种编程语言，如今已被Oracle收购。</p><p>但时至今日，Java已经不仅仅是一门编程语言，Java包含着许多方面：</p><ul><li>一类编程语言</li><li>一种开发环境</li><li>一种应用运行环境</li></ul><p>得益于Java本身强大的兼容性，其不仅仅在服务器端的应用中占据着一席之地，同样在PC，移动端应用开发上有广大的应用场景。</p><h3 id="Java迄今的地位"><a href="#Java迄今的地位" class="headerlink" title="Java迄今的地位"></a>Java迄今的地位</h3><p>迄今为止，Java在编程语言使用率上仍然占据着第四名的位置。这得益于其兼容性；易于理解的编译语言；内置的内存处理机制等等。</p><h3 id="Java的不同版本"><a href="#Java的不同版本" class="headerlink" title="Java的不同版本"></a>Java的不同版本</h3><p>SUN公司曾经为Java设定了三个版本，这种分类标准被沿用至今：</p><ul><li>Java SE (Standard Edition)</li><li>Java EE (Enterprise Edition)</li><li>Java ME (Micro Edition)</li></ul><p>三者之间的关系为：EE &gt; SE &gt; ME</p><h3 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h3><p><em><strong>JDK</strong></em> 是Java Development Kit 的简称。<br><em><strong>JRE</strong></em> 是Java Runtime Environment 的简称。<br><em><strong>JVM</strong></em> 是Java Virtual Machine 的简称。</p><p>Java在每台计算机上会内置一个虚拟机，即JVM。代码会先编译为Java字节码，而后放在JVM上运行，以此很好的保证了Java在各个平台上的兼容性。</p><p>JRE是Java运行的环境，而JDK比JRE更大一层，其中除了JRE外还内置了编译器、调试器等工具。</p><h2 id="编译入门"><a href="#编译入门" class="headerlink" title="编译入门"></a>编译入门</h2><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>与C不同，Java的配置过程稍显复杂，也需要更多的时间与步骤。</p><p>整体而言，分为 下载JDK -&gt; 配置环境变量 -&gt; 运行IDE 三个步骤。</p><p>本笔记的运行全程以JDK-20为环境，在VScode上进行java的编写。<br>博主在这个方面不做详细阐述，请自行上网搜索</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-1</title>
      <link href="/posts/55842.html"/>
      <url>/posts/55842.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在此前C语言的章节中，曾提到过一个十分有名的等式：算法 + 数据结构 &#x3D; 程序。本部分的博文会从C语言的角度来对数据结构进行相应的阐述，有利于理清思路，也可以以相似的想法套用至其它编译语言中。</p></blockquote><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="1-数据结构的概念"><a href="#1-数据结构的概念" class="headerlink" title="1. 数据结构的概念"></a>1. 数据结构的概念</h2><blockquote><p>何为数据结构？</p></blockquote><p>在编程的过程中，我们通常遇到的问题能够被分为两类：</p><ol><li>数值计算问题</li><li>非数值计算问题</li></ol><p>数值计算问题往往是能够通过明确的数学公式进行解决的，编译的过程需要思考的问题相对较少。而非数值计算问题则涉及的方面更多，也更考验编译者的抽象思维，这一过程中就涉及到选取正确的数据存储方式，以此使我们在计算机上能够更加便利地对数据进行操作，数据结构的概念由此产生。</p><p>我们定义数据结构时，往往通过三方面进行考虑。</p><ul><li>数据的逻辑结构：即信息的组织方式</li><li>数据的存储结构：即信息在计算机上的存储方式</li><li>数据的运算：即在计算机上应当如何处理这些数据</li></ul><p>以下举出两例，进行相关的说明：</p><ol><li><p>表：</p><p> 表的逻辑结构往往是线性的，这意味着其中的数据组与组之间关系并不十分强烈，因此可以采用在计算机中采用顺序（数组）或链式（链表）存储方式。运算也往往包含插、删、改、查四种方式。</p></li><li><p>图：</p><p> 图的逻辑结构体现在结点与结点之间，其组与组之间的关系更加复杂，因为任意两组数据之间均有可能产生联系。因此在存储时，既要考虑结点本身信息的存储，也要考虑结点之间的关系如何构建。运算相应添加了关键路径、最短路径的问题等。</p></li></ol><p>通过上述示例，我们能看出 <strong>数据结构往往解决的是非数值计算问题，它意在数据组织的基础上解决复杂程序的设计问题</strong>。</p><h2 id="2-数据的结构"><a href="#2-数据的结构" class="headerlink" title="2. 数据的结构"></a>2. 数据的结构</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是能够被输入到计算机中进行存储、操作的符号的总称。其衍生出的名词还有：</p><ul><li>数据元素：即数据中的一个个体</li><li>数据项：数据中的一个个体可能有多项数据，这其中每一项数据都能被称作数据项</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>数据元素之间存在某种关系，这种关系被称为逻辑结构。</p><p>常见的逻辑结构有：</p><ul><li>集合</li><li>线性结构</li><li>树形结构</li><li>图 &#x2F; 网状结构</li></ul><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>将数据结构在计算机中存储，表示的方式称为存储结构。它也可以理解为逻辑结构在计算机中的映像。（如二进制、顺序存储映像、链式存储映像等）</p><p>由于某些数据的逻辑结构极其相似，因此统一用一类存储结构对它们进行存储，这种特定的存储结构叫做 <strong>数据类型</strong> （如数组，链表等具体类型）</p><p>同时，对相应数据类型的操作有时也极其相似，因此对相应一类操作起个名，叫 <strong>抽象数据类型（Abstract Data Type）</strong> （不同的教材中叫法不同）<br>这与很多编译语言中的 <strong>类</strong> 的概念十分类似。</p><h3 id="Abstract-Data-Type（ADT）"><a href="#Abstract-Data-Type（ADT）" class="headerlink" title="Abstract Data Type（ADT）"></a>Abstract Data Type（ADT）</h3><h4 id="重要特征"><a href="#重要特征" class="headerlink" title="重要特征"></a>重要特征</h4><p>由于ADT本身的性质，其具有两个重要的特征：</p><ul><li>数据抽象：ADT强调数据本身的性质，而其中的操作是一致的，因此对于其本身与外部用户的接口具有严格的要求。</li><li>数据封装：其内部的实现细节往往对外部用户隐藏。</li></ul><h4 id="ADT的定义"><a href="#ADT的定义" class="headerlink" title="ADT的定义"></a>ADT的定义</h4><pre class="line-numbers language-none"><code class="language-none">ADT抽象数据类型名&#123;    数据对象：    数据关系：    &#x2F;&#x2F;以上两种定义利用伪码描述    基本操作：        基本操作名（参数表）        初始条件：        操作结果：&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本操作的参数表中含有两种参数：</p><ol><li>赋值参数：为操作提供输入值</li><li>引用参数（以&amp;开头）：可返回操作结果</li></ol><p>初始条件表明了该种操作需要满足的条件，可以为空。<br>操作结果表明了数据结构的变化状况，以及此操作后应当返回怎样的结果。</p><h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><p>算法，是对特定问题解决步骤的描述，根据时间、空间占用量的不同有优劣之分。</p><h3 id="算法的特点"><a href="#算法的特点" class="headerlink" title="算法的特点"></a>算法的特点</h3><p>首先，算法必须具有以下五条基本性质：</p><ul><li>有穷性</li><li>确定性（指令明确）</li><li>可行性（每条指令都可被执行）</li><li>有输入（0或多个）</li><li>有输出（0或多个）</li></ul><p>其次，要写出一个 <strong>好的算法</strong> ，则还应当有如下特点进行辅助：</p><ul><li>正确性</li><li>可读性</li><li>健壮性（程序不会轻易崩溃）</li><li>高效率 &amp; 低存储量</li></ul><blockquote><p>正确性、可读性、健壮性自然不必多言，下面从高效率与低存储量方面进行说明。</p></blockquote><h3 id="算法执行时间"><a href="#算法执行时间" class="headerlink" title="算法执行时间"></a>算法执行时间</h3><p>首先，明确一下与执行时间密切相关的因素：</p><ul><li>算法策略</li><li>问题规模</li><li>使用语言</li><li>机器代码质量</li><li>机器性能</li></ul><p>在我们的控制范围内的，主要是算法策略与使用语言。其中又以算法策略为重点优化对象。</p><p>这里我们继续细分， <em><strong>算法 &#x3D; 控制结构 + 原操作</strong></em><br>其中控制结构主要指程序的顺序、分支与循环，而原操作则指固有数据类型的操作。</p><p>形成习惯的是，算法中原操作的重复次数往往与算法的执行时间成正比，因此以 <strong>原操作在算法中重复执行的次数</strong> 作为算法执行时间的衡量准则，称为 <strong>时间复杂度</strong> ，以 <em><strong>O(n)</strong></em> 表示。<br>下面举几例常见的时间复杂度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token comment">//O(1) 常量阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n) 线性阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token operator">++</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n^2)  平方阶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里提出两个经典的问题供读者思考，有兴趣也可以自行搜索相应解答：</p><ul><li>折半查找的算法时间复杂度</li><li>汉诺塔问题递归解法的时间复杂度</li></ul><p>请务必注意，上文中的 <strong>原操作</strong> 指的是 <strong>ADT中的一次基本操作</strong> ，如对于折半查找来说，即进行一次折半操作，对于汉诺塔问题来说，则是挪一次盘子的操作。<br><strong>请务必不要将原操作理解为一条语句！</strong></p><h3 id="算法占用空间"><a href="#算法占用空间" class="headerlink" title="算法占用空间"></a>算法占用空间</h3><p>相对应的，算法本身的操作也需要相应的存储空间，这也就产生了 <strong>空间复杂度</strong> 的概念，不过博主至今并未了解相应的计算机制，烦请读者自行搜索。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好久不见</title>
      <link href="/posts/62537.html"/>
      <url>/posts/62537.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于此前的断更"><a href="#关于此前的断更" class="headerlink" title="关于此前的断更"></a>关于此前的断更</h2><p>距离上一次更新已经有半年之久，这期间主要是由于博主的学习与生活琐事所致，今后会尽力维持更新</p><h2 id="关于此后的内容"><a href="#关于此后的内容" class="headerlink" title="关于此后的内容"></a>关于此后的内容</h2><p>会有偏向性的转向C++与Java方面，另外，（如果博主能够学会相应的表述）可能会有一些数学方面的简记</p><p>好了，下篇博文见~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.8</title>
      <link href="/posts/34435.html"/>
      <url>/posts/34435.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote><p>在一个C语言程序中，除了自行编写程序之外，我们还想到应该如何对计算机内依然存在的文件进行操作，这就引出了本文的主题。</p></blockquote><h3 id="内存与外存"><a href="#内存与外存" class="headerlink" title="内存与外存"></a>内存与外存</h3><p>要描述文件，首先需要从内存，外存两个概念说起。</p><p>内存的概念，此前曾多次提及，是各类变量，算法储存的位置，并会在程序运行结束后及时释放。<br>内存中的数据会在关机后立刻消失。  </p><blockquote><p>如果对DIY有一定了解，则会常常听到“内存条”，就是这东西。</p></blockquote><p>外存则是永久存放各类文件，数据的地方，其中的数据在关机后不会消失。</p><blockquote><p>同样的，接触到的固态硬盘，机械硬盘，以及延伸至各类u盘，软盘，都属于外存的范畴。</p></blockquote><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p><strong>文件</strong> 是数据的集合，也是操作系统储存数据的基本方法。</p><p>文件有以下基本属性：</p><ol><li>文件名</li><li>占用空间</li><li>存储位置</li><li>文件类型</li><li>读写属性</li><li>创建，访问，修改时间</li><li>….</li></ol><p>操作系统为了使各种各样的文件有序的存储，衍生出了 <strong>目录</strong> 这一概念（即文件夹）</p><p>要通过程序操作文件，就必须要求相应的高级语言具有相应的文件操纵能力。</p><p>我们要达到的目的就是通过C语言程序访问文件，即对文件进行相关的输入（input），输出（output）操作。<br>为了简化书写，对输入输出，下文中简称为（I&#x2F;O）</p><h3 id="C语言中的文件形式"><a href="#C语言中的文件形式" class="headerlink" title="C语言中的文件形式"></a>C语言中的文件形式</h3><p>C语言将文件看成一个二进制流或字符流：</p><ol><li>二进制流（常用于二进制文件）：<br>相当于把文件看成很多0&#x2F;1序列，这种方式更有利于计算机的信息读取，保存，写入，但不利于阅读。</li><li>字符流（常用于文本文件）：<br>将文件看成很多字符序列的组合，每行后有一个换行符。这种形式很适合I&#x2F;O操作。</li></ol><p>与此同时，C语言在其标准库中加入了相应函数，包括：</p><ul><li>打开文件</li><li>关闭文件</li><li>读写文件</li></ul><h2 id="2-文件的打开与关闭"><a href="#2-文件的打开与关闭" class="headerlink" title="2. 文件的打开与关闭"></a>2. 文件的打开与关闭</h2><h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><p>在C语言中打开文件常用 <strong>fopen</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span>fp  <span class="token comment">//定义文件类型指针</span>fp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"这里写你的文件名（别忘加后缀）"</span><span class="token punctuation">,</span> <span class="token string">"这里写打开方式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里处理无法打开的情况</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>几个注意事项：</p><ol><li>如果打开文件成功，则返回一个FILE类型的指针地址，并且此后的文件操作都通过这个指针进行。<br>如果打开失败，则返回空指针。<br>因此利用C语言打开文件后一定要检查是否打开成功。</li><li>c语言有很多种文件打开方式：<ul><li>“r”: 打开文本文件，只读</li><li>“w”: 新建文本文件（或者删除原本的内容），只写</li><li>“a”: 打开文本文件，追加</li><li>“r+”: 打开文本文件，可以读+写</li><li>“w+”: 新建文本文件（删除原来的内容），可以读+写</li><li>“a+”: 打开文本文件，可以读+追加</li></ul></li><li>如果用二进制模式打开文件则在打开方式后加b，即：”rb”,”ab+”等。</li></ol><h3 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h3><p>在C语言中关闭文件常用 <strong>fclose</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几点注意事项：</p><ul><li>对于执行写入操作的文件，会将缓冲区内的内容写入文件中，然后关闭文件。</li><li>对于只读文件，会丢弃缓冲区内的内容，然后关闭文件</li><li>程序退出时，所有文件会自动关闭</li></ul><h3 id="三个标准文件指针"><a href="#三个标准文件指针" class="headerlink" title="三个标准文件指针"></a>三个标准文件指针</h3><p>C语言中，有三个自动生成的标准文件指针：</p><ul><li>stdin（标准输入流）</li><li>stdout（标准输出流）</li><li>stderr（标准错误流）</li></ul><p>stdin一般与键盘相连接，stdout一般与显示器相连接。</p><h2 id="3-文件的操作"><a href="#3-文件的操作" class="headerlink" title="3. 文件的操作"></a>3. 文件的操作</h2><blockquote><p>文件的读写涉及到多个函数，这其中还包括顺序读写与随机读写两种类型。</p></blockquote><h3 id="文件的顺序读写"><a href="#文件的顺序读写" class="headerlink" title="文件的顺序读写"></a>文件的顺序读写</h3><h4 id="字符读写函数：fgetc-fputc"><a href="#字符读写函数：fgetc-fputc" class="headerlink" title="字符读写函数：fgetc &amp; fputc"></a>字符读写函数：fgetc &amp; fputc</h4><p>首先对fgetc函数进行说明。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>pp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//通过只读模式打开一个文件</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从文件指针的位置读取一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgetc函数只能对以”r”（只读）, “r+”（只读写）的文件进行操作。</li><li>fgetc函数通过文件内部的位置指针进行读取。</li><li>每次读取一个字符，则文件指针fp向后移动一个位置。若读取失败（如读取到最后一个字符时），则返回EOF。<br>注：在应用时，可以利用这个特性进行循环读入：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过这种方式实现对文件的整体输出。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>此后是fputc函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token function">fputc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在p所指向的位置写入一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>被fput操作的文件只能是通过”w”, “w+”, “a”所打开的文件。</li><li>每写入一个字符，则字符指针fp向后移动一个位置。若写入失败，返回EOF。</li></ul><h4 id="字符串读写函数：fgets-fputs"><a href="#字符串读写函数：fgets-fputs" class="headerlink" title="字符串读写函数：fgets &amp; fputs"></a>字符串读写函数：fgets &amp; fputs</h4><p>先对fgets进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//这里权且为了说明写了n，正常情况下这种写法不合规</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开的过程</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在fp的位置读取n-1个字符，并将其放入str中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgets函数如果遇到了换行符或EOF，则自动结束读取。</li><li>fgets函数的返回值为字符数组的首地址。</li><li>若读取失败，则返回NULL。</li></ul><p>在对fputs进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">fputs</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在p的位置将str送入文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数执行成功则返回0，否则则返回EOF。</p><h4 id="格式化读写函数：fscanf-fprintf"><a href="#格式化读写函数：fscanf-fprintf" class="headerlink" title="格式化读写函数：fscanf &amp; fprintf"></a>格式化读写函数：fscanf &amp; fprintf</h4><p>从名字就能看出来，这两个函数与scanf以及printf的功能及其类似，区别在于这两个函数的操作对象是文件，而scanf，printf的操作对象为键盘。（标准输入设备）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开过程</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将文件中的数据读取并存储在变量中</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将变量中的数据写入到文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="数据块读写函数-fread-fwrite"><a href="#数据块读写函数-fread-fwrite" class="headerlink" title="数据块读写函数 fread &amp; fwrite"></a>数据块读写函数 fread &amp; fwrite</h4><p>fread与fwrite常用于二进制文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fread</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fp的位置开始每次读4个字节，读5次，并存入fa所在的地址中。（fa，fp均为指针）</span><span class="token function">fwrite</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fa的位置每次取4个字节，取5次，并放入fp所指向的文件中。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="文件定位函数：rewind-fseek"><a href="#文件定位函数：rewind-fseek" class="headerlink" title="文件定位函数：rewind &amp; fseek"></a>文件定位函数：rewind &amp; fseek</h4><p>先对rewind进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rewind</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将fp放置到文件开头</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在对fseek进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>fseek函数比较复杂：</p><ul><li>第一个参数fp为文件指针。</li><li>第二个参数为偏移量（一个long型变量）。</li><li>第三个参数为偏移起始点：<ul><li>SEEK_SET：代表文件开头（也可以用0代替）</li><li>SEEK_CUR：代表现在fp所在的位置（也可以用1代替）</li><li>SEEK_END：代表文件末尾（也可以用2代替）</li></ul></li></ul><h3 id="文件的检测"><a href="#文件的检测" class="headerlink" title="文件的检测"></a>文件的检测</h3><h4 id="错误检测：ferror"><a href="#错误检测：ferror" class="headerlink" title="错误检测：ferror"></a>错误检测：ferror</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ferror</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测被操作文件的当前状态，正常则返回0，错误则返回1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="清除出错：clearerr"><a href="#清除出错：clearerr" class="headerlink" title="清除出错：clearerr"></a>清除出错：clearerr</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">clearerr</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将所有文件错误标志与文件结束标志强制置0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上，是文件操作的所有函数。<br>确实很复杂，并且博主用的也确实很少 <del>（现在谁还用C语言编辑文档啊.jpg）</del><br>随用随取吧。</p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.7</title>
      <link href="/posts/33475.html"/>
      <url>/posts/33475.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态数据结构"><a href="#动态数据结构" class="headerlink" title="动态数据结构"></a>动态数据结构</h1><h2 id="1-动态存储管理"><a href="#1-动态存储管理" class="headerlink" title="1. 动态存储管理"></a>1. 动态存储管理</h2><h3 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h3><p>在此前的编程过程中，我们所声明的存储大小都是静态的，数组有大小，变量有类型。这固然已经能够满足很多需求，但相应的，有些数据大小未知的情形我们便无法很完美的解决。在此举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> student<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//这种先输入再创建的情况是不合规的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此前，我们的解决方法大多都是创建一个足够大的数组，从而能够达成目标，但这样做势必会浪费许多存储空间。</p><p>因此，引入我们的正题——动态存储分配。</p><h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>在C语言中，动态存储主要依赖于两个标准库以及四个函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//两个标准库：</span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>malloc<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token comment">//四个函数：</span>malloccallocreallocfree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来会一个个介绍</p><h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//分配一个大小为n个int的存储空间，并将其首地址赋给p，如果分配失败则返回空指针。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//如果p是空指针，则直接退出程序，返回值0。</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放程序中被分配的空间。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>malloc可以通过指针的形式来创建一个大小由用户自行输入的存储空间。</p><h4 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//务必注意calloc函数与malloc函数的写法区别。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>calloc函数可以通过指针的方式来创建一个大小由用户自行输入的存储空间 <font color=Aqua> <strong>并将其中的元素自动赋值为0</strong> </font></p><h4 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过以上的语句已经分配了一个空间</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//现在发现原先分配的空间不够，需要重新分配。</span>n<span class="token operator">=</span>n<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//将原先的n变为2倍。</span><span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//重新分配一个大小为n的存储区域，将首地址赋值给一个新的指针q；</span><span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    p<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//若分配失败，p仍然指向原来的存储区；若成功，p指向新存储区。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放原先p所指向的存储块。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="一点注意事项"><a href="#一点注意事项" class="headerlink" title="一点注意事项"></a>一点注意事项</h4><ol><li>请务必注意区分malloc, calloc, realloc的用法以及写法区别。</li><li>malloc, calloc, realloc三种函数通常情况下返回的都是通用指针，因此在给具体类型指针赋值时需要进行强制类型转换（具体原理见上一章：指针）</li></ol><h2 id="2-自定义类型"><a href="#2-自定义类型" class="headerlink" title="2. 自定义类型"></a>2. 自定义类型</h2><blockquote><p>此前提到过一种自定义类型——宏定义define，但宏定义只能做到简单的字符替换，从而在各种计算，定义中产生不可预知的后果，因此在这里给出更加通用的自定义类型。</p></blockquote><h3 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ULI<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>tppedef会用最后的一个词来代替前面的类型。<br>常用于简化程序书写。</p><p>但是typedef在程序书写时不仅仅是简单替换，这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IP</span> <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span> </span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token operator">*</span> P<span class="token punctuation">;</span><span class="token comment">//若之后想要定义两个指针</span>IP a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  <span class="token comment">//等价于int *a, b; 会发现b不是指针</span>P m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>  <span class="token comment">//这时候m, n都是指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-结构"><a href="#3-结构" class="headerlink" title="3. 结构"></a>3. 结构</h2><blockquote><p>C语言中虽然提供了很多变量类型，但是如果我们需要很多不同类型变量的结合体，则仅仅使用C语言提供的变量则显得效率低下。因此，产生了可以自定义的结构类型。</p></blockquote><h3 id="结构类型的定义"><a href="#结构类型的定义" class="headerlink" title="结构类型的定义"></a>结构类型的定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>  <span class="token comment">//这样就定义了一个名叫POINT的结构类型，之后可以直接使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在程序中常用的结构可以通过上述方式来进行定义，从而简化此后需要使用相应模型时的书写过程。</p><p>需要注意的是，结构定义时其成员可以包含其他结构，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    POINT center<span class="token punctuation">;</span>    <span class="token keyword">double</span> radius<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>CIRCLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，结构存在单位大小，但结构的单位大小并不是简简单单的将各个元素的大小加到一起，因此在计算结构大小时建议使用sizeof运算符。（这种状况的出现原因为结构体内的对齐问题，具体请自行搜索）</p><h3 id="结构类型的访问"><a href="#结构类型的访问" class="headerlink" title="结构类型的访问"></a>结构类型的访问</h3><p>在C语言中，结构的访问有其规则。</p><p>如果结构类型相同，则可以直接通过整体相等来赋值<br>如果需要对一个结构里的成员进行编辑，则使用 .<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT A<span class="token punctuation">,</span> B<span class="token punctuation">;</span>A<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>A<span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token number">3.2</span><span class="token punctuation">;</span>A<span class="token operator">=</span>B<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>相应的，结构既然是自定义的数据类型，同样也可以定义一个以自定义结构为元素的数组。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//相当于创建了一个由四个POINT组成的数组。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，与数组相似，结构数组也可以用指针表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>POINT <span class="token operator">*</span>P<span class="token punctuation">;</span>P<span class="token operator">=</span>PT<span class="token punctuation">;</span><span class="token comment">//这里P就与PT数组的首地址绑定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引出了通过指针如何访问结构内的成员，比如我要用指针访问上述数组中第二个点中的X坐标值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//这种表达过于繁琐，因此C语言提供了另一种方法</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-></span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//与上面的表达等价</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-补充</title>
      <link href="/posts/4308.html"/>
      <url>/posts/4308.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的目的在于对此前C语言的笔记进行相应的补充，同时整理一下博主遇到的一些有趣的函数。</p></blockquote><h2 id="1-知识点补充-编程疑难解决"><a href="#1-知识点补充-编程疑难解决" class="headerlink" title="1. 知识点补充 &amp; 编程疑难解决"></a>1. 知识点补充 &amp; 编程疑难解决</h2><h3 id="关于scanf"><a href="#关于scanf" class="headerlink" title="关于scanf"></a>关于scanf</h3><ol><li>在没有特殊说明的情况下，scanf遇到空格，回车等特殊字符会停止，因此在输入字符后需要回车时，不用在scanf后特地打出\n这样的转义字符。</li><li>用scanf时，字符与数字最好分开输入，不然很容易报错，具体原理貌似是%c与%d的输入规则不同。</li></ol><h3 id="关于程序运行时间成本的降低"><a href="#关于程序运行时间成本的降低" class="headerlink" title="关于程序运行时间成本的降低"></a>关于程序运行时间成本的降低</h3><p>运行程序时常常会出现运行时间过长，无法以一个理想的时间得出结果的情况。有以下几种解决办法：</p><ol><li>程序中是否出现了&lt;math.h&gt;中的pow函数，因为pow函数的运算方式为浮点运算，速度较慢，如果运算不需要用到浮点数，可以尝试自己写一个更简单的函数进行改进。</li><li>程序中是否有三层以上的循环，一般来说不会遇到这么复杂的循环，可以尝试改变算法。</li><li>程序中是否有各种递归算法，如果有，尝试改写成循环写法。</li></ol><h3 id="关于排序"><a href="#关于排序" class="headerlink" title="关于排序"></a>关于排序</h3><blockquote><p>在前面的章节中曾经讲过冒泡排序，这是C语言的一种最基础的排序算法，当我们遇到一些更加复杂 &#x2F; 数据更多的情况时，冒泡排序就显得过于简陋，效率也不够看了。</p></blockquote><h4 id="qsort函数（首选）"><a href="#qsort函数（首选）" class="headerlink" title="qsort函数（首选）"></a>qsort函数（首选）</h4><p>QSORT函数位于 &lt;stdlib.h&gt; 中，其原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span>  <span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> size<span class="token punctuation">,</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先别急着头疼，这里会一个个解释。</p><ol><li><p>void* base:<br><strong>base</strong> 是一个指针，该指针指向数组的首地址。(通常直接传入数组名即可)</p></li><li><p>nuemb:<br><strong>nuemb</strong> 是个 <strong>无符号整数类型</strong>，用size_t表示，这个值表示数组内元素个数。(通常可以直接使用 <em>sizeof(数组名)&#x2F;sizeof(数组单个元素大小)</em> 来计算得出)</p></li><li><p>size:<br><strong>size</strong> 表示数组内每个元素的大小。</p></li><li><p>*compar:<br>这一部分是qsort的核心部分，指向的是一个比较两个元素的值的函数，直接决定了排序的顺序。这玩意是要自己写的。这里详细论述：</p><p>首先说明这一函数如何决定排序顺序：<br>当这一函数返回值小于0，则将 p1 指向的元素放在 p2 之前；<br>大于0，将 p1 指向的元素放在 p2 之后；<br>等于0，顺序 <strong>不确定</strong> 。</p><p>再说明这个函数的一些注意事项： </p><ol><li>注意传入数据格式：<br>传入的是两个通用指针，因此在函数内使用时请务必转换成相应类型指针再进行计算。</li><li>务必注意这个函数返回值为0时，排序顺序是随机的！</li></ol></li></ol><h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><h4 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h4><p>字符串的输入有几种方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><del>一般而言，博主更常用gets_s。</del><br>tmd，经过紧接着几个月的拷打之后，还是fgets比较好使…</p><p>但需要注意，关于gets的三种输入函数都存在回车问题，即当这几个函数上面有scanf的时候，会出现函数读入回车导致跳过原本预期中字符串输入的过程，对此有两种解决方式：</p><ol><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于清空缓冲区内的数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于读入此前的回车进而防止其影响字符串输入。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>博主用第二种方法更多一些。</p><h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式不会补充回车</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式会自动补充回车，效果同printf("%s\n", str);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="读入不定个数个字符串"><a href="#读入不定个数个字符串" class="headerlink" title="读入不定个数个字符串"></a>读入不定个数个字符串</h4><p>常用gets_s的返回值进行操作。<br>这里进行说明：</p><p>gets_s是有返回值的，具体返回值为输入字符串的地址（相当于返回一个指针）。如果输入不成功则返回一个空指针。</p><p>因此常用这个性质：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//需要结束输入时则使用CTRL+Z进行结尾。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串的各种转化"><a href="#字符串的各种转化" class="headerlink" title="字符串的各种转化"></a>字符串的各种转化</h4><blockquote><p>假设一串字符串中存着一个5位的整数，我们想用这个值进行计算，这时候如果再用循环进行转化，就太慢，也不优雅（笑</p></blockquote><p>好在，C语言其实是有相应的命令的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为int</span><span class="token function">atol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为long</span><span class="token function">atof</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这一系列函数通通位于 &lt;stdlib.h&gt; 中，传入的参数都是字符串的首地址（可以直接写字符串名）<br>这三个函数可以极大程度上提高我们的效率。</p><h3 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h3><h4 id="指针的地址？-指针所指向的地址？"><a href="#指针的地址？-指针所指向的地址？" class="headerlink" title="指针的地址？ 指针所指向的地址？"></a>指针的地址？ 指针所指向的地址？</h4><p>这是两码事。</p><p>指针的地址可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><p>而指针所指向的地址则可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><h3 id="关于精度（老大难）"><a href="#关于精度（老大难）" class="headerlink" title="关于精度（老大难）"></a>关于精度（老大难）</h3><p>有些oj会要求咱们将小数保留至两位精度（类似的），这种情况下如果我们计算到对应的精度（如0.01）大概率会出现一些奇奇怪怪的错误，要注意这种题求解时按照比题目要求精度高一位的精度来做。（常常在枚举题目中看到这玩意）</p><h2 id="2-一些有趣的函数"><a href="#2-一些有趣的函数" class="headerlink" title="2. 一些有趣的函数"></a>2. 一些有趣的函数</h2><blockquote><p>这个条目仅仅用于记录博主遇到过的觉得有一定利用意义的函数。</p></blockquote><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>利用&lt;stdlib.h&gt;中的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数的功能为得到0~ RAND_MAX 之间的整数，不同系统的RAND_MAX不一样，反正够用</p><p>如果要得到一个范围内的数，比如3-10之间的数，可以用如下方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> random<span class="token punctuation">;</span>  random<span class="token operator">=</span><span class="token number">3</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">//前面的3为最小值，rand后面取余的数为区间宽度。</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> random<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述算法还有个问题，该函数生成的是伪随机数，如果种子不刷新，则生成的随机数是有规律的。<br>因此建议每次使用该函数之前，都多引用一个库，并在主函数中加一句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤的目的是在每次运行程序之前都刷新种子。（通过time(0)这个随时间变化的变量，而这个变量存储在 &lt;time.h&gt; 中。）</p><p>需要注意的是，这个语句请务必加在主函数中，而非是一个调用多次的子函数或迭代很快的循环中，由于time(0)是一个只统计到秒的变量，因此如果过快地多次重置，则会发现你生成的随机数都是同一个数。</p><h3 id="求素数"><a href="#求素数" class="headerlink" title="求素数"></a>求素数</h3><p>用空间换时间</p><p>具体算法：</p><ol><li>令n&#x3D;2，如果n是素数，则划掉序列中所有n的倍数。</li><li>令n等于下一个没有划掉的元素，回到步骤2。</li></ol><h2 id="3-关于C"><a href="#3-关于C" class="headerlink" title="3.关于C++"></a>3.关于C++</h2><p>其实博主本来不打算在这里写C++的东西，但是耐不住学校的安排着实比较无奈，略写吧。</p><h3 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h3><p>C++里面的引用其实比较类似于C里面的指针，只不过不用再使用解引用符了，可以直接通过名称来访问原本的地址，这一点在函数传参的时候尤为常用。</p><h3 id="关于malloc"><a href="#关于malloc" class="headerlink" title="关于malloc"></a>关于malloc</h3><p>这一部分博主着实不是非常确定，但确实出现过在C++中利用malloc却出现报错的情况，在网上查了一下相关资料，发现C++中最好使用新的内存申请方法，即 <strong>new</strong> 关键字。</p><h3 id="关于STL"><a href="#关于STL" class="headerlink" title="关于STL"></a>关于STL</h3><p>这里仅仅会列举一些STL的常见错误，以及一些博主认为需要额外说明的玩意。</p><h4 id="关于push-back后iterator的报错"><a href="#关于push-back后iterator的报错" class="headerlink" title="关于push_back后iterator的报错"></a>关于push_back后iterator的报错</h4><p>在C++中提供了迭代器，即iterator的用法，这东西通常可以用于迭代各类STL容器。</p><p>但有一个事得额外讲一下，vector这个容器相比于正常数组的好处在于其可以随时通过库函数方便的调整它的大小，看起来很美好，其实际底层原理是在原先的数组空间不够时直接将整个数组移到另一个内存地址。</p><p>这在平常是没什么问题的，但是如果你恰好设置了一个迭代器，我们会发现迭代器根本没有转移到新的位置（能转移就有鬼了），而这个时候我们再操作这个迭代器，就会报错。</p><p>所以，在调整数组大小时，尤其需要注意iter的位置。</p><hr><p>本文会随着博主编程经历的增长持续更新。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.6</title>
      <link href="/posts/16898.html"/>
      <url>/posts/16898.html</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="1-指针概述"><a href="#1-指针概述" class="headerlink" title="1. 指针概述"></a>1. 指针概述</h2><p><strong>指针</strong> 在C语言中有着十分重要的作用，其特点体现在其极高的灵活性上，并且能够十分方便的在不同函数间传递。</p><p>要理解指针到底是个啥，需要从一个基础概念 <strong>地址</strong> 说起。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>此前的章节中，曾提到过编程时的各种变量以及算法是储存在 <strong>内存</strong> 中的，而内存在储存数据时对不同的数据都有一个编号，这个编号就被称为 <strong>地址</strong> 。</p><p>在编程过程中，系统会根据程序中的变量名对不同的数据进行存储，相应的，不同的变量占用的内存大小也不尽相同。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>    <span class="token comment">//4个字节</span><span class="token keyword">char</span>   <span class="token comment">//1个字节</span><span class="token keyword">float</span>  <span class="token comment">//4个字节</span><span class="token keyword">double</span> <span class="token comment">//8个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>有了地址这个概念，相应的，程序需要调用相应变量时，就会通过地址找到内存中对应的部分进行调用，这个过程被称为 <strong>寻址</strong> 。</p><p>寻址有两种方式：  </p><ol><li><p>直接寻址</p><p><strong>直接寻址</strong> 指的是直接按变量的地址存取变量的值<br>平时用的如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这些都属于直接寻址。</p></li><li><p>间接寻址</p><p>与直接寻址不同， <strong>间接寻址</strong> 是以地址跳转的方式来存取变量的值。</p><p>这就涉及到了本章的核心—— <strong>指针</strong> ，因为指针所存储的就是地址。</p></li></ol><h2 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2. 指针的使用"></a>2. 指针的使用</h2><h3 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3><p>同样的，指针变量也有不同的类型，以下给出几例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要提出的是，指针变量可以指向任何类型，不仅仅局限于常见的变量类型，还包括函数，结构体等等。</p><h3 id="指针的赋值"><a href="#指针的赋值" class="headerlink" title="指针的赋值"></a>指针的赋值</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//上面是一种赋值方式</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//这是另一种赋值方式</span><span class="token comment">//请格外注意，这种赋值方式是不合规的！</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针变量常用取地址符号 <strong>&amp;</strong> 进行一系列的赋值操作。<br>此外，只能赋给指针与其指针类型对应的变量的地址。（如：整形指针只能赋予其整形变量的地址）</p><h3 id="指针相关的运算符"><a href="#指针相关的运算符" class="headerlink" title="指针相关的运算符"></a>指针相关的运算符</h3><p>与指针相关的运算符有两个： <strong>&amp;</strong> 以及 * 。</p><p>&amp;的意义为取地址，可以将其后方的变量的地址提取出来。<br>*的意义为解引用，只能操作有指针意义的值。</p><p>这里给出*的使用例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//等价于a++;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//等价于printf("%d", a);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里还需要提一下指针的常用情景，此前曾经提过，由于形参的限制，在函数中直接交换另一个函数中的变量是不可取的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span>a<span class="token punctuation">;</span>    a<span class="token operator">=</span>b<span class="token punctuation">;</span>    b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“3 5”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但在这里，指针可以完成这个操作，因为指针直接指向相应变量的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span><span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a<span class="token operator">=</span><span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“5 3”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是为什么说指针很灵活的原因之一。</p><h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>C语言中提供了一个特殊的指针值，被称为空指针，表示该指针变量闲置。常见写法为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//也可以写成int *p=0; 但这种写法不常用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="通用指针"><a href="#通用指针" class="headerlink" title="通用指针"></a>通用指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上述语句可以定义一个通用指针，该指针可以被任何类型的变量地址赋值。<br>但需要注意的是，当使用该指针为其他非通用指针赋值时，需要做类型转换。下面给出一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，可以接受任何变量的地址。</span>pt<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，但pt为整形指针，因此赋值时需要进行强制类型转换。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在日常使用中，通用指针的作用并非进行各类计算，而是常用于动态内存分配函数malloc, calloc中，这点在本文靠后的位置中会提及。</p><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p>野指针：也叫悬空指针，即指针的地址是无效地址，或者未分配存储空间的地址。 <del>（指针指到别的地方去了）</del></p><h2 id="3-指针与数组"><a href="#3-指针与数组" class="headerlink" title="3. 指针与数组"></a>3. 指针与数组</h2><blockquote><p>在使用多次后，会逐渐发现数组和指针其实十分类似 <del>（就一个玩意）</del></p></blockquote><h3 id="数组的存储方式"><a href="#数组的存储方式" class="headerlink" title="数组的存储方式"></a>数组的存储方式</h3><p>在进入正题之前，咱们先来回顾一下数组如何在内存中进行存储。<br>在上一章，提到过数组名其实就是个地址，这里给出更具体的阐释：</p><p>数组名是一个 <strong>基类型为数组元素基类型</strong> 的地址常量。</p><p>解释一下，定义一个数组，其实就是在内存中开辟了一片区域，其每个单元大小都是一个数组元素的大小，然后给数组名关联上那片区域的起始位置的地址。</p><p>说到这里，是不是想到了什么？<br>指针也是个地址，因此用指针去访问数组中的元素是完全可行的。</p><h3 id="访问数组的指针"><a href="#访问数组的指针" class="headerlink" title="访问数组的指针"></a>访问数组的指针</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p， i<span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>  <span class="token comment">//这里也可以写成p=&amp;a[0]; 一个道理。</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//上述代码的输出结果为"1 1 1 1 1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述例子，可以发现我们通过将数组名与指针关联，进而实现了通过指针对数组中的元素进行访问。</p><p>需要注意的是：<br>当我们将数组的首地址赋值给指针时，指针就同样具有了 <strong>单位</strong> 这一概念，即其关联的数组的一个元素的大小。<br>因此，这时下列表达式便都存在意义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">;</span>p<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，现在数组元素的访问便有了两种方法：</p><ol><li>下标：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>指针：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>先回顾一下二维数组的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以理解为先创建了一个长度为5的数组，这个数组里每个单位又有五个整形元素。</p><p>因此，如果用指针操作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token comment">//也可以通过这种方式进行赋值</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出6，相当于tdarray[1][2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于*(*(p+i)+j)做出一些解释：</p><ol><li>p+i：相当于第i行的地址</li><li>*(p+i)：相当于第i行第1个元素的地址</li><li>*(p+i)+j：相当于第i行第j个元素的地址</li><li>*( *(p+i)+j)：相当于第i行第j个元素</li></ol><h3 id="一些额外说明"><a href="#一些额外说明" class="headerlink" title="一些额外说明"></a>一些额外说明</h3><p>需要明确的是，上面的阐述过程中一直将数组名与数组首地址画了等号，这其实并不十分准确，但因为这种阐述方法易于理解，因此采纳了这种方式。</p><p>实际上，大多数情况下，数组名都可以与数组首地址划等号，除了以下两种情况：</p><ol><li>使用sizeof运算符计算数组大小时<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结果为20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用&amp;取地址符号时</li></ol><h2 id="4-指针与字符串"><a href="#4-指针与字符串" class="headerlink" title="4. 指针与字符串"></a>4. 指针与字符串</h2><p>同样的道理，此前的字符数组定义为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显然，str作为字符串名也是一个地址，因此，我们也可以用指针来达成同样的效果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>str<span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是，指针所代表的字符串的起始位置是其地址，终止位置是第一个“\0”。</p><p>下面拿一道例题进行说明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ABCDE"</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> arr<span class="token punctuation">;</span> ptr <span class="token operator">&lt;</span> arr<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span> ptr<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//该程序运行结果为：</span><span class="token comment">//  ABCDE</span><span class="token comment">//  BCDE</span><span class="token comment">//  CDE</span><span class="token comment">//  DE</span><span class="token comment">//  E</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-指针数组"><a href="#5-指针数组" class="headerlink" title="5. 指针数组"></a>5. 指针数组</h2><blockquote><p>请务必区分指针数组与指针形式的二维数组</p></blockquote><p>如果我们想定义一个由指针元素构成的数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句的意义为定义了一个有四个元素的指针数组。</p><p><font color=red>注意：二维数组的定义方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></font><p>产生二者区别的根本原因在于[]的运算优先级高于*，因此前者代表着定义了一个由四个指针元素组成的数组，而后者则仅仅是一个指针，这个指针内对应的地址含有四个元素。</p><p>由于博主对于指针数组的应用实在过少，这里先暂且搁置，待后续补充。</p><h2 id="6-命令行参数"><a href="#6-命令行参数" class="headerlink" title="6. 命令行参数"></a>6. 命令行参数</h2><p>在每个程序的主函数中，都会有这样一个语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>事实上，main后面的括号里是可以填东西的。其完整形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里做出一点说明：</p><ol><li><p>argc是一个整形变量，由系统自动赋值，其值为后续*argv[]字符指针数组的个数。</p></li><li><p>*argv[]是一个字符指针数组，可以接受多个字符串。</p></li><li><p>至于这些字符串如何输入，是通过windows用户终端（cmd）里面执行相应程序的exe文件时需要输入的内容。</p><p>这里给出一例：<br>在终端中找到对应的exe文件（cd 对应文件地址），之后输入：</p><pre class="line-numbers language-none"><code class="language-none">你的文件名.exe Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的话，argv[0]便被赋值为”你的文件名.exe”，argv[1]被赋值为”Hello”, argc[2]被赋值为”World”。<br>argc则被赋值为3。</p><p>这些参数可以在C语言程序中使用。</p></li></ol><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.5</title>
      <link href="/posts/17218.html"/>
      <url>/posts/17218.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1. 数组概述"></a>1. 数组概述</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><p><strong>数组</strong> 是一种能够包含多个 <strong>同类型数据</strong> 的复合结构。</p><p>可以理解为一个连续的存储空间，被切分为了多个存储单元</p><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>数组的定义需要三个要素：  </p><ol><li>数组元素类型</li><li>数组名称</li><li>数组的大小</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">double</span> m<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：</p><ol><li>数组方括号内的只能是 <strong>字面量</strong> 或 <strong>枚举常量</strong>，不能是变量（已赋值的也不行） ；<br>如：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token keyword">int</span> m<span class="token punctuation">[</span>N<span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">enum</span><span class="token punctuation">&#123;</span>X<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//以上是合法的数组定义</span><span class="token comment">//以下是不合法的数组定义</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//注：该种定义方法在C99标准中被允许</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在常规编程中，数组的大小不宜太大（博主最高使用过长度为10000的数组），过大的数组可能会引起报错。<br>如真的需要使用一个很大的存储空间，请参考后一篇文章： <strong>指针</strong></li></ol><h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><h4 id="基本操作：元素访问"><a href="#基本操作：元素访问" class="headerlink" title="基本操作：元素访问"></a>基本操作：元素访问</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>值得一提的是，变量不能出现在数组定义的方括号中，但可以出现在使用数组时的方括号中。如：</p><h4 id="常用操作：批量赋值"><a href="#常用操作：批量赋值" class="headerlink" title="常用操作：批量赋值"></a>常用操作：批量赋值</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种用法是可行的。</p><p>注：<br>利用 <strong>for</strong> 循环对数组内的元素进行统一赋值是十分常见的用法，但这一过程中常常会出现 <strong>越界访问</strong> 问题。</p><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>三种方法：  </p><ol><li>直接初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>注：直接初始化不能使用除了常量之外的任何表达式。</li><li>部分初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会将未提到的元素自动赋值0。</li><li>直接写数组<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会在编译过程中自动给出数组的大小。</li></ol><h4 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h4><p>问题在于，C语言的参数传递是值传递，因此无法简单的在函数中使用数组。</p><p>解决方案：将数组在内存中存储的地址传递给函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的基本使用至此以叙述完毕，接下来会阐述一些常用的数组及其用法。</p><h2 id="2-一维数值型数组的应用"><a href="#2-一维数值型数组的应用" class="headerlink" title="2. 一维数值型数组的应用"></a>2. 一维数值型数组的应用</h2><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p><strong>排序</strong> 是十分常见的可以用数组解决的问题之一，在本篇博文中，仅仅展示出一个基本的方法—— <strong>冒泡排序</strong> 。</p><p><strong>冒泡排序</strong> 的基本思路是运用嵌套for循环对数组进行操作，每一轮循环都将最大的数挪到数组后方相应位置。</p><p>这里给出参考代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]是需要排序的数组，n是数组的大小</span>   <span class="token keyword">int</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span>n<span class="token operator">-</span>i1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">>=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> m<span class="token punctuation">;</span>  <span class="token comment">//m是个临时变量</span>            m<span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>m<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token comment">//如果前一个元素大于（等于）后一个元素，则将两个元素交换</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">//排序完成，如需输出：</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要标注的是，关于排序还有不少改进方法，如 <strong>选择排序</strong> ， <strong>插入排序</strong> 等，在后面的进阶训练篇章中会有提及。</p><h3 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h3><p><strong>查找</strong> 即在数组中寻找某个元素</p><h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><p>线性查找的思路是最简单的，即从头到尾全过一遍，找到相应元素便返回。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]为要进行查找的数组，n为数组大小，goal为要查找的元素</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>         count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> count<span class="token punctuation">;</span>   <span class="token comment">//数组中每个等于goal的元素下标均输出，并返回出现次数（count）</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，这种查找方法在数组已经排好序的情况下是效率较低的。这样就衍生出了另一种查找方法—— <strong>折半查找</strong> 。</p><p>同样的，在后续进阶文章中会提及。</p><h3 id="插入，删除问题"><a href="#插入，删除问题" class="headerlink" title="插入，删除问题"></a>插入，删除问题</h3><p>插入，删除的操作方法相比于查找就多了一步，因此此处不再详细阐述，给出思路。</p><p>插入：<br>找到插入位置-&gt;将后面的元素全部往后挪一位-&gt;将要插入的元素放进去</p><p>删除：<br>找到要删除的元素-&gt;将后面的元素往前挪一位</p><h2 id="3-字符数组-字符串"><a href="#3-字符数组-字符串" class="headerlink" title="3. 字符数组 &#x2F; 字符串"></a>3. 字符数组 &#x2F; 字符串</h2><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>顾名思义， <strong>字符串常量</strong> 即由一连串字符组成的常量。<br>在C语言中规定： <strong>\0</strong> 是字符串结尾的标志。<br>即：如果定义了一个内容为”C programming”的字符串，那它在存储空间内的存储方式为：”C programming\0”</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p><strong>字符数组</strong> 可以用来存储字符串。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>与其他数组定义方式相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> array<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：定义字符数组时需要考虑”\0”占据的一个大小。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化字符数组有多种方法。</p><ol><li><p>逐个字符赋值：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> task<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'p'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//其中未声明初始值的元素会自动赋值为 '\0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>直接定义字符串常量：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"That's a string"</span><span class="token punctuation">;</span><span class="token comment">//未定义初始大小的字符串常量会自动设定其大小为链长+1（用于存储 \0）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这种方法只能用于初始化，不能用于赋值。</p></li></ol><h4 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入&#x2F;输出"></a>输入&#x2F;输出</h4><p>C语言中的scanf（visual studio中为scanf_s）以及printf函数为字符串设定了单独的输入输出格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但很遗憾，由于scanf的限制，这样的输入不适用于列中带有空格的字符串。因为scanf遇到空格会中止。</p><p>因此，以下部分引入新的标准库&lt;string.h&gt;</p><h3 id="概述"><a href="#概述" class="headerlink" title="&lt;string.h&gt;概述"></a>&lt;string.h&gt;概述</h3><p>在C语言中，涉及到字符串，这个标准库几乎是逃不过去的，因为其中涉及到了许多很好用的操作字符串的函数。</p><h4 id="字符串输入函数-gets"><a href="#字符串输入函数-gets" class="headerlink" title="字符串输入函数 gets"></a>字符串输入函数 gets</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数遇到空格不会终止，当遇到回车时会中止输入，并自动在最后多赋值一个 \0</p><h4 id="字符串输出函数-puts"><a href="#字符串输出函数-puts" class="headerlink" title="字符串输出函数 puts"></a>字符串输出函数 puts</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会输出括号中的字符串，并在最后自动加上回车。</p><h4 id="字符串长度函数-strlen"><a href="#字符串长度函数-strlen" class="headerlink" title="字符串长度函数 strlen"></a>字符串长度函数 strlen</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"I'm editing a blog"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会自动计算括号内字符串的实际长度。（不含 \0）</p><h4 id="字符串复制函数-strcpy"><a href="#字符串复制函数-strcpy" class="headerlink" title="字符串复制函数 strcpy"></a>字符串复制函数 strcpy</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> <span class="token string">"blog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容复制到前面的字符串中。<br>需要注意的是前面的字符串需要够大来容纳后面的字符串。</p><h4 id="字符串比较函数-strcmp"><a href="#字符串比较函数-strcmp" class="headerlink" title="字符串比较函数 strcmp"></a>字符串比较函数 strcmp</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Shanghai"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出一个非0的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数会比较前后两字符串的值，相同则输出0，不相同则输出非0；</p><h4 id="字符串连接函数-strcat"><a href="#字符串连接函数-strcat" class="headerlink" title="字符串连接函数 strcat"></a>字符串连接函数 strcat</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Programming"</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"c language"</span><span class="token punctuation">;</span><span class="token function">strcat</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将str2的内容接到str后面</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容接到前面的字符串后面。</p><h3 id="一点补充"><a href="#一点补充" class="headerlink" title="一点补充"></a>一点补充</h3><p>字符串的操作方法十分繁杂，包括最简单的gets，puts函数的各种变体也有很多，在这里不过多赘述，在后面的文章中还会相应提及。</p><h2 id="4-二维数组"><a href="#4-二维数组" class="headerlink" title="4. 二维数组"></a>4. 二维数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述方式表示定义一个5*5的二维数组。</p><h3 id="赋值-使用"><a href="#赋值-使用" class="headerlink" title="赋值&#x2F;使用"></a>赋值&#x2F;使用</h3><p>二维数组的赋值常用两个for循环嵌套进行</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若二维数组作为函数参数使用，则需要使用如下格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//二维数组前面的一维长度不需要给出，但后面的二维长度必须给出</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上，关于数组的一些基本概念已经梳理完毕了。</p><p>下一章的指针，相对而言更加复杂，理解难度也更高，但归根结底与数组的原理极其相似，熟练应用后指针反而更加灵活。 <del>（虽然我现在还不能熟练应用）</del></p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.4</title>
      <link href="/posts/33667.html"/>
      <url>/posts/33667.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-函数概述"><a href="#1-函数概述" class="headerlink" title="1. 函数概述"></a>1. 函数概述</h2><p><strong>函数</strong> 是C语言中的基本单位，具体表现为一段代码，可重复使用从而实现某种功能。</p><p>在C语言的源文件中，仅能存在一个 <strong>main函数</strong> （程序入口）以及多个子函数（名称可自定）</p><p>注：C语言不允许函数的嵌套定义，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token function">function2</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此类函数定义方式是不被允许的。</p><h2 id="2-函数的定义，调用，声明"><a href="#2-函数的定义，调用，声明" class="headerlink" title="2. 函数的定义，调用，声明"></a>2. 函数的定义，调用，声明</h2><p>这里直接列举定义，调用以及声明的方法：</p><ol><li>定义：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">double</span> num<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>声明：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>调用：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> fact<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>几个要注意的点：</p><ol><li><p>函数的返回值类型必须与函数类型相同（第一个词写的啥返回啥）</p></li><li><p><strong>void</strong> 关键字可以指函数类型，此时函数无返回结果，也可用于描述参数，此时函数无参数。</p></li><li><p>关于实参与形参：<br>定义&#x2F;声明函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的a, b称为形参，函数执行完毕后即清除相应内存。</p><p>与此不同，调用函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> result<span class="token punctuation">;</span><span class="token keyword">double</span> n<span class="token operator">=</span><span class="token number">4.2</span><span class="token punctuation">;</span>result<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的m, n被称为实参。</p><p>在调用函数时，会将实参中的值自左向右传递给形参<br>（上例中即会先将m的值传给a，将n的值传给b）<br>此后再进行函数的下一步语句。</p><p>注意：实参传递给形参相应值是 <Font color=CornflowerBlue><em><strong>单向传递</strong></em> </Font></p></li><li><p>关于函数的结束：两种方法  </p><ol><li>执行完最后一条语句</li><li>遇到了return，返回了相应值</li></ol></li><li><p>一般而言，可以在主函数前定义相应函数并在主函数中进行调用，但如果想在主函数后定义相应函数，则需要在主函数前进行函数声明。</p></li><li><p>c语言中的函数允许多级调用（也叫嵌套调用）<br><strong>明确一点，只是允许多级调用，但不允许嵌套定义（在前面有提及）</strong></p></li></ol><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h2><p><strong>递归</strong> 指的是一个函数中存在调用自己本身这个函数的行为，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span>n<span class="token operator">+</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在fact函数中，若n!&#x3D;1，则会重复调用fact自身。</p><p><strong>一个特点：</strong><br> 递归可以转化为循环，但递归写法常常更加简洁，更加易读，相应的，递归的计算复杂度（不确定这个词是否准确）会更高，时间成本也会更高。<br>   举出一个比较合适的例子：斐波那契数列<br>   首先写出递归写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> result<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   然后再给出循环写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token keyword">long</span> f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> result<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span>f1<span class="token operator">+</span>f2<span class="token punctuation">;</span>      f1<span class="token operator">=</span>f2<span class="token punctuation">;</span>      f2<span class="token operator">=</span>result<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   明显看出，编辑时，循环写法涉及到的细节更多，包括for循环的数量问题，f1, f2, result等变量的重新赋值等，而递归写法编程难度要简单许多。</p><p>   但同时，也需要承认，在递归写法中，对许多量都需要进行重复运算，比如每算一次fibo(5)就要算一次fibo(4)和fibo(3)，但这时算fibo(4)则再次涉及到了fibo(3)的运算，这种运算量如果多次叠加，时间成本是很恐怖的。</p><p>综上，请在递归降低编程难度这一特点能够弥补上它自己本身的效率开销时，再进行递归算法的使用。</p><p>进一步的问题解决敬请期待C语言进阶训练篇章。 <del>（我直接挖坑）</del></p><h2 id="4-预编译"><a href="#4-预编译" class="headerlink" title="4. 预编译"></a>4. 预编译</h2><p>在本系列笔记的第二节中曾提及：预编译这一说法，这里给出详细说明。</p><p>预编译命令共三类：  </p><ol><li><p>文件引入</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一类编译命令还有一种写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"...（你自己的文件名）"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一种写法，是在系统头文件中寻找响应文件并引入，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>math<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二种写法，是现在编程文件所在目录下进行文件查找，若找不到，再到系统指定目录下寻找响应文件</p><p>无论如何，文件引入的根本目的是实现多文件编程，使得在这个编程文件中可以使用其他文件中所定义的函数。<br><Font color=cornflowerblue> <strong>其具体原理是用指定文件的内容代替相应的命令行</strong> </Font></p><p>这里存在一种简单易行的方法进行多文件编程，即将你的函数一并写到一个文件中，命名为&lt;file1.h&gt;，此后在需要使用函数的地方预编译： <strong>include &lt;file1.h&gt;</strong> 即可。</p><p>但当头文件有很多个时，会遇到另一个问题，参考如下例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件file1.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file2.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file3.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file4.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file5.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.3></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.4></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当出现必须要同时引用 file3 与 file4 时，会出现对 file1 与 file2 的重复引用（即引用了两次，会报错）<br>因此这里给出方法，在每个文件前都加上一行代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此代码代表本文件仅引用一次。</p></li><li><p>宏定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">name</span> <span class="token expression">maintext</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>宏定义的作用 <strong>maintext</strong> 来替换正文中出现的 <strong>name</strong><br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UD</span> <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">double</span></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>UD x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的UD x, y; 作用等同于unsigned double x, y;  </p><p>几个注意事项：</p><ol><li>宏定义后面没有引号，与文件引入相同。</li><li>宏定义是简单替换，会将maintext原封不动的替换到name的位置，容易造成计算方面的错误，因此不推荐频繁使用。</li></ol></li><li><p>条件编译</p><p>用于仅对c程序中的一部分进行编译，另一部分不编译。（通过if，else实现）<br>具体格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">expression1</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">expression2</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> </span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>局部&#x2F;全局变量</p><p><strong>局部变量</strong> 指的是在函数内定义的变量，仅仅能在函数内部生效。（包括主函数）<br>注意：在复合语句中定义的变量生效范围仅为该复合语句内部。</p><p><strong>全局变量</strong> 指的是在函数外定义的变量，作用范围从定义处到函数源文件结束。</p></li></ol><p>这里单开一块单独说明变量的问题。</p><h2 id="5-动态-静态储存变量"><a href="#5-动态-静态储存变量" class="headerlink" title="5. 动态&#x2F;静态储存变量"></a>5. 动态&#x2F;静态储存变量</h2><p>程序在内存的分布区域是有规划的，分为：</p><ol><li>程序区：存放用户代码</li><li>静态存储区：存放全局数据与静态数据（在程序执行完毕后再释放相应内存）</li><li>动态存储区：存放动态数据（在相应函数执行完毕后便释放对应内存区域）</li><li>寄存器（ <strong>CPU内</strong> ）：将某些用的很多的动态变量存入CPU相应的存储区域中，加快程序执行速度</li></ol><p>由此，可将变量按照存储方式分类：</p><ol><li><p>自动变量<br><strong>自动变量</strong> 存储在动态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">auto</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但由于auto关键字往往可省略，因此任何函数中的未加说明的变量定义均为自动变量。</p></li><li><p>静态变量<br><strong>静态变量</strong> 存储在静态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量在函数执行完毕后将不会被销毁，并会在后续对其进行操作时保留对其进行的改变。</p></li><li><p>寄存器变量<br><strong>寄存器变量</strong> 存储在寄存器中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">register</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几个要注意的要点：  </p><ol><li>只有动态变量可以作为寄存器变量</li><li>寄存器变量不能无限定义，因为寄存器数目有限</li></ol></li><li><p>全局变量<br><strong>全局变量</strong> 存储在静态存储区中，定义方式为在函数外部进行相应定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>extern可以通过在多文件编程中进行使用，但是在另一个文件中使用本文件的全局变量时需要加上extern前缀说明。<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件A的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//这是文件B的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>     <span class="token comment">//x存在，但是定义在别的地方</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>需要注意的是，全局变量、静态变量的使用会降低程序可读性，增加编程复杂度，故请适量使用。</p><p>此外，添加一点补充：  </p><ol><li><p>在嵌套作用域中出现同名变量名定义时，内层作用域的同名变量在这其中会遮盖外层变量。<br>这里浅举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">5</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很明显，在内部作用域中b被重新定义的b&#x3D;2覆盖，当执行完毕后b的值重新变回5。</p></li><li><p>需要注意，多个源文件中不能有重名的全局变量，否则在某一个文件中对全局变量进行引用时会出现链接问题</p></li><li><p>C语言中的常量定义：</p><ol><li>enum<br><strong>enum</strong> 代表枚举常量，仅能定义整数常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>N<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> M<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这样定义出的常量在函数编译过程中值不会改变</li><li>const<br><strong>const</strong> 代表常量，可以定义各种常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> m<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">long</span> r<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>同样，这样定义出的常量在函数编译过程中值不会改变</li></ol></li></ol><p>至此，函数以及各类预编译事项便具体说明完毕。</p><p>接下来就是一些比较复杂的数据处理了，如数组，指针等。</p><p>这篇博文先到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.3</title>
      <link href="/posts/16834.html"/>
      <url>/posts/16834.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><h2 id="1-三种基本结构"><a href="#1-三种基本结构" class="headerlink" title="1. 三种基本结构"></a>1. 三种基本结构</h2><ol><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ol><h2 id="2-关系，逻辑，条件的相关语句"><a href="#2-关系，逻辑，条件的相关语句" class="headerlink" title="2. 关系，逻辑，条件的相关语句"></a>2. 关系，逻辑，条件的相关语句</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>六个： <strong>&lt; &lt;&#x3D; &#x3D;&#x3D; &gt; &gt;&#x3D;</strong><br><strong>注：在C语言中，&#x3D;&#x3D;表示相等，&#x3D;表示赋值，勿混淆</strong></p><h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>在C语言中，用 <strong>1</strong> 表示表达式为真，用 <strong>0</strong> 表示表达式为假<br>如：  </p><ol><li>表达式： <strong>8&gt;4</strong> 为真，值为1</li><li>表达式： <strong>0&#x3D;&#x3D;1</strong> 为假，值为0</li></ol><p>这里引入一种语句： <strong>条件运算符</strong><br>写为：？：<br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述语句表示：<br>若a&gt;b，则x&#x3D;a，反之，则x&#x3D;b</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>三个： <strong>! &amp;&amp; ||</strong><br>分别表示：非，与，或</p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>对于 ! 表达式，会对该表达式求值，以该值的否定为结果<br>对于 &amp;&amp; 表达式，会对两侧表达式分别求值，只有两侧表达式值均为1时，整个表达式值才为1，否则均为0<br>对于 || 表达式，会对两侧表达式分别求值，只有两侧表达式值均为0时，整个表达式值才为0，否则均为1</p><h3 id="短路特性（重点关注）"><a href="#短路特性（重点关注）" class="headerlink" title="短路特性（重点关注）"></a>短路特性（重点关注）</h3><p>逻辑表达式求值时，只有系统判定必须计算下一个运算符才能得出表达式的值时，才会进行计算 <del>（多绕的慌啊）</del></p><p>举个例子：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">&amp;&amp;</span> b <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当上述例子输入时，第一个数值（即a的值）输入0时，则不会计算b &amp;&amp; c这一部分的值，而会直接将x的值赋值为0</p><h2 id="3-顺序结构程序设计"><a href="#3-顺序结构程序设计" class="headerlink" title="3. 顺序结构程序设计"></a>3. 顺序结构程序设计</h2><p><em><strong>自上而下，逐行运行</strong></em></p><p>主要由以下部分组成：</p><ol><li>赋值语句</li><li>复合语句</li><li>函数调用语句</li></ol><p><em>赋值，函数调用在前面的章节已经有过叙述，这里仅对复合语句做简要说明</em></p><p>复合语句指一组语句，可以由 <strong>{}</strong> 框在中间</p><h2 id="4-选择结构程序设计"><a href="#4-选择结构程序设计" class="headerlink" title="4. 选择结构程序设计"></a>4. 选择结构程序设计</h2><p>选择结构需要利用此前的关系，逻辑表达式来阐述条件</p><p>两种常用语句： <strong>if ; switch</strong></p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>有三种形式：  </p><ol><li>if：条件成立后执行</li><li>if-else：条件成立则执行if后的语句，反之则执行else后的语句</li><li>else-if：用于增加if-else中的条件个数</li></ol><p>最完备的一种情况：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">(</span>条件n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><em>用于实现多分支选择结构</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> E1<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> E2<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">default</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，通过对variable（即变量）的值进行判断从而决定要执行的语句<br>当variable&#x3D;&#x3D;E1时，执行case E1中的语句<br>后续同理<br>如果variable的值不等于其中的任意一个case，则执行default中的语句</p><p><strong>注</strong>：  </p><ol><li>执行语句时，只有遇到 <strong>break</strong> 或 <strong>}</strong> 才会终止，故这里推荐在每一个case后均加上break</li><li>default并不是必须的，如果不加default，则variable不符合要求时不会执行任何语句</li><li>variable不仅仅可以是数值，也可以是字符形式</li></ol><h2 id="5-循环程序结构设计"><a href="#5-循环程序结构设计" class="headerlink" title="5. 循环程序结构设计"></a>5. 循环程序结构设计</h2><p>与选择结构类似地，同样需要利用关系、逻辑表达式进行条件的阐述</p><p>常用语句： <strong>while ; for ; do-while</strong></p><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即：当condition为真（即condition非零）时，执行while内语句，执行完毕后重新判断condition，直至condition为假</p><p><strong>注</strong>：<br>当执行语句时遇到诸如 <strong>break ; return ; goto</strong> 之类的语句时，会跳出while循环</p><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>expr1 <span class="token punctuation">;</span> expr2 <span class="token punctuation">;</span> expr3<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要做出一点说明：  </p><ol><li><strong>expr1</strong> 表示初始条件</li><li><strong>expr2</strong> 表示需要满足的条件</li><li><strong>expr3</strong> 表示每次执行完一次语句后要做出的改变</li></ol><p>给出一例方便理解：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句表示：i 的初始值为0；每次执行完语句后 i 自增1，直到 i 大于五十时结束循环</p><p><strong>注</strong>：  </p><ol><li>for结构中每个表达式都可以省略，但分号不可省略</li><li>for结构和while结构可以互相转化，下属while语句与上述for语句等价<pre class="line-numbers language-c" data-language="c"><code class="language-c">expr1<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>expr2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> expr3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>特殊语句同样可以跳出for循环，如 <strong>break ; goto ; return</strong> 等</li></ol><h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与 while 的区别在于这种语句会先将语句执行一遍再判断</p><h3 id="循环中的常见问题"><a href="#循环中的常见问题" class="headerlink" title="循环中的常见问题"></a>循环中的常见问题</h3><ol><li>循环可以相互嵌套，但一般不超过三层（会极大降低运行效率）</li><li>一般不用浮点数对循环进行控制，原因是浮点数存在误差，容易增减循环次数</li></ol><p>以上</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈《阿凡达2：水之道》</title>
      <link href="/posts/54708.html"/>
      <url>/posts/54708.html</url>
      
        <content type="html"><![CDATA[<p><em>阅前提醒：本片博文是在博主仅仅对阿凡达1的剧情略知一二的情形下的观影体验，文章中的观点难免有失偏颇，仅代表个人看法</em></p><blockquote><p><strong>阿凡达2：一部“徒有其表”的科幻作品</strong></p></blockquote><h2 id="剧情梗概"><a href="#剧情梗概" class="headerlink" title="剧情梗概"></a>剧情梗概</h2><blockquote><p>博主的梗概极其简略，肯定无法将电影中的细节进行呈现，这里还请读者有兴趣的话自行观看</p></blockquote><p>阿凡达2采用了一个非常“合家欢”的剧本</p><p>几个基本设定：  </p><ol><li>故事发生的星球叫做：潘多拉星</li><li>该星球上存在着名为“纳美”的原始土著</li><li>纳美人与潘多拉星的自然环境有着一种天然的“联系”，能使他们免遭人类的追捕</li><li>人类通过将自己的记忆转移至阿凡达体内，可以防止自己被潘多拉星的自然环境所针对</li></ol><p>本作剧情：<br>男主在变为纳美族后，了解到人类要取自己性命，为了不拖累自己的森林部族，便主动禅让，并与其家人一同离开森林部族，前往海洋部族，寻求其庇护。<br>在海洋部族的时段，男主学习了海洋部族的各类技能，但仍旧无法逃过人类的追捕，自己的孩子以及海洋部族首领的孩子均被人类所绑架，以此要挟男主主动投降。<br>最终男主在海洋部族及自然的帮助下，击退了前来追杀自己的人类队伍。</p><p>对，在我的眼中这部电影中真正可以说是 <strong>剧情相关</strong> 的部分就这么多，但就是这些内容，居然能拍了长达 <strong>三小时</strong> ？！</p><h2 id="一些亮点"><a href="#一些亮点" class="headerlink" title="一些亮点"></a>一些亮点</h2><p>咱先谈谈这部电影哪里好</p><h3 id="画面，音乐，特效"><a href="#画面，音乐，特效" class="headerlink" title="画面，音乐，特效"></a>画面，音乐，特效</h3><p>可以承认的是，这部电影在这些基础层面，可以说的上是好好学生了，这一系列的基本功打的极其扎实。画面上，很干净，很透亮，对于一部“水战”的主题电影，这是一个很好的加分项；音乐上，至少头一次看，不会有很大的违和感，该起该落，情感把控都还算可以；特效上，阿凡达1就是凭这个打出名声的，不多赘述</p><h3 id="运镜！"><a href="#运镜！" class="headerlink" title="运镜！"></a>运镜！</h3><p>这点我一定得夸一下，这部电影的运镜节奏非常合适，它不会像某些科幻片一样让你感觉到一种“看不过来”的感觉，也不会显得过于拖沓，这带来的观影效果提升确实很明显</p><h2 id="吐槽-（正片开始）"><a href="#吐槽-（正片开始）" class="headerlink" title="吐槽 （正片开始）"></a>吐槽 <del>（正片开始）</del></h2><p>好了，该夸的夸完了，现在该骂一骂了</p><h3 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h3><p>首先从我认为最无法理解的地方说起<br>2022年的 <strong>“科幻巨制”</strong> ，却给我看出了一股子儿女情长，并肩加上一些环境保护的“陈词滥调”，我觉得多少有些无聊了吧</p><p>我可以接受电影以“家庭”，“环境”为主旨，但我不认可为了这所谓的主旨而把剧情的合理性抛之脑后的做法</p><p>我认为本作的不合理处包括并不限于：</p><ol><li>男主明知 <em>人类想要掠夺整个潘多拉星，他自己仅仅是个导火索</em> 的事实，却仍然选择逃窜到另一个部族</li><li>在人类已然找上门时，男主仍在坚守自己“忍一时风平浪静”的岁月静好思想</li><li>在男主终于打算前往一战时，海洋部族仅仅是开场露了个面，此后便在整场决战中 <strong>“销声匿迹”</strong> 了</li></ol><h3 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h3><p>其次，说说这个剧情带来的副作用——整个影片的剧情发展拖沓的令人发指</p><p>不同于此前所提及的“运镜”相关的节奏恰当，本片的剧情进展十分缓慢，依我看来，这部电影的主线完全可以在2小时内结束，能拖到3小时的原因在于影片中存在许多“不必要”的铺垫</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>很多细节上的处理完全为主线服务，而完全忽视了与背景的契合度</p><p>在此略举几例：<br>在太空时代，科技领先潘多拉星多少倍的人类，时至如今，其飞行器的前窗仍然能被纳美人一箭射穿。<br>以及科技如此发达的人类社会，在绑架男主几个孩子时，“固执”地使用 <strong>皮带</strong> 将几个孩子拷在船上，在男主初次成功救出部分人质后，仍然“执拗”地使用 <em><strong>皮带</strong></em> 将剩余人质拷在船上。 <del>（好家伙你搁这玩梅开二度呢？）</del></p><p>无力吐槽。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>阿凡达2的基础是好的，甚至可以说是杰出的，但抵不过剧情，细节上的硬伤带来的观感下降</p><p>如果奔着画面和特效所带来的震撼，可以尝试<br>如果奔着剧情去，大可不必了</p><p>本篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Movies </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.2</title>
      <link href="/posts/5828.html"/>
      <url>/posts/5828.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计初步"><a href="#程序设计初步" class="headerlink" title="程序设计初步"></a>程序设计初步</h1><h2 id="1-程序的基本结构"><a href="#1-程序的基本结构" class="headerlink" title="1.程序的基本结构"></a>1.程序的基本结构</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><Font color=CornflowerBlue> <em><strong>函数</strong></em> </Font> 是C语言程序的基本单位<br>函数以 <strong>{}</strong> 为开始&#x2F;结束标志<br>作为一个程序，必须有一个主函数，即 <strong>main</strong> 函数<br>每个函数由语句构成，每个语句以 <strong>；</strong> 结尾</p><h3 id="预编译命令"><a href="#预编译命令" class="headerlink" title="预编译命令"></a>预编译命令</h3><p>每个C语言程序都含有预编译命令<br>预编译命令有三类：  </p><ol><li>宏定义  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define PI 3.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>文件引入  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>条件编译 <del>（我没用过）</del><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释在程序的编译与运行中均不起作用，仅仅增加程序可读性<br>具体格式:  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;这是一条注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><h3 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h3><p>C语言源程序只能存在基本字符，否则无法通过编译<br>基本字符包括：  </p><ol><li>大小写字母</li><li>数字</li><li>其他的可显示字符</li><li>特殊字符</li></ol><p>注： <strong>程序中所有的字符（除了注释中的内容）必须是英文格式</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符用于标识程序中的名字，描述变量（其实就是你给函数或变量取的名）<br>分为三类：  </p><ol><li>用户自定义标识符</li><li>预定义标识符</li><li>关键字</li></ol><p>几个重要特征：</p><ol><li>标识符只能由 <strong>字母，数字及下划线</strong> 组成</li><li>标识符对大小写敏感</li></ol><p>关于关键字：<br>系统给其赋予了特定功能，不能用于其他目的<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intfloatdoublecharbreak...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><p>C语言中的数据区分类型</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>基本类型<ol><li>整形：int</li><li>字符型：char</li><li>浮点型：<ol><li>单精度浮点型：float</li><li>双精度浮点型：double</li></ol></li></ol></li><li>构造类型<ol><li>数组类型</li><li>结构体类型</li><li>共用体类型</li><li>枚举类型</li></ol></li><li>指针类型</li><li>空类型</li></ol><p><strong>限于章节原因，本处仅对基本类型进行说明</strong></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="整形（int）"><a href="#整形（int）" class="headerlink" title="整形（int）"></a>整形（int）</h4><p>用于描述整数<br>取值范围：$-2^{31}$~$2^{31}-1$</p><h4 id="浮点型（float，double）"><a href="#浮点型（float，double）" class="headerlink" title="浮点型（float，double）"></a>浮点型（float，double）</h4><p>用于描述实数<br>其中 <strong>float</strong> 与 <strong>double</strong> 的区别在于前者精度更低，占用内存也更小<br><em><strong>由于计算机以指数形式存储浮点型，因此存在误差</strong></em></p><h4 id="字符型（char）"><a href="#字符型（char）" class="headerlink" title="字符型（char）"></a>字符型（char）</h4><p>用于存储单个字符信息<br>存储的是对应字符的 <strong>ASCⅡ码</strong><br>在此举一例：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;%c&quot;, 63);printf(&quot;%c&quot;, ?);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两条语句的输出结果应当都是字符 ‘ <strong>？</strong>’</p><h3 id="基本数据类型的扩充"><a href="#基本数据类型的扩充" class="headerlink" title="基本数据类型的扩充"></a>基本数据类型的扩充</h3><h4 id="短整型（short-int-short）"><a href="#短整型（short-int-short）" class="headerlink" title="短整型（short int &#x2F; short）"></a>短整型（short int &#x2F; short）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围更小，占用内存也更小<br>取值范围：$-2^{15}$~$2^{15}-1$</p><h4 id="长整型（long-int-long）"><a href="#长整型（long-int-long）" class="headerlink" title="长整型（long int &#x2F; long）"></a>长整型（long int &#x2F; long）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围大于等于int的范围，主要用于处理一些比较大的整数问题</p><h4 id="无数据类型（unsigned）"><a href="#无数据类型（unsigned）" class="headerlink" title="无数据类型（unsigned）"></a>无数据类型（unsigned）</h4><p><strong>unsigned</strong> 可以加在 <strong>int, short, long, char</strong> 的前面，取消其二进制数第一位表示符号的限制，因此unsigned类型只能表示正数</p><h3 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量 &amp; 常量"></a>变量 &amp; 常量</h3><p><em>顾名思义，变量在函数编译过程中可变，而常量不可变</em></p><p>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">double x &#x3D; 2.3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一语句中，x是被定义出来的变量，2.3是个常量</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>系统在编译过程中会为变量分配相应的内存空间，不同类型的变量被分配的空间不同</p><p>变量的定义：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;char c;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>变量的赋值：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;i &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>分类：</p><ol><li>整形常量</li><li>实型常量</li><li>字符型常量</li><li>字符串常量</li><li>符号常量</li></ol><h5 id="关于字符型常量参与计算"><a href="#关于字符型常量参与计算" class="headerlink" title="关于字符型常量参与计算"></a>关于字符型常量参与计算</h5><p>由于字符型常量存储的是相应字符的 <strong>ASCⅡ码</strong>，因此可以将其作为整形进行相应计算<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char c &#x3D; &#39;a&#39;;c &#x3D; c - 32;printf(&quot;%c&quot;, c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的输出结果应该是 ‘A’</p><h5 id="关于转义字符"><a href="#关于转义字符" class="headerlink" title="关于转义字符"></a>关于转义字符</h5><p>用转义字符表示 <strong>ASCⅡ码</strong> 中不可打印的功能性字符<br>如：换行表示为‘ <em><strong>\n</strong></em> ’, 制表（tab）表示为‘ <em><strong>\t</strong></em> ’, …</p><h5 id="关于字符串常量"><a href="#关于字符串常量" class="headerlink" title="关于字符串常量"></a>关于字符串常量</h5><p>字符串常量利用双引号括起来，可表示多个字符的集合<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&quot;Hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-数据的输入与输出"><a href="#4-数据的输入与输出" class="headerlink" title="4. 数据的输入与输出"></a>4. 数据的输入与输出</h2><h3 id="输出函数printf"><a href="#输出函数printf" class="headerlink" title="输出函数printf"></a>输出函数printf</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;格式控制串&quot;, 输出表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式控制串决定输出的数据类型，分别表示为：</p><ol><li><strong>%d</strong> -&gt; <strong>int</strong></li><li><strong>%f</strong> -&gt; <strong>float&#x2F;double</strong></li><li><strong>%c</strong> -&gt; <strong>char</strong></li><li><strong>%ld</strong> -&gt; <strong>long</strong></li><li><strong>%s</strong> -&gt; <strong>字符串</strong></li></ol><h3 id="输入函数scanf（在Visual-Studio中为scanf-s）"><a href="#输入函数scanf（在Visual-Studio中为scanf-s）" class="headerlink" title="输入函数scanf（在Visual Studio中为scanf_s）"></a>输入函数scanf（在Visual Studio中为scanf_s）</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">scanf(&quot;格式控制串&quot;, 地址表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：<br>格式控制串与printf大抵相同，但是这里将 <strong>double</strong> 的格式控制串更改为了 <strong>%lf</strong><br>同时后面的地址表列为地址，故需要在变量前加上取地址符号 <strong>&amp;</strong></p><h3 id="字符型数据的输入与输出"><a href="#字符型数据的输入与输出" class="headerlink" title="字符型数据的输入与输出"></a>字符型数据的输入与输出</h3><p>C语言为字符型数据设定了新的输入方式（ <strong>getchar</strong> ）与新的输出方式（ <strong>putchar</strong> ）<br>格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-运算符与表达式"><a href="#5-运算符与表达式" class="headerlink" title="5.运算符与表达式"></a>5.运算符与表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是C语言中表示相应运算的特殊符号<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="运算符表"></p><p>关于运算符的运算顺序与层级，博主认为依靠个人的编程经验与计算习惯可以判断，故这里不再详述。</p><p>几点提示：  </p><ol><li>C语言中整形除以整形得出的数字还是整形，如：  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这个语句的输出应当是1</li><li><strong>size of</strong> 是个运算符，不是个函数，要记牢</li><li>自增（减）时，如果符号在前，就先加减，再运算，反之，若符号在后，就先运算，再加减</li><li>关于 <strong>+，*，%</strong> 与 <strong>&#x3D;</strong> 的连用： <pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>等价于：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>上述法则对于 *，%同样适用，不再赘述</li></ol><h2 id="6-数据类型的转换"><a href="#6-数据类型的转换" class="headerlink" title="6.数据类型的转换"></a>6.数据类型的转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>在运算时，如果程序识别到两个不同类型的数据进行运算，会以 <em><strong>向高看齐</strong></em> 的原则进行格式转换<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E5%90%91%E9%AB%98%E7%9C%8B%E9%BD%90.png" alt="向高看齐"></p><p>注意：此时可能会出现数值溢出的问题，通常警告为：</p><pre class="line-numbers language-none"><code class="language-none">warning: overflow in implicit constant conversion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在编程过程中，如果需要令一个变量以另一个数据类型参与运算，可以采用强制类型转换的方式，具体格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>i <span class="token operator">+</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，上述过程中对原本为整形的 i 进行了强制类型转换，将其转换为 double 类型参与运算</p><p>需要注意的是，强制类型转换后，被转换的变量类型是不变的，即 i 仍然是int型变量</p><h2 id="7-数学函数"><a href="#7-数学函数" class="headerlink" title="7.数学函数"></a>7.数学函数</h2><p>在C语言中有相应的对各种数学函数进行定义的库： <strong>&lt;math.h&gt;</strong><br>在需要使用时，在函数前进行相应的预编译即可</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/math.h.png" alt="math.h中的常用函数"></p><p>以上，是编程前需要了解的一些知识</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.1</title>
      <link href="/posts/32835.html"/>
      <url>/posts/32835.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计概述"><a href="#程序设计概述" class="headerlink" title="程序设计概述"></a>程序设计概述</h1><h2 id="1-程序设计语言"><a href="#1-程序设计语言" class="headerlink" title="1.程序设计语言"></a>1.程序设计语言</h2><p><em>计算机语言：计算机能够接受和处理的具有一定格式的语言</em>  </p><h3 id="发展历程："><a href="#发展历程：" class="headerlink" title="发展历程："></a>发展历程：</h3><ol><li>机器语言：二进制</li><li>汇编语言：少许助记符号</li><li>高级语言：  <ol><li>面向过程：Basic， C等</li><li>面向对象：Java， C++等</li></ol></li></ol><h2 id="2-程序设计基本概念"><a href="#2-程序设计基本概念" class="headerlink" title="2.程序设计基本概念"></a>2.程序设计基本概念</h2><h3 id="五部曲：（我自己起的）"><a href="#五部曲：（我自己起的）" class="headerlink" title="五部曲：（我自己起的）"></a>五部曲：<del>（我自己起的）</del></h3><ol><li>分析</li><li>确定算法</li><li>编程</li><li>调试</li><li>优化、改进</li></ol><h3 id="程序-数据结构-算法"><a href="#程序-数据结构-算法" class="headerlink" title=" 程序 &#x3D; 数据结构 + 算法 "></a><Font color=CornflowerBlue> <em><strong>程序 &#x3D; 数据结构 + 算法</strong></em> </Font></h3><h3 id="算法的特性："><a href="#算法的特性：" class="headerlink" title="算法的特性："></a>算法的特性：</h3><ol><li>有穷性：有终点</li><li>确定性：定义清晰</li><li>有零个或多个输入</li><li>至少有一个输出</li><li>可行性：每一步都得可行</li></ol><h3 id="如何描述算法？"><a href="#如何描述算法？" class="headerlink" title="如何描述算法？"></a>如何描述算法？</h3><ol><li><em><strong>流程图</strong></em> ：最常用的方法</li><li>结构流程图：<del>我没用过</del></li><li>伪代码：对相应代码块进行简写</li></ol><p>关于流程图的图例：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.1/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%9B%BE%E4%BE%8B.png" alt="流程图图例"></p><h2 id="3-结构化程序设计"><a href="#3-结构化程序设计" class="headerlink" title="3.结构化程序设计"></a>3.结构化程序设计</h2><p><em>顾名思义，将“程序设计”这个流程结构化，标准化</em></p><h3 id="三种基本结构"><a href="#三种基本结构" class="headerlink" title="三种基本结构"></a>三种基本结构</h3><ol><li>顺序：循序渐进</li><li>选择：涉及到判断，选择支线 <del>（不要介意这个游戏内常见的用语）</del></li><li>循环：涉及到判断，并是否返回执行</li></ol><h2 id="4-程序的实现环境"><a href="#4-程序的实现环境" class="headerlink" title="4.程序的实现环境"></a>4.程序的实现环境</h2><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><ol><li>输入设备</li><li>输出设备</li><li>外存&amp;内存</li><li>CPU：<ol><li>运算器</li><li>控制器</li></ol></li></ol><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><ol><li>操作系统</li><li>编辑程序</li><li>编译程序</li><li>连接程序</li></ol><h3 id="一些解释："><a href="#一些解释：" class="headerlink" title="一些解释："></a>一些解释：</h3><p>用高级语言编写出来的文件叫做 <strong>源程序</strong> ，不能直接执行<br>因此，需要先将其转换为可执行程序，这一过程称为 <strong>C程序的加工</strong><br>C程序的加工分为两步：  </p><ol><li>编译：具体表现为将 <em><strong>.c</strong></em> 程序转换为 <em><strong>.obj</strong></em> 程序</li><li>链接：将 <em><strong>.obj</strong></em> 程序与其他目标程序&#x2F;库装配，形成 <em><strong>.exe</strong></em>文件</li></ol><p>后续过程中如果涉及到编程，博主会以 <em><strong>Visual Studio 2022</strong></em> 为运行环境</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博第一篇</title>
      <link href="/posts/32455.html"/>
      <url>/posts/32455.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h2><p>这个博客来源于博主的一时兴起。</p><p>想发点啥但没有很系统的方法，之后发现了个人博客是个挺自在的地方，故就这样了。</p><h2 id="关于博客的内容"><a href="#关于博客的内容" class="headerlink" title="关于博客的内容"></a>关于博客的内容</h2><p>初步确定为进行个人学习笔记的整理，以及各种博主想说的（包括但不限于各种评价，各种想法…）</p><h2 id="后续更新计划"><a href="#后续更新计划" class="headerlink" title="后续更新计划"></a>后续更新计划</h2><p>· 博客的美化工作，会持续，长期进行</p><p>· 各类二级界面的创建与完善</p><p>· 后续内容的持续跟进…</p><p>目前就这些啦~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客的搭建流程</title>
      <link href="/posts/23043.html"/>
      <url>/posts/23043.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建流程概述"><a href="#搭建流程概述" class="headerlink" title="搭建流程概述"></a>搭建流程概述</h2><h3 id="Step-1：Nodejs的下载及配置"><a href="#Step-1：Nodejs的下载及配置" class="headerlink" title="Step 1：Nodejs的下载及配置"></a>Step 1：Nodejs的下载及配置</h3><p><em>本博客是以Hexo为基本框架，以Github Page为雏形的个人博客，而在Windows上装载Hexo的最佳方法是通过Git（一个应用，内置了Linux的些许命令）从Github上克隆相应仓库，同时Hexo的运行需要Nodejs所提供的环境</em></p><p>首先前往Nodejs官网：<strong>nodejs.org</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Nodejs.png" alt="Nodejs官网"></p><p>这边我选择的是左边的18.12.1版本，相对来说比较稳定<br>安装过程很简单，按照默认配置来就可以<del>（无脑下一步）</del></p><p>此后会涉及到两个环境变量的配置：<br>这里附上一篇博文，我觉得人家讲的比我清楚<del>（水平有限，见谅）</del>  </p><blockquote><p><a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>注：下载完后可以通过cmd（快捷键Ctrl+X，选中其中的 <strong>终端(管理员)</strong> ）检验一下Nodejs是否成功下载并运行了，一并检查一下npm是否成功安装（npm是一个在安装Nodejs后自动给你附带安装的东西，后面会用到）<br>具体命令：</p><pre class="line-numbers language-none"><code class="language-none">&#123;node -v  npm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错才对</p><h3 id="Step-2-将npm更改为国内镜像源提供的cnpm"><a href="#Step-2-将npm更改为国内镜像源提供的cnpm" class="headerlink" title="Step 2: 将npm更改为国内镜像源提供的cnpm"></a>Step 2: 将npm更改为国内镜像源提供的cnpm</h3><p><em>本步骤的目的在于更换npm组件，由于原版npm在后续流程中极其容易报错，因此本步骤至少在博主创建博客时是必要的</em></p><p>命令为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤需要等待一段时间（安装耗时）</p><p>等待其安装完成后，分别输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm  cnpm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错</p><p><strong>注：本步骤中博主遇到了报错情况，提示为：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm : 无法加载文件 D:\nodejs\node_global\cnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，可以通过命令解除限制：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Set-ExecutionPolicy RemoteSigned -Scope Process&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解除限制后再次输入cnpm相关命令即可</p><h3 id="Step-3-正式安装Hexo（主角登场）"><a href="#Step-3-正式安装Hexo（主角登场）" class="headerlink" title="Step 3: 正式安装Hexo（主角登场）"></a>Step 3: 正式安装Hexo<del>（主角登场）</del></h3><p><em>上文有提到，本博客以Hexo为基本框架</em></p><p>仍然是在cmd中，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install -g hexo-cli&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待其安装成功后，再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若没报错，说明安装成功</p><h3 id="Step-4-下载Git"><a href="#Step-4-下载Git" class="headerlink" title="Step 4: 下载Git"></a>Step 4: 下载Git</h3><p><em>上文有提到，通过Git可以有效装载运行Hexo，并与相关的Github仓库进行配套使用</em></p><p>前往Git官网：<strong><a href="https://git-scm.com/">https://git-scm.com/</a></strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Git.png" alt="Git官网"></p><p>博主采用的是2.39.0版本</p><p>同样的，下载，安装<del>（无脑下一步）</del></p><p>接下来仍然涉及到一个环境变量的设置：<br>把刚刚Git安装目录下的bin文件夹打开，复制相应的文件路径，将其添加到<strong>环境变量-系统变量-Path</strong>里面</p><h3 id="Step-5：新建一个用于操作你的博客的文件夹"><a href="#Step-5：新建一个用于操作你的博客的文件夹" class="headerlink" title="Step 5：新建一个用于操作你的博客的文件夹"></a>Step 5：新建一个用于操作你的博客的文件夹</h3><p><em>接下来就是正式的博客搭建环节</em></p><p>在你的电脑中随意一个位置（你得能记住奥）创建一个新文件夹，取名Blog<br>此后点进那个文件夹，右键空白处，点击<strong>Git Bash Here</strong><br>这时应该会出现一个黑框，像这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/gitbash.png" alt="Git控制台界面"></p><p>在其中输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo init&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里大概率会出现两个问题：<br>（1）显示经过多少多少毫秒之后连接错误<br>（2）显示无法成功安装，让你人工输入<em>npm install</em></p><p>如果是第一个错误，请你给git挂上代理（自行搜索）<br>如果是第二个错误，这时候之前做的就有用了，这时直接输入<em>npm install</em>大概率会报错，所以我们输入:</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果没有报错，就大概率成了，这时候看向你的Blog文件夹，如果有一个叫<em>node_modules</em>的文件夹，就可以放心进行下一步了</p><h3 id="Step-6-尝试第一次启动本地服务器"><a href="#Step-6-尝试第一次启动本地服务器" class="headerlink" title="Step 6: 尝试第一次启动本地服务器"></a>Step 6: 尝试第一次启动本地服务器</h3><p>在刚刚那个Git控制台中再次输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果显示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Hexo running at ______(这里是一个地址）_________, Press Ctrl+C to stop.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明成功了，现在在浏览器内打开那个地址，就可以看到一个初步的网页，上面有 <strong>Hexo</strong>标识</p><p>我们先Ctrl+C将其关闭</p><h3 id="Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接"><a href="#Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接" class="headerlink" title="Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接"></a>Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接</h3><p>这边需要你创建一个自己的Github账号<br>牢记你的注册邮箱以及用户名，密码</p><p>创建一个新的库（repository），将这个库的名字改为 <em><strong>你的账户名.github.io</strong></em>  (这一步很重要！)  </p><p>此后进行SSH与Github的绑定,这里还是给出链接  </p><blockquote><p><a href="https://blog.csdn.net/qq_35703954/article/details/87446876">https://blog.csdn.net/qq_35703954/article/details/87446876</a></p></blockquote><p>绑定成功后，需要对Blog文件夹中的一个文件进行些许更改<br>那个文件叫： <em><strong>_config.yml</strong></em></p><p>注：这个文件可以使用记事本打开，但是我强烈建议有需求的各位下载VScode打开这个文件，自行搜索就可以。</p><p>咱们继续：<br>打开后将文件翻到最后，有一个 <em><strong>deploy：…</strong></em> ，将deploy以下的部分全部删除，改为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;deploy:    type: git    repository: 你自己刚刚创建的GitHub的那个项目地址（下文会写如何查看）    branch: main&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>几个需要注意的点</strong></em><br>· 注意格式，deploy后面的内容是有缩进的，以及冒号后面的空格。<br>· 项目地址的查看方法：<br>前往你的GitHub相应项目中，右上角有一个 <em><strong>code</strong></em> 按钮，长这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code.png" alt="Code"><br>点击它，会出现这样的一个界面：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Loading.svg" data-original="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code-1.png" alt="点击Code之后的界面"><br>选中那个 <em><strong>HTTPS</strong></em>， 之后将底下的链接复制，粘贴至上面的 <em><strong>_config.yml</strong></em> 文件的repository后面</p><h3 id="Step-8-装载部署工具"><a href="#Step-8-装载部署工具" class="headerlink" title="Step 8: 装载部署工具"></a>Step 8: 装载部署工具</h3><p>还是 <em><strong>Blog</strong></em> 文件夹，还是右键 <strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install hexo-deployer-git --save&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待安装完成，之后输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待生成完成（不报错），之后再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这之后再输入你的库的名称（即 <em><strong>你的账户名.github.io</strong></em>）到浏览器地址栏中，应该就能看到刚刚那个有Hexo的界面了</p><h3 id="Step-9-编写博文"><a href="#Step-9-编写博文" class="headerlink" title="Step 9: 编写博文"></a>Step 9: 编写博文</h3><p><em><strong>Blog</strong></em>文件夹，右键，<strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo n 你想起的文章名&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后应该会出现一个提示，在你的 <em>source-_posts</em>文件夹内生成了一个markdown文件，这就是你撰写新博客的地方</p><p>注：这也是为什么我推荐安装vscode，因为vscode只需要安装两个插件就可以做到编写，预览Markdown文件，很方便（方法请自行搜索）</p><p>写完你的博文之后，保存，返回 <em><strong>blog</strong></em>文件夹，<strong>Git Bash Here</strong>，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo cl&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一套流程下来，你的博文就可以被成功上传到那个网页中</p><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><p>此次博客的搭建，从整体而言是相对繁琐的，同时中间掉了很多次坑，往往一个坑都得花费1-2个小时进行查询，修补，一套流程下来基本上花了有两天时间。</p><p>回过头来，再看这一整个流程，缺乏的就是一个整体框架，如果一股脑冲进去，会做着做着迷失了方向，就不知道该做什么了</p><p>故此，在这里整理下整套流程，供读者参考，更是供自己反思优化</p><p>关于美化，应该不会再整理步骤了，因为各种模板包里面都有详尽的使用说明，并且不同的模板操作方式不同，待读者自行探索了</p><p>这篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

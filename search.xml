<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构-Chap-2</title>
      <link href="/posts/55842.html"/>
      <url>/posts/55842.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-Chap-2-线性表"><a href="#数据结构-Chap-2-线性表" class="headerlink" title="数据结构 Chap.2 线性表"></a>数据结构 Chap.2 线性表</h1><h2 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h2><p>线性表是一种最简单的数据结构，其表现为一系列有顺序的元素集合。<br>自然，线性表需要满足如下标准：</p><ul><li>有 <strong>第一元素</strong> 与 <strong>最后元素</strong></li><li>除了第一元素之外，每个元素都有它的 <strong>后继</strong> ，除了最后元素之外，每个元素都有它的 <strong>前驱</strong> 。</li><li>同一线性表内的元素必定具有相同的特性。</li></ul><h2 id="线性表的相关操作"><a href="#线性表的相关操作" class="headerlink" title="线性表的相关操作"></a>线性表的相关操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>首先，我们来了解一些线性表的基本操作。<br>它们包括：</p><ul><li>初始化: InitList</li><li>销毁: DestoryList</li><li>判断是否为空: ListEmpty</li><li>求长度: ListLength</li><li>求指定元素的前驱: PriorElem</li><li>求指定元素的后继: NextElem</li><li>提取指定元素: GetElem</li><li>定位: LocateElem</li><li>遍历: ListTraverse</li><li>置空: ClearList</li><li>改变指定元素的值: PutElem</li><li>插入元素: ListInsert</li><li>删除元素: ListDelete</li></ul><p>这里对定位操作进行些许说明：<br>该操作的意义为在线性表中找到第一个符合某个条件的元素，并返回其位置。<br>一般而言，若未找到，则返回-1。</p><p>需要明确的是，上述表述仅仅关系了这些操作是 <strong>做什么的</strong> ，并没有深究应当如何实现这种操作，具体应当如何实现，应当依靠读者使用的语言，采用的具体结构而定。</p><p>上述基础运算也可以构成更进一步的应用，如线性表的有序合并，拆分，排序等。</p><h3 id="应用事例"><a href="#应用事例" class="headerlink" title="应用事例"></a>应用事例</h3><h4 id="两个线性表-LA-与-LB-的合并"><a href="#两个线性表-LA-与-LB-的合并" class="headerlink" title="两个线性表 LA 与 LB 的合并"></a>两个线性表 LA 与 LB 的合并</h4><p>该操作可以分为三步：</p><ul><li>从LB中依次取出每个元素</li><li>观察LB中取出的元素在LA中是否存在</li><li>若不存在，则存入LA中</li></ul><p>若写成代码块：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span>List <span class="token operator">&amp;</span>LA<span class="token punctuation">,</span> List LB<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LA_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LA<span class="token punctuation">)</span><span class="token punctuation">;</span>    LB_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LB_len <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">GetElem</span><span class="token punctuation">(</span>LB<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取第i个元素赋予e</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> e<span class="token punctuation">,</span> equal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">ListInsert</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> LA_len<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将e插入LA的最后</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处，给出了一个很基础的操作代码块，后续在无必要的情况下，将不会这样详细的给出具体步骤。</p><p>回归正题，这个算法需要在遍历LB内每个元素的同时也遍历LA中的每个元素来进行查重，因此我们可以计算出其时间复杂度：<br><em><strong>O(ListLength(LA) * ListLength(LB))</strong></em></p><h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><blockquote><p>前面讲的内容比较概括性，也相对抽象，以下将具体讲述线性表的表示方法。</p></blockquote><h3 id="什么是顺序表示"><a href="#什么是顺序表示" class="headerlink" title="什么是顺序表示"></a>什么是顺序表示</h3><p><em><strong>顺序表示</strong></em> 正如其名，线性表中的数据结构在内存中的表示也是有顺序的，具体表现为前一个元素紧挨着后一个元素。再简单一点，顺序表示可以通俗的理解为C中的 <strong>数组</strong> 。</p><h3 id="用C语言实现线性表的顺序存储"><a href="#用C语言实现线性表的顺序存储" class="headerlink" title="用C语言实现线性表的顺序存储"></a>用C语言实现线性表的顺序存储</h3><h4 id="线性表的初始化：InitList"><a href="#线性表的初始化：InitList" class="headerlink" title="线性表的初始化：InitList"></a>线性表的初始化：InitList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">L<span class="token punctuation">.</span>Elem <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> List_Elem_Size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的容量扩展：ExtendList"><a href="#线性表的容量扩展：ExtendList" class="headerlink" title="线性表的容量扩展：ExtendList"></a>线性表的容量扩展：ExtendList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">NewBase <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>List_Elem_Size <span class="token operator">+</span> Expand_Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的元素定位：LocateElem"><a href="#线性表的元素定位：LocateElem" class="headerlink" title="线性表的元素定位：LocateElem"></a>线性表的元素定位：LocateElem</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>statment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//定位到符合statment语句的元素</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="线性表的元素插入：ListInsert"><a href="#线性表的元素插入：ListInsert" class="headerlink" title="线性表的元素插入：ListInsert"></a>线性表的元素插入：ListInsert</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">>=</span>q<span class="token punctuation">;</span> p<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将插入位置后方的元素分别向后移动一位</span><span class="token operator">*</span>p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//插入元素e</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>线性表的删除操作与插入操作类似，在此不再详述。</p><h3 id="顺序存储线性表的优劣"><a href="#顺序存储线性表的优劣" class="headerlink" title="顺序存储线性表的优劣"></a>顺序存储线性表的优劣</h3><p>顺序存储的优点主要表现在以下两方面：</p><ul><li>存储时不需要为了表述元素之间的关系而额外花费内存空间</li><li>可以实现元素的随机读取</li></ul><p>顺序存储的缺点主要表现在以下两方面：</p><ul><li>必须分配连续存储空间给线性表，在内存连续片段较小时，有初始化失败的可能性</li><li>在插入 &#x2F; 删除元素时，需要大量移动元素，造成不便</li></ul><h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><h3 id="什么是链式表示"><a href="#什么是链式表示" class="headerlink" title="什么是链式表示"></a>什么是链式表示</h3><p><em><strong>链式表示</strong></em> ， 每个数据元素单独存储，它们在内存中可以是连续的，也可以是分散的，它们之间的关系通过每个数据元素附带的一个指针域进行连接。说的更具体化一些，即用结构体将指针于数据元素包装在一起，它们链式存储中的一个数据元素。在C语言中常常通过链表表示。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>这里需要对 <strong>链表</strong> 这一概念进行引入。<br>链表即指代如同上述表达中提及的，一个数据域附带一个指针域形成的结构。其主要分为以下几类：</p><ul><li>单链表</li><li>双链表</li><li>循环链表（单 &#x2F; 双）</li><li>静态链表</li></ul><p>让我们先从最基础的单链表讲起</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>顾名思义，单链表的连接方式是单向的，即我们只能通过前一个元素的指针域找到它的后继，而无法通过后一个元素找到其前驱。<br>其通常在C语言中以这样的方式进行结点定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    ElemType Elem<span class="token punctuation">;</span>    Node<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以得知，只要得知第一个结点，就可以通过每个结点指针域中的指针得知其下一个结点，从而实现链表的一系列操作，因此，我们一般称单链表的第一个结点为 <strong>头结点</strong> 。</p><p>注：有时为了方便，头结点的数据域中不进行存储。</p><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><h5 id="单链表的元素提取：List-GetElem"><a href="#单链表的元素提取：List-GetElem" class="headerlink" title="单链表的元素提取：List_GetElem"></a>单链表的元素提取：List_GetElem</h5><p>不同于顺序存储，链式存储在提取元素时必须通过头结点分部向后寻找指定位置的元素。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_GetElem</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    e <span class="token operator">=</span> p<span class="token operator">-></span>Elem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h5 id="单链表的元素插入：List-Insert"><a href="#单链表的元素插入：List-Insert" class="headerlink" title="单链表的元素插入：List_Insert"></a>单链表的元素插入：List_Insert</h5><p>同样，链式存储的元素插入与顺序存储差异极大。<br>我们需要先找到插入位置的前一个元素，这之后只需要改变这个元素与被插入元素的指针域即可。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_Insert</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//链表的每次插入都需要手动创建一个新结点</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_node<span class="token operator">-></span>ElemType <span class="token operator">=</span> e<span class="token punctuation">;</span>    new_node<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> new_node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>单链表的元素删除相比元素插入仅仅多了一个free（释放内存）的操作，即将删除的结点释放掉，这里不再详述。</p><h5 id="单链表的置空操作：ClearList"><a href="#单链表的置空操作：ClearList" class="headerlink" title="单链表的置空操作：ClearList"></a>单链表的置空操作：ClearList</h5><p>与删除操作类似。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ClearList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>        L<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="单链表的改进"><a href="#单链表的改进" class="headerlink" title="单链表的改进"></a>单链表的改进</h4><p>从上述应用中我们可以看出，单链表的运用很依赖于链表本身的一些特殊结点与位置，那我们不妨改进一下单链表，单独为它设置一个结构体，用于存储这些特殊的位置和个数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sruct List<span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> Head<span class="token punctuation">,</span> Tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种定义，我们可以清晰的明确一个链表的头、尾结点，以及其元素总个数。</p><h4 id="单链表：注意事项"><a href="#单链表：注意事项" class="headerlink" title="单链表：注意事项"></a>单链表：注意事项</h4><p>可以看到，在以上操作中，我们在函数内对单链表进行操作，往往不会直接使用其头结点，而是单独定义一个指针，再通过移动这个指针来操作链表内的元素。<br>这是因为，如果直接对头结点的Head指针进行移动，由于函数的参数是Head的地址，因此在函数中你对Head的每一次移动都是永久性的，函数结束后Head指针的地址并不会还原，你会丢失前面的元素。<br>因此，请务必注意这一点。</p><h3 id="其他形式的链表"><a href="#其他形式的链表" class="headerlink" title="其他形式的链表"></a>其他形式的链表</h3><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p><strong>双链表</strong> 是对单链表的改进，其相比于单链表，一个数据元素占用的内存更大，这是因为它不仅仅能通过一个元素找到它的后继，同时也能找到它的前驱。</p><p>我们常常这样定义一个双链表的结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">DuNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token comment">//数据域</span>    DuNode<span class="token operator">*</span> prior<span class="token punctuation">;</span>    DuNode<span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们通过prior来指向元素的前驱，通过next来指向元素的后继。</p><p>由于指针域的增加，对一个双向链表进行操作时的指针域更改会更加复杂一些，但道理总归相似，请读者自行类比即可。<br>需要特殊说明的是，双向链表在进行插入、删除操作时，需要更改其前驱的next指针，也需要更改其后继的prior指针。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表</strong> 是将链表最后一个元素指向了这个链表的头结点，从而实现了让这个链表首尾相接的效果。<br>此时，判断元素是否是最后一个元素的依据也不是其后继是不是 NULL ，而变成了是不是头结点。</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p><strong>静态链表</strong> 是在某些没有指针这个设定的高级语言中应用的，它通常这样定义一个结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">StaticNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述链表是通过数组来实现的，数组中的一个元素就是一个结点，同时其通过游标cur来表示其结点在链表中的位次。<br>这种链表通过游标来指示其下一个元素的位置，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这就是链表的第1个元素所在的下标位置</span>S<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这是链表第2个元素所在的下标位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>虽然这种链表仍然需要一个相对较大的存储空间，但其在插入 &#x2F; 删除元素时，仍然只需要改变指针，而不用移动元素，因此其仍然具备链式存储结构的主要优点。</p><p>这种链表的顺链查找通常会这样写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i <span class="token operator">=</span> S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span> <span class="token comment">//S[0]相当于头结点</span><span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i <span class="token operator">=</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链式存储的优劣"><a href="#链式存储的优劣" class="headerlink" title="链式存储的优劣"></a>链式存储的优劣</h3><p>链式存储的优势体现在：</p><ul><li>插入 &#x2F; 删除时，无需大量移动元素</li><li>不需要一大块连续的存储空间</li><li>扩充表的规模很容易</li></ul><p>链式存储的主要劣势：</p><ul><li>无法随机访问表内元素，访问时间长短与元素在表内的位置相关。</li></ul><p>至此，关于线性表的大致内容梳理完成。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.1</title>
      <link href="/posts/36863.html"/>
      <url>/posts/36863.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h1><blockquote><p>本文旨在让读者大致了解Java，并对其中的一些基本内容进行说明</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在学习Java之前，我们首先应当了解Java的一些细节</p></blockquote><h3 id="Java是什么？"><a href="#Java是什么？" class="headerlink" title="Java是什么？"></a>Java是什么？</h3><p>Java是由SUN公司开发的一种编程语言，如今已被Oracle收购。</p><p>但时至今日，Java已经不仅仅是一门编程语言，Java包含着许多方面：</p><ul><li>一类编程语言</li><li>一种开发环境</li><li>一种应用运行环境</li></ul><p>得益于Java本身强大的兼容性，其不仅仅在服务器端的应用中占据着一席之地，同样在PC，移动端应用开发上有广大的应用场景。</p><h3 id="Java迄今的地位"><a href="#Java迄今的地位" class="headerlink" title="Java迄今的地位"></a>Java迄今的地位</h3><p>迄今为止，Java在编程语言使用率上仍然占据着第四名的位置。这得益于其兼容性；易于理解的编译语言；内置的内存处理机制等等。</p><h3 id="Java的不同版本"><a href="#Java的不同版本" class="headerlink" title="Java的不同版本"></a>Java的不同版本</h3><p>SUN公司曾经为Java设定了三个版本，这种分类标准被沿用至今：</p><ul><li>Java SE (Standard Edition)</li><li>Java EE (Enterprise Edition)</li><li>Java ME (Micro Edition)</li></ul><p>三者之间的关系为：EE &gt; SE &gt; ME</p><h3 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h3><p><em><strong>JDK</strong></em> 是Java Development Kit 的简称。<br><em><strong>JRE</strong></em> 是Java Runtime Environment 的简称。<br><em><strong>JVM</strong></em> 是Java Virtual Machine 的简称。</p><p>Java在每台计算机上会内置一个虚拟机，即JVM。代码会先编译为Java字节码，而后放在JVM上运行，以此很好的保证了Java在各个平台上的兼容性。</p><p>JRE是Java运行的环境，而JDK比JRE更大一层，其中除了JRE外还内置了编译器、调试器等工具。</p><h2 id="编译入门"><a href="#编译入门" class="headerlink" title="编译入门"></a>编译入门</h2><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>与C不同，Java的配置过程稍显复杂，也需要更多的时间与步骤。</p><p>整体而言，分为 下载JDK -&gt; 配置环境变量 -&gt; 运行IDE 三个步骤。</p><p>本笔记的运行全程以JDK-20为环境，在VScode上进行java的编写。<br>博主在这个方面不做详细阐述，请自行上网搜索</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-1</title>
      <link href="/posts/55842.html"/>
      <url>/posts/55842.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在此前C语言的章节中，曾提到过一个十分有名的等式：算法 + 数据结构 &#x3D; 程序。本部分的博文会从C语言的角度来对数据结构进行相应的阐述，有利于理清思路，也可以以相似的想法套用至其它编译语言中。</p></blockquote><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="1-数据结构的概念"><a href="#1-数据结构的概念" class="headerlink" title="1. 数据结构的概念"></a>1. 数据结构的概念</h2><blockquote><p>何为数据结构？</p></blockquote><p>在编程的过程中，我们通常遇到的问题能够被分为两类：</p><ol><li>数值计算问题</li><li>非数值计算问题</li></ol><p>数值计算问题往往是能够通过明确的数学公式进行解决的，编译的过程需要思考的问题相对较少。而非数值计算问题则涉及的方面更多，也更考验编译者的抽象思维，这一过程中就涉及到选取正确的数据存储方式，以此使我们在计算机上能够更加便利地对数据进行操作，数据结构的概念由此产生。</p><p>我们定义数据结构时，往往通过三方面进行考虑。</p><ul><li>数据的逻辑结构：即信息的组织方式</li><li>数据的存储结构：即信息在计算机上的存储方式</li><li>数据的运算：即在计算机上应当如何处理这些数据</li></ul><p>以下举出两例，进行相关的说明：</p><ol><li><p>表：</p><p> 表的逻辑结构往往是线性的，这意味着其中的数据组与组之间关系并不十分强烈，因此可以采用在计算机中采用顺序（数组）或链式（链表）存储方式。运算也往往包含插、删、改、查四种方式。</p></li><li><p>图：</p><p> 图的逻辑结构体现在结点与结点之间，其组与组之间的关系更加复杂，因为任意两组数据之间均有可能产生联系。因此在存储时，既要考虑结点本身信息的存储，也要考虑结点之间的关系如何构建。运算相应添加了关键路径、最短路径的问题等。</p></li></ol><p>通过上述示例，我们能看出 <strong>数据结构往往解决的是非数值计算问题，它意在数据组织的基础上解决复杂程序的设计问题</strong>。</p><h2 id="2-数据的结构"><a href="#2-数据的结构" class="headerlink" title="2. 数据的结构"></a>2. 数据的结构</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是能够被输入到计算机中进行存储、操作的符号的总称。其衍生出的名词还有：</p><ul><li>数据元素：即数据中的一个个体</li><li>数据项：数据中的一个个体可能有多项数据，这其中每一项数据都能被称作数据项</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>数据元素之间存在某种关系，这种关系被称为逻辑结构。</p><p>常见的逻辑结构有：</p><ul><li>集合</li><li>线性结构</li><li>树形结构</li><li>图 &#x2F; 网状结构</li></ul><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>将数据结构在计算机中存储，表示的方式称为存储结构。它也可以理解为逻辑结构在计算机中的映像。（如二进制、顺序存储映像、链式存储映像等）</p><p>由于某些数据的逻辑结构极其相似，因此统一用一类存储结构对它们进行存储，这种特定的存储结构叫做 <strong>数据类型</strong> （如数组，链表等具体类型）</p><p>同时，对相应数据类型的操作有时也极其相似，因此对相应一类操作起个名，叫 <strong>抽象数据类型（Abstract Data Type）</strong> （不同的教材中叫法不同）<br>这与很多编译语言中的 <strong>类</strong> 的概念十分类似。</p><h3 id="Abstract-Data-Type（ADT）"><a href="#Abstract-Data-Type（ADT）" class="headerlink" title="Abstract Data Type（ADT）"></a>Abstract Data Type（ADT）</h3><h4 id="重要特征"><a href="#重要特征" class="headerlink" title="重要特征"></a>重要特征</h4><p>由于ADT本身的性质，其具有两个重要的特征：</p><ul><li>数据抽象：ADT强调数据本身的性质，而其中的操作是一致的，因此对于其本身与外部用户的接口具有严格的要求。</li><li>数据封装：其内部的实现细节往往对外部用户隐藏。</li></ul><h4 id="ADT的定义"><a href="#ADT的定义" class="headerlink" title="ADT的定义"></a>ADT的定义</h4><pre class="line-numbers language-none"><code class="language-none">ADT抽象数据类型名&#123;    数据对象：    数据关系：    &#x2F;&#x2F;以上两种定义利用伪码描述    基本操作：        基本操作名（参数表）        初始条件：        操作结果：&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本操作的参数表中含有两种参数：</p><ol><li>赋值参数：为操作提供输入值</li><li>引用参数（以&amp;开头）：可返回操作结果</li></ol><p>初始条件表明了该种操作需要满足的条件，可以为空。<br>操作结果表明了数据结构的变化状况，以及此操作后应当返回怎样的结果。</p><h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><p>算法，是对特定问题解决步骤的描述，根据时间、空间占用量的不同有优劣之分。</p><h3 id="算法的特点"><a href="#算法的特点" class="headerlink" title="算法的特点"></a>算法的特点</h3><p>首先，算法必须具有以下五条基本性质：</p><ul><li>有穷性</li><li>确定性（指令明确）</li><li>可行性（每条指令都可被执行）</li><li>有输入（0或多个）</li><li>有输出（0或多个）</li></ul><p>其次，要写出一个 <strong>好的算法</strong> ，则还应当有如下特点进行辅助：</p><ul><li>正确性</li><li>可读性</li><li>健壮性（程序不会轻易崩溃）</li><li>高效率 &amp; 低存储量</li></ul><blockquote><p>正确性、可读性、健壮性自然不必多言，下面从高效率与低存储量方面进行说明。</p></blockquote><h3 id="算法执行时间"><a href="#算法执行时间" class="headerlink" title="算法执行时间"></a>算法执行时间</h3><p>首先，明确一下与执行时间密切相关的因素：</p><ul><li>算法策略</li><li>问题规模</li><li>使用语言</li><li>机器代码质量</li><li>机器性能</li></ul><p>在我们的控制范围内的，主要是算法策略与使用语言。其中又以算法策略为重点优化对象。</p><p>这里我们继续细分， <em><strong>算法 &#x3D; 控制结构 + 原操作</strong></em><br>其中控制结构主要指程序的顺序、分支与循环，而原操作则指固有数据类型的操作。</p><p>形成习惯的是，算法中原操作的重复次数往往与算法的执行时间成正比，因此以 <strong>原操作在算法中重复执行的次数</strong> 作为算法执行时间的衡量准则，称为 <strong>时间复杂度</strong> ，以 <em><strong>O(n)</strong></em> 表示。<br>下面举几例常见的时间复杂度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token comment">//O(1) 常量阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n) 线性阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token operator">++</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n^2)  平方阶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里提出两个经典的问题供读者思考，有兴趣也可以自行搜索相应解答：</p><ul><li>折半查找的算法时间复杂度</li><li>汉诺塔问题递归解法的时间复杂度</li></ul><p>请务必注意，上文中的 <strong>原操作</strong> 指的是 <strong>ADT中的一次基本操作</strong> ，如对于折半查找来说，即进行一次折半操作，对于汉诺塔问题来说，则是挪一次盘子的操作。<br><strong>请务必不要将原操作理解为一条语句！</strong></p><h3 id="算法占用空间"><a href="#算法占用空间" class="headerlink" title="算法占用空间"></a>算法占用空间</h3><p>相对应的，算法本身的操作也需要相应的存储空间，这也就产生了 <strong>空间复杂度</strong> 的概念，不过博主至今并未了解相应的计算机制，烦请读者自行搜索。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好久不见</title>
      <link href="/posts/62537.html"/>
      <url>/posts/62537.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于此前的断更"><a href="#关于此前的断更" class="headerlink" title="关于此前的断更"></a>关于此前的断更</h2><p>距离上一次更新已经有半年之久，这期间主要是由于博主的学习与生活琐事所致，今后会尽力维持更新</p><h2 id="关于此后的内容"><a href="#关于此后的内容" class="headerlink" title="关于此后的内容"></a>关于此后的内容</h2><p>会有偏向性的转向C++与Java方面，另外，（如果博主能够学会相应的表述）可能会有一些数学方面的简记</p><p>好了，下篇博文见~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.8</title>
      <link href="/posts/34435.html"/>
      <url>/posts/34435.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote><p>在一个C语言程序中，除了自行编写程序之外，我们还想到应该如何对计算机内依然存在的文件进行操作，这就引出了本文的主题。</p></blockquote><h3 id="内存与外存"><a href="#内存与外存" class="headerlink" title="内存与外存"></a>内存与外存</h3><p>要描述文件，首先需要从内存，外存两个概念说起。</p><p>内存的概念，此前曾多次提及，是各类变量，算法储存的位置，并会在程序运行结束后及时释放。<br>内存中的数据会在关机后立刻消失。  </p><blockquote><p>如果对DIY有一定了解，则会常常听到“内存条”，就是这东西。</p></blockquote><p>外存则是永久存放各类文件，数据的地方，其中的数据在关机后不会消失。</p><blockquote><p>同样的，接触到的固态硬盘，机械硬盘，以及延伸至各类u盘，软盘，都属于外存的范畴。</p></blockquote><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p><strong>文件</strong> 是数据的集合，也是操作系统储存数据的基本方法。</p><p>文件有以下基本属性：</p><ol><li>文件名</li><li>占用空间</li><li>存储位置</li><li>文件类型</li><li>读写属性</li><li>创建，访问，修改时间</li><li>….</li></ol><p>操作系统为了使各种各样的文件有序的存储，衍生出了 <strong>目录</strong> 这一概念（即文件夹）</p><p>要通过程序操作文件，就必须要求相应的高级语言具有相应的文件操纵能力。</p><p>我们要达到的目的就是通过C语言程序访问文件，即对文件进行相关的输入（input），输出（output）操作。<br>为了简化书写，对输入输出，下文中简称为（I&#x2F;O）</p><h3 id="C语言中的文件形式"><a href="#C语言中的文件形式" class="headerlink" title="C语言中的文件形式"></a>C语言中的文件形式</h3><p>C语言将文件看成一个二进制流或字符流：</p><ol><li>二进制流（常用于二进制文件）：<br>相当于把文件看成很多0&#x2F;1序列，这种方式更有利于计算机的信息读取，保存，写入，但不利于阅读。</li><li>字符流（常用于文本文件）：<br>将文件看成很多字符序列的组合，每行后有一个换行符。这种形式很适合I&#x2F;O操作。</li></ol><p>与此同时，C语言在其标准库中加入了相应函数，包括：</p><ul><li>打开文件</li><li>关闭文件</li><li>读写文件</li></ul><h2 id="2-文件的打开与关闭"><a href="#2-文件的打开与关闭" class="headerlink" title="2. 文件的打开与关闭"></a>2. 文件的打开与关闭</h2><h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><p>在C语言中打开文件常用 <strong>fopen</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span>fp  <span class="token comment">//定义文件类型指针</span>fp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"这里写你的文件名（别忘加后缀）"</span><span class="token punctuation">,</span> <span class="token string">"这里写打开方式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里处理无法打开的情况</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>几个注意事项：</p><ol><li>如果打开文件成功，则返回一个FILE类型的指针地址，并且此后的文件操作都通过这个指针进行。<br>如果打开失败，则返回空指针。<br>因此利用C语言打开文件后一定要检查是否打开成功。</li><li>c语言有很多种文件打开方式：<ul><li>“r”: 打开文本文件，只读</li><li>“w”: 新建文本文件（或者删除原本的内容），只写</li><li>“a”: 打开文本文件，追加</li><li>“r+”: 打开文本文件，可以读+写</li><li>“w+”: 新建文本文件（删除原来的内容），可以读+写</li><li>“a+”: 打开文本文件，可以读+追加</li></ul></li><li>如果用二进制模式打开文件则在打开方式后加b，即：”rb”,”ab+”等。</li></ol><h3 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h3><p>在C语言中关闭文件常用 <strong>fclose</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几点注意事项：</p><ul><li>对于执行写入操作的文件，会将缓冲区内的内容写入文件中，然后关闭文件。</li><li>对于只读文件，会丢弃缓冲区内的内容，然后关闭文件</li><li>程序退出时，所有文件会自动关闭</li></ul><h3 id="三个标准文件指针"><a href="#三个标准文件指针" class="headerlink" title="三个标准文件指针"></a>三个标准文件指针</h3><p>C语言中，有三个自动生成的标准文件指针：</p><ul><li>stdin（标准输入流）</li><li>stdout（标准输出流）</li><li>stderr（标准错误流）</li></ul><p>stdin一般与键盘相连接，stdout一般与显示器相连接。</p><h2 id="3-文件的操作"><a href="#3-文件的操作" class="headerlink" title="3. 文件的操作"></a>3. 文件的操作</h2><blockquote><p>文件的读写涉及到多个函数，这其中还包括顺序读写与随机读写两种类型。</p></blockquote><h3 id="文件的顺序读写"><a href="#文件的顺序读写" class="headerlink" title="文件的顺序读写"></a>文件的顺序读写</h3><h4 id="字符读写函数：fgetc-amp-fputc"><a href="#字符读写函数：fgetc-amp-fputc" class="headerlink" title="字符读写函数：fgetc &amp; fputc"></a>字符读写函数：fgetc &amp; fputc</h4><p>首先对fgetc函数进行说明。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>pp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//通过只读模式打开一个文件</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从文件指针的位置读取一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgetc函数只能对以”r”（只读）, “r+”（只读写）的文件进行操作。</li><li>fgetc函数通过文件内部的位置指针进行读取。</li><li>每次读取一个字符，则文件指针fp向后移动一个位置。若读取失败（如读取到最后一个字符时），则返回EOF。<br>注：在应用时，可以利用这个特性进行循环读入：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过这种方式实现对文件的整体输出。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>此后是fputc函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token function">fputc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在p所指向的位置写入一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>被fput操作的文件只能是通过”w”, “w+”, “a”所打开的文件。</li><li>每写入一个字符，则字符指针fp向后移动一个位置。若写入失败，返回EOF。</li></ul><h4 id="字符串读写函数：fgets-amp-fputs"><a href="#字符串读写函数：fgets-amp-fputs" class="headerlink" title="字符串读写函数：fgets &amp; fputs"></a>字符串读写函数：fgets &amp; fputs</h4><p>先对fgets进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//这里权且为了说明写了n，正常情况下这种写法不合规</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开的过程</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在fp的位置读取n-1个字符，并将其放入str中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgets函数如果遇到了换行符或EOF，则自动结束读取。</li><li>fgets函数的返回值为字符数组的首地址。</li><li>若读取失败，则返回NULL。</li></ul><p>在对fputs进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">fputs</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在p的位置将str送入文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数执行成功则返回0，否则则返回EOF。</p><h4 id="格式化读写函数：fscanf-amp-fprintf"><a href="#格式化读写函数：fscanf-amp-fprintf" class="headerlink" title="格式化读写函数：fscanf &amp; fprintf"></a>格式化读写函数：fscanf &amp; fprintf</h4><p>从名字就能看出来，这两个函数与scanf以及printf的功能及其类似，区别在于这两个函数的操作对象是文件，而scanf，printf的操作对象为键盘。（标准输入设备）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开过程</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将文件中的数据读取并存储在变量中</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将变量中的数据写入到文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="数据块读写函数-fread-amp-fwrite"><a href="#数据块读写函数-fread-amp-fwrite" class="headerlink" title="数据块读写函数 fread &amp; fwrite"></a>数据块读写函数 fread &amp; fwrite</h4><p>fread与fwrite常用于二进制文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fread</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fp的位置开始每次读4个字节，读5次，并存入fa所在的地址中。（fa，fp均为指针）</span><span class="token function">fwrite</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fa的位置每次取4个字节，取5次，并放入fp所指向的文件中。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="文件定位函数：rewind-amp-fseek"><a href="#文件定位函数：rewind-amp-fseek" class="headerlink" title="文件定位函数：rewind &amp; fseek"></a>文件定位函数：rewind &amp; fseek</h4><p>先对rewind进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rewind</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将fp放置到文件开头</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在对fseek进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>fseek函数比较复杂：</p><ul><li>第一个参数fp为文件指针。</li><li>第二个参数为偏移量（一个long型变量）。</li><li>第三个参数为偏移起始点：<ul><li>SEEK_SET：代表文件开头（也可以用0代替）</li><li>SEEK_CUR：代表现在fp所在的位置（也可以用1代替）</li><li>SEEK_END：代表文件末尾（也可以用2代替）</li></ul></li></ul><h3 id="文件的检测"><a href="#文件的检测" class="headerlink" title="文件的检测"></a>文件的检测</h3><h4 id="错误检测：ferror"><a href="#错误检测：ferror" class="headerlink" title="错误检测：ferror"></a>错误检测：ferror</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ferror</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测被操作文件的当前状态，正常则返回0，错误则返回1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="清除出错：clearerr"><a href="#清除出错：clearerr" class="headerlink" title="清除出错：clearerr"></a>清除出错：clearerr</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">clearerr</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将所有文件错误标志与文件结束标志强制置0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上，是文件操作的所有函数。<br>确实很复杂，并且博主用的也确实很少 <del>（现在谁还用C语言编辑文档啊.jpg）</del><br>随用随取吧。</p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.7</title>
      <link href="/posts/33475.html"/>
      <url>/posts/33475.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态数据结构"><a href="#动态数据结构" class="headerlink" title="动态数据结构"></a>动态数据结构</h1><h2 id="1-动态存储管理"><a href="#1-动态存储管理" class="headerlink" title="1. 动态存储管理"></a>1. 动态存储管理</h2><h3 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h3><p>在此前的编程过程中，我们所声明的存储大小都是静态的，数组有大小，变量有类型。这固然已经能够满足很多需求，但相应的，有些数据大小未知的情形我们便无法很完美的解决。在此举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> student<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//这种先输入再创建的情况是不合规的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此前，我们的解决方法大多都是创建一个足够大的数组，从而能够达成目标，但这样做势必会浪费许多存储空间。</p><p>因此，引入我们的正题——动态存储分配。</p><h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>在C语言中，动态存储主要依赖于两个标准库以及四个函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//两个标准库：</span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>malloc<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token comment">//四个函数：</span>malloccallocreallocfree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来会一个个介绍</p><h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//分配一个大小为n个int的存储空间，并将其首地址赋给p，如果分配失败则返回空指针。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//如果p是空指针，则直接退出程序，返回值0。</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放程序中被分配的空间。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>malloc可以通过指针的形式来创建一个大小由用户自行输入的存储空间。</p><h4 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//务必注意calloc函数与malloc函数的写法区别。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>calloc函数可以通过指针的方式来创建一个大小由用户自行输入的存储空间 <font color=Aqua> <strong>并将其中的元素自动赋值为0</strong> </font></p><h4 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过以上的语句已经分配了一个空间</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//现在发现原先分配的空间不够，需要重新分配。</span>n<span class="token operator">=</span>n<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//将原先的n变为2倍。</span><span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//重新分配一个大小为n的存储区域，将首地址赋值给一个新的指针q；</span><span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    p<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//若分配失败，p仍然指向原来的存储区；若成功，p指向新存储区。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放原先p所指向的存储块。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="一点注意事项"><a href="#一点注意事项" class="headerlink" title="一点注意事项"></a>一点注意事项</h4><ol><li>请务必注意区分malloc, calloc, realloc的用法以及写法区别。</li><li>malloc, calloc, realloc三种函数通常情况下返回的都是通用指针，因此在给具体类型指针赋值时需要进行强制类型转换（具体原理见上一章：指针）</li></ol><h2 id="2-自定义类型"><a href="#2-自定义类型" class="headerlink" title="2. 自定义类型"></a>2. 自定义类型</h2><blockquote><p>此前提到过一种自定义类型——宏定义define，但宏定义只能做到简单的字符替换，从而在各种计算，定义中产生不可预知的后果，因此在这里给出更加通用的自定义类型。</p></blockquote><h3 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ULI<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>tppedef会用最后的一个词来代替前面的类型。<br>常用于简化程序书写。</p><p>但是typedef在程序书写时不仅仅是简单替换，这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IP</span> <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span> </span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token operator">*</span> P<span class="token punctuation">;</span><span class="token comment">//若之后想要定义两个指针</span>IP a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  <span class="token comment">//等价于int *a, b; 会发现b不是指针</span>P m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>  <span class="token comment">//这时候m, n都是指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-结构"><a href="#3-结构" class="headerlink" title="3. 结构"></a>3. 结构</h2><blockquote><p>C语言中虽然提供了很多变量类型，但是如果我们需要很多不同类型变量的结合体，则仅仅使用C语言提供的变量则显得效率低下。因此，产生了可以自定义的结构类型。</p></blockquote><h3 id="结构类型的定义"><a href="#结构类型的定义" class="headerlink" title="结构类型的定义"></a>结构类型的定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>  <span class="token comment">//这样就定义了一个名叫POINT的结构类型，之后可以直接使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在程序中常用的结构可以通过上述方式来进行定义，从而简化此后需要使用相应模型时的书写过程。</p><p>需要注意的是，结构定义时其成员可以包含其他结构，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    POINT center<span class="token punctuation">;</span>    <span class="token keyword">double</span> radius<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>CIRCLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，结构存在单位大小，但结构的单位大小并不是简简单单的将各个元素的大小加到一起，因此在计算结构大小时建议使用sizeof运算符。（这种状况的出现原因为结构体内的对齐问题，具体请自行搜索）</p><h3 id="结构类型的访问"><a href="#结构类型的访问" class="headerlink" title="结构类型的访问"></a>结构类型的访问</h3><p>在C语言中，结构的访问有其规则。</p><p>如果结构类型相同，则可以直接通过整体相等来赋值<br>如果需要对一个结构里的成员进行编辑，则使用 .<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT A<span class="token punctuation">,</span> B<span class="token punctuation">;</span>A<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>A<span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token number">3.2</span><span class="token punctuation">;</span>A<span class="token operator">=</span>B<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>相应的，结构既然是自定义的数据类型，同样也可以定义一个以自定义结构为元素的数组。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//相当于创建了一个由四个POINT组成的数组。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，与数组相似，结构数组也可以用指针表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>POINT <span class="token operator">*</span>P<span class="token punctuation">;</span>P<span class="token operator">=</span>PT<span class="token punctuation">;</span><span class="token comment">//这里P就与PT数组的首地址绑定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引出了通过指针如何访问结构内的成员，比如我要用指针访问上述数组中第二个点中的X坐标值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//这种表达过于繁琐，因此C语言提供了另一种方法</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-></span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//与上面的表达等价</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-补充</title>
      <link href="/posts/4308.html"/>
      <url>/posts/4308.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的目的在于对此前C语言的笔记进行相应的补充，同时整理一下博主遇到的一些有趣的函数。</p></blockquote><h2 id="1-知识点补充-amp-编程疑难解决"><a href="#1-知识点补充-amp-编程疑难解决" class="headerlink" title="1. 知识点补充 &amp; 编程疑难解决"></a>1. 知识点补充 &amp; 编程疑难解决</h2><h3 id="关于scanf"><a href="#关于scanf" class="headerlink" title="关于scanf"></a>关于scanf</h3><ol><li>在没有特殊说明的情况下，scanf遇到空格，回车等特殊字符会停止，因此在输入字符后需要回车时，不用在scanf后特地打出\n这样的转义字符。</li><li>用scanf时，字符与数字最好分开输入，不然很容易报错，具体原理貌似是%c与%d的输入规则不同。</li></ol><h3 id="关于程序运行时间成本的降低"><a href="#关于程序运行时间成本的降低" class="headerlink" title="关于程序运行时间成本的降低"></a>关于程序运行时间成本的降低</h3><p>运行程序时常常会出现运行时间过长，无法以一个理想的时间得出结果的情况。有以下几种解决办法：</p><ol><li>程序中是否出现了&lt;math.h&gt;中的pow函数，因为pow函数的运算方式为浮点运算，速度较慢，如果运算不需要用到浮点数，可以尝试自己写一个更简单的函数进行改进。</li><li>程序中是否有三层以上的循环，一般来说不会遇到这么复杂的循环，可以尝试改变算法。</li><li>程序中是否有各种递归算法，如果有，尝试改写成循环写法。</li></ol><h3 id="关于排序"><a href="#关于排序" class="headerlink" title="关于排序"></a>关于排序</h3><blockquote><p>在前面的章节中曾经讲过冒泡排序，这是C语言的一种最基础的排序算法，当我们遇到一些更加复杂 &#x2F; 数据更多的情况时，冒泡排序就显得过于简陋，效率也不够看了。</p></blockquote><h4 id="qsort函数（首选）"><a href="#qsort函数（首选）" class="headerlink" title="qsort函数（首选）"></a>qsort函数（首选）</h4><p>QSORT函数位于 &lt;stdlib.h&gt; 中，其原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span>  <span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> size<span class="token punctuation">,</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先别急着头疼，这里会一个个解释。</p><ol><li><p>void* base:<br><strong>base</strong> 是一个指针，该指针指向数组的首地址。(通常直接传入数组名即可)</p></li><li><p>nuemb:<br><strong>nuemb</strong> 是个 <strong>无符号整数类型</strong>，用size_t表示，这个值表示数组内元素个数。(通常可以直接使用 <em>sizeof(数组名)&#x2F;sizeof(数组单个元素大小)</em> 来计算得出)</p></li><li><p>size:<br><strong>size</strong> 表示数组内每个元素的大小。</p></li><li><p>*compar:<br>这一部分是qsort的核心部分，指向的是一个比较两个元素的值的函数，直接决定了排序的顺序。这玩意是要自己写的。这里详细论述：</p><p>首先说明这一函数如何决定排序顺序：<br>当这一函数返回值小于0，则将 p1 指向的元素放在 p2 之前；<br>大于0，将 p1 指向的元素放在 p2 之后；<br>等于0，顺序 <strong>不确定</strong> 。</p><p>再说明这个函数的一些注意事项： </p><ol><li>注意传入数据格式：<br>传入的是两个通用指针，因此在函数内使用时请务必转换成相应类型指针再进行计算。</li><li>务必注意这个函数返回值为0时，排序顺序是随机的！</li></ol></li></ol><h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><h4 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h4><p>字符串的输入有几种方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><del>一般而言，博主更常用gets_s。</del><br>tmd，经过紧接着几个月的拷打之后，还是fgets比较好使…</p><p>但需要注意，关于gets的三种输入函数都存在回车问题，即当这几个函数上面有scanf的时候，会出现函数读入回车导致跳过原本预期中字符串输入的过程，对此有两种解决方式：</p><ol><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于清空缓冲区内的数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于读入此前的回车进而防止其影响字符串输入。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>博主用第二种方法更多一些。</p><h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式不会补充回车</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式会自动补充回车，效果同printf("%s\n", str);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="读入不定个数个字符串"><a href="#读入不定个数个字符串" class="headerlink" title="读入不定个数个字符串"></a>读入不定个数个字符串</h4><p>常用gets_s的返回值进行操作。<br>这里进行说明：</p><p>gets_s是有返回值的，具体返回值为输入字符串的地址（相当于返回一个指针）。如果输入不成功则返回一个空指针。</p><p>因此常用这个性质：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//需要结束输入时则使用CTRL+Z进行结尾。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串的各种转化"><a href="#字符串的各种转化" class="headerlink" title="字符串的各种转化"></a>字符串的各种转化</h4><blockquote><p>假设一串字符串中存着一个5位的整数，我们想用这个值进行计算，这时候如果再用循环进行转化，就太慢，也不优雅（笑</p></blockquote><p>好在，C语言其实是有相应的命令的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为int</span><span class="token function">atol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为long</span><span class="token function">atof</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这一系列函数通通位于 &lt;stdlib.h&gt; 中，传入的参数都是字符串的首地址（可以直接写字符串名）<br>这三个函数可以极大程度上提高我们的效率。</p><h3 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h3><h4 id="指针的地址？-指针所指向的地址？"><a href="#指针的地址？-指针所指向的地址？" class="headerlink" title="指针的地址？ 指针所指向的地址？"></a>指针的地址？ 指针所指向的地址？</h4><p>这是两码事。</p><p>指针的地址可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><p>而指针所指向的地址则可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><h2 id="2-一些有趣的函数"><a href="#2-一些有趣的函数" class="headerlink" title="2. 一些有趣的函数"></a>2. 一些有趣的函数</h2><blockquote><p>这个条目仅仅用于记录博主遇到过的觉得有一定利用意义的函数。</p></blockquote><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>利用&lt;stdlib.h&gt;中的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数的功能为得到0~ RAND_MAX 之间的整数，不同系统的RAND_MAX不一样，反正够用</p><p>如果要得到一个范围内的数，比如3-10之间的数，可以用如下方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> random<span class="token punctuation">;</span>  random<span class="token operator">=</span><span class="token number">3</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">//前面的3为最小值，rand后面取余的数为区间宽度。</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> random<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述算法还有个问题，该函数生成的是伪随机数，如果种子不刷新，则生成的随机数是有规律的。<br>因此建议每次使用该函数之前，都多引用一个库，并在主函数中加一句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤的目的是在每次运行程序之前都刷新种子。（通过time(0)这个随时间变化的变量，而这个变量存储在 &lt;time.h&gt; 中。）</p><p>需要注意的是，这个语句请务必加在主函数中，而非是一个调用多次的子函数或迭代很快的循环中，由于time(0)是一个只统计到秒的变量，因此如果过快地多次重置，则会发现你生成的随机数都是同一个数。</p><h3 id="求素数"><a href="#求素数" class="headerlink" title="求素数"></a>求素数</h3><p>用空间换时间</p><p>具体算法：</p><ol><li>令n&#x3D;2，如果n是素数，则划掉序列中所有n的倍数。</li><li>令n等于下一个没有划掉的元素，回到步骤2。</li></ol><hr><p>本文会随着博主编程经历的增长持续更新。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.6</title>
      <link href="/posts/16898.html"/>
      <url>/posts/16898.html</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="1-指针概述"><a href="#1-指针概述" class="headerlink" title="1. 指针概述"></a>1. 指针概述</h2><p><strong>指针</strong> 在C语言中有着十分重要的作用，其特点体现在其极高的灵活性上，并且能够十分方便的在不同函数间传递。</p><p>要理解指针到底是个啥，需要从一个基础概念 <strong>地址</strong> 说起。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>此前的章节中，曾提到过编程时的各种变量以及算法是储存在 <strong>内存</strong> 中的，而内存在储存数据时对不同的数据都有一个编号，这个编号就被称为 <strong>地址</strong> 。</p><p>在编程过程中，系统会根据程序中的变量名对不同的数据进行存储，相应的，不同的变量占用的内存大小也不尽相同。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>    <span class="token comment">//4个字节</span><span class="token keyword">char</span>   <span class="token comment">//1个字节</span><span class="token keyword">float</span>  <span class="token comment">//4个字节</span><span class="token keyword">double</span> <span class="token comment">//8个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>有了地址这个概念，相应的，程序需要调用相应变量时，就会通过地址找到内存中对应的部分进行调用，这个过程被称为 <strong>寻址</strong> 。</p><p>寻址有两种方式：  </p><ol><li><p>直接寻址</p><p><strong>直接寻址</strong> 指的是直接按变量的地址存取变量的值<br>平时用的如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这些都属于直接寻址。</p></li><li><p>间接寻址</p><p>与直接寻址不同， <strong>间接寻址</strong> 是以地址跳转的方式来存取变量的值。</p><p>这就涉及到了本章的核心—— <strong>指针</strong> ，因为指针所存储的就是地址。</p></li></ol><h2 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2. 指针的使用"></a>2. 指针的使用</h2><h3 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3><p>同样的，指针变量也有不同的类型，以下给出几例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要提出的是，指针变量可以指向任何类型，不仅仅局限于常见的变量类型，还包括函数，结构体等等。</p><h3 id="指针的赋值"><a href="#指针的赋值" class="headerlink" title="指针的赋值"></a>指针的赋值</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//上面是一种赋值方式</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//这是另一种赋值方式</span><span class="token comment">//请格外注意，这种赋值方式是不合规的！</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针变量常用取地址符号 <strong>&amp;</strong> 进行一系列的赋值操作。<br>此外，只能赋给指针与其指针类型对应的变量的地址。（如：整形指针只能赋予其整形变量的地址）</p><h3 id="指针相关的运算符"><a href="#指针相关的运算符" class="headerlink" title="指针相关的运算符"></a>指针相关的运算符</h3><p>与指针相关的运算符有两个： <strong>&amp;</strong> 以及 * 。</p><p>&amp;的意义为取地址，可以将其后方的变量的地址提取出来。<br>*的意义为解引用，只能操作有指针意义的值。</p><p>这里给出*的使用例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//等价于a++;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//等价于printf("%d", a);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里还需要提一下指针的常用情景，此前曾经提过，由于形参的限制，在函数中直接交换另一个函数中的变量是不可取的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span>a<span class="token punctuation">;</span>    a<span class="token operator">=</span>b<span class="token punctuation">;</span>    b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“3 5”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但在这里，指针可以完成这个操作，因为指针直接指向相应变量的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span><span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a<span class="token operator">=</span><span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“5 3”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是为什么说指针很灵活的原因之一。</p><h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>C语言中提供了一个特殊的指针值，被称为空指针，表示该指针变量闲置。常见写法为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//也可以写成int *p=0; 但这种写法不常用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="通用指针"><a href="#通用指针" class="headerlink" title="通用指针"></a>通用指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上述语句可以定义一个通用指针，该指针可以被任何类型的变量地址赋值。<br>但需要注意的是，当使用该指针为其他非通用指针赋值时，需要做类型转换。下面给出一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，可以接受任何变量的地址。</span>pt<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，但pt为整形指针，因此赋值时需要进行强制类型转换。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在日常使用中，通用指针的作用并非进行各类计算，而是常用于动态内存分配函数malloc, calloc中，这点在本文靠后的位置中会提及。</p><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p>野指针：也叫悬空指针，即指针的地址是无效地址，或者未分配存储空间的地址。 <del>（指针指到别的地方去了）</del></p><h2 id="3-指针与数组"><a href="#3-指针与数组" class="headerlink" title="3. 指针与数组"></a>3. 指针与数组</h2><blockquote><p>在使用多次后，会逐渐发现数组和指针其实十分类似 <del>（就一个玩意）</del></p></blockquote><h3 id="数组的存储方式"><a href="#数组的存储方式" class="headerlink" title="数组的存储方式"></a>数组的存储方式</h3><p>在进入正题之前，咱们先来回顾一下数组如何在内存中进行存储。<br>在上一章，提到过数组名其实就是个地址，这里给出更具体的阐释：</p><p>数组名是一个 <strong>基类型为数组元素基类型</strong> 的地址常量。</p><p>解释一下，定义一个数组，其实就是在内存中开辟了一片区域，其每个单元大小都是一个数组元素的大小，然后给数组名关联上那片区域的起始位置的地址。</p><p>说到这里，是不是想到了什么？<br>指针也是个地址，因此用指针去访问数组中的元素是完全可行的。</p><h3 id="访问数组的指针"><a href="#访问数组的指针" class="headerlink" title="访问数组的指针"></a>访问数组的指针</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p， i<span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>  <span class="token comment">//这里也可以写成p=&amp;a[0]; 一个道理。</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//上述代码的输出结果为"1 1 1 1 1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述例子，可以发现我们通过将数组名与指针关联，进而实现了通过指针对数组中的元素进行访问。</p><p>需要注意的是：<br>当我们将数组的首地址赋值给指针时，指针就同样具有了 <strong>单位</strong> 这一概念，即其关联的数组的一个元素的大小。<br>因此，这时下列表达式便都存在意义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">;</span>p<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，现在数组元素的访问便有了两种方法：</p><ol><li>下标：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>指针：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>先回顾一下二维数组的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以理解为先创建了一个长度为5的数组，这个数组里每个单位又有五个整形元素。</p><p>因此，如果用指针操作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token comment">//也可以通过这种方式进行赋值</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出6，相当于tdarray[1][2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于*(*(p+i)+j)做出一些解释：</p><ol><li>p+i：相当于第i行的地址</li><li>*(p+i)：相当于第i行第1个元素的地址</li><li>*(p+i)+j：相当于第i行第j个元素的地址</li><li>*( *(p+i)+j)：相当于第i行第j个元素</li></ol><h3 id="一些额外说明"><a href="#一些额外说明" class="headerlink" title="一些额外说明"></a>一些额外说明</h3><p>需要明确的是，上面的阐述过程中一直将数组名与数组首地址画了等号，这其实并不十分准确，但因为这种阐述方法易于理解，因此采纳了这种方式。</p><p>实际上，大多数情况下，数组名都可以与数组首地址划等号，除了以下两种情况：</p><ol><li>使用sizeof运算符计算数组大小时<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结果为20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用&amp;取地址符号时</li></ol><h2 id="4-指针与字符串"><a href="#4-指针与字符串" class="headerlink" title="4. 指针与字符串"></a>4. 指针与字符串</h2><p>同样的道理，此前的字符数组定义为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显然，str作为字符串名也是一个地址，因此，我们也可以用指针来达成同样的效果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>str<span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是，指针所代表的字符串的起始位置是其地址，终止位置是第一个“\0”。</p><p>下面拿一道例题进行说明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ABCDE"</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> arr<span class="token punctuation">;</span> ptr <span class="token operator">&lt;</span> arr<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span> ptr<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//该程序运行结果为：</span><span class="token comment">//  ABCDE</span><span class="token comment">//  BCDE</span><span class="token comment">//  CDE</span><span class="token comment">//  DE</span><span class="token comment">//  E</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-指针数组"><a href="#5-指针数组" class="headerlink" title="5. 指针数组"></a>5. 指针数组</h2><blockquote><p>请务必区分指针数组与指针形式的二维数组</p></blockquote><p>如果我们想定义一个由指针元素构成的数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句的意义为定义了一个有四个元素的指针数组。</p><p><font color=red>注意：二维数组的定义方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></font><p>产生二者区别的根本原因在于[]的运算优先级高于*，因此前者代表着定义了一个由四个指针元素组成的数组，而后者则仅仅是一个指针，这个指针内对应的地址含有四个元素。</p><p>由于博主对于指针数组的应用实在过少，这里先暂且搁置，待后续补充。</p><h2 id="6-命令行参数"><a href="#6-命令行参数" class="headerlink" title="6. 命令行参数"></a>6. 命令行参数</h2><p>在每个程序的主函数中，都会有这样一个语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>事实上，main后面的括号里是可以填东西的。其完整形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里做出一点说明：</p><ol><li><p>argc是一个整形变量，由系统自动赋值，其值为后续*argv[]字符指针数组的个数。</p></li><li><p>*argv[]是一个字符指针数组，可以接受多个字符串。</p></li><li><p>至于这些字符串如何输入，是通过windows用户终端（cmd）里面执行相应程序的exe文件时需要输入的内容。</p><p>这里给出一例：<br>在终端中找到对应的exe文件（cd 对应文件地址），之后输入：</p><pre class="line-numbers language-none"><code class="language-none">你的文件名.exe Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的话，argv[0]便被赋值为”你的文件名.exe”，argv[1]被赋值为”Hello”, argc[2]被赋值为”World”。<br>argc则被赋值为3。</p><p>这些参数可以在C语言程序中使用。</p></li></ol><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.5</title>
      <link href="/posts/17218.html"/>
      <url>/posts/17218.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1. 数组概述"></a>1. 数组概述</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><p><strong>数组</strong> 是一种能够包含多个 <strong>同类型数据</strong> 的复合结构。</p><p>可以理解为一个连续的存储空间，被切分为了多个存储单元</p><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>数组的定义需要三个要素：  </p><ol><li>数组元素类型</li><li>数组名称</li><li>数组的大小</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">double</span> m<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：</p><ol><li>数组方括号内的只能是 <strong>字面量</strong> 或 <strong>枚举常量</strong>，不能是变量（已赋值的也不行） ；<br>如：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token keyword">int</span> m<span class="token punctuation">[</span>N<span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">enum</span><span class="token punctuation">&#123;</span>X<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//以上是合法的数组定义</span><span class="token comment">//以下是不合法的数组定义</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//注：该种定义方法在C99标准中被允许</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在常规编程中，数组的大小不宜太大（博主最高使用过长度为10000的数组），过大的数组可能会引起报错。<br>如真的需要使用一个很大的存储空间，请参考后一篇文章： <strong>指针</strong></li></ol><h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><h4 id="基本操作：元素访问"><a href="#基本操作：元素访问" class="headerlink" title="基本操作：元素访问"></a>基本操作：元素访问</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>值得一提的是，变量不能出现在数组定义的方括号中，但可以出现在使用数组时的方括号中。如：</p><h4 id="常用操作：批量赋值"><a href="#常用操作：批量赋值" class="headerlink" title="常用操作：批量赋值"></a>常用操作：批量赋值</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种用法是可行的。</p><p>注：<br>利用 <strong>for</strong> 循环对数组内的元素进行统一赋值是十分常见的用法，但这一过程中常常会出现 <strong>越界访问</strong> 问题。</p><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>三种方法：  </p><ol><li>直接初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>注：直接初始化不能使用除了常量之外的任何表达式。</li><li>部分初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会将未提到的元素自动赋值0。</li><li>直接写数组<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会在编译过程中自动给出数组的大小。</li></ol><h4 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h4><p>问题在于，C语言的参数传递是值传递，因此无法简单的在函数中使用数组。</p><p>解决方案：将数组在内存中存储的地址传递给函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的基本使用至此以叙述完毕，接下来会阐述一些常用的数组及其用法。</p><h2 id="2-一维数值型数组的应用"><a href="#2-一维数值型数组的应用" class="headerlink" title="2. 一维数值型数组的应用"></a>2. 一维数值型数组的应用</h2><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p><strong>排序</strong> 是十分常见的可以用数组解决的问题之一，在本篇博文中，仅仅展示出一个基本的方法—— <strong>冒泡排序</strong> 。</p><p><strong>冒泡排序</strong> 的基本思路是运用嵌套for循环对数组进行操作，每一轮循环都将最大的数挪到数组后方相应位置。</p><p>这里给出参考代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]是需要排序的数组，n是数组的大小</span>   <span class="token keyword">int</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span>n<span class="token operator">-</span>i1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">>=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> m<span class="token punctuation">;</span>  <span class="token comment">//m是个临时变量</span>            m<span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>m<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token comment">//如果前一个元素大于（等于）后一个元素，则将两个元素交换</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">//排序完成，如需输出：</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要标注的是，关于排序还有不少改进方法，如 <strong>选择排序</strong> ， <strong>插入排序</strong> 等，在后面的进阶训练篇章中会有提及。</p><h3 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h3><p><strong>查找</strong> 即在数组中寻找某个元素</p><h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><p>线性查找的思路是最简单的，即从头到尾全过一遍，找到相应元素便返回。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]为要进行查找的数组，n为数组大小，goal为要查找的元素</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>         count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> count<span class="token punctuation">;</span>   <span class="token comment">//数组中每个等于goal的元素下标均输出，并返回出现次数（count）</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，这种查找方法在数组已经排好序的情况下是效率较低的。这样就衍生出了另一种查找方法—— <strong>折半查找</strong> 。</p><p>同样的，在后续进阶文章中会提及。</p><h3 id="插入，删除问题"><a href="#插入，删除问题" class="headerlink" title="插入，删除问题"></a>插入，删除问题</h3><p>插入，删除的操作方法相比于查找就多了一步，因此此处不再详细阐述，给出思路。</p><p>插入：<br>找到插入位置-&gt;将后面的元素全部往后挪一位-&gt;将要插入的元素放进去</p><p>删除：<br>找到要删除的元素-&gt;将后面的元素往前挪一位</p><h2 id="3-字符数组-x2F-字符串"><a href="#3-字符数组-x2F-字符串" class="headerlink" title="3. 字符数组 &#x2F; 字符串"></a>3. 字符数组 &#x2F; 字符串</h2><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>顾名思义， <strong>字符串常量</strong> 即由一连串字符组成的常量。<br>在C语言中规定： <strong>\0</strong> 是字符串结尾的标志。<br>即：如果定义了一个内容为”C programming”的字符串，那它在存储空间内的存储方式为：”C programming\0”</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p><strong>字符数组</strong> 可以用来存储字符串。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>与其他数组定义方式相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> array<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：定义字符数组时需要考虑”\0”占据的一个大小。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化字符数组有多种方法。</p><ol><li><p>逐个字符赋值：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> task<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'p'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//其中未声明初始值的元素会自动赋值为 '\0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>直接定义字符串常量：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"That's a string"</span><span class="token punctuation">;</span><span class="token comment">//未定义初始大小的字符串常量会自动设定其大小为链长+1（用于存储 \0）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这种方法只能用于初始化，不能用于赋值。</p></li></ol><h4 id="输入-x2F-输出"><a href="#输入-x2F-输出" class="headerlink" title="输入&#x2F;输出"></a>输入&#x2F;输出</h4><p>C语言中的scanf（visual studio中为scanf_s）以及printf函数为字符串设定了单独的输入输出格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但很遗憾，由于scanf的限制，这样的输入不适用于列中带有空格的字符串。因为scanf遇到空格会中止。</p><p>因此，以下部分引入新的标准库&lt;string.h&gt;</p><h3 id="lt-string-h-gt-概述"><a href="#lt-string-h-gt-概述" class="headerlink" title="&lt;string.h&gt;概述"></a>&lt;string.h&gt;概述</h3><p>在C语言中，涉及到字符串，这个标准库几乎是逃不过去的，因为其中涉及到了许多很好用的操作字符串的函数。</p><h4 id="字符串输入函数-gets"><a href="#字符串输入函数-gets" class="headerlink" title="字符串输入函数 gets"></a>字符串输入函数 gets</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数遇到空格不会终止，当遇到回车时会中止输入，并自动在最后多赋值一个 \0</p><h4 id="字符串输出函数-puts"><a href="#字符串输出函数-puts" class="headerlink" title="字符串输出函数 puts"></a>字符串输出函数 puts</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会输出括号中的字符串，并在最后自动加上回车。</p><h4 id="字符串长度函数-strlen"><a href="#字符串长度函数-strlen" class="headerlink" title="字符串长度函数 strlen"></a>字符串长度函数 strlen</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"I'm editing a blog"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会自动计算括号内字符串的实际长度。（不含 \0）</p><h4 id="字符串复制函数-strcpy"><a href="#字符串复制函数-strcpy" class="headerlink" title="字符串复制函数 strcpy"></a>字符串复制函数 strcpy</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> <span class="token string">"blog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容复制到前面的字符串中。<br>需要注意的是前面的字符串需要够大来容纳后面的字符串。</p><h4 id="字符串比较函数-strcmp"><a href="#字符串比较函数-strcmp" class="headerlink" title="字符串比较函数 strcmp"></a>字符串比较函数 strcmp</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Shanghai"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出一个非0的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数会比较前后两字符串的值，相同则输出0，不相同则输出非0；</p><h4 id="字符串连接函数-strcat"><a href="#字符串连接函数-strcat" class="headerlink" title="字符串连接函数 strcat"></a>字符串连接函数 strcat</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Programming"</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"c language"</span><span class="token punctuation">;</span><span class="token function">strcat</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将str2的内容接到str后面</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容接到前面的字符串后面。</p><h3 id="一点补充"><a href="#一点补充" class="headerlink" title="一点补充"></a>一点补充</h3><p>字符串的操作方法十分繁杂，包括最简单的gets，puts函数的各种变体也有很多，在这里不过多赘述，在后面的文章中还会相应提及。</p><h2 id="4-二维数组"><a href="#4-二维数组" class="headerlink" title="4. 二维数组"></a>4. 二维数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述方式表示定义一个5*5的二维数组。</p><h3 id="赋值-x2F-使用"><a href="#赋值-x2F-使用" class="headerlink" title="赋值&#x2F;使用"></a>赋值&#x2F;使用</h3><p>二维数组的赋值常用两个for循环嵌套进行</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若二维数组作为函数参数使用，则需要使用如下格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//二维数组前面的一维长度不需要给出，但后面的二维长度必须给出</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上，关于数组的一些基本概念已经梳理完毕了。</p><p>下一章的指针，相对而言更加复杂，理解难度也更高，但归根结底与数组的原理极其相似，熟练应用后指针反而更加灵活。 <del>（虽然我现在还不能熟练应用）</del></p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.4</title>
      <link href="/posts/33667.html"/>
      <url>/posts/33667.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-函数概述"><a href="#1-函数概述" class="headerlink" title="1. 函数概述"></a>1. 函数概述</h2><p><strong>函数</strong> 是C语言中的基本单位，具体表现为一段代码，可重复使用从而实现某种功能。</p><p>在C语言的源文件中，仅能存在一个 <strong>main函数</strong> （程序入口）以及多个子函数（名称可自定）</p><p>注：C语言不允许函数的嵌套定义，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token function">function2</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此类函数定义方式是不被允许的。</p><h2 id="2-函数的定义，调用，声明"><a href="#2-函数的定义，调用，声明" class="headerlink" title="2. 函数的定义，调用，声明"></a>2. 函数的定义，调用，声明</h2><p>这里直接列举定义，调用以及声明的方法：</p><ol><li>定义：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">double</span> num<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>声明：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>调用：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> fact<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>几个要注意的点：</p><ol><li><p>函数的返回值类型必须与函数类型相同（第一个词写的啥返回啥）</p></li><li><p><strong>void</strong> 关键字可以指函数类型，此时函数无返回结果，也可用于描述参数，此时函数无参数。</p></li><li><p>关于实参与形参：<br>定义&#x2F;声明函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的a, b称为形参，函数执行完毕后即清除相应内存。</p><p>与此不同，调用函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> result<span class="token punctuation">;</span><span class="token keyword">double</span> n<span class="token operator">=</span><span class="token number">4.2</span><span class="token punctuation">;</span>result<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的m, n被称为实参。</p><p>在调用函数时，会将实参中的值自左向右传递给形参<br>（上例中即会先将m的值传给a，将n的值传给b）<br>此后再进行函数的下一步语句。</p><p>注意：实参传递给形参相应值是 <Font color=CornflowerBlue><em><strong>单向传递</strong></em> </Font></p></li><li><p>关于函数的结束：两种方法  </p><ol><li>执行完最后一条语句</li><li>遇到了return，返回了相应值</li></ol></li><li><p>一般而言，可以在主函数前定义相应函数并在主函数中进行调用，但如果想在主函数后定义相应函数，则需要在主函数前进行函数声明。</p></li><li><p>c语言中的函数允许多级调用（也叫嵌套调用）<br><strong>明确一点，只是允许多级调用，但不允许嵌套定义（在前面有提及）</strong></p></li></ol><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h2><p><strong>递归</strong> 指的是一个函数中存在调用自己本身这个函数的行为，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span>n<span class="token operator">+</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在fact函数中，若n!&#x3D;1，则会重复调用fact自身。</p><p><strong>一个特点：</strong><br> 递归可以转化为循环，但递归写法常常更加简洁，更加易读，相应的，递归的计算复杂度（不确定这个词是否准确）会更高，时间成本也会更高。<br>   举出一个比较合适的例子：斐波那契数列<br>   首先写出递归写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> result<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   然后再给出循环写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token keyword">long</span> f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> result<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span>f1<span class="token operator">+</span>f2<span class="token punctuation">;</span>      f1<span class="token operator">=</span>f2<span class="token punctuation">;</span>      f2<span class="token operator">=</span>result<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   明显看出，编辑时，循环写法涉及到的细节更多，包括for循环的数量问题，f1, f2, result等变量的重新赋值等，而递归写法编程难度要简单许多。</p><p>   但同时，也需要承认，在递归写法中，对许多量都需要进行重复运算，比如每算一次fibo(5)就要算一次fibo(4)和fibo(3)，但这时算fibo(4)则再次涉及到了fibo(3)的运算，这种运算量如果多次叠加，时间成本是很恐怖的。</p><p>综上，请在递归降低编程难度这一特点能够弥补上它自己本身的效率开销时，再进行递归算法的使用。</p><p>进一步的问题解决敬请期待C语言进阶训练篇章。 <del>（我直接挖坑）</del></p><h2 id="4-预编译"><a href="#4-预编译" class="headerlink" title="4. 预编译"></a>4. 预编译</h2><p>在本系列笔记的第二节中曾提及：预编译这一说法，这里给出详细说明。</p><p>预编译命令共三类：  </p><ol><li><p>文件引入</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一类编译命令还有一种写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"...（你自己的文件名）"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一种写法，是在系统头文件中寻找响应文件并引入，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>math<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二种写法，是现在编程文件所在目录下进行文件查找，若找不到，再到系统指定目录下寻找响应文件</p><p>无论如何，文件引入的根本目的是实现多文件编程，使得在这个编程文件中可以使用其他文件中所定义的函数。<br><Font color=cornflowerblue> <strong>其具体原理是用指定文件的内容代替相应的命令行</strong> </Font></p><p>这里存在一种简单易行的方法进行多文件编程，即将你的函数一并写到一个文件中，命名为&lt;file1.h&gt;，此后在需要使用函数的地方预编译： <strong>include &lt;file1.h&gt;</strong> 即可。</p><p>但当头文件有很多个时，会遇到另一个问题，参考如下例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件file1.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file2.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file3.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file4.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file5.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.3></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.4></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当出现必须要同时引用 file3 与 file4 时，会出现对 file1 与 file2 的重复引用（即引用了两次，会报错）<br>因此这里给出方法，在每个文件前都加上一行代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此代码代表本文件仅引用一次。</p></li><li><p>宏定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">name</span> <span class="token expression">maintext</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>宏定义的作用 <strong>maintext</strong> 来替换正文中出现的 <strong>name</strong><br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UD</span> <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">double</span></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>UD x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的UD x, y; 作用等同于unsigned double x, y;  </p><p>几个注意事项：</p><ol><li>宏定义后面没有引号，与文件引入相同。</li><li>宏定义是简单替换，会将maintext原封不动的替换到name的位置，容易造成计算方面的错误，因此不推荐频繁使用。</li></ol></li><li><p>条件编译</p><p>用于仅对c程序中的一部分进行编译，另一部分不编译。（通过if，else实现）<br>具体格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">expression1</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">expression2</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> </span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>局部&#x2F;全局变量</p><p><strong>局部变量</strong> 指的是在函数内定义的变量，仅仅能在函数内部生效。（包括主函数）<br>注意：在复合语句中定义的变量生效范围仅为该复合语句内部。</p><p><strong>全局变量</strong> 指的是在函数外定义的变量，作用范围从定义处到函数源文件结束。</p></li></ol><p>这里单开一块单独说明变量的问题。</p><h2 id="5-动态-x2F-静态储存变量"><a href="#5-动态-x2F-静态储存变量" class="headerlink" title="5. 动态&#x2F;静态储存变量"></a>5. 动态&#x2F;静态储存变量</h2><p>程序在内存的分布区域是有规划的，分为：</p><ol><li>程序区：存放用户代码</li><li>静态存储区：存放全局数据与静态数据（在程序执行完毕后再释放相应内存）</li><li>动态存储区：存放动态数据（在相应函数执行完毕后便释放对应内存区域）</li><li>寄存器（ <strong>CPU内</strong> ）：将某些用的很多的动态变量存入CPU相应的存储区域中，加快程序执行速度</li></ol><p>由此，可将变量按照存储方式分类：</p><ol><li><p>自动变量<br><strong>自动变量</strong> 存储在动态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">auto</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但由于auto关键字往往可省略，因此任何函数中的未加说明的变量定义均为自动变量。</p></li><li><p>静态变量<br><strong>静态变量</strong> 存储在静态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量在函数执行完毕后将不会被销毁，并会在后续对其进行操作时保留对其进行的改变。</p></li><li><p>寄存器变量<br><strong>寄存器变量</strong> 存储在寄存器中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">register</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几个要注意的要点：  </p><ol><li>只有动态变量可以作为寄存器变量</li><li>寄存器变量不能无限定义，因为寄存器数目有限</li></ol></li><li><p>全局变量<br><strong>全局变量</strong> 存储在静态存储区中，定义方式为在函数外部进行相应定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>extern可以通过在多文件编程中进行使用，但是在另一个文件中使用本文件的全局变量时需要加上extern前缀说明。<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件A的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//这是文件B的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>     <span class="token comment">//x存在，但是定义在别的地方</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>需要注意的是，全局变量、静态变量的使用会降低程序可读性，增加编程复杂度，故请适量使用。</p><p>此外，添加一点补充：  </p><ol><li><p>在嵌套作用域中出现同名变量名定义时，内层作用域的同名变量在这其中会遮盖外层变量。<br>这里浅举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">5</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很明显，在内部作用域中b被重新定义的b&#x3D;2覆盖，当执行完毕后b的值重新变回5。</p></li><li><p>需要注意，多个源文件中不能有重名的全局变量，否则在某一个文件中对全局变量进行引用时会出现链接问题</p></li><li><p>C语言中的常量定义：</p><ol><li>enum<br><strong>enum</strong> 代表枚举常量，仅能定义整数常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>N<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> M<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这样定义出的常量在函数编译过程中值不会改变</li><li>const<br><strong>const</strong> 代表常量，可以定义各种常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> m<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">long</span> r<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>同样，这样定义出的常量在函数编译过程中值不会改变</li></ol></li></ol><p>至此，函数以及各类预编译事项便具体说明完毕。</p><p>接下来就是一些比较复杂的数据处理了，如数组，指针等。</p><p>这篇博文先到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.3</title>
      <link href="/posts/16834.html"/>
      <url>/posts/16834.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><h2 id="1-三种基本结构"><a href="#1-三种基本结构" class="headerlink" title="1. 三种基本结构"></a>1. 三种基本结构</h2><ol><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ol><h2 id="2-关系，逻辑，条件的相关语句"><a href="#2-关系，逻辑，条件的相关语句" class="headerlink" title="2. 关系，逻辑，条件的相关语句"></a>2. 关系，逻辑，条件的相关语句</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>六个： <strong>&lt; &lt;&#x3D; &#x3D;&#x3D; &gt; &gt;&#x3D;</strong><br><strong>注：在C语言中，&#x3D;&#x3D;表示相等，&#x3D;表示赋值，勿混淆</strong></p><h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>在C语言中，用 <strong>1</strong> 表示表达式为真，用 <strong>0</strong> 表示表达式为假<br>如：  </p><ol><li>表达式： <strong>8&gt;4</strong> 为真，值为1</li><li>表达式： <strong>0&#x3D;&#x3D;1</strong> 为假，值为0</li></ol><p>这里引入一种语句： <strong>条件运算符</strong><br>写为：？：<br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述语句表示：<br>若a&gt;b，则x&#x3D;a，反之，则x&#x3D;b</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>三个： <strong>! &amp;&amp; ||</strong><br>分别表示：非，与，或</p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>对于 ! 表达式，会对该表达式求值，以该值的否定为结果<br>对于 &amp;&amp; 表达式，会对两侧表达式分别求值，只有两侧表达式值均为1时，整个表达式值才为1，否则均为0<br>对于 || 表达式，会对两侧表达式分别求值，只有两侧表达式值均为0时，整个表达式值才为0，否则均为1</p><h3 id="短路特性（重点关注）"><a href="#短路特性（重点关注）" class="headerlink" title="短路特性（重点关注）"></a>短路特性（重点关注）</h3><p>逻辑表达式求值时，只有系统判定必须计算下一个运算符才能得出表达式的值时，才会进行计算 <del>（多绕的慌啊）</del></p><p>举个例子：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">&amp;&amp;</span> b <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当上述例子输入时，第一个数值（即a的值）输入0时，则不会计算b &amp;&amp; c这一部分的值，而会直接将x的值赋值为0</p><h2 id="3-顺序结构程序设计"><a href="#3-顺序结构程序设计" class="headerlink" title="3. 顺序结构程序设计"></a>3. 顺序结构程序设计</h2><p><em><strong>自上而下，逐行运行</strong></em></p><p>主要由以下部分组成：</p><ol><li>赋值语句</li><li>复合语句</li><li>函数调用语句</li></ol><p><em>赋值，函数调用在前面的章节已经有过叙述，这里仅对复合语句做简要说明</em></p><p>复合语句指一组语句，可以由 <strong>{}</strong> 框在中间</p><h2 id="4-选择结构程序设计"><a href="#4-选择结构程序设计" class="headerlink" title="4. 选择结构程序设计"></a>4. 选择结构程序设计</h2><p>选择结构需要利用此前的关系，逻辑表达式来阐述条件</p><p>两种常用语句： <strong>if ; switch</strong></p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>有三种形式：  </p><ol><li>if：条件成立后执行</li><li>if-else：条件成立则执行if后的语句，反之则执行else后的语句</li><li>else-if：用于增加if-else中的条件个数</li></ol><p>最完备的一种情况：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">(</span>条件n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><em>用于实现多分支选择结构</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> E1<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> E2<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">default</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，通过对variable（即变量）的值进行判断从而决定要执行的语句<br>当variable&#x3D;&#x3D;E1时，执行case E1中的语句<br>后续同理<br>如果variable的值不等于其中的任意一个case，则执行default中的语句</p><p><strong>注</strong>：  </p><ol><li>执行语句时，只有遇到 <strong>break</strong> 或 <strong>}</strong> 才会终止，故这里推荐在每一个case后均加上break</li><li>default并不是必须的，如果不加default，则variable不符合要求时不会执行任何语句</li><li>variable不仅仅可以是数值，也可以是字符形式</li></ol><h2 id="5-循环程序结构设计"><a href="#5-循环程序结构设计" class="headerlink" title="5. 循环程序结构设计"></a>5. 循环程序结构设计</h2><p>与选择结构类似地，同样需要利用关系、逻辑表达式进行条件的阐述</p><p>常用语句： <strong>while ; for ; do-while</strong></p><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即：当condition为真（即condition非零）时，执行while内语句，执行完毕后重新判断condition，直至condition为假</p><p><strong>注</strong>：<br>当执行语句时遇到诸如 <strong>break ; return ; goto</strong> 之类的语句时，会跳出while循环</p><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>expr1 <span class="token punctuation">;</span> expr2 <span class="token punctuation">;</span> expr3<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要做出一点说明：  </p><ol><li><strong>expr1</strong> 表示初始条件</li><li><strong>expr2</strong> 表示需要满足的条件</li><li><strong>expr3</strong> 表示每次执行完一次语句后要做出的改变</li></ol><p>给出一例方便理解：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句表示：i 的初始值为0；每次执行完语句后 i 自增1，直到 i 大于五十时结束循环</p><p><strong>注</strong>：  </p><ol><li>for结构中每个表达式都可以省略，但分号不可省略</li><li>for结构和while结构可以互相转化，下属while语句与上述for语句等价<pre class="line-numbers language-c" data-language="c"><code class="language-c">expr1<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>expr2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> expr3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>特殊语句同样可以跳出for循环，如 <strong>break ; goto ; return</strong> 等</li></ol><h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与 while 的区别在于这种语句会先将语句执行一遍再判断</p><h3 id="循环中的常见问题"><a href="#循环中的常见问题" class="headerlink" title="循环中的常见问题"></a>循环中的常见问题</h3><ol><li>循环可以相互嵌套，但一般不超过三层（会极大降低运行效率）</li><li>一般不用浮点数对循环进行控制，原因是浮点数存在误差，容易增减循环次数</li></ol><p>以上</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈《阿凡达2：水之道》</title>
      <link href="/posts/54708.html"/>
      <url>/posts/54708.html</url>
      
        <content type="html"><![CDATA[<p><em>阅前提醒：本片博文是在博主仅仅对阿凡达1的剧情略知一二的情形下的观影体验，文章中的观点难免有失偏颇，仅代表个人看法</em></p><blockquote><p><strong>阿凡达2：一部“徒有其表”的科幻作品</strong></p></blockquote><h2 id="剧情梗概"><a href="#剧情梗概" class="headerlink" title="剧情梗概"></a>剧情梗概</h2><blockquote><p>博主的梗概极其简略，肯定无法将电影中的细节进行呈现，这里还请读者有兴趣的话自行观看</p></blockquote><p>阿凡达2采用了一个非常“合家欢”的剧本</p><p>几个基本设定：  </p><ol><li>故事发生的星球叫做：潘多拉星</li><li>该星球上存在着名为“纳美”的原始土著</li><li>纳美人与潘多拉星的自然环境有着一种天然的“联系”，能使他们免遭人类的追捕</li><li>人类通过将自己的记忆转移至阿凡达体内，可以防止自己被潘多拉星的自然环境所针对</li></ol><p>本作剧情：<br>男主在变为纳美族后，了解到人类要取自己性命，为了不拖累自己的森林部族，便主动禅让，并与其家人一同离开森林部族，前往海洋部族，寻求其庇护。<br>在海洋部族的时段，男主学习了海洋部族的各类技能，但仍旧无法逃过人类的追捕，自己的孩子以及海洋部族首领的孩子均被人类所绑架，以此要挟男主主动投降。<br>最终男主在海洋部族及自然的帮助下，击退了前来追杀自己的人类队伍。</p><p>对，在我的眼中这部电影中真正可以说是 <strong>剧情相关</strong> 的部分就这么多，但就是这些内容，居然能拍了长达 <strong>三小时</strong> ？！</p><h2 id="一些亮点"><a href="#一些亮点" class="headerlink" title="一些亮点"></a>一些亮点</h2><p>咱先谈谈这部电影哪里好</p><h3 id="画面，音乐，特效"><a href="#画面，音乐，特效" class="headerlink" title="画面，音乐，特效"></a>画面，音乐，特效</h3><p>可以承认的是，这部电影在这些基础层面，可以说的上是好好学生了，这一系列的基本功打的极其扎实。画面上，很干净，很透亮，对于一部“水战”的主题电影，这是一个很好的加分项；音乐上，至少头一次看，不会有很大的违和感，该起该落，情感把控都还算可以；特效上，阿凡达1就是凭这个打出名声的，不多赘述</p><h3 id="运镜！"><a href="#运镜！" class="headerlink" title="运镜！"></a>运镜！</h3><p>这点我一定得夸一下，这部电影的运镜节奏非常合适，它不会像某些科幻片一样让你感觉到一种“看不过来”的感觉，也不会显得过于拖沓，这带来的观影效果提升确实很明显</p><h2 id="吐槽-（正片开始）"><a href="#吐槽-（正片开始）" class="headerlink" title="吐槽 （正片开始）"></a>吐槽 <del>（正片开始）</del></h2><p>好了，该夸的夸完了，现在该骂一骂了</p><h3 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h3><p>首先从我认为最无法理解的地方说起<br>2022年的 <strong>“科幻巨制”</strong> ，却给我看出了一股子儿女情长，并肩加上一些环境保护的“陈词滥调”，我觉得多少有些无聊了吧</p><p>我可以接受电影以“家庭”，“环境”为主旨，但我不认可为了这所谓的主旨而把剧情的合理性抛之脑后的做法</p><p>我认为本作的不合理处包括并不限于：</p><ol><li>男主明知 <em>人类想要掠夺整个潘多拉星，他自己仅仅是个导火索</em> 的事实，却仍然选择逃窜到另一个部族</li><li>在人类已然找上门时，男主仍在坚守自己“忍一时风平浪静”的岁月静好思想</li><li>在男主终于打算前往一战时，海洋部族仅仅是开场露了个面，此后便在整场决战中 <strong>“销声匿迹”</strong> 了</li></ol><h3 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h3><p>其次，说说这个剧情带来的副作用——整个影片的剧情发展拖沓的令人发指</p><p>不同于此前所提及的“运镜”相关的节奏恰当，本片的剧情进展十分缓慢，依我看来，这部电影的主线完全可以在2小时内结束，能拖到3小时的原因在于影片中存在许多“不必要”的铺垫</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>很多细节上的处理完全为主线服务，而完全忽视了与背景的契合度</p><p>在此略举几例：<br>在太空时代，科技领先潘多拉星多少倍的人类，时至如今，其飞行器的前窗仍然能被纳美人一箭射穿。<br>以及科技如此发达的人类社会，在绑架男主几个孩子时，“固执”地使用 <strong>皮带</strong> 将几个孩子拷在船上，在男主初次成功救出部分人质后，仍然“执拗”地使用 <em><strong>皮带</strong></em> 将剩余人质拷在船上。 <del>（好家伙你搁这玩梅开二度呢？）</del></p><p>无力吐槽。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>阿凡达2的基础是好的，甚至可以说是杰出的，但抵不过剧情，细节上的硬伤带来的观感下降</p><p>如果奔着画面和特效所带来的震撼，可以尝试<br>如果奔着剧情去，大可不必了</p><p>本篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Movies </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.2</title>
      <link href="/posts/5828.html"/>
      <url>/posts/5828.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计初步"><a href="#程序设计初步" class="headerlink" title="程序设计初步"></a>程序设计初步</h1><h2 id="1-程序的基本结构"><a href="#1-程序的基本结构" class="headerlink" title="1.程序的基本结构"></a>1.程序的基本结构</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><Font color=CornflowerBlue> <em><strong>函数</strong></em> </Font> 是C语言程序的基本单位<br>函数以 <strong>{}</strong> 为开始&#x2F;结束标志<br>作为一个程序，必须有一个主函数，即 <strong>main</strong> 函数<br>每个函数由语句构成，每个语句以 <strong>；</strong> 结尾</p><h3 id="预编译命令"><a href="#预编译命令" class="headerlink" title="预编译命令"></a>预编译命令</h3><p>每个C语言程序都含有预编译命令<br>预编译命令有三类：  </p><ol><li>宏定义  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define PI 3.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>文件引入  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>条件编译 <del>（我没用过）</del><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释在程序的编译与运行中均不起作用，仅仅增加程序可读性<br>具体格式:  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;这是一条注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><h3 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h3><p>C语言源程序只能存在基本字符，否则无法通过编译<br>基本字符包括：  </p><ol><li>大小写字母</li><li>数字</li><li>其他的可显示字符</li><li>特殊字符</li></ol><p>注： <strong>程序中所有的字符（除了注释中的内容）必须是英文格式</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符用于标识程序中的名字，描述变量（其实就是你给函数或变量取的名）<br>分为三类：  </p><ol><li>用户自定义标识符</li><li>预定义标识符</li><li>关键字</li></ol><p>几个重要特征：</p><ol><li>标识符只能由 <strong>字母，数字及下划线</strong> 组成</li><li>标识符对大小写敏感</li></ol><p>关于关键字：<br>系统给其赋予了特定功能，不能用于其他目的<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intfloatdoublecharbreak...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><p>C语言中的数据区分类型</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>基本类型<ol><li>整形：int</li><li>字符型：char</li><li>浮点型：<ol><li>单精度浮点型：float</li><li>双精度浮点型：double</li></ol></li></ol></li><li>构造类型<ol><li>数组类型</li><li>结构体类型</li><li>共用体类型</li><li>枚举类型</li></ol></li><li>指针类型</li><li>空类型</li></ol><p><strong>限于章节原因，本处仅对基本类型进行说明</strong></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="整形（int）"><a href="#整形（int）" class="headerlink" title="整形（int）"></a>整形（int）</h4><p>用于描述整数<br>取值范围：$-2^{31}$~$2^{31}-1$</p><h4 id="浮点型（float，double）"><a href="#浮点型（float，double）" class="headerlink" title="浮点型（float，double）"></a>浮点型（float，double）</h4><p>用于描述实数<br>其中 <strong>float</strong> 与 <strong>double</strong> 的区别在于前者精度更低，占用内存也更小<br><em><strong>由于计算机以指数形式存储浮点型，因此存在误差</strong></em></p><h4 id="字符型（char）"><a href="#字符型（char）" class="headerlink" title="字符型（char）"></a>字符型（char）</h4><p>用于存储单个字符信息<br>存储的是对应字符的 <strong>ASCⅡ码</strong><br>在此举一例：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;%c&quot;, 63);printf(&quot;%c&quot;, ?);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两条语句的输出结果应当都是字符 ‘ <strong>？</strong>’</p><h3 id="基本数据类型的扩充"><a href="#基本数据类型的扩充" class="headerlink" title="基本数据类型的扩充"></a>基本数据类型的扩充</h3><h4 id="短整型（short-int-x2F-short）"><a href="#短整型（short-int-x2F-short）" class="headerlink" title="短整型（short int &#x2F; short）"></a>短整型（short int &#x2F; short）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围更小，占用内存也更小<br>取值范围：$-2^{15}$~$2^{15}-1$</p><h4 id="长整型（long-int-x2F-long）"><a href="#长整型（long-int-x2F-long）" class="headerlink" title="长整型（long int &#x2F; long）"></a>长整型（long int &#x2F; long）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围大于等于int的范围，主要用于处理一些比较大的整数问题</p><h4 id="无数据类型（unsigned）"><a href="#无数据类型（unsigned）" class="headerlink" title="无数据类型（unsigned）"></a>无数据类型（unsigned）</h4><p><strong>unsigned</strong> 可以加在 <strong>int, short, long, char</strong> 的前面，取消其二进制数第一位表示符号的限制，因此unsigned类型只能表示正数</p><h3 id="变量-amp-常量"><a href="#变量-amp-常量" class="headerlink" title="变量 &amp; 常量"></a>变量 &amp; 常量</h3><p><em>顾名思义，变量在函数编译过程中可变，而常量不可变</em></p><p>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">double x &#x3D; 2.3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一语句中，x是被定义出来的变量，2.3是个常量</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>系统在编译过程中会为变量分配相应的内存空间，不同类型的变量被分配的空间不同</p><p>变量的定义：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;char c;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>变量的赋值：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;i &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>分类：</p><ol><li>整形常量</li><li>实型常量</li><li>字符型常量</li><li>字符串常量</li><li>符号常量</li></ol><h5 id="关于字符型常量参与计算"><a href="#关于字符型常量参与计算" class="headerlink" title="关于字符型常量参与计算"></a>关于字符型常量参与计算</h5><p>由于字符型常量存储的是相应字符的 <strong>ASCⅡ码</strong>，因此可以将其作为整形进行相应计算<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char c &#x3D; &#39;a&#39;;c &#x3D; c - 32;printf(&quot;%c&quot;, c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的输出结果应该是 ‘A’</p><h5 id="关于转义字符"><a href="#关于转义字符" class="headerlink" title="关于转义字符"></a>关于转义字符</h5><p>用转义字符表示 <strong>ASCⅡ码</strong> 中不可打印的功能性字符<br>如：换行表示为‘ <em><strong>\n</strong></em> ’, 制表（tab）表示为‘ <em><strong>\t</strong></em> ’, …</p><h5 id="关于字符串常量"><a href="#关于字符串常量" class="headerlink" title="关于字符串常量"></a>关于字符串常量</h5><p>字符串常量利用双引号括起来，可表示多个字符的集合<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&quot;Hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-数据的输入与输出"><a href="#4-数据的输入与输出" class="headerlink" title="4. 数据的输入与输出"></a>4. 数据的输入与输出</h2><h3 id="输出函数printf"><a href="#输出函数printf" class="headerlink" title="输出函数printf"></a>输出函数printf</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;格式控制串&quot;, 输出表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式控制串决定输出的数据类型，分别表示为：</p><ol><li><strong>%d</strong> -&gt; <strong>int</strong></li><li><strong>%f</strong> -&gt; <strong>float&#x2F;double</strong></li><li><strong>%c</strong> -&gt; <strong>char</strong></li><li><strong>%ld</strong> -&gt; <strong>long</strong></li><li><strong>%s</strong> -&gt; <strong>字符串</strong></li></ol><h3 id="输入函数scanf（在Visual-Studio中为scanf-s）"><a href="#输入函数scanf（在Visual-Studio中为scanf-s）" class="headerlink" title="输入函数scanf（在Visual Studio中为scanf_s）"></a>输入函数scanf（在Visual Studio中为scanf_s）</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">scanf(&quot;格式控制串&quot;, 地址表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：<br>格式控制串与printf大抵相同，但是这里将 <strong>double</strong> 的格式控制串更改为了 <strong>%lf</strong><br>同时后面的地址表列为地址，故需要在变量前加上取地址符号 <strong>&amp;</strong></p><h3 id="字符型数据的输入与输出"><a href="#字符型数据的输入与输出" class="headerlink" title="字符型数据的输入与输出"></a>字符型数据的输入与输出</h3><p>C语言为字符型数据设定了新的输入方式（ <strong>getchar</strong> ）与新的输出方式（ <strong>putchar</strong> ）<br>格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-运算符与表达式"><a href="#5-运算符与表达式" class="headerlink" title="5.运算符与表达式"></a>5.运算符与表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是C语言中表示相应运算的特殊符号<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="运算符表"></p><p>关于运算符的运算顺序与层级，博主认为依靠个人的编程经验与计算习惯可以判断，故这里不再详述。</p><p>几点提示：  </p><ol><li>C语言中整形除以整形得出的数字还是整形，如：  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这个语句的输出应当是1</li><li><strong>size of</strong> 是个运算符，不是个函数，要记牢</li><li>自增（减）时，如果符号在前，就先加减，再运算，反之，若符号在后，就先运算，再加减</li><li>关于 <strong>+，*，%</strong> 与 <strong>&#x3D;</strong> 的连用： <pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>等价于：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>上述法则对于 *，%同样适用，不再赘述</li></ol><h2 id="6-数据类型的转换"><a href="#6-数据类型的转换" class="headerlink" title="6.数据类型的转换"></a>6.数据类型的转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>在运算时，如果程序识别到两个不同类型的数据进行运算，会以 <em><strong>向高看齐</strong></em> 的原则进行格式转换<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E5%90%91%E9%AB%98%E7%9C%8B%E9%BD%90.png" alt="向高看齐"></p><p>注意：此时可能会出现数值溢出的问题，通常警告为：</p><pre class="line-numbers language-none"><code class="language-none">warning: overflow in implicit constant conversion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在编程过程中，如果需要令一个变量以另一个数据类型参与运算，可以采用强制类型转换的方式，具体格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>i <span class="token operator">+</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，上述过程中对原本为整形的 i 进行了强制类型转换，将其转换为 double 类型参与运算</p><p>需要注意的是，强制类型转换后，被转换的变量类型是不变的，即 i 仍然是int型变量</p><h2 id="7-数学函数"><a href="#7-数学函数" class="headerlink" title="7.数学函数"></a>7.数学函数</h2><p>在C语言中有相应的对各种数学函数进行定义的库： <strong>&lt;math.h&gt;</strong><br>在需要使用时，在函数前进行相应的预编译即可</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/math.h.png" alt="math.h中的常用函数"></p><p>以上，是编程前需要了解的一些知识</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.1</title>
      <link href="/posts/32835.html"/>
      <url>/posts/32835.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计概述"><a href="#程序设计概述" class="headerlink" title="程序设计概述"></a>程序设计概述</h1><h2 id="1-程序设计语言"><a href="#1-程序设计语言" class="headerlink" title="1.程序设计语言"></a>1.程序设计语言</h2><p><em>计算机语言：计算机能够接受和处理的具有一定格式的语言</em>  </p><h3 id="发展历程："><a href="#发展历程：" class="headerlink" title="发展历程："></a>发展历程：</h3><ol><li>机器语言：二进制</li><li>汇编语言：少许助记符号</li><li>高级语言：  <ol><li>面向过程：Basic， C等</li><li>面向对象：Java， C++等</li></ol></li></ol><h2 id="2-程序设计基本概念"><a href="#2-程序设计基本概念" class="headerlink" title="2.程序设计基本概念"></a>2.程序设计基本概念</h2><h3 id="五部曲：（我自己起的）"><a href="#五部曲：（我自己起的）" class="headerlink" title="五部曲：（我自己起的）"></a>五部曲：<del>（我自己起的）</del></h3><ol><li>分析</li><li>确定算法</li><li>编程</li><li>调试</li><li>优化、改进</li></ol><h3 id="程序-x3D-数据结构-算法"><a href="#程序-x3D-数据结构-算法" class="headerlink" title=" 程序 &#x3D; 数据结构 + 算法 "></a><Font color=CornflowerBlue> <em><strong>程序 &#x3D; 数据结构 + 算法</strong></em> </Font></h3><h3 id="算法的特性："><a href="#算法的特性：" class="headerlink" title="算法的特性："></a>算法的特性：</h3><ol><li>有穷性：有终点</li><li>确定性：定义清晰</li><li>有零个或多个输入</li><li>至少有一个输出</li><li>可行性：每一步都得可行</li></ol><h3 id="如何描述算法？"><a href="#如何描述算法？" class="headerlink" title="如何描述算法？"></a>如何描述算法？</h3><ol><li><em><strong>流程图</strong></em> ：最常用的方法</li><li>结构流程图：<del>我没用过</del></li><li>伪代码：对相应代码块进行简写</li></ol><p>关于流程图的图例：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.1/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%9B%BE%E4%BE%8B.png" alt="流程图图例"></p><h2 id="3-结构化程序设计"><a href="#3-结构化程序设计" class="headerlink" title="3.结构化程序设计"></a>3.结构化程序设计</h2><p><em>顾名思义，将“程序设计”这个流程结构化，标准化</em></p><h3 id="三种基本结构"><a href="#三种基本结构" class="headerlink" title="三种基本结构"></a>三种基本结构</h3><ol><li>顺序：循序渐进</li><li>选择：涉及到判断，选择支线 <del>（不要介意这个游戏内常见的用语）</del></li><li>循环：涉及到判断，并是否返回执行</li></ol><h2 id="4-程序的实现环境"><a href="#4-程序的实现环境" class="headerlink" title="4.程序的实现环境"></a>4.程序的实现环境</h2><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><ol><li>输入设备</li><li>输出设备</li><li>外存&amp;内存</li><li>CPU：<ol><li>运算器</li><li>控制器</li></ol></li></ol><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><ol><li>操作系统</li><li>编辑程序</li><li>编译程序</li><li>连接程序</li></ol><h3 id="一些解释："><a href="#一些解释：" class="headerlink" title="一些解释："></a>一些解释：</h3><p>用高级语言编写出来的文件叫做 <strong>源程序</strong> ，不能直接执行<br>因此，需要先将其转换为可执行程序，这一过程称为 <strong>C程序的加工</strong><br>C程序的加工分为两步：  </p><ol><li>编译：具体表现为将 <em><strong>.c</strong></em> 程序转换为 <em><strong>.obj</strong></em> 程序</li><li>链接：将 <em><strong>.obj</strong></em> 程序与其他目标程序&#x2F;库装配，形成 <em><strong>.exe</strong></em>文件</li></ol><p>后续过程中如果涉及到编程，博主会以 <em><strong>Visual Studio 2022</strong></em> 为运行环境</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博第一篇</title>
      <link href="/posts/32455.html"/>
      <url>/posts/32455.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h2><p>这个博客来源于博主的一时兴起。</p><p>想发点啥但没有很系统的方法，之后发现了个人博客是个挺自在的地方，故就这样了。</p><h2 id="关于博客的内容"><a href="#关于博客的内容" class="headerlink" title="关于博客的内容"></a>关于博客的内容</h2><p>初步确定为进行个人学习笔记的整理，以及各种博主想说的（包括但不限于各种评价，各种想法…）</p><h2 id="后续更新计划"><a href="#后续更新计划" class="headerlink" title="后续更新计划"></a>后续更新计划</h2><p>· 博客的美化工作，会持续，长期进行</p><p>· 各类二级界面的创建与完善</p><p>· 后续内容的持续跟进…</p><p>目前就这些啦~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客的搭建流程</title>
      <link href="/posts/23043.html"/>
      <url>/posts/23043.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建流程概述"><a href="#搭建流程概述" class="headerlink" title="搭建流程概述"></a>搭建流程概述</h2><h3 id="Step-1：Nodejs的下载及配置"><a href="#Step-1：Nodejs的下载及配置" class="headerlink" title="Step 1：Nodejs的下载及配置"></a>Step 1：Nodejs的下载及配置</h3><p><em>本博客是以Hexo为基本框架，以Github Page为雏形的个人博客，而在Windows上装载Hexo的最佳方法是通过Git（一个应用，内置了Linux的些许命令）从Github上克隆相应仓库，同时Hexo的运行需要Nodejs所提供的环境</em></p><p>首先前往Nodejs官网：<strong>nodejs.org</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Nodejs.png" alt="Nodejs官网"></p><p>这边我选择的是左边的18.12.1版本，相对来说比较稳定<br>安装过程很简单，按照默认配置来就可以<del>（无脑下一步）</del></p><p>此后会涉及到两个环境变量的配置：<br>这里附上一篇博文，我觉得人家讲的比我清楚<del>（水平有限，见谅）</del>  </p><blockquote><p><a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>注：下载完后可以通过cmd（快捷键Ctrl+X，选中其中的 <strong>终端(管理员)</strong> ）检验一下Nodejs是否成功下载并运行了，一并检查一下npm是否成功安装（npm是一个在安装Nodejs后自动给你附带安装的东西，后面会用到）<br>具体命令：</p><pre class="line-numbers language-none"><code class="language-none">&#123;node -v  npm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错才对</p><h3 id="Step-2-将npm更改为国内镜像源提供的cnpm"><a href="#Step-2-将npm更改为国内镜像源提供的cnpm" class="headerlink" title="Step 2: 将npm更改为国内镜像源提供的cnpm"></a>Step 2: 将npm更改为国内镜像源提供的cnpm</h3><p><em>本步骤的目的在于更换npm组件，由于原版npm在后续流程中极其容易报错，因此本步骤至少在博主创建博客时是必要的</em></p><p>命令为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤需要等待一段时间（安装耗时）</p><p>等待其安装完成后，分别输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm  cnpm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错</p><p><strong>注：本步骤中博主遇到了报错情况，提示为：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm : 无法加载文件 D:\nodejs\node_global\cnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，可以通过命令解除限制：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Set-ExecutionPolicy RemoteSigned -Scope Process&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解除限制后再次输入cnpm相关命令即可</p><h3 id="Step-3-正式安装Hexo（主角登场）"><a href="#Step-3-正式安装Hexo（主角登场）" class="headerlink" title="Step 3: 正式安装Hexo（主角登场）"></a>Step 3: 正式安装Hexo<del>（主角登场）</del></h3><p><em>上文有提到，本博客以Hexo为基本框架</em></p><p>仍然是在cmd中，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install -g hexo-cli&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待其安装成功后，再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若没报错，说明安装成功</p><h3 id="Step-4-下载Git"><a href="#Step-4-下载Git" class="headerlink" title="Step 4: 下载Git"></a>Step 4: 下载Git</h3><p><em>上文有提到，通过Git可以有效装载运行Hexo，并与相关的Github仓库进行配套使用</em></p><p>前往Git官网：<strong><a href="https://git-scm.com/">https://git-scm.com/</a></strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Git.png" alt="Git官网"></p><p>博主采用的是2.39.0版本</p><p>同样的，下载，安装<del>（无脑下一步）</del></p><p>接下来仍然涉及到一个环境变量的设置：<br>把刚刚Git安装目录下的bin文件夹打开，复制相应的文件路径，将其添加到<strong>环境变量-系统变量-Path</strong>里面</p><h3 id="Step-5：新建一个用于操作你的博客的文件夹"><a href="#Step-5：新建一个用于操作你的博客的文件夹" class="headerlink" title="Step 5：新建一个用于操作你的博客的文件夹"></a>Step 5：新建一个用于操作你的博客的文件夹</h3><p><em>接下来就是正式的博客搭建环节</em></p><p>在你的电脑中随意一个位置（你得能记住奥）创建一个新文件夹，取名Blog<br>此后点进那个文件夹，右键空白处，点击<strong>Git Bash Here</strong><br>这时应该会出现一个黑框，像这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/gitbash.png" alt="Git控制台界面"></p><p>在其中输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo init&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里大概率会出现两个问题：<br>（1）显示经过多少多少毫秒之后连接错误<br>（2）显示无法成功安装，让你人工输入<em>npm install</em></p><p>如果是第一个错误，请你给git挂上代理（自行搜索）<br>如果是第二个错误，这时候之前做的就有用了，这时直接输入<em>npm install</em>大概率会报错，所以我们输入:</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果没有报错，就大概率成了，这时候看向你的Blog文件夹，如果有一个叫<em>node_modules</em>的文件夹，就可以放心进行下一步了</p><h3 id="Step-6-尝试第一次启动本地服务器"><a href="#Step-6-尝试第一次启动本地服务器" class="headerlink" title="Step 6: 尝试第一次启动本地服务器"></a>Step 6: 尝试第一次启动本地服务器</h3><p>在刚刚那个Git控制台中再次输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果显示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Hexo running at ______(这里是一个地址）_________, Press Ctrl+C to stop.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明成功了，现在在浏览器内打开那个地址，就可以看到一个初步的网页，上面有 <strong>Hexo</strong>标识</p><p>我们先Ctrl+C将其关闭</p><h3 id="Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接"><a href="#Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接" class="headerlink" title="Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接"></a>Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接</h3><p>这边需要你创建一个自己的Github账号<br>牢记你的注册邮箱以及用户名，密码</p><p>创建一个新的库（repository），将这个库的名字改为 <em><strong>你的账户名.github.io</strong></em>  (这一步很重要！)  </p><p>此后进行SSH与Github的绑定,这里还是给出链接  </p><blockquote><p><a href="https://blog.csdn.net/qq_35703954/article/details/87446876">https://blog.csdn.net/qq_35703954/article/details/87446876</a></p></blockquote><p>绑定成功后，需要对Blog文件夹中的一个文件进行些许更改<br>那个文件叫： <em><strong>_config.yml</strong></em></p><p>注：这个文件可以使用记事本打开，但是我强烈建议有需求的各位下载VScode打开这个文件，自行搜索就可以。</p><p>咱们继续：<br>打开后将文件翻到最后，有一个 <em><strong>deploy：…</strong></em> ，将deploy以下的部分全部删除，改为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;deploy:    type: git    repository: 你自己刚刚创建的GitHub的那个项目地址（下文会写如何查看）    branch: main&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>几个需要注意的点</strong></em><br>· 注意格式，deploy后面的内容是有缩进的，以及冒号后面的空格。<br>· 项目地址的查看方法：<br>前往你的GitHub相应项目中，右上角有一个 <em><strong>code</strong></em> 按钮，长这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code.png" alt="Code"><br>点击它，会出现这样的一个界面：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code-1.png" alt="点击Code之后的界面"><br>选中那个 <em><strong>HTTPS</strong></em>， 之后将底下的链接复制，粘贴至上面的 <em><strong>_config.yml</strong></em> 文件的repository后面</p><h3 id="Step-8-装载部署工具"><a href="#Step-8-装载部署工具" class="headerlink" title="Step 8: 装载部署工具"></a>Step 8: 装载部署工具</h3><p>还是 <em><strong>Blog</strong></em> 文件夹，还是右键 <strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install hexo-deployer-git --save&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待安装完成，之后输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待生成完成（不报错），之后再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这之后再输入你的库的名称（即 <em><strong>你的账户名.github.io</strong></em>）到浏览器地址栏中，应该就能看到刚刚那个有Hexo的界面了</p><h3 id="Step-9-编写博文"><a href="#Step-9-编写博文" class="headerlink" title="Step 9: 编写博文"></a>Step 9: 编写博文</h3><p><em><strong>Blog</strong></em>文件夹，右键，<strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo n 你想起的文章名&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后应该会出现一个提示，在你的 <em>source-_posts</em>文件夹内生成了一个markdown文件，这就是你撰写新博客的地方</p><p>注：这也是为什么我推荐安装vscode，因为vscode只需要安装两个插件就可以做到编写，预览Markdown文件，很方便（方法请自行搜索）</p><p>写完你的博文之后，保存，返回 <em><strong>blog</strong></em>文件夹，<strong>Git Bash Here</strong>，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo cl&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一套流程下来，你的博文就可以被成功上传到那个网页中</p><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><p>此次博客的搭建，从整体而言是相对繁琐的，同时中间掉了很多次坑，往往一个坑都得花费1-2个小时进行查询，修补，一套流程下来基本上花了有两天时间。</p><p>回过头来，再看这一整个流程，缺乏的就是一个整体框架，如果一股脑冲进去，会做着做着迷失了方向，就不知道该做什么了</p><p>故此，在这里整理下整套流程，供读者参考，更是供自己反思优化</p><p>关于美化，应该不会再整理步骤了，因为各种模板包里面都有详尽的使用说明，并且不同的模板操作方式不同，待读者自行探索了</p><p>这篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

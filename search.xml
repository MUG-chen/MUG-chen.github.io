<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Front-end(1)</title>
      <link href="/posts/15663.html"/>
      <url>/posts/15663.html</url>
      
        <content type="html"><![CDATA[<h1 id="Front-end-Design-1"><a href="#Front-end-Design-1" class="headerlink" title="Front-end Design(1)"></a>Front-end Design(1)</h1><blockquote><p>写在前面</p><p>本章节的产生原因在于博主需要参加的大创(全称: 大学生创新创业竞赛)项目需要相关的前端界面设计, 而博主恰好负责这一部分较多, 因此在此新开一坑, 衔接此前HTML&amp;CSS的章节, 并在此之上继续向前, 目的在于在博文的最后能够设计出一个较为完整的前端界面出来.</p></blockquote><h2 id="1-JavaScript-概述"><a href="#1-JavaScript-概述" class="headerlink" title="1. JavaScript 概述"></a>1. JavaScript 概述</h2><p>JS, 全称 JavaScript, 是一个使用十分广泛, 应用较广的 <strong>脚本语言</strong> , 被广泛运用在前端的设计上, 通过JS的种种 <strong>行为</strong> , 能够实现前端界面的动画, 以及一些较为合理的交互逻辑.</p><h3 id="1-1-ECMAScript-JavaScript"><a href="#1-1-ECMAScript-JavaScript" class="headerlink" title="1.1 ECMAScript &amp; JavaScript"></a>1.1 ECMAScript &amp; JavaScript</h3><p>通俗而言, ECMAScript(后文简称ES)是由国际组织(ECMA)指定的一个脚本语言规范, 而JavaScript(后文简称JS)是由Netscape公司开发的, 基于 ES 的脚本语言.</p><p>ES的广为流传的版本为ES6, 它于2015年发布.</p><h3 id="1-2-JS-语句-标识符"><a href="#1-2-JS-语句-标识符" class="headerlink" title="1.2 JS 语句 &#x2F; 标识符"></a>1.2 JS 语句 &#x2F; 标识符</h3><p>JS作为单独的脚本语言, 它有其自己的一套语法, 一套单独的规范.</p><p>JS的标识符可以容纳的字符包括 <strong>字母, 数字, 下划线, $</strong> 这四种, 数字不能用在标识符开头.</p><blockquote><p>除此之外, 其实中文也可以作为标识符, 但本文中不推荐这样做. 中文进入代码行中出现的各种编码问题, 适配问题已经能搞得博主焦头烂额了.</p></blockquote><p>除此之外, JS也有一套关键字, 类似于C中的 <strong>break, return, …</strong> , 它们有自己的作用, 因此不能作为单独的标识符使用. 这些关键字我们会在后文中的使用中慢慢引出, 读者在此大可不必过于在意.</p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>在JS中, 变量可以非常简单的利用统一的符号进行定义:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">></span>    <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>关于这个前后的&lt;script&gt;, 有HTML基础的读者应该看出这是个标签了, 确实, 由于JS的重要应用就是前端的设计, 因此常常需要插在HTML中进行书写, 具体方式即在相应的html文件中插入对应的标签即可. 后文会将这前后的标签省略, 还请读者记住这个事情.</p></blockquote><h4 id="1-3-1-变量的监视"><a href="#1-3-1-变量的监视" class="headerlink" title="1.3.1 变量的监视"></a>1.3.1 变量的监视</h4><p>但不同于C, Java的编译器提供的良好环境, 我们如何监视JS中的各种变量呢? 一个比较直接的方式是通过控制台显示出来.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过这样的语句, 我们可以通过浏览器中 <strong>检查-&gt;控制台</strong> 的界面查看变量的当前值.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/console.log.png" alt="Console.log"></p><h4 id="1-3-2-变量提升"><a href="#1-3-2-变量提升" class="headerlink" title="1.3.2 变量提升"></a>1.3.2 变量提升</h4><p>在JS中, 为了增加兼容性, 会将脚本中所有声明的变量提前至代码运行前优先声明.</p><p>这句话不是很好理解, 我们举个例子:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果以C语言输出的角度来看, 上面这段代码应当报错, 但实际上, 在浏览器中显示的状态:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.png" alt="变量提升"></p><p>相当于, 浏览器在运行这段脚本时, 其实相当于这样:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这即所谓变量提升的意义.</p><h3 id="1-4-JS的引入"><a href="#1-4-JS的引入" class="headerlink" title="1.4 JS的引入"></a>1.4 JS的引入</h3><p>与CSS类似, JS除开在HTML中单独书写外, 还可以通过外部文件引入的方式进行.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script type <span class="token operator">=</span> <span class="token string">"text/javascript"</span> src <span class="token operator">=</span> <span class="token string">"./my_first_js.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script src <span class="token operator">=</span> <span class="token string">"http://..."</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述内容分别代表了从本地引入js, 以及从网络外部连接引入js的方法.</p><h3 id="1-5-JS的注释"><a href="#1-5-JS的注释" class="headerlink" title="1.5 JS的注释"></a>1.5 JS的注释</h3><p>JS中的注释可以通过两种方式进行:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 这是一条注释</span><span class="token comment">/*这是一条多行注释*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>明确, 这种注释是只能在JS中进行的. 相对应, 读者别忘记HTML与CSS中的注释形式.</p><p>当然, 比较方便的快捷键是 <strong>Ctrl + &#x2F;</strong></p><h3 id="1-6-JS的输出"><a href="#1-6-JS的输出" class="headerlink" title="1.6 JS的输出"></a>1.6 JS的输出</h3><p>这里简要提供三种方式</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Method 1</span><span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">"This is Method 1."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Method 2</span>Document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"This is Method 2."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Method 3</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"This is Method 3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种方式以弹出框的形式来输出内容, 用户可见:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/%E5%BC%B9%E5%87%BA%E6%A1%86%E5%BD%A2%E5%BC%8F.png" alt="Method 1"></p><p>第二种方式在页面上单独显示一行字体, 用户同样可见:</p><p>第三种方式我们之前说过了, 在控制台中进行相关输出, 用户不可见:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Front-end/%E5%86%99%E5%85%A5%E9%A1%B5%E9%9D%A2%26%E6%8E%A7%E5%88%B6%E5%8F%B0.png" alt="写入页面 / 控制台"></p><h3 id="1-7-JS的数据类型"><a href="#1-7-JS的数据类型" class="headerlink" title="1.7 JS的数据类型"></a>1.7 JS的数据类型</h3><h4 id="1-7-1-原始数据类型"><a href="#1-7-1-原始数据类型" class="headerlink" title="1.7.1 原始数据类型"></a>1.7.1 原始数据类型</h4><p>原始数据类型, 也被称为基本数据类型, 一般有三个:</p><ul><li>数值</li><li>字符串</li><li>布尔值</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span><span class="token keyword">var</span> bool <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-7-2-合成数据类型"><a href="#1-7-2-合成数据类型" class="headerlink" title="1.7.2 合成数据类型"></a>1.7.2 合成数据类型</h4><p>合成数据类型, 也被称为复合数据类型, 一般由多个原始数据类型组成(C中的结构体):</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"Mug-chen"</span><span class="token punctuation">,</span>    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token literal-property property">admin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意, 变量之间通过 <strong>,</strong> 隔开</p><h4 id="1-7-3-特殊类型"><a href="#1-7-3-特殊类型" class="headerlink" title="1.7.3 特殊类型"></a>1.7.3 特殊类型</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">null</span><span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-7-4-类型判断"><a href="#1-7-4-类型判断" class="headerlink" title="1.7.4 类型判断"></a>1.7.4 类型判断</h4><p>在数据类型的判断上, 常用typeof函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//number</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"string"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//string</span><span class="token keyword">var</span> boo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> boo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//boolean</span><span class="token keyword">var</span> user <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object</span><span class="token comment">//两个特殊类型的结果</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>null通常表示对象为空; undefined一般表示数值为空.</p><h3 id="1-8-运算符"><a href="#1-8-运算符" class="headerlink" title="1.8 运算符"></a>1.8 运算符</h3><p>整体的运算符与C语言基本相同, 这里仅提及不同处.</p><h4 id="1-8-1-除法"><a href="#1-8-1-除法" class="headerlink" title="1.8.1 除法"></a>1.8.1 除法</h4><p>当然, 这里的除法是可以直接算出小数的, 不会像C, java那样整数除以整数只能得到整数解.</p><h4 id="1-8-2-严格等于-严格不等于"><a href="#1-8-2-严格等于-严格不等于" class="headerlink" title="1.8.2 严格等于 &amp; 严格不等于"></a>1.8.2 严格等于 &amp; 严格不等于</h4><p>在JS中, 等于运算符 “=&#x3D;” 出现了一个衍生, 叫 <strong>严格等于</strong> “&#x3D;&#x3D;&#x3D;”, 二者的区别在于, 前者会先进行类型转换再比较, 后者不会:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">==</span> <span class="token string">"5"</span><span class="token punctuation">)</span> \\<span class="token boolean">true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">===</span> <span class="token string">"5"</span><span class="token punctuation">)</span> \\<span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>类似的, 也有 <strong>!&#x3D;</strong> 与 <strong>!&#x3D;&#x3D;</strong> 的使用, 我们推荐使用 <strong>严格等于 &#x2F; 严格不等于</strong> .</p><h4 id="1-8-3-布尔运算"><a href="#1-8-3-布尔运算" class="headerlink" title="1.8.3 布尔运算"></a>1.8.3 布尔运算</h4><p>这里主要提及取反 <strong>!</strong> , 因为实际应用过程中常常对非布尔值进行取反(主要是方便), 我们这里给出6个取反后为真的例子.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">!</span><span class="token boolean">false</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token keyword">null</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token keyword">undefined</span><span class="token punctuation">;</span><span class="token operator">!</span><span class="token string">""</span><span class="token punctuation">;</span> <span class="token comment">//空字符串取反</span><span class="token operator">!</span><span class="token number">NaN</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-9-语句"><a href="#1-9-语句" class="headerlink" title="1.9 语句"></a>1.9 语句</h3><h4 id="1-9-1-条件语句"><a href="#1-9-1-条件语句" class="headerlink" title="1.9.1 条件语句"></a>1.9.1 条件语句</h4><p>给三种</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// if_else</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//elseif</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//switch</span><span class="token keyword">switch</span><span class="token punctuation">(</span>var_name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token operator">...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token operator">...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token operator">...</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见, 与C &#x2F; Java极其类似.</p><h4 id="1-9-2-三元运算符"><a href="#1-9-2-三元运算符" class="headerlink" title="1.9.2 三元运算符"></a>1.9.2 三元运算符</h4><p>即C &#x2F; Java中都有的特殊的条件判断:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span><span class="token operator">></span><span class="token number">2</span> <span class="token operator">?</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">:</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-9-3-循环语句"><a href="#1-9-3-循环语句" class="headerlink" title="1.9.3 循环语句"></a>1.9.3 循环语句</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-10-字符串"><a href="#1-10-字符串" class="headerlink" title="1.10 字符串"></a>1.10 字符串</h3><p>字符串与Java中类似, 换行需要利用 <strong>\</strong> </p><h4 id="1-10-1-字符串常用方法"><a href="#1-10-1-字符串常用方法" class="headerlink" title="1.10.1 字符串常用方法"></a>1.10.1 字符串常用方法</h4><p>(1) <strong>charAt</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//指定位置字符</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World."</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(2) <strong>concat</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//字符串连接</span><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以有多个参数, 参数之间利用逗号隔开</span><span class="token keyword">var</span> str3 <span class="token operator">=</span> <span class="token string">"!"</span><span class="token punctuation">;</span><span class="token keyword">var</span> s <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然, 熟悉java的读者, 应该知道, 直接用+也可以连接字符串, 也没毛病.</p><p>那用concat有什么区别?</p><p>事实是, +使用类型强转, 而concat调用它们的 <strong>toString()</strong> 方法.</p><p>一般情况下区别不大就是了.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">var</span> grade <span class="token operator">=</span> <span class="token string">"grade: "</span><span class="token keyword">var</span> str <span class="token operator">=</span> grade<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(3) <strong>substring</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//子字符串</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//llo </span><span class="token comment">//第二个参数可不写</span><span class="token keyword">var</span> sub_1 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//llo World</span><span class="token comment">//会自动排序两个参数的大小</span><span class="token keyword">var</span> sub_2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于</span><span class="token keyword">var</span> sub_2 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//负数会被自动转化成0</span><span class="token keyword">var</span> sub_3 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于</span><span class="token keyword">var</span> sub_3 <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与Java中相同, 含前不含后.</p><p>(4) <strong>substr</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//子字符串, 但第二个参数是字符串长度</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//llo </span><span class="token comment">//第二个参数不写, 则一直取到最后</span><span class="token comment">//第一个参数写成负数, 则取逆序的字母值</span><span class="token comment">//第二个参数写成负数, 则自动置为0(空字符串)</span><span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//l</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(5) <strong>indexOf</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//查看一个字符串在另一个字符串中第一次出现的位置, 如果找不到返回0</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token string">"Wor"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//6</span><span class="token comment">//可以接受第二个参数, 表示开始查找的位置</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>sub<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(6) <strong>trim</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//用于去除字符串两端的特殊字符, 包括空格, 制表符\t, \r, 回车符\n等</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"      Hello World      "</span><span class="token punctuation">;</span><span class="token keyword">var</span> res <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ES6新增扩展方法:</span><span class="token function">trimStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//去掉头部特殊字符</span><span class="token function">trimEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//去掉尾部特殊字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(7) <strong>split</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//字符串分割函数, 返回一个由子字符串组成的数组</span><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">"Hello World Here Is My Blog"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//["Hello", "World", "Here", "Is", "My", "Blog"]</span><span class="token comment">//可以进行空字符串分割, 返回一个由字符串中每个字符单独组成的字符串组成的数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//省略参数, 则返回原字符串组成的数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以接受第二个参数, 限定返回数组的最大成员数</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//["H", "e", "l"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面是主要使用的字符串方法, 但其实JS中字符串方法远不止这么多, 希望读者使用时可以有限查一查有没有对应的函数. <del>毕竟直接调库比手搓一个函数可方便多了(笑)</del></p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blockchain-2</title>
      <link href="/posts/3283.html"/>
      <url>/posts/3283.html</url>
      
        <content type="html"><![CDATA[<h1 id="Blockchain-2"><a href="#Blockchain-2" class="headerlink" title="Blockchain(2)"></a>Blockchain(2)</h1><blockquote><p>在本节中, 我们主要会针对 <strong>以太坊</strong> 这一另一个主要的加密货币进行说明.</p><p>仍然需要写在前面, 本文主要基于 《区块链技术与应用》(北京大学 肖臻教授) 的课程进行笔记整理与内容扩展, 文中除开视频内容外,也会涉及到一些博主自己的思考, 烦请读者理性看待. 在此也附上视频链接(<a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=1&vd_source=4565edcb254cb6582d6382ac80011294">https://www.bilibili.com/video/BV1Vt411X7JF?p=1&amp;vd_source=4565edcb254cb6582d6382ac80011294</a>), 有了他们的工作, 才能让区块链这一技术为更多人所知.</p><p>在此对 肖臻教授 以及 北京大学相应课程组 表达诚挚的敬意与感激!</p></blockquote><p><strong>以太坊(Ethereum)</strong> 对于比特币中出现的各种问题进行了更为针对性的改进, 包括但不限于 <strong>出块时间 &#x2F; 谜题设计 &#x2F; 共识协议</strong> 等等方面.</p><p>与此同时, 以太坊相对于比特币的最显著的该进, 在于 <strong>智能合约(Smart Contract)</strong> 的提出.</p><hr><p>为什么要提出智能合约?</p><p>在BTC时代, BTC实现的最重要的成就是它达成了一个真正的 <strong>去中心化的货币政策(Decentralized Currency)</strong> , 比特币通过技术手段取代了一部分本该通过政府来保证的公信力; 人们看到了BTC的成功, 并希望将这种去中心化的思路推而广之(If we can decentralize currency, what else can we decentralize?), 以太坊在此基础上设计出了 <strong>去中心化的合约设计(Decentralized Contract)</strong> , 智能合约类似地通过技术手段, 取代了一部分原本应当由司法机关来保证的合约公信力.</p><hr>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理_Fin</title>
      <link href="/posts/61250.html"/>
      <url>/posts/61250.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><blockquote><p>写在前面:<br>本文是针对《计算机组成原理》(唐朔飞编著 &#x2F; 第三版) 一书的总结, 也是博主应对期末考试的知识梳理.<br>本文中使用了大量的图片, 它们大多来自课上的PPT, 在这里对于PPT作者致以诚挚的谢意, 如有侵权, 请联系作者进行博文的删除操作.<br>文中如果提到书目页数, 指向的也是上文提到的教材.</p><p>此外, 由于博主的课堂教授顺序与书中不尽然相同, 因此会按照课堂的教授顺序进行梳理, 章节名称以及序号会以书中的名称 &#x2F; 序号为准. 读者可根据目录快速查询到相关章节.</p></blockquote><h2 id="Chap-1-计算机系统概论"><a href="#Chap-1-计算机系统概论" class="headerlink" title="Chap.1 计算机系统概论"></a>Chap.1 计算机系统概论</h2><h3 id="1-1-计算机系统的组成"><a href="#1-1-计算机系统的组成" class="headerlink" title="1.1 计算机系统的组成"></a>1.1 计算机系统的组成</h3><h4 id="1）软硬件概念"><a href="#1）软硬件概念" class="headerlink" title="1）软硬件概念"></a>1）软硬件概念</h4><ul><li>硬件：各类实体、主机 &#x2F; 外设等</li><li>软件：由具有各类特殊功能的信息（程序）组成<ul><li>系统软件：用于管理整个计算机系统</li><li>应用软件</li></ul></li></ul><h4 id="2）解题过程-层次结构"><a href="#2）解题过程-层次结构" class="headerlink" title="2）解题过程 &amp; 层次结构"></a>2）解题过程 &amp; 层次结构</h4><p>计算机的程序运行过程主要经过以下过程：</p><p>高级语言程序-&gt;翻译为机器语言程序-&gt;运行-&gt;输出结果</p><p>根据该解题过程，可以将计算机分为如下层次结构：</p><ul><li>虚拟机器M4：用高级语言书写，利用 <strong>编译程序</strong> 翻译为汇编语言程序。</li><li>虚拟机器M3：用汇编语言书写，利用 <strong>汇编程序</strong> 翻译为机器语言程序。</li><li>操作系统机器M2：用机器语言解释操作系统。</li><li>实际机器M1：用微指令解释机器指令。</li><li>微程序机器M0：用硬件直接执行微指令。</li></ul><h4 id="3）计算机体系结构-Vs-计算机组成"><a href="#3）计算机体系结构-Vs-计算机组成" class="headerlink" title="3）计算机体系结构 Vs 计算机组成"></a>3）计算机体系结构 Vs 计算机组成</h4><ul><li>计算机体系结构：包含的主要是程序员能够见到的计算机系统属性。 <strong>概念性的结构与功能</strong> 。指令集、寻址技术等。</li><li>计算机组成：包含如何 <strong>实现计算机体系结构</strong> 涉及到的属性，但这些属性对于程序员而言大部分是透明的。</li></ul><h3 id="1-2-计算机的基本组成"><a href="#1-2-计算机的基本组成" class="headerlink" title="1.2 计算机的基本组成"></a>1.2 计算机的基本组成</h3><h4 id="1）冯·诺依曼计算机的特点"><a href="#1）冯·诺依曼计算机的特点" class="headerlink" title="1）冯·诺依曼计算机的特点"></a>1）冯·诺依曼计算机的特点</h4><ul><li>由五大部件组成<ul><li>运算器：算术运算、逻辑运算，并暂存结果</li><li>存储器：存放数据、程序</li><li>控制器：控制、指挥程序和数据的输入、运行，并处理运算结果</li><li>输入设备：将人类能识别的信息转化为机器信息</li><li>输出设备：将机器信息（运算结果）转化为人类可识别的信息</li></ul></li><li>指令、数据以 <strong>同等地位</strong> 存于存储器，可按地址寻访</li><li>指令和数据均用二进制表示</li><li>指令由操作码和地址码组成</li><li>指令在存储器内按顺序存放</li><li>机器以运算器为中心</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A1%86%E5%9B%BE.png" alt="冯·诺伊曼计算机框图"></p><h4 id="2）现代计算机框图"><a href="#2）现代计算机框图" class="headerlink" title="2）现代计算机框图"></a>2）现代计算机框图</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A1%86%E5%9B%BE.png" alt="现代计算机框图"></p><ul><li>主机<ul><li>CPU<ul><li>ALU运算器</li><li>CU控制单元</li></ul></li><li>主存储器</li></ul></li><li>I&#x2F;O设备</li></ul><h4 id="3）计算机工作步骤"><a href="#3）计算机工作步骤" class="headerlink" title="3）计算机工作步骤"></a>3）计算机工作步骤</h4><ul><li>上机前的准备<ul><li>建立数学模型</li><li>确定计算方法</li><li>编制解题程序（不同的算法对应的解题程序完全不同）</li></ul></li></ul><p>如：计算 ax^2 + bx + c –&gt; (ax + b)x + c</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/ax%5E2%2Bbx%2Bc%E8%AE%A1%E7%AE%97%E4%B8%BE%E4%BE%8B.png" alt="计算例"></p><ul><li>解题过程</li></ul><p>（1）存储器的基本组成：</p><p>①存储体：</p><p>存储体-&gt;存储单元-&gt;存储元件</p><p>类比为：一栋大楼-&gt;一个房间-&gt;一个床位</p><p>一个存储元件能表示一位二进制数。<br>一个存储单元代表着一串二进制代码，这被称为一个字。</p><p>②MAR &amp; MDR：</p><p>MAR被称为地址寄存器，反应存储单元的个数。<br>MDR被称为数据寄存器，反应存储字长。</p><p>举例：MAR：4位，MDR：8位<br>代表有16个存储单元（2^4），一个存储单元由八位二进制数组成。</p><hr><p>（2）运算器的基本组成及操作过程：</p><p>加法：</p><ul><li>[M] -&gt; X</li><li>[ACC]+[X] -&gt; ACC</li></ul><p>减法：</p><ul><li>[M] -&gt; X</li><li>[ACC]-[X] -&gt; ACC</li></ul><blockquote><p>对于加减法，无需使用MQ，即乘商寄存器，只需要将最终结果暂存在ACC中即可。</p></blockquote><p>乘法：</p><ul><li>[M] -&gt; MQ</li><li>[ACC] -&gt; X</li><li>0 -&gt; ACC</li><li>[X]*[MQ] -&gt; ACC&#x2F;&#x2F;MQ</li></ul><blockquote><p>对于乘法，由于十分可能出现溢出，因此需要将ACC与MQ串在一起存储结果，我们记成 ACC&#x2F;&#x2F;MQ ，这里的MQ是乘商寄存器。</p></blockquote><p>除法：</p><ul><li>[M] -&gt; X</li><li>[ACC]&#x2F;[X] -&gt; MQ</li><li>R -&gt; ACC</li></ul><blockquote><p>对于除法，将结果暂存在乘商寄存器中，将余数存在ACC内。</p></blockquote><hr><p>（3）控制器的基本组成：</p><ul><li>PC：程序计数器，存放当前需要执行指令的地址</li><li>IR：指令寄存器，存放当前即将执行的指令</li><li>CU：控制单元</li></ul><p>完成一条指令需要三步：</p><ul><li>取指：PC（PC直接与MAR相连，方便取指）</li><li>分析：IR（IR的高位，即操作码会送到CU，记为OP(IR)-&gt;CU；IR的低位，即地址码会送到MAR，记作Ad(IR)-&gt;MAR）</li><li>执行：CU（发送各种位操作命令序列）</li></ul><p>例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%96%E6%95%B0%E6%8C%87%E4%BB%A4%E5%AE%8C%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="取数指令完成过程"></p><h3 id="1-3-计算机硬件的技术指标"><a href="#1-3-计算机硬件的技术指标" class="headerlink" title="1.3 计算机硬件的技术指标"></a>1.3 计算机硬件的技术指标</h3><h4 id="1）机器字长"><a href="#1）机器字长" class="headerlink" title="1）机器字长"></a>1）机器字长</h4><p>CPU一次能处理数据的位数。</p><h4 id="2）存储容量"><a href="#2）存储容量" class="headerlink" title="2）存储容量"></a>2）存储容量</h4><p>$$ 存储容量 &#x3D; 存储单元个数 * 存储字长 $$</p><p>存储单元个数由MAR体现，即：<strong>2^MAR 个存储单元</strong> ；而MDR反应存储字长， <strong>字长就是MDR位数本身</strong> 。</p><p>常用的存储单位：</p><p>1 byte &#x3D; 2^3 bit &#x3D; 8 bit</p><p>1 KB &#x3D; 2^10 byte</p><p>1 MB &#x3D; 2^10 KB</p><p>1 GB &#x3D; 2^10 MB</p><h4 id="3）运算速度"><a href="#3）运算速度" class="headerlink" title="3）运算速度"></a>3）运算速度</h4><ul><li>主频</li><li>吉普森法： $ T_M &#x3D; \sum_{i&#x3D;1}^n f_i * t_i $ 其中TM为机器运行速度，fi表示第i种指令占全部操作的占比数，ti表示该种指令的运行时间。</li><li>MIPS：每秒执行百万条指令</li><li>CPI：执行一条指令所需时钟周期数</li><li>FLOPS：每秒浮点运算次数</li></ul><h2 id="Chap-6-计算机的运算方法"><a href="#Chap-6-计算机的运算方法" class="headerlink" title="Chap.6 计算机的运算方法"></a>Chap.6 计算机的运算方法</h2><h3 id="6-1-无符号数和有符号数"><a href="#6-1-无符号数和有符号数" class="headerlink" title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h3><h4 id="1）无符号数"><a href="#1）无符号数" class="headerlink" title="1）无符号数"></a>1）无符号数</h4><p>顾名思义，无符号数无正负，所有的位数都用于表示数字的大小。</p><p>例：8位无符号数能表示的范围：0~255（$ 2^8 -1 $）</p><h4 id="2）有符号数"><a href="#2）有符号数" class="headerlink" title="2）有符号数"></a>2）有符号数</h4><p>利用单独的一位符号位来表示正负，用0表示正，用1表示负。</p><p>下面提三种表示方法：</p><p>①原码表示法</p><p>最简单的一种方法，符号位+数值位，数值位上就是 <strong>真值的绝对值</strong> 。</p><p>严谨定义如下：</p><p>$$ x_{整数}[原] &#x3D; \begin{cases}<br>    x, 2^n &gt; x \geq 0 \\<br>    2^n - x, 0 \geq x &gt; -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[原] &#x3D; \begin{cases}<br>    x, 1 &gt; x \geq 0 \\<br>    1 - x, 0 \geq x &gt; -1\<br>\end{cases} $$</p><p>其实不用摁记原始定义，在实际换算上，整数使用带余除法，小数利用不断乘2，取整数位的操作来获得即可。</p><p><strong>需要注意的是，在x &#x3D; 0时，正零和负零利用原码的表示是不同的：</strong> </p><p>$ [+0]_原 &#x3D; 0,0000 $<br>$ [-0]_原 &#x3D; 1,0000 $</p><hr><p>②补码表示法</p><p>计算机为了归一加法和减法，利用了另一种表示方法，即 <strong>补码</strong> 的概念。</p><p>补码的根本概念需要说起同余，即涉及到了带余除法的概念，具体而言，-3与+9在除以12时，余数是一样的，因此在模12的意义下，这俩是一个数。</p><p>因此，我们类比上面的思路，可以将负数转化为相对应的模数。</p><p>给出严谨定义如下：</p><p>$$ x_{整数}[补] &#x3D; \begin{cases}<br>    x, 2^n &gt; x \geq 0 \\<br>    2^{n+1} + x \space(mod \space 2^{n+1}), 0 &gt; x \geq -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[补] &#x3D; \begin{cases}<br>    x, 1 &gt; x \geq 0 \\<br>    2 + x \space (mod \space 2), 0 &gt; x \geq -1\<br>\end{cases} $$</p><p>需要说明的是，式子里的x是真值。</p><p>还是不用摁记定义，有一种快捷的方式可以求补码。</p><p>显然，正数的补码不用管，就是它自身；<br>负数的补码可以通过 <strong>除符号位每位取反，最后在末位再加1求得</strong> 。</p><p><strong>两个特殊的案例：</strong></p><p>首先，根据定义（这里不要用快捷的求补码方式），+0 和 -0 的补码是一样的，都是 0,0000</p><p>第二，关于多出来的 1,0000这个值怎么办，这个值原先是 -0的原码，但是现在-0被占据了，那就将其指向最小的那个负数，这也就是为什么补码可以比原码表示的负数个数多一个。</p><p>举个例子，8位原码表示的范围是： $ -2^7+1 \to 2^7-1 $ </p><p>而8位补码能表示的范围是： $ -2^7 \to 2^7-1 $</p><hr><p>③反码表示法</p><p>反码表示法的严谨定义如下：</p><p>$$ x_{整数}[反] &#x3D; \begin{cases}<br>    x, 2^n &gt; x \geq 0 \\<br>    (2^{n+1} - 1) + x \space(mod \space 2^{n+1} - 1), 0 \geq x &gt; -2^n\<br>\end{cases} $$</p><p>$$ x_{小数}[反] &#x3D; \begin{cases}<br>    x, 1 &gt; x \geq 0 \\<br>    (2 - 2^{-n}) + x \space(mod \space 2 - 2^{-n}), 0 \geq x &gt; -1 \<br>\end{cases} $$</p><p>这里n是指小数的位数</p><p>同样的，有一种快速求反码的方式，即 <strong>除了符号位之外各位取反</strong> 即可。</p><p>我们把三种东西总结一下：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%EF%BC%8C%E8%A1%A5%EF%BC%8C%E5%8F%8D.png" alt="原，补，反"></p><hr><p>最后，提一嘴关于移码的内容。</p><p>移码是为了解决补码无法非常直观的看出数字大小而发明的。</p><p>其定义为：</p><p>$$ x[移] &#x3D; 2^n + x $$</p><p>n是整数的位数。</p><p>其快捷算法即 <strong>先将补码算出来，改一个符号位即可</strong> 。</p><p>显然，根据移码的定义，移码这里也没有+0，-0的区分。</p><p>而对于对应数位上最小的那个值，其移码为全0。</p><p>举个例子：n&#x3D;5时， $ -2^5[移] &#x3D; 0,00000 $</p><p>这也与其补码相匹配，毕竟 $ -2^5[补] &#x3D; 1,00000 $</p><h3 id="6-2-数的定点表示和浮点表示"><a href="#6-2-数的定点表示和浮点表示" class="headerlink" title="6.2 数的定点表示和浮点表示"></a>6.2 数的定点表示和浮点表示</h3><h4 id="1）定点表示"><a href="#1）定点表示" class="headerlink" title="1）定点表示"></a>1）定点表示</h4><p>即将小数点位置固定在某一位置，这样的方法容易在进行运算时产生溢出风险，尤其是在处理的数字不是纯整数或纯小数时。</p><h4 id="2）浮点表示"><a href="#2）浮点表示" class="headerlink" title="2）浮点表示"></a>2）浮点表示</h4><p>浮点数是当前更多采用的方法，其一般形式为：</p><p>$$ N &#x3D; S * r^j $$</p><ul><li>S: 尾数，小数，可正可负</li><li>r: 基数，一般取2，4，8，16等</li><li>j: 阶码，整数，可正可负</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F.png" alt="浮点数的表示形式"></p><p>n，是尾数的位数，反映了浮点数的精度<br>m，是阶码的位数，反映了浮点数的表示范围</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4.png" alt="浮点数的表示范围"></p><hr><p>浮点数的规格化：即将类似 0.00001 这类的小数转化成 $ 0.10000 * 2^{1,0100} $ 这样的德行（这里全用的二进制机器数），说的再简单点，就是把小数点后面能用阶码表示的0全去了。</p><p>具体怎么规格化呢，先将真值对应的二进制数字进行规格化，比如： $ -0.0001011 &#x3D; 2^{-3} * -0.1011$ ，而后再进行对应的机器数转换，后面这个转换过程中不需要再做任何移位操作。</p><p>需要注意的是，规格化之后也涉及到补码、反码之类的一堆形式，一般会给要求，如 <strong>阶原尾补</strong> 之类的，即阶码用原码表示，尾数用补码表示。</p><p>关于机器0：当尾数为0时，不论阶码为何值，均按照机器0处理。</p><h3 id="6-3-定点运算"><a href="#6-3-定点运算" class="headerlink" title="6.3 定点运算"></a>6.3 定点运算</h3><p>计算机中的乘法是通过类似笔算乘法的方式通过移位来实现的：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%AC%94%E7%AE%97%E4%B9%98%E6%B3%95%E6%94%B9%E8%BF%9B.png" alt="笔算乘法的改进"></p><p>这里A是 <strong>被乘数</strong> , B是 <strong>乘数</strong> .</p><p>因此我们将其化为下面的竖式:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%AC%94%E7%AE%97%E4%B9%98%E6%B3%95_%E7%AB%96%E5%BC%8F.png" alt="改进笔算乘法的竖式表示"></p><p>上面的步骤可以总结为:</p><ul><li>利用加法和移位进行乘法运算.</li><li>由乘数的末尾决定是否与被乘数相加, 而后进行 <strong>整体右移</strong> , 乘数最后一位丢弃, 同时结果(即原先部分积)右移一位, 将放不下的那一位放在 <strong>乘数右移空出的高位</strong> 上.</li><li>总次数取决于乘数的位数</li></ul><h4 id="6-3-1-原码一位乘"><a href="#6-3-1-原码一位乘" class="headerlink" title="6.3.1 原码一位乘"></a>6.3.1 原码一位乘</h4><p>原码一位乘与上述笔算乘法思想完全相同, 不过需要额外考虑 <strong>符号位</strong> 的问题, 这里一般采取 <strong>符号位和数值位分开处理</strong> 的方法.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98.png" alt="原码一位乘"></p><p>最终将符号位 ( $ 1 \bigoplus 0 &#x3D; 1 $ ) 加上即可得到最终结果: 1.10110110.</p><h4 id="6-3-2-原码两位乘"><a href="#6-3-2-原码两位乘" class="headerlink" title="6.3.2 原码两位乘"></a>6.3.2 原码两位乘</h4><p>两位乘法是为了后续为了节省时间而设计出来的算法, 但是两位乘法涉及到 <strong>加三个被乘数</strong> , 而计算机对于三这个数字并不高效, 因此通过单独一个进位位来进行处理:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98.png" alt="原码两位乘_原理"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98_%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png" alt="原码两位乘_运算规则"></p><p>需要额外说明的是, 由于原码二位乘涉及到进位问题( 详细来说, 就是可能需要加两倍的被乘数[即左移一位], 或者减去一倍的被乘数[符号位全部置1] ) 因此在原码两位乘时, 我们需要 <strong>写三个符号位</strong> .</p><p>原码两位乘的符号位仍然需要单独处理, 乘法是否结束看的是乘数位数( <strong>x位需要右移 $ \frac{x}{2} $ 次, 每次右移两位</strong> ).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8E%9F%E7%A0%81%E4%B8%A4%E4%BD%8D%E4%B9%98_%E4%BE%8B.png" alt="原码两位乘_例"></p><h4 id="6-3-3-补码乘法"><a href="#6-3-3-补码乘法" class="headerlink" title="6.3.3 补码乘法"></a>6.3.3 补码乘法</h4><p>补码一位乘:</p><p>补码一位乘即利用补码的形式进行与上述模式类似的优化乘法, 运算规则如下:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A1%A5%E7%A0%81%E4%B8%80%E4%BD%8D%E4%B9%98_%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png" alt="补码一位乘_运算规则"></p><hr><p>这里着重介绍Booth算法:</p><p>Booth算法 <strong>无需考虑被乘数和乘数的符号</strong> , 这里不对其原理进行详细介绍, 仅给出计算规则:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Booth%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="Booth_计算公式"></p><p>请额外注意: <strong>Booth算法的乘数需要带着符号位</strong> , 也正因如此, <strong>Booth算法的最后一步加法无需右移</strong> .</p><p>此外, Booth算法的右移是 <strong>补码右移</strong> , 补上的数字 <strong>同当前计算结果的符号位</strong> .</p><p>给个例子:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Booth_%E4%BE%8B.png" alt="Booth_例"></p><h3 id="6-4-浮点四则运算"><a href="#6-4-浮点四则运算" class="headerlink" title="6.4 浮点四则运算"></a>6.4 浮点四则运算</h3><p>本节需要明确的问题是处理两个规格化的浮点数之间的运算.</p><p>对于浮点数:</p><p>$$ x &#x3D; S_x * 2^{j_x} $$</p><p>$$ y &#x3D; S_y * 2^{j_y} $$</p><h4 id="6-4-1-浮点加减"><a href="#6-4-1-浮点加减" class="headerlink" title="6.4.1 浮点加减"></a>6.4.1 浮点加减</h4><p>可以分为三步来进行:</p><ul><li>对阶: 相当于正常运算中的对齐对应位操作</li><li>尾数求和: 利用对应的补码加减定点运算进行</li><li>规格化</li><li>舍入: 如果规格化过程中出现了 <strong>尾数末尾丢失</strong> 的情况, 要考虑舍入</li></ul><hr><p>1.对阶:</p><p>显然, 阶数小的浮点数应当向阶数大的浮点数看齐.</p><p>为了方便, 这里应当 <strong>尽可能使用补码运算</strong> .</p><p>2.尾数求和:</p><p>利用化完的补码进行加减即可.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E5%8A%A0%E5%87%8F_%E4%BE%8B.png" alt="浮点加减_例"></p><p>3.规格化:</p><p>规格化, 意思为需要将加(减)完的数转变为规格化数.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A7%84%E6%A0%BC%E5%8C%96%E6%95%B0.png" alt="规格化数"></p><p>由于我们这里通常使用补码加, 因此要记住补码的规格化数特点: <strong>符号位和第一数位不同</strong> .</p><p>延续上例:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%A7%84%E6%A0%BC%E5%8C%96_%E6%96%B9%E6%B3%95.png" alt="规格化_方法"></p><p>4.舍入:</p><p>即考虑被舍弃的尾数应当如何处理:</p><ul><li>0舍1入: 被舍弃的值是0则直接舍弃, 是1则将舍弃后尾数加1(精度较高)</li><li>恒置1: 不论舍弃的低位是什么, <strong>舍弃后的最低位</strong> 恒置为1</li></ul><h4 id="6-4-2-浮点乘除"><a href="#6-4-2-浮点乘除" class="headerlink" title="6.4.2 浮点乘除"></a>6.4.2 浮点乘除</h4><p>与加减不同, 浮点乘除不需要考虑对阶, 直接进行运算即可:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%AE%E7%82%B9%E4%B9%98%E9%99%A4.png" alt="浮点乘除"></p><p>除法运算并不要求掌握, 这里不细说了.</p><h3 id="6-5-算术逻辑单元ALU"><a href="#6-5-算术逻辑单元ALU" class="headerlink" title="6.5 算术逻辑单元ALU"></a>6.5 算术逻辑单元ALU</h3><h4 id="6-5-1-ALU概述"><a href="#6-5-1-ALU概述" class="headerlink" title="6.5.1 ALU概述"></a>6.5.1 ALU概述</h4><p>因为这不是数字电路基础的复习, 因此对于ALU的详细电路组成不会进行非常详细的讲解.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/ALU.png" alt="ALU"></p><p>中间的ALU其实是相当复杂的组合逻辑电路, 典型的四位ALU芯片为74181, 在数字电路中有所提及.</p><p>这里只需要明确, ALU是 <strong>根据 $ K_i $ 的不同取值对 $ A_i, B_i $ 进行相应的操作, 从而使 $ F_i $ 输出对应的运算结果</strong> 的器件即可(明确一下, 这里i使可以取多位的, 要不然ALU只能进行一位数的两种运算也太low了).</p><h4 id="6-5-2-快速进位链"><a href="#6-5-2-快速进位链" class="headerlink" title="6.5.2 快速进位链"></a>6.5.2 快速进位链</h4><p>我们需要详细了解的是ALU的快速进位链, 即ALU进位的过程.</p><hr><p>1.并行加法器:</p><p>这种进位是最慢的, 因为它需要等待前面的位运算完毕产生进位信号 $ C_i $ 后, 才能进行自己的运算.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BF%AB%E9%80%9F%E8%BF%9B%E4%BD%8D%E9%93%BE_%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8.png" alt="并行加法器"></p><hr><p>2.串行进位链:</p><p>我们先看正常全加器中 $ C_i $ 的逻辑表达式</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%85%A8%E5%8A%A0%E5%99%A8%E9%80%BB%E8%BE%91_%E8%BF%9B%E4%BD%8D%E6%9D%A1%E4%BB%B6.png" alt="进位条件"></p><p>可见, 将其进位公式抽象成了:</p><p>$$ C_i &#x3D; d_i + t_i C_{i-1}, d_i &#x3D; A_i B_i, t_i &#x3D; A_i+B_i $$</p><p>显然, $ d_i, t_i $ 都是可以先算出来的, 而 $ C_{i-1} $ 需要等待下位传递.</p><p>因此, 一个像这样的串行进位链就出来了:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E9%93%BE.png" alt="串行加法链"></p><p>如果一个与非门的判断延迟时间: $ t_y $</p><ul><li>一位进位信号产生时间: $ 2t_y $</li><li>n位进位信号产生时间: $ 2nt_y $</li></ul><hr><p>3.并行进位链:</p><p>其实将上面的 $ C_0, C_1, C_2 $ 等元素进行递推, 就可以发现并行进位链的效率可以进一步提高(相当于 $ C_{-1} $ 的进位信号来了, 就可以一次产生4个进位信号).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E9%93%BE.png" alt="并行进位链"></p><p>这样的结构需要额外在每个进位位前面加一个 <strong>与或非门</strong> , 我们假设其判断时间为: $ 1.5t_y $</p><p>可见, 仅需要 $ 1.5t_y + t_y &#x3D; 2.5t_y $ 的时间, 就可以产生四位的进位信号, 效率很高.</p><p>但是肉眼可见的, 这种进位的电路相当的复杂, 因此, 只能成组使用.</p><p>(1) 单重分组跳跃进位:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B6%E8%A1%8C%E8%BF%9B%E4%BD%8D%E9%93%BE_%E5%8D%95%E9%87%8D%E5%88%86%E7%BB%84.png" alt="并行进位链_单重分组"></p><p>可见, 将四位为1组, 每组可以在 $ 2.5t_y $ 的时间内产生进位信号, 并将最后一位的进位信号传向下一组.</p><p>(2) 双重分组跳跃进位链:</p><p>在上述分组的基础上, 每小组再分成一个大组:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D_%E7%94%B5%E8%B7%AF.png" alt="双重分组跳跃进位_电路"></p><p>我们以第八小组为例, 给出进位逻辑: </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D%E9%93%BE_%E9%80%BB%E8%BE%91.png" alt="双重分组跳跃进位链_逻辑"></p><p>可见, 可以通过进一步拆解递推公式, 发现一大组中的四个小组的进位信号 $ C_i $ 都可以通过前一个大组传来的最终进位信号 $ C_{-1} $ 得到, 进而进一步设计电路节省时间.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E8%B7%B3%E8%B7%83%E5%88%86%E7%BB%84_%E5%A4%A7%E7%BB%84%E7%94%B5%E8%B7%AF.png" alt="双重跳跃分组_大组电路"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E8%B7%B3%E8%B7%83%E5%88%86%E7%BB%84_%E5%B0%8F%E7%BB%84%E7%94%B5%E8%B7%AF.png" alt="双重跳跃分组_小组电路"></p><p>小组分组电路中, 由于第8小组的 <strong>最高位进位</strong> $ C_3 $ 可以根据 $ T_8, D_8 $ 得到, 而 $ T_8, D_8 $ <strong>还可以进一步用于后续小组(第5, 6, 7小组)的进位</strong> , 因此不再输出 $ C_3 $ , 转而输出 $ T_8, D_8 $</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E8%BF%9B%E4%BD%8D%E9%93%BE_%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90.png" alt="双重分组跳跃进位链_时间分析"></p><p>可见, 双重分组跳跃进位链产生16位进位的时间进一步缩短到 $ 7.5t_y $ , 究其根本原因在于每一个小组的最高位进位( $ C_15, C_11, C_7, C_3 $ )通过电路提前根据 $ C_{-1} $ 算出来了, 而不像单重分组那样需要等待前几个分组的信号.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/32%E4%BD%8D%E5%8F%8C%E9%87%8D%E5%88%86%E7%BB%84%E8%B7%B3%E8%B7%83%E9%93%BE_%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90.png" alt="32位双重分组跳跃链_时间分析"></p><h2 id="Chap-4-存储器"><a href="#Chap-4-存储器" class="headerlink" title="Chap.4 存储器"></a>Chap.4 存储器</h2><h3 id="4-1-存储器概述"><a href="#4-1-存储器概述" class="headerlink" title="4.1 存储器概述"></a>4.1 存储器概述</h3><h4 id="4-1-1-存储器分类"><a href="#4-1-1-存储器分类" class="headerlink" title="4.1.1 存储器分类"></a>4.1.1 存储器分类</h4><p>存储器有多种分类方式:</p><ul><li>按存储介质分类<ul><li>半导体存储器: TTL &#x2F; MOS</li><li>磁表面存储器: 磁头, 载磁体</li><li>磁芯存储器: 硬磁材料, 环状原件</li><li>光盘存储器: 激光, 激光材料</li></ul></li><li>按存取方式分类:<ul><li>存取时间与物理地址无关(随机访问)<ul><li>随机存储器( <strong>可读可写</strong> )</li><li>只读存储器( <strong>只读</strong> )</li></ul></li><li>存取时间与物理地址有关(串行访问)<ul><li>顺序存取存储器(磁带)</li><li>直接存取存储器(磁盘)</li></ul></li></ul></li><li><strong>按在计算机中的作用分类</strong> :<ul><li>主存储器:<ul><li>RAM<ul><li>静态RAM: SRAM</li><li>动态RAM: DRAM, SDRAM</li></ul></li><li>ROM<ul><li>MROM</li><li>PROM</li><li>EPROM</li><li>EEPROM</li></ul></li></ul></li><li>Flash Memory(闪存)</li><li>高速缓冲存储器(Cache)</li><li>辅助存储器: 磁盘, 磁带, 光盘</li></ul></li></ul><h4 id="4-1-2-存储器的层次结构"><a href="#4-1-2-存储器的层次结构" class="headerlink" title="4.1.2 存储器的层次结构"></a>4.1.2 存储器的层次结构</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%8D%E5%90%8C%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%B9%E6%AF%94.png" alt="存储器对比"></p><p>由于目前比较常见的说法都按照在计算机中的作用分类, 因此我们通常利用该种分类方式来描述存储器的主要特性.</p><p>根据上图的层次性质对比, 可以将计算机的存储层次归纳为:</p><p>$$ CPU \iff 缓存 \iff 主存 \iff 辅存 $$</p><p>这其中:</p><ul><li><strong>$ 缓存 \iff 主存 $ 层次主要解决CPU与主存速度不匹配的问题</strong></li><li><strong>$ 主存 \iff 辅存 $ 层次主要解决存储系统的容量问题</strong></li></ul><h3 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h3><h4 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h4><p><strong>主存的基本组成</strong> 如下图所示:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png" alt="主存的基本组成"></p><p><strong>MAR &#x2F; MDR</strong> 即地址寄存器和数据寄存器在第一章中有所提及, CPU向MAR, MDR发送数据, 而后MAR, MDR分别通过地址总线和数据总线与内存的相应电路相连, 并以此达到读或写的目的.</p><h4 id="4-2-2-主存中存储单元的地址"><a href="#4-2-2-主存中存储单元的地址" class="headerlink" title="4.2.2 主存中存储单元的地址"></a>4.2.2 主存中存储单元的地址</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E9%85%8D_%E6%8C%89%E5%AD%97%E8%8A%82%E4%B8%8E%E6%8C%89%E5%AD%97%E5%AF%BB%E5%9D%80.png" alt="按字节与按字寻址"></p><p><strong>地址线</strong> 决定了计算机的寻址空间: 一根地址线能够一个二进制位.</p><p>如果按照字节编址: 寻址范围为 $ 2^{24} &#x3D; 16M $</p><p>如果按照字编址: 寻址范围则缩小为 $ \frac{2^{24}}{\frac{x}{8}}, x是字的位数 $ , 即 $ \frac{原寻址范围}{一个字包含的字节数} $</p><p>读者可以将按照字编制理解为将多个字节打了个包, 只能寻找到一个包裹而不能单独将包裹内的字节拿出来, 因此寻址范围也需要相应减少.</p><h4 id="4-2-3-主存的技术指标"><a href="#4-2-3-主存的技术指标" class="headerlink" title="4.2.3 主存的技术指标"></a>4.2.3 主存的技术指标</h4><p>主要有三种存储器指标可供参考:</p><ul><li>存储容量: 主存存放二进制代码的总位数</li><li>存储速度<ul><li>存取时间: 包括 <strong>访问时间, 读出时间, 写入时间</strong></li><li>存取周期: 连续两次 <strong>独立</strong> 的存储器操作所需的最小间隔时间</li></ul></li><li>存储器的带宽: 位&#x2F;秒</li></ul><blockquote><p>存储器带宽的算法要会, 具体而言, $ 单次取出位数*存储器频率 $ , 通常可能给出一个存取周期, 给出单次取出位数, 会让算存储器带宽.</p></blockquote><h4 id="4-2-4-半导体存储芯片"><a href="#4-2-4-半导体存储芯片" class="headerlink" title="4.2.4 半导体存储芯片"></a>4.2.4 半导体存储芯片</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87_%E5%AE%B9%E9%87%8F%E8%AF%B4%E6%98%8E.png" alt="半导体存储芯片及容量说明"></p><p>目前主流的半导体存储芯片利用地址线通过译码驱动电路指向存储矩阵中的内存单元, 再由数据线将内存单元中的数据取出.</p><blockquote><p>可以直接根据地址线和数据线的数量来计算出总芯片容量, $ 容量 &#x3D; 2^{地址线位数} * 数据线位数 $ , 即 <strong>总共多少个存储单元 * 一个存储单元内多少位</strong> .</p></blockquote><p><strong>片选线</strong> 用于选取存储芯片(后文会提及), <strong>读写控制线</strong> 用于决定进行何种(读 &#x2F; 写)操作.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%89%87%E9%80%89%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="片选线"></p><p>上图也能证明, 很多存储器是由 <strong>多片容量更小的存储器组合在一起</strong> 组成的.</p><h4 id="4-2-5-半导体存储芯片的译码驱动方式"><a href="#4-2-5-半导体存储芯片的译码驱动方式" class="headerlink" title="4.2.5 半导体存储芯片的译码驱动方式"></a>4.2.5 半导体存储芯片的译码驱动方式</h4><p>1.线选法:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8_%E7%BA%BF%E9%80%89%E6%B3%95.png" alt="线选法"></p><p>线选法原理简单, 如上图所示, 很多的存储单元组成 $ m*n $ 位的矩阵, 地址译码器先将地址线的二进制数译码为对应的行数, 而位线再通过与对应列数对齐将一行的所有位输出.</p><p>2.重合法:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8_%E9%87%8D%E5%90%88%E6%B3%95.png" alt="重合法"></p><p>重合法通过二维的地址译码器选中一个特定的存储单元. 两侧的译码单元作用与上面的线选法原理相同.</p><h4 id="4-2-6-静态RAM及芯片举例"><a href="#4-2-6-静态RAM及芯片举例" class="headerlink" title="4.2.6 静态RAM及芯片举例"></a>4.2.6 静态RAM及芯片举例</h4><p>静态RAM通过触发器与放大器等元器件进行数据读写, 这里不对具体的原理电路进行说明, 进进行芯片举例:</p><p><strong>Intel 2114</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%202114%20RAM%E7%9F%A9%E9%98%B5.png" alt="Intel 2114 RAM"></p><p>总体思路与重合法(矩阵单元选择)的方法很像, 但2114的列地址译码器可以一次选择一行中的四位(即 $ x, x+16, x+32, x+48 $ 四列), 从而达到一次传输出4位二进制数据的效果.</p><p>这里以写操作举例:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%202114%20%E5%86%99%E6%93%8D%E4%BD%9C.png" alt="Intel 2114 写操作"></p><h4 id="4-2-7-动态RAM及芯片举例"><a href="#4-2-7-动态RAM及芯片举例" class="headerlink" title="4.2.7 动态RAM及芯片举例"></a>4.2.7 动态RAM及芯片举例</h4><p>动态RAM通过电容存储电荷的原理来寄存信息. 电容上的电荷仅能持续 1~2 ms, 因此, 必须每2ms对所有存储单元恢复一次原状态, 这被称为 <strong>再生或刷新</strong> .</p><p>由于动态RAM的基本单元性质, 它读出的高低电平与 <strong>原存信息反相</strong> .</p><p><strong>Intel 1103</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Intel%201103%20%E8%AF%BB%E6%93%8D%E4%BD%9C.png"></p><hr><p><strong>动态RAM的刷新</strong></p><p>由于电容的特性, 动态RAM需要定时进行刷新.</p><p><strong>1.集中刷新</strong></p><p>即在一段时间后单独拉出一段整时间进行全体刷新:</p><p>需要明确的是, 刷新是跟行地址强相关的, 即一次存取周期刷新一整行.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png" alt="集中刷新"></p><p>图中两个概念:</p><ul><li>死区: 用于刷新的时间, 即 $ 存取周期 * 矩阵行数 $</li><li>死时间率: 死区时间占比, 即 $ \frac{死区时间}{刷新时间间隔} $</li></ul><p><strong>2.分散刷新</strong></p><p>分散刷新将刷新分布在了存取周期内, 即花一半的周期进行读 &#x2F; 写, 另一半的周期用于刷新.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM_%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png" alt="分散刷新"></p><p>由于刷新按行进行, 因此只需要 $ (0.5+0.5)*128 &#x3D; 128\mu s $ 就能完成一整次刷新. 并且不会存在停止读写的死区时间.</p><p>代价是存取周期更长了, 整个系统的速度受影响.</p><p><strong>3.异步刷新</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM_%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png" alt="异步刷新"></p><p>异步刷新想将分散刷新与集中刷新结合起来, 其做到每行隔 2ms 刷新一次, 平均到每行, 即 $ \frac{2*10^3}{128} &#x3D; 15.6 \mu s $ 刷新一行. 仍有死区, 但死区很短, 并且对系统速度影响较小.</p><h4 id="4-2-8-动态RAM与静态RAM的比较"><a href="#4-2-8-动态RAM与静态RAM的比较" class="headerlink" title="4.2.8 动态RAM与静态RAM的比较"></a>4.2.8 动态RAM与静态RAM的比较</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8A%A8%E6%80%81RAM%E4%B8%8E%E9%9D%99%E6%80%81RAM%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="动 / 静态比较"></p><h4 id="4-2-9-只读存储器ROM"><a href="#4-2-9-只读存储器ROM" class="headerlink" title="4.2.9 只读存储器ROM"></a>4.2.9 只读存储器ROM</h4><ul><li>MROM</li><li>PROM(一次性编程)</li><li>EPROM(多次性编程)</li><li>EEPROM(电可擦写多次性编程)</li><li>Flash Memory(闪存)<ul><li>便宜</li><li>电可擦洗</li><li>比EEPROM快</li></ul></li></ul><h3 id="4-3-存储器与CPU的连接"><a href="#4-3-存储器与CPU的连接" class="headerlink" title="4.3 存储器与CPU的连接"></a>4.3 存储器与CPU的连接</h3><h4 id="4-3-1-存储容量扩展"><a href="#4-3-1-存储容量扩展" class="headerlink" title="4.3.1 存储容量扩展"></a>4.3.1 存储容量扩展</h4><p><strong>1.位扩展(增加存储字长)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="位扩展"></p><p><strong>2.字扩展(增加存储字(也可理解为存储单元)的数量)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E5%AD%97%E6%89%A9%E5%B1%95.png" alt="字扩展"></p><p><strong>3.字 &#x2F; 位同时扩展(上述二者结合)</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%E6%89%A9%E5%B1%95_%E5%AD%97%2C%20%E4%BD%8D%E6%89%A9%E5%B1%95.png" alt="字 / 位扩展"></p><p>由上述说明可知, 通过地址线的增加来实现字扩展(扩大寻址空间), 通过数据线的增加来实现位扩展(扩大存储单元位数)</p><h4 id="4-3-2-存储器与CPU的连接"><a href="#4-3-2-存储器与CPU的连接" class="headerlink" title="4.3.2 存储器与CPU的连接"></a>4.3.2 存储器与CPU的连接</h4><p>例题: 见书P94~99 例4.1 &#x2F; 4.2 &#x2F; 4.3</p><p>通常可以分为四步: </p><ul><li>写出要求主存地址空间分配的二进制码</li><li>确定使用的芯片数量及类型</li><li>分配CPU的地址线</li><li>形成片选信号</li></ul><p>需要注意的是, 这里题目中给出的4K, 8K往往代表 <strong>寻址空间</strong> 而并非 <strong>总容量</strong> (举例而言, 如果题目希望分配4K地址的系统程序区, 而系统又有8根数据线, 你应当分配一个4K*8位的存储芯片, 而并非是一个256bit*8位的存储芯片), 即这里的地址指的都是编好地址的一个个存储单元, 而并非单独的一位.</p><h3 id="4-4-提高访存速度的措施"><a href="#4-4-提高访存速度的措施" class="headerlink" title="4.4 提高访存速度的措施"></a>4.4 提高访存速度的措施</h3><p>总体而言, 提高访存速度有三种方法:</p><ul><li>采用高速器件</li><li>采用层次结构(Cache-主存)</li><li>调整主存结构</li></ul><p>从主存结构说起:</p><p><strong>1.单体多字系统</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E7%BB%93%E6%9E%84_%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F.png" alt="单体多字系统"></p><p>这种设计的目的在于单次从存储体中某一地址取出多条指令, 并在此后每隔一定时间送给CPU一条指令, 这极大程度上提高了主存的带宽, 但显然, 这种设计的前提在于指令必须是连续存储的.</p><blockquote><p>劣势: 遇到 <strong>转移指令</strong> 或 <strong>操作数不能连续存放的指令</strong> 时, 效果不明显</p></blockquote><p><strong>2.多体并行系统</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%28%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%29.png" alt="多体并行系统(高位交叉编址)"></p><p>相当于将主存再度分层, 分为N个模块, 每个模块都有自己的MAR, MDR可供独立使用, 这使得它们可以并行工作, 又可以交叉工作.</p><p>上图所谓 <strong>高位交叉</strong> 即高位地址表示体号, 低位地址表示体内地址. 这种编址可以使不同的请求源同时访问不同的体, 实现 <strong>多体并行操作</strong> ;</p><hr><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84_%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F%28%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%29.png" alt="多体并行系统(低位交叉编址)"></p><p>与高位交叉相反的思路是 <strong>低位交叉</strong> , 即低位地址表示体号, 高位地址表示体内地址, ( <strong>将所有内存分成几个体, 就称作模几交叉, 比如上图就是一个模4的交叉编址</strong> ) 这种方式能够在不改变存取周期的前提下增加存储器的带宽: </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89_%E5%A2%9E%E5%A4%A7%E5%B8%A6%E5%AE%BD.png" alt="低位交叉_增大带宽"></p><p>如上图, 低位交叉可以通过硬件设计使得 <strong>不同的体先后在同一个访存周期的不同时段启动</strong> , 以此达到一个访存周期传递多条指令的效果(上例中读顺序: 0-&gt;1-&gt;2-&gt;3-&gt;0-&gt;1-&gt;2-&gt;3)</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89_%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8E%9F%E7%90%86.png" alt="低位交叉_流水线原理"></p><hr><p>存储器控制部件(存控)</p><p>存控中含有四个部件:</p><ul><li>控制线路</li><li>节拍发生器</li><li>存控标记触发器</li><li>排队器</li></ul><p>其中, 排队器是相当重要的, 它能根据请求源的紧急程度为CPU处理顺序排序, 具体顺序: 易发生代码丢失的请求源-&gt;严重影响CPU工作的请求源-&gt;其他请求源;</p><hr><p>高性能存储芯片</p><p>SDRAM(同步DRAM): 能在系统时钟的控制下进行写入和读出, 这使得 <strong>CPU无需等待</strong> ;</p><p>带Cache的DRAM: 继承了一个由SRAM组成的Cache, 有利于猝发式读取;</p><h3 id="4-5-高速缓冲存储器"><a href="#4-5-高速缓冲存储器" class="headerlink" title="4.5 高速缓冲存储器"></a>4.5 高速缓冲存储器</h3><p>简称 <strong>缓存</strong> , 位于CPU与主存之间, 负责解决CPU的 <strong>空等</strong> 现象, 容量比主存小, 速度比主存高;</p><h4 id="4-5-1-Cache工作原理"><a href="#4-5-1-Cache工作原理" class="headerlink" title="4.5.1 Cache工作原理"></a>4.5.1 Cache工作原理</h4><p>主存和缓存均按照块存储(类似于前面的多体并行系统), 块的大小相同, 一个块中有很多存储单元;</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%BB%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%96%E5%9D%80.png" alt="主存和缓存的编址"></p><p>缓存内共有C块, 主存共有M块, 显然, M&gt;&gt;C;</p><p>因此, 需要根据某种规则将主存的块与缓存的块建立联系, 这就衍生出两个名词:</p><ul><li>命中: 主存块成功调入了缓存, 建立了对应关系;</li><li>未命中: 主存块未调入缓存, 对应关系未能建立;</li></ul><h4 id="4-5-2-Cache的命中率以及效率"><a href="#4-5-2-Cache的命中率以及效率" class="headerlink" title="4.5.2 Cache的命中率以及效率"></a>4.5.2 Cache的命中率以及效率</h4><p>即CPU希望访问的信息在Cache中的比率.</p><p>$$ Cache命中率 \space h &#x3D; \frac{Nc}{Nc+Nm} $$</p><p>上式中: Nc表示访问Cache的次数, Nm表示访问主存的次数;</p><p><strong>可以通过命中率推断主存系统的平均访问时间:</strong></p><p>设:</p><ul><li>访问Cache的时间 $ t_c $ </li><li>访问主存的时间 $ t_m $ </li><li>Cache命中率 $ h $</li></ul><p>则主存系统的平均访问时间:</p><p>$$ t_a &#x3D; h * t_c + (1-h) * t_m $$</p><blockquote><p>上面这个式子的意义就是: 命中缓存, 则直接从缓存里取; 未命中缓存, 则需要进一步访问主存;</p></blockquote><p>进一步推出 <strong>Cache-主存系统的效率</strong> :</p><p>$$ Efficiency &#x3D; \frac{访问Cache的时间}{平均访问时间} * 100 %  &#x3D; \frac{t_c}{h * t_c + (1-h) * t_m} * 100 % $$</p><h4 id="4-5-3-Cache的读写"><a href="#4-5-3-Cache的读写" class="headerlink" title="4.5.3 Cache的读写"></a>4.5.3 Cache的读写</h4><p>下列框图为Cache的读操作</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/Cache%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C.png" alt="Cache的读操作"></p><p>在写操作上, 则有两种方法: </p><ul><li>写直达法: 写操作时 <strong>既将数据写入Cache, 也写入主存</strong> , 花费时间为 <strong>访问主存的时间</strong></li><li>写回法: 写操作时 <strong>只把数据写入Cache</strong> , 当Cache数据需要被替换出去后再写回主存, 花费时间是 <strong>访问Cache的时间</strong></li></ul><h4 id="4-5-4-Cache-主存的地址映射"><a href="#4-5-4-Cache-主存的地址映射" class="headerlink" title="4.5.4 Cache-主存的地址映射"></a>4.5.4 Cache-主存的地址映射</h4><p><strong>1.直接映射</strong></p><p>直接映射很容易理解, 就是一个取模操作.</p><p>我们上面提到过的变量这里列一下:</p><ul><li>m: 主存地址中存储块数的位数, 这说明主存总共有 $ M &#x3D; 2^m $ 个块</li><li>c: Cache地址中用于存储块数的位数, 这说明Cache中共有 $ C &#x3D; 2^c $ 个块</li><li>i: Cache中的块号</li><li>j: 主存中的块号</li></ul><p>我们可以得到:</p><p>$$ i &#x3D; j(mod \space C) \space 或者 i &#x3D; j(mod\space 2^c) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.png" alt="直接映射"></p><p>此时, CPU传来的主存地址的高m位被分成了两部分: 低c位指的就是对应Cache的字块地址, 而高(m-c)位则代表 <strong>主存字块标记</strong> , 表示当前Cache中存放的是主存的第几组数据( <strong>相当于把主存按照Cache的总字块数量再度分了个类</strong> : 0<del>[C-1], C</del>[2C-1], …, [M-C]~[M-1]). 如果读者看过上一篇博文, 或者了解过数论相关的知识, 这就是 <strong>同余类</strong> 的概念.</p><p>当CPU传过来一个对应地址时, Cache先找到对应的同余类, 而后看 <strong>主存字块标记</strong> 字段能否与对应Cache地址的 <strong>标记</strong> 字段匹配, 如果匹配则命中缓存, 直接调用Cache中的数据, 如果不匹配则仍需要进一步访问主存, 并同时替换Cache的对应字块, 并修改该块Cache的 <strong>标记</strong> .</p><p>这种映射方式容易理解, 但不够灵活.</p><hr><p><strong>2.全相联映射</strong></p><p>即Cache中每一个字块都可以与主存的任何字块建立对应关系. 这意味着 <strong>主存字块标记字段</strong> 以及 Cache对应的 <strong>标记</strong> 字段均 <strong>上升到了m位</strong> , 并且CPU每传来一个主存地址, 都需要与Cache的每个 <strong>标记</strong> 全部比较一遍, 效率无疑是比较低的.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="全相联映射"></p><hr><p><strong>3.组相联映射</strong></p><p>组相联映射是对上面两种方式的一种折中.</p><p>具体而言, 组相联映射对Cache也进行了分组, 将Cache分成Q组, 每组有R块. </p><p>借鉴直接映射, 我们还是有这个式子: </p><p>$$ i &#x3D; j(mod \space Q) $$</p><p>相当于将主存对应组别映射到Cache对应同余类的组别中.</p><p>我们假设Q &#x3D; 16, R &#x3D; 2, C &#x3D; Q*R &#x3D; 32;(Cache中总共32块, 2块为一组, 共16组)</p><p>则主存标号为 0, 16, 32, …, M-16 的字块对应Cache的第0组, 它们中任意一个字块都能存储到这一组2个块中的任意一个之中.</p><p>即: 主存的第j块映射到Cache的第i组内(直接映射), 同时, 又能存在第i组R个字块中的任意一个中(全相联映射).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.png" alt="组相联映射"></p><p>这种映射方式仍然将CPU传来的主存地址的高m位分类了, 组地址 $ q &#x3D; c-r $ 表示对应Cache的第几组, 前面 $ m-q &#x3D; m-c+r $ 位代表主存字块标记, 需要与Cache中的对应组 $ 2^r &#x3D; R $ 个标记字段相比较.</p><hr><p>上面这一段可以说是存储器中最不好理解的一段, 主要是涉及到的变量确实很多, 读者还请尽力理解.</p><p>给几个例子:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E4%BE%8B.png" alt="缓存_例"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BC%93%E5%AD%98_%E4%BE%8B2.png" alt="缓存_例"></p><h2 id="Chap-7-指令系统"><a href="#Chap-7-指令系统" class="headerlink" title="Chap.7 指令系统"></a>Chap.7 指令系统</h2><h3 id="7-1-机器指令"><a href="#7-1-机器指令" class="headerlink" title="7.1 机器指令"></a>7.1 机器指令</h3><h4 id="7-1-1-指令的一般格式"><a href="#7-1-1-指令的一般格式" class="headerlink" title="7.1.1 指令的一般格式"></a>7.1.1 指令的一般格式</h4><p>计算机的指令一般由 <strong>操作码</strong> 和 <strong>地址码</strong> 两部分构成.</p><p>总共有三种设计方式:</p><ul><li><p>长度固定指令: 主要用于指令字长较长的情况;</p></li><li><p>长度可变指令: 操作码分散在不同字段中, 显然, 这会增加指令译码 &#x2F; 分析 &#x2F; 控制器设计的难度;</p></li><li><p>扩展操作码指令: 随着地址数减少, 操作码的位数增加, 这里通过16位字长指令来解释一下这个设计思路:  </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E6%8A%80%E6%9C%AF.png" alt="扩展操作码技术"></p><p>可见, 每将一种三地址指令分解, 则可以分解成 $ 2^4 $ 个二地址指令, $ 2^8 $ 个一地址指令</p><p>(这里一地址, 二地址, 三地址指的是地址数目)</p></li></ul><h4 id="7-1-2-地址码的设置机制"><a href="#7-1-2-地址码的设置机制" class="headerlink" title="7.1.2 地址码的设置机制"></a>7.1.2 地址码的设置机制</h4><p>一条指令中的地址数量有很多种情况, 通常分为:</p><ul><li><p>四地址<br>顾名思义, 四地址中含有四个地址;<br>通常情况下, 这分别表示 <strong>第一操作数 &#x2F; 第二操作数 &#x2F; 结果存储 &#x2F; 下一条指令的地址</strong> ;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E5%9B%9B%E5%9C%B0%E5%9D%80.png" alt="四地址"></p></li><li><p>三地址<br>三地址区别于四地址, 它将下一条指令的地址隐去了, 通常隐含在程序计数器PC中(程序计数器见第一章);<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%B8%89%E5%9C%B0%E5%9D%80.png" alt="三地址"></p></li><li><p>二地址<br>二地址进一步简化指令, 它将结果存储的位置也隐去, 这意味着它必须将结果存在:  </p><ol><li>$ A_1 $ &#x2F; $ A_2 $ 中</li><li>累加器ACC中<br>前者的情况, 一条指令需要访存4次(取指令, 读两个数, 存一个数), 而如果仅存在ACC中, 则只需要访存3次(取指令, 取两个数).<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%BA%8C%E5%9C%B0%E5%9D%80.png" alt="二地址"></li></ol></li><li><p>一地址<br>一地址进一步简化, 直接省去了一个操作数的位置, 因为它默认另一个操作数处于累加器ACC中;<br>它会固定将结果存在ACC中;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9C%B0%E5%9D%80%E7%A0%81_%E4%B8%80%E5%9C%B0%E5%9D%80.png" alt="一地址"></p></li><li><p>零地址<br>零地址没有地址码, 这意味着它无法执行正常的运算操作, 一般是空操作 &#x2F; 停机 &#x2F; 返回 &#x2F; 中断返回等.</p></li></ul><blockquote><p>需要指明的是, 并不是地址数越多越好, 因为地址数越少, 它能包含的位数就越多, 这说明其寻址范围就越大.</p></blockquote><h4 id="7-1-3-指令字长的设置"><a href="#7-1-3-指令字长的设置" class="headerlink" title="7.1.3 指令字长的设置"></a>7.1.3 指令字长的设置</h4><p>从上面的描述应该不难看出, 指令字长取决于:</p><ul><li>操作码的长度</li><li>操作数地址的长度</li><li>操作数地址的个数</li></ul><p>一般而言, 指令字长可以有两种方法来设计:</p><ol><li>指令字长固定: 即 $ 指令字长 &#x3D; 存储字长 $ ;</li><li>指令字长可变: 即 $ 指令字长按照字节的倍数来变化 $ ;</li></ol><h3 id="7-2-操作数类型及操作种类"><a href="#7-2-操作数类型及操作种类" class="headerlink" title="7.2 操作数类型及操作种类"></a>7.2 操作数类型及操作种类</h3><h4 id="7-2-1-操作数类型"><a href="#7-2-1-操作数类型" class="headerlink" title="7.2.1 操作数类型"></a>7.2.1 操作数类型</h4><p>机器中的操作类型有: 地址 &#x2F; 数字 &#x2F; 字符 &#x2F; 逻辑数等.</p><p>它们的表示方法如下:</p><ul><li>地址: 无符号整数</li><li>数字: 定点数 &#x2F; 浮点数 &#x2F; 十进制数</li><li>字符: ASCⅡ</li><li>逻辑数: 逻辑运算</li></ul><h4 id="7-2-2-存储器中的数据存放"><a href="#7-2-2-存储器中的数据存放" class="headerlink" title="7.2.2 存储器中的数据存放"></a>7.2.2 存储器中的数据存放</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE.png" alt="存储器中的数据存放"></p><h4 id="7-2-3-操作类型"><a href="#7-2-3-操作类型" class="headerlink" title="7.2.3 操作类型"></a>7.2.3 操作类型</h4><p>操作类型大体可分为以下四类:</p><ul><li><p>数据传送: 从 <strong>寄存器或存储器</strong> 将数据送往 <strong>存储器或寄存器</strong> 的操作;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B_%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81.png" alt="数据传送"></p></li><li><p>算术逻辑操作: 在运算器ALU中进行的各类计算操作;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B_%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91.png" alt="算术逻辑"></p></li><li><p>移位: 算术移位(保留符号位, 适用于有符号数), 逻辑移位(不保留符号位, 适用于无符号数), 循环移位(将移出的位数重新移入, 分带进位 &#x2F; 不带进位)等:</p><ul><li>不带进位的循环移位: 直接将移出的值原样移到另一侧即可;</li><li>带进位的循环移位: 即在原先循环移位的基础上加了一个 <strong>进位位</strong>, 当移位时, 将 <strong>进位位</strong> 的值赋给空出的位置, 并将被移出的值赋给 <strong>进位位</strong> ;</li></ul></li><li><p>转移: </p><ul><li>无条件转移: JMP</li><li>条件转移: <ul><li>结果为零转移(Z &#x3D; 1): JZ</li><li>结果溢出转移(O &#x3D; 1): JO</li><li>结果有进位转移(C &#x3D; 1): JC</li><li>跳过一条指令: SKP, 其通常格式为: SKP DZ, 表示如果完成触发器D为0, 则跳过下一条指令;</li></ul></li></ul></li><li><p>陷阱(Trap)与陷阱指令: 陷阱一般指一种意外事故导致的中断, 这种类型的指令一般不提供给用户直接使用. 而是在出现事故时, 由CPU自动产生并执行.</p></li><li><p>输入输出: </p><ul><li>输入指令: 从 <strong>端口地址</strong> -&gt; CPU的寄存器;</li><li>输出指令: 从 CPU的寄存器 -&gt; 端口地址;<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%87%E4%BB%A4.png" alt="输入输出指令"></li></ul></li></ul><h3 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h3><p>寻址方式, 指的是如何 <strong>确定本条指令操作数的存放地址, 以及确定下一条欲执行指令的存放地址</strong> ;</p><p>更简单地讲, 就是完成了这两件事: </p><ul><li>指令寻址</li><li>数据寻址</li></ul><h4 id="7-3-1-指令寻址"><a href="#7-3-1-指令寻址" class="headerlink" title="7.3.1 指令寻址"></a>7.3.1 指令寻址</h4><p>指令寻址涉及到的操作相对简单, 分为 <strong>顺序寻址</strong> 和 <strong>跳跃寻址</strong> 两种.</p><p>顺序寻址即 <strong>直接在程序计数器PC上加1, 得到新一条指令的地址</strong> .</p><p>跳跃寻址需要通过 <strong>转移指令</strong> 给出下一条指令的地址(转移指令的定义见上一节).</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80.png" alt="指令寻址"></p><h4 id="7-3-2-数据寻址"><a href="#7-3-2-数据寻址" class="headerlink" title="7.3.2 数据寻址"></a>7.3.2 数据寻址</h4><p>数据寻址相对于指令寻址要复杂很多, 这里我们给出两个名词:</p><ul><li>形式地址A: 即指令字中的地址;</li><li>有效地址EA: 操作数的真实地址;</li></ul><p>在数据寻址中, 一般会将一个指令字分为 <strong>操作码</strong> &#x2F; <strong>寻址特征</strong> &#x2F; <strong>形式地址A</strong> 三部分. 机器通过寻址特征来进行相关操作, 进而找到有效地址.</p><p><strong>1.立即寻址:</strong></p><p>所谓立即寻址, 即 <strong>形式地址A就是操作数</strong> , 这也被称为 <strong>立即数</strong> , 显然, 这种形式的好处在于无需访存, 但A的位数也限制了操作数的大小.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.png" alt="立即寻址"></p><p><strong>2.直接寻址:</strong></p><p>直接寻址即 <strong>有效地址由形式地址直接给出</strong> , 显然, 这种方式需要访存一次, A的位数决定了本次指令操作数的寻址范围.</p><p>$$ EA &#x3D; A $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="直接寻址"></p><p><strong>3.隐含寻址:</strong></p><p>隐含寻址, 说明有某一个操作数的地址时隐含在操作码中的, <strong>其实就是上面一地址指令的思路</strong> .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.png" alt="隐含寻址"></p><p>举个例子: 比如8086中的MUL指令, 其被乘数是隐含在AX寄存器或AL寄存器中的, 而这个地址不用给出, 而是通过操作码(MUL)给出的.</p><p>这种方式使得指令字中少了一个地址字段, 可以有效缩短指令字长.</p><p><strong>4.间接寻址</strong></p><p>间接寻址, 即 <strong>有效地址由形式地址间接提供</strong> , 换言之, 即需要通过形式地址对应主存块的内容多次跳转才能得到有效地址.(读者如果有过编程基础, 其实就是 <strong>指针</strong> 的思想)</p><p>$$ EA &#x3D; (A) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="间接寻址"></p><p>类似的, 指针也分单层和多层, 上图右侧即通过多次反复跳转进行寻址的过程. 这种方式的好处是扩大了寻址范围, 但每一次寻址都需要耗费对应的访存时间.</p><p>间接寻址其实运用的十分广泛, 典型代表比如当用户调用子程序时, 会通过间接寻址的方式给出子程序的起始地址.</p><p><strong>5.寄存器寻址</strong></p><p>寄存器寻址, 即 <strong>有效地址是寄存器编号, 由形式地址直接给出</strong> .</p><p>$$ EA &#x3D; R_i $$</p><p>这种方式省去了访存的时间成本, 只需要访问寄存器即可, 执行较快, 并且可以有效缩短指令字长(给一个编号与给一个地址的长度必然前者更短一些), 但寄存器个数有限, 代表着这种方式也有其局限性.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.png" alt="寄存器寻址"></p><p><strong>6.寄存器间接寻址</strong></p><p>与第四种间接寻址的想法十分类似, 只不过这次有效地址存在寄存器中, 形式地址仍然只给出寄存器编号.</p><p>$$ EA &#x3D; (R_i) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.png" alt="寄存器间接寻址"></p><p>这种方式相比于间接寻址能够减少一次访存时间开销(因为第一次只需要访问寄存器即可).</p><p><strong>7.基址寻址</strong></p><p>基址寻址通过一个寄存器作为 <strong>基址寄存器(BR)</strong> , 其有效地址表示为:</p><p>$$ EA &#x3D; (BR) + A $$</p><p>通常, 在程序执行的过程中, BR内的内容是不变的, 这个值由操作系统或管理程序决定. 这种方式可以一定程度上扩大寻址范围, 有利于多道程序的运行.</p><p>相应的, 作为基址寄存器的寄存器也分两类:</p><ul><li>采用专用寄存器作为基址寄存器</li><li>采用通用寄存器作为基址寄存器(此时, 哪个通用寄存器作为基址寄存器由用户指定)</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%281%29.png" alt="采用专用寄存器的基址寻址"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80%282%29.png" alt="采用通用寄存器的基址寻址"></p><p><strong>8.变址寻址</strong></p><p>变址寻址的思路与基址寻址的思路恰好反过来, 有这么一个变址寄存器IX(可专用可通用), 在程序执行的过程中, IX的内容由用户给定, 并且 <strong>可以变化</strong> , 而对应的, 形式地址A不再变化.</p><p>$$ EA &#x3D; (IX) + A $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.png" alt="变址寻址"></p><p>这种方式同样可以扩大寻址范围, 同时非常适合 <strong>处理数组问题</strong> .</p><p><strong>9.相对寻址</strong></p><p>相对寻址更特殊一点, 通过给出 <strong>操作数与当前指令的地址差值</strong> 来寻找操作数.</p><p>$$ EA &#x3D; (PC) + A $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.png" alt="相对寻址"></p><p>这种方式对于书写程序浮动的情况相当有利, 也广泛被用于转移指令中.</p><p><strong>10.堆栈寻址</strong></p><p>堆栈寻址使用了 <strong>数据结构中的栈结构</strong> , 其通过先进后出的思路来设计寻址.</p><p>其通过一个变量 SP 来维护栈顶地址, 每当入栈一个指令后, 栈顶-1; 对应的, 每出栈一条指令, 则栈顶+1(注: 这是通过字编址的情况, 如果通过字节编址则需要加减相应指令以字节计数的长度);</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E5%AF%BB%E5%9D%80_%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80.png" alt="堆栈寻址"></p><h3 id="7-4-指令格式"><a href="#7-4-指令格式" class="headerlink" title="7.4 指令格式"></a>7.4 指令格式</h3><p>这一节主要讲述设计指令时需要考虑的各类因素, 但它对考试不是很重要, 这里不在枚举了, 仅引出一个概念:</p><p>平均码长: </p><p>$$ \sum_{i} F_i * B_i $$</p><p>其中:</p><ul><li>$ i $ : 表示指令</li><li>$ F_i $ : 表示指令的频率</li><li>$ B_i $ : 表示编码该条指令所用的位数</li></ul><p>给个例子:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B3%E5%9D%87%E7%A0%81%E9%95%BF_%E4%BE%8B.png" alt="平均码长_例"></p><blockquote><p>本题中, 编码方式涉及到了一些霍夫曼树的知识, 简单来说, 频率越高的指令, 码长应当越短;</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B9%B3%E5%9D%87%E7%A0%81%E9%95%BF_%E4%BE%8B_%E8%A7%A3.png" alt="平均码长_例_解"></p><blockquote><p>本章中, 涉及到了RISC与CISC的对比, 在博文中不在列举, 请见PPT</p></blockquote><h2 id="Chap-8-CPU的结构与功能"><a href="#Chap-8-CPU的结构与功能" class="headerlink" title="Chap.8 CPU的结构与功能"></a>Chap.8 CPU的结构与功能</h2><h3 id="8-1-CPU的结构"><a href="#8-1-CPU的结构" class="headerlink" title="8.1 CPU的结构"></a>8.1 CPU的结构</h3><h4 id="8-1-1-CPU的功能"><a href="#8-1-1-CPU的功能" class="headerlink" title="8.1.1 CPU的功能"></a>8.1.1 CPU的功能</h4><p>在第一章中, 提及过CPU的两个重要组成部分: <strong>控制器(CU)</strong> 与 <strong>运算器(ALU)</strong> ;</p><ul><li>控制器<ul><li>取指令</li><li>分析指令</li><li>执行指令 &#x2F; 发出各种操作命令</li><li>控制程序输入 &#x2F; 结果输出</li><li>总线管理</li><li>处理异常 &#x2F; 特殊请求</li></ul></li><li>运算器<ul><li>实现算术运算 &#x2F; 逻辑运算</li></ul></li></ul><blockquote><p>总而言之, CPU实现的功能分五大类: 指令控制(PC, IR) &#x2F; 操作控制(CU, 时序电路) &#x2F; 时间控制(CU, 时序电路) &#x2F; 数据加工(ALU, 寄存器) &#x2F; 处理中断(中断系统)</p></blockquote><h4 id="8-1-2-CPU的结构框图"><a href="#8-1-2-CPU的结构框图" class="headerlink" title="8.1.2 CPU的结构框图"></a>8.1.2 CPU的结构框图</h4><p>结构框图</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/CPU%E7%9A%84%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.png" alt="CPU的结构框图"></p><hr><p>内部结构</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/CPU%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="CPU的内部结构"></p><hr><p>关于CPU的寄存器:</p><ul><li>通用寄存器: 存放操作数</li><li>数据寄存器: 存放操作数</li><li>地址寄存器: 存放地址</li><li>条件码寄存器: 存放条件码(一般是程序分支的依据)</li></ul><p>通常的工作顺序:</p><p>$$ PC \to MAR \to M \to MDR \to IR $$</p><h3 id="8-2-指令周期"><a href="#8-2-指令周期" class="headerlink" title="8.2 指令周期"></a>8.2 指令周期</h3><h4 id="8-2-1-指令周期的概念"><a href="#8-2-1-指令周期的概念" class="headerlink" title="8.2.1 指令周期的概念"></a>8.2.1 指令周期的概念</h4><p>指令周期, 指 <strong>取出并完成一条指令所需的全部时间</strong> .</p><p>其基本组成过程分为: </p><ul><li>取指周期: 取指令</li><li>(间指周期): 取有效地址</li><li>执行周期: 取操作数</li><li>(中断周期): 保存程序断点</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.png" alt="指令周期流程"></p><h4 id="8-2-2-指令周期的数据流"><a href="#8-2-2-指令周期的数据流" class="headerlink" title="8.2.2 指令周期的数据流"></a>8.2.2 指令周期的数据流</h4><p><strong>1.取指周期数据流</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_取指周期"></p><ul><li>PC存放现行指令的地址, 该地址被送到MAR, 并随后被送至地址总线</li><li>CU向存储器发读命令</li><li>对应MAR指向单元的内容经过数据总线送到MDR, 再送至IR</li><li>CU控制PC+1</li></ul><p><strong>2.间指周期数据流</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E9%97%B4%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_间指周期"></p><ul><li>CU检查IR中的内容, 确定本条指令是否有间指操作</li><li>如果有间指操作, 则MDR中的右侧N位(被称作 <strong>Ad(MDR)</strong> )会被送到MAR, 并被进一步送至地址总线</li><li>CU向存储器发读命令</li><li>获取有效地址, 存入MDR</li></ul><p><strong>3.执行周期数据流</strong></p><p>不同指令的执行周期数据流往往差别较大, 因此这里无法利用框图表示.</p><p><strong>4.中断周期数据流</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png" alt="数据流_中断周期"></p><ul><li>CU将用于保存程序断点的存储器特殊地址(典型案例, 比如此前在堆栈寻址中讲到的SP, 即指向栈顶的指针)送往MAR, 进一步送往地址总线</li><li>CU向存储器发写命令</li><li>将PC中的内容(程序断点)送到MDR, 并经过数据总线写入存储器</li><li>CU将中断程序的入口地址送至PC, 为下一个取指周期做好准备</li></ul><h3 id="8-3-指令流水"><a href="#8-3-指令流水" class="headerlink" title="8.3 指令流水"></a>8.3 指令流水</h3><h4 id="8-3-1-系统并行性"><a href="#8-3-1-系统并行性" class="headerlink" title="8.3.1 系统并行性"></a>8.3.1 系统并行性</h4><p>所谓指令流水, 是提高 <strong>系统并行性</strong> 的一种称呼, 即希望两个或两个以上事件在同一时间段发生.</p><p>并行性分等级:</p><ul><li>过程级: 指作业, 进程之间的并行, 这可以通过软件实现</li><li>指令级: 指不同指令之间, 或指令内部的操作之间的并行, 这需要通过硬件实现</li></ul><h4 id="8-3-2-指令流水的具体设计"><a href="#8-3-2-指令流水的具体设计" class="headerlink" title="8.3.2 指令流水的具体设计"></a>8.3.2 指令流水的具体设计</h4><p><strong>最简单的方式: 串行执行</strong></p><p>串行指令是我们最容易想到的, 它的工作方式就是一条条指令进行下去, 没有任何并行性, 效率也自然很低.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E4%B8%B2%E8%A1%8C.png" alt="指令流水_串行"></p><p><strong>进一步设计: 二级流水</strong></p><p>第二种想法是将取指令和执行指令分开:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E4%BA%8C%E7%BA%A7%E5%B9%B6%E8%A1%8C.png" alt="指令流水_二级并行"></p><p>这种方式也被称为 <strong>指令预取</strong> , 如果取指阶段和执行阶段在时间上完全重叠, 那么理论上指令周期可以减半, 速度可以提高一倍.</p><p>但很遗憾, 指令的执行时间一般大于取指时间, 因此二者速度其实并不十分匹配; 另外, 遇到一些条件转移指令时, 往往下一步是不可知的, 必须等待上一条指令执行阶段结束, 判断出条件真伪后才能进行下一阶段的取指.</p><p><strong>再度分级: 六级流水</strong></p><p>为了解决二级流水遇到的以上问题, 我们将指令的处理过程继续细化分解:</p><ul><li>FI(Fetch Instruction): 取指</li><li>DI(Decode Instruction): 指令译码</li><li>CO(Calculate operand address): 计算操作数地址</li><li>FO(Fetch operand): 取操作数</li><li>EI(Execute instruction): 执行指令</li><li>WO(Write back operand): 写操作数</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4_%E5%85%AD%E7%BA%A7%E5%B9%B6%E8%A1%8C.png" alt="指令流水_六级并行"></p><p>我们考虑一个含有六条指令的程序, 如果串行执行: 需要6*9 &#x3D; 54个时间单位, 而通过上述流水线的思路, 则只需要14个时间单位!</p><h4 id="8-3-3-流水线性能评估"><a href="#8-3-3-流水线性能评估" class="headerlink" title="8.3.3 流水线性能评估"></a>8.3.3 流水线性能评估</h4><p><strong>1.吞吐率</strong></p><p>即 <strong>单位时间内流水线所完成指令的数量</strong></p><p>设 m 段的流水线隔段时间为 $ \Delta t $</p><p>(1) 最大吞吐率</p><p>$$ T_{pmax} &#x3D; \frac{1}{\Delta t} $$</p><p>(2) 实际吞吐率: 连续处理n条指令的吞吐率</p><p>$$ T_p &#x3D; \frac{n}{m * \Delta t + (n-1) * \Delta t} $$</p><p><strong>2.加速比</strong></p><p>设流水线各段时间为 $ \Delta T $ , 每条指令共 m 段;</p><p>加速比即 <strong>非流水线的速度与 m 段的流水线的速度之比</strong></p><p>则:</p><p>$$ S_p &#x3D; \frac{n * m * \Delta t}{m * \Delta t + (n-1) * \Delta t} &#x3D; \frac{n * m}{m+n-1} $$</p><p><strong>3.效率</strong></p><p>流水线自身的效率, 即 <strong>流水线中各功能段的利用率</strong></p><p>$$ 效率 &#x3D; \frac{m * n * \Delta t}{m * (m+n-1) * \Delta t} &#x3D; \frac{n}{m+n-1} $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%95%88%E7%8E%87%E8%AF%B4%E6%98%8E.png" alt="流水线效率说明"></p><h3 id="8-4-中断系统"><a href="#8-4-中断系统" class="headerlink" title="8.4 中断系统"></a>8.4 中断系统</h3><p>本节本来放到了 I&#x2F;O 设备后讲述, 在本文中为了整体性将其与第八章其余内容放在一块, 读者也可以先不看这一节</p><h4 id="8-4-1-概述"><a href="#8-4-1-概述" class="headerlink" title="8.4.1 概述"></a>8.4.1 概述</h4><p>引发中断的因素有很多:</p><ul><li>人为设置的中断(转管指令)</li><li>程序性事故(移出, 操作码不能识别, 除法非法)</li><li>硬件故障</li><li>I&#x2F;O 设备</li><li>外部事件(用键盘中断现行程序)</li></ul><p>每个可能出现中断的请求源, 都有一个 <strong>INTR(中断请求标记触发器)</strong> , 其分散在多个中断源的接口电路中, 也集中在CPU的中断系统内</p><h4 id="8-4-2-中断判优逻辑"><a href="#8-4-2-中断判优逻辑" class="headerlink" title="8.4.2 中断判优逻辑"></a>8.4.2 中断判优逻辑</h4><p>1.分散在各个中断源的接口电路中, 比如 I&#x2F;O 设备的链式排队器(见第五章 5.5)</p><p>2.集中在CPU内:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9B%86%E4%B8%AD%E5%9C%A8CPU%E5%86%85%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F%E7%94%B5%E8%B7%AF.png" alt="集中在CPU内的中断排队电路"></p><p>3.通过软件轮流查询:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%80%9A%E8%BF%87%E8%BD%AF%E4%BB%B6%E9%80%BB%E8%BE%91%E8%BD%AE%E6%B5%81%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F.png" alt="通过软件逻辑轮流查询的中断排队"></p><h4 id="8-4-3-中断服务程序入口地址的寻找"><a href="#8-4-3-中断服务程序入口地址的寻找" class="headerlink" title="8.4.3 中断服务程序入口地址的寻找"></a>8.4.3 中断服务程序入口地址的寻找</h4><ul><li>通过硬件直接形成中断向量寻找(见5.4)</li><li>通过软件查询</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80_%E8%BD%AF%E4%BB%B6%E6%9F%A5%E8%AF%A2.png" alt="中断服务程序入口地址_软件查询"></p><h4 id="8-4-4-中断响应的条件与时间"><a href="#8-4-4-中断响应的条件与时间" class="headerlink" title="8.4.4 中断响应的条件与时间"></a>8.4.4 中断响应的条件与时间</h4><p>见5.5</p><h4 id="8-4-5-多重中断"><a href="#8-4-5-多重中断" class="headerlink" title="8.4.5 多重中断"></a>8.4.5 多重中断</h4><p>即优先级别高的中断源有权中断优先级别低的中断源</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD.png" alt="多重中断"></p><p>需要说明的是, 保护多重中断中, 因为 <strong>存在多次保护现场操作</strong> , 因此保护现场的暂存地址不可能永远是那个特殊的0地址了, 每次新中断时, 要将 <strong>原先0地址内的内容转存</strong> .</p><h4 id="8-4-6-屏蔽技术"><a href="#8-4-6-屏蔽技术" class="headerlink" title="8.4.6 屏蔽技术"></a>8.4.6 屏蔽技术</h4><p>重点理解 <strong>屏蔽字与优先等级的改变</strong> , 具体而言, <strong>屏蔽字为1</strong> 代表 <strong>对应中断源的中断请求会被本中断请求屏蔽掉</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%B1%8F%E8%94%BD%E5%AD%97%26%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%AD%89%E7%BA%A7.png" alt="屏蔽字&amp;中断优先等级"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%96%B0%E5%B1%8F%E8%94%BD%E5%AD%97%E7%9A%84%E5%A4%84%E7%90%86%E9%A1%BA%E5%BA%8F.png" alt="新屏蔽字的处理顺序"></p><p>如上图所示, 响应优先级是不能被更改的, 因此A处理完后, 还是会优先响应B, 但是 <strong>C的处理优先级更高, 所以C可以打断B的响应</strong> , 同理, D打断C的响应, 并最先处理完, 随后C处理完, B处理完.</p><h2 id="Chap-9-控制单元的功能"><a href="#Chap-9-控制单元的功能" class="headerlink" title="Chap.9 控制单元的功能"></a>Chap.9 控制单元的功能</h2><h3 id="9-1-操作命令的分析"><a href="#9-1-操作命令的分析" class="headerlink" title="9.1 操作命令的分析"></a>9.1 操作命令的分析</h3><p>回忆第八章的内容, 指令的执行过程分四个周期, 在这里将每个周期实现的操作再度利用比较标准的语言描述一下:</p><p><strong>1.取指周期</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E5%8F%96%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_取指周期"></p><ul><li>$ PC \to MAR \to 地址线 $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to IR $</li><li>$ OP(IR) \to CU $</li><li>$ (PC) + 1 \to PC $</li></ul><p><strong>2.间指周期</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E9%97%B4%E6%8C%87%E5%91%A8%E6%9C%9F.png" alt="数据流_间指周期"></p><ul><li>$ 指令形式地址 \to MAR $ 即 $ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to Ad(IR) $</li></ul><p><strong>3.执行周期</strong></p><p>(1)非访存指令:</p><ul><li>CLA(将ACC清零): $ 0 \to ACC $</li><li>COM(ACC取反): $ \overline{ACC} \to ACC $</li><li>SHR(算术右移): $ L(ACC) \to R(ACC), ACC_0 \to ACC_0 $ (后面一步代表符号位不变)</li><li>CSL(循环左移): $ R(ACC) \to L(ACC), ACC_0 \to ACC_n $</li><li>STP(停机): $ 0 \to G $</li></ul><p>(2)访存指令:</p><ul><li>加法指令: $ ADD \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ (ACC) + (MDR) \to ACC $</li></ul></li><li>存数指令: $ STA \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to W $</li><li>$ ACC \to MDR $</li><li>$ MDR \to M(MAR) $</li></ul></li><li>取数指令: $ LDA \space X $<ul><li>$ Ad(IR) \to MAR $</li><li>$ 1 \to R $</li><li>$ M(MAR) \to MDR $</li><li>$ MDR \to ACC $</li></ul></li></ul><p>(3)转移指令(不访存)</p><ul><li>无条件转: $ JMP \space X $<ul><li>$ Ad(IR) \to PC $</li></ul></li><li>条件转移: $ BAN \space X $ , 这里假设 $ A_7 &#x3D; 1 $ 为满足条件<ul><li>$ A_7 * Ad(IR) + \overline{A_7} * (PC) \to PC $</li></ul></li></ul><p>上述指令的执行周期总结如下:<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E7%B1%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F.png" alt="三类指令的指令周期"></p><p><strong>4.中断周期</strong></p><p>中断分两种:</p><ul><li>关中断</li><li>程序中途中断</li></ul><p>二者区别只在需要执行的第一个操作</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%95%B0%E6%8D%AE%E6%B5%81_%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png" alt="数据流_中断周期"></p><ul><li>保存程序断点:<ul><li>关中断: $ 0 \to MAR $ , 即断点存入0地址</li><li>程序中途中断: $ (SP)-1 \to SP \to MAR $ , 即断点进栈</li></ul></li><li>$ 1 \to W $</li><li>$ PC \to MDR $</li><li>$ MDR \to M(MAR) $</li><li>$ 中断程序入口地址M \to PC $</li><li>$ 0 \to EINT $</li></ul><h3 id="9-2-控制单元的功能"><a href="#9-2-控制单元的功能" class="headerlink" title="9.2 控制单元的功能"></a>9.2 控制单元的功能</h3><h4 id="9-2-1-控制单元的外特性"><a href="#9-2-1-控制单元的外特性" class="headerlink" title="9.2.1 控制单元的外特性"></a>9.2.1 控制单元的外特性</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83_%E5%A4%96%E7%89%B9%E6%80%A7.png" alt="控制单元_外特性"></p><p>从图中, 我们整理一下控制单元的输入 &#x2F; 输出信号来源:</p><ul><li>输入信号<ul><li>时钟: CU受到时钟控制</li><li>指令寄存器 ( $ OP(IR) \to CU $ ), 与操作码相关</li><li>标志: CU收到各类标志寄存器的控制</li><li>外来信号: 如INTR(中断请求) &#x2F; HRQ(总线请求)</li></ul></li><li>输出信号<ul><li>CPU内的各种控制信号<ul><li>来自寄存器的</li><li>来自PC的</li><li>来自ALU的</li></ul></li><li>送到控制总线的信号<ul><li>$ \overline{MREQ} $ , 访存控制信号</li><li>$ \overline{IO} &#x2F; M $ , 访问IO &#x2F; 存储器的控制信号</li><li>$ \overline{RD} $ , 读命令</li><li>$ \overline{WR} $ , 写命令</li><li>$ INTA $ , 中断响应信号</li><li>$ HLDA $ , 总线响应信号</li></ul></li></ul></li></ul><h4 id="9-2-2-控制信号举例"><a href="#9-2-2-控制信号举例" class="headerlink" title="9.2.2 控制信号举例"></a>9.2.2 控制信号举例</h4><p>详见书 $ P_{380} $</p><p>这里仅对是否使用CPU内部总线进行说明, CPU内部总线是一根将所有器件串连起来的总线, 相当于所有的信号都可以通过内部总线传递给其他部件.</p><h4 id="9-2-3-多级时序系统"><a href="#9-2-3-多级时序系统" class="headerlink" title="9.2.3 多级时序系统"></a>9.2.3 多级时序系统</h4><p><strong>1.机器周期</strong></p><p>机器周期是 <strong>所有指令执行过程中的一个基准时间</strong> ;</p><p>这个基准时间的确定需要考虑:</p><ul><li>完成最复杂的指令功能的时间</li><li>访问一次存储器的时间</li></ul><p>通常, 访存时间比CPU中的处理要长很多, 因此在 <strong>指令字长 &#x3D; 存储字长</strong> 的前提下, <strong>取指周期 &#x3D; 机器周期</strong></p><hr><p><strong>2.时钟周期</strong></p><p>一个机器周期内可以完成若干个微操作, 因此将 <strong>机器周期进一步细分为若干个时间相等的时钟周期</strong></p><p>时钟周期是 <strong>计算机操作的最小单位时间</strong> , 可以利用它产生一个或几个微操作命令</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%20%26%20%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png" alt="机器周期&amp;时钟周期"></p><hr><p><strong>3.多级时序系统</strong></p><p>一个指令周期包含多个机器周期, 一个机器周期包含多个时钟周期.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%A4%9A%E7%BA%A7%E6%97%B6%E5%BA%8F%E7%B3%BB%E7%BB%9F.png" alt="多级时序系统"></p><hr><p><strong>4.机器主频</strong></p><p>机器主频越快:</p><ul><li>机器速度越快</li><li>一个机器周期中包含的时钟周期数越多</li><li>一个指令周期中包含的机器周期数越多</li></ul><h4 id="9-2-4-控制方式"><a href="#9-2-4-控制方式" class="headerlink" title="9.2.4 控制方式"></a>9.2.4 控制方式</h4><p>1.同步控制方式</p><ul><li>采用定长的机器周期: 即以最长的微操作序列以及最繁的微操作作为标准, <strong>每个机器周期内节拍数目相同</strong></li><li>采用不定长的机器周期: 每个机器周期内节拍数不等</li><li>中央控制+局部控制: 将大部分指令安排在统一 &#x2F; 较短的机器周期内完成, 对于少数较复杂的指令, 采用局部控制方法完成</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E5%A4%AE%E6%8E%A7%E5%88%B6%2B%E5%B1%80%E9%83%A8%E6%8E%A7%E5%88%B6.png" alt="中央控制+局部控制"></p><p>2.异步控制方式</p><ul><li>无基准时标信号</li><li>无固定应答节拍和严格的时钟同步</li><li>采用应答方式</li></ul><p>3.联合控制方式</p><ul><li>同步+异步</li></ul><p>4.人工控制方式</p><ul><li>Reset</li><li>连续+单条指令执行转换开关</li><li>符合停机开关</li></ul><h2 id="Chap-10-控制单元的设计"><a href="#Chap-10-控制单元的设计" class="headerlink" title="Chap.10 控制单元的设计"></a>Chap.10 控制单元的设计</h2><h3 id="10-1-微程序设计"><a href="#10-1-微程序设计" class="headerlink" title="10.1 微程序设计"></a>10.1 微程序设计</h3><h4 id="10-1-1-微程序设计思想"><a href="#10-1-1-微程序设计思想" class="headerlink" title="10.1.1 微程序设计思想"></a>10.1.1 微程序设计思想</h4><p>将一条机器指令进一步细分, 一条机器指令对应一个 <strong>微程序</strong> , 一个微程序对应很多条 <strong>微指令</strong> .</p><p>如果预先将一些操作可预测的微程序写进ROM中, 则可以大大提高执行速度.</p><h4 id="10-1-2-微程序控制单元工作原理"><a href="#10-1-2-微程序控制单元工作原理" class="headerlink" title="10.1.2 微程序控制单元工作原理"></a>10.1.2 微程序控制单元工作原理</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83.png" alt="微程序控制单元"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A1%86%E5%9B%BE.png" alt="微程序控制单元框图"></p><p>这其中:</p><ul><li>控制存储器(控存): 是核心部件, 负责存放全部微程序</li><li>CMAR(控存地址寄存器): 存放欲读出的微指令地址</li><li>CMDR(控存数据寄存器): 存放从控存读出的微指令</li><li>顺序逻辑: 用于控制微指令序列</li></ul><p>微指令的基本格式中:</p><ul><li>操作控制字段负责发出控制信号</li><li>顺序控制字段负责指出下一条微指令的地址(简称 <strong>下地址</strong> )</li></ul><p>给出工作方式:</p><ul><li>取指阶段<ul><li>取指周期微程序首地址 $ M \to CMAR $</li><li>将对应控存中的第一条微指令读到控存数据寄存器 $ CM(CMAR) \to CMDR $</li><li>根据微指令的操作控制字段发出控制信号, 如 $ PC \to MAR, 1 \to R $ 等诸如此类</li><li>根据微指令的顺序控制字段找到下一条微指令, 即 $ Ad(CMDR) \to CMAR $</li><li>回到第二步, 循环进行, 直到相应指令已经存入IR中为止</li></ul></li><li>执行阶段<ul><li>将操作码送至微地址形成部件, 其输出即第一条微指令的地址, $ OP(IR) \to 微地址形成部件 \to CMAR $</li><li>$ CM(CMAR) \to CMDR $</li><li>发出控制信号, $ Ad(CMDR) \to CMAR $ …</li><li>直至指令执行结束为止</li></ul></li></ul><p><strong>微指令有两个很重要的问题:</strong></p><ul><li>操作控制字段如何形成微操作命令</li><li>后续地址如何形成</li></ul><h4 id="10-1-3-微指令的编码方式-控制方式"><a href="#10-1-3-微指令的编码方式-控制方式" class="headerlink" title="10.1.3 微指令的编码方式(控制方式)"></a>10.1.3 微指令的编码方式(控制方式)</h4><p>即 <strong>微指令的操作控制字段如何产生应当产生的控制信号</strong> , 解决第一个问题.</p><p>1.直接编码(直接控制方式)</p><p>这种方式代表 在操作控制字段中 <strong>每一位代表一个微操作命令</strong> , 该位为1则代表该控制信号有效;</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81_%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6.png" alt="微指令编码_直接控制"></p><p>2.字段直接编码方式</p><p>这种方式将控制字段中的位分成了若干段, 每一段经过单独译码后发出控制信号, <strong>每段中的命令是互斥的</strong></p><p>其缩短了微指令字长, 但增加了译码时间</p><blockquote><p>为什么缩短了控制时间? 假设有7个互斥微操作, 第一种方法需要7位, 第二种方法只需要3位, 因为 $ 2^3 &#x3D; 8&gt;7 $</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%8E%A7%E5%88%B6_%E5%AD%97%E6%AE%B5%E7%9B%B4%E6%8E%A5%E7%BC%96%E7%A0%81.png" alt="微指令控制_字段直接编码"></p><p>3.字段间接编码方式</p><p>这种方式代表 <strong>一个字段的某些微操作还需要另一个字段中的某些微命令来解释</strong> , 可以进一步缩短微指令字长, 但削弱了微指令的并行控制能力.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%8E%A7%E5%88%B6_%E5%AD%97%E6%AE%B5%E9%97%B4%E6%8E%A5%E7%BC%96%E7%A0%81.png" alt="微指令控制_字段间接编码"></p><h4 id="10-1-4-微指令序列地址的形成"><a href="#10-1-4-微指令序列地址的形成" class="headerlink" title="10.1.4 微指令序列地址的形成"></a>10.1.4 微指令序列地址的形成</h4><p>通常有四种形成方式:</p><ul><li>下地址字段指出</li><li>根据机器指令的操作码形成</li><li>增量计数器, 即 $ (CMAR) + 1 \to CMAR $</li><li>分支转移:</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E4%B8%8B%E5%9C%B0%E5%9D%80_%E5%88%86%E6%94%AF%E8%BD%AC%E7%A7%BB.png" alt="微指令下地址_分支转移"></p><ul><li>测试网络:</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BE%AE%E6%8C%87%E4%BB%A4%E4%B8%8B%E5%9C%B0%E5%9D%80_%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C.png" alt="微指令下地址_测试网络"></p><ul><li>直接由硬件产生: 通常常见于 <strong>第一条微指令地址的产生</strong> 以及 <strong>中断周期的中断周期微程序</strong></li></ul><h4 id="10-1-5-一些杂项"><a href="#10-1-5-一些杂项" class="headerlink" title="10.1.5 一些杂项"></a>10.1.5 一些杂项</h4><ul><li>水平型微指令: 一次能定义并执行多个并行操作</li><li>垂直型微指令: 类似机器指令操作码, 根据操作码字段规定微指令的功能</li></ul><p>相比而言, 水平型微指令 <strong>并行操作能力强, 灵活性强</strong>, 执行一条机器指令需要的水平型微指令 <strong>数目更少, 速度更快</strong> , 其用较短的微程序结构换取了较长的微指令结构.</p><hr><ul><li>静态微程序: 采用ROM, 微程序不需要改变</li><li>动态微程序: 采用EPROM, 可以通过改变微指令和微程序来改变机器指令</li></ul><hr><p>毫微程序设计</p><p>相当于对微指令进行了进一步细分, 好比微指令相对于机器指令</p><hr><p>串行微程序与并行微程序</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%B2%E8%A1%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F%26%E5%B9%B6%E8%A1%8C%E5%BE%AE%E7%A8%8B%E5%BA%8F.png" alt="串行微程序&amp;并行微程序"></p><h3 id="10-2-微程序设计举例"><a href="#10-2-微程序设计举例" class="headerlink" title="10.2 微程序设计举例"></a>10.2 微程序设计举例</h3><p>所有微指令的涉及到的微命令都在9.1节中有所提及, 这里相当于将其整合, 根据每一条指令需要做的事情列出一个表.</p><p>具体表格见书 $ P_{419} $ , 这里强调几点:</p><ul><li>书中所有的0均省去了</li><li>书中的微指令地址是八进制, 这意味着后续顺序控制字段三位代表八进制一位字符</li></ul><h3 id="10-3-组合逻辑设计"><a href="#10-3-组合逻辑设计" class="headerlink" title="10.3 组合逻辑设计"></a>10.3 组合逻辑设计</h3><h4 id="10-3-1-组合逻辑控制单元框图"><a href="#10-3-1-组合逻辑控制单元框图" class="headerlink" title="10.3.1 组合逻辑控制单元框图"></a>10.3.1 组合逻辑控制单元框图</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E6%A1%86%E5%9B%BE.png" alt="组合逻辑控制单元框图"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F%20%26%20%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F.png" alt="节拍安排"></p><h4 id="10-3-2-微操作的节拍安排"><a href="#10-3-2-微操作的节拍安排" class="headerlink" title="10.3.2 微操作的节拍安排"></a>10.3.2 微操作的节拍安排</h4><p>采用 <strong>同步控制方式</strong></p><p>一个机器周期内有 <strong>3个节拍(即3个时钟周期)</strong></p><p>安排微操作时序的原则如下:</p><ul><li>微操作的先后顺序不得随意更改</li><li>被控对象不同的微操作尽量安排在一个节拍内完成</li><li>占用时间较短的微操作尽量安排在一个节拍内完成, 并允许有先后顺序</li></ul><p>具体各个周期以及执行周期各个命令的节拍安排, 见书 $ P_{396} $ ~ $ P_{398} $</p><p>各个指令在 取指 &#x2F; 间指 &#x2F; 执行阶段的不同节拍内分别干了啥, 请见书 $ P_{402} $</p><h4 id="10-3-3-组合逻辑设计步骤"><a href="#10-3-3-组合逻辑设计步骤" class="headerlink" title="10.3.3 组合逻辑设计步骤"></a>10.3.3 组合逻辑设计步骤</h4><p>1.给出操作时间表(类似书 $ P_{402} $ )</p><p>2.写出微操作命令的最简表达式:</p><p>举例而言, 对于 $ M(MAR) \to MDR $ 这条微操作, 可以写出这样的表达式:</p><p>$$ M(MAR) \to MDR &#x3D; \\<br>FE * T_1 + IND * T_1(ADD+STA+LDA+JMP+BAN) \\<br>T_1 \lbrace FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA) \rbrace $$</p><p>3.画出逻辑图</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/M%28MAR%29%20to%20MDR%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt=" $ M(MAR) \to MDR $ "></p><h2 id="Chap-5-输入输出系统"><a href="#Chap-5-输入输出系统" class="headerlink" title="Chap.5 输入输出系统"></a>Chap.5 输入输出系统</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><h4 id="5-1-1-输入输出系统概况"><a href="#5-1-1-输入输出系统概况" class="headerlink" title="5.1.1 输入输出系统概况"></a>5.1.1 输入输出系统概况</h4><ul><li>早期输入输出系统<ul><li>分散连接方式</li><li>CPU 与 I&#x2F;O 设备串行工作, 采用程序查询方式</li></ul></li><li>接口模块 &#x2F; DMA阶段<ul><li>总线连接方式</li><li>CPU 与 I&#x2F;O 设备并行工作, 采用中断方式 &#x2F; DMA 方式</li></ul></li><li>具有通道结构的阶段</li><li>具有 I&#x2F;O 处理机的阶段</li></ul><h4 id="5-1-2-输入输出系统组成"><a href="#5-1-2-输入输出系统组成" class="headerlink" title="5.1.2 输入输出系统组成"></a>5.1.2 输入输出系统组成</h4><ul><li>I&#x2F;O 软件<ul><li>I&#x2F;O 指令, 是CPU指令的一部分</li><li>通道指令, 指通道自身的指令</li></ul></li><li>I&#x2F;O 硬件<ul><li>设备 &amp; I&#x2F;O接口</li><li>设备 &#x2F; 设备控制器 &#x2F; 通道</li></ul></li></ul><h4 id="5-1-3-I-O-设备与主机的联系方式"><a href="#5-1-3-I-O-设备与主机的联系方式" class="headerlink" title="5.1.3 I&#x2F;O 设备与主机的联系方式"></a>5.1.3 I&#x2F;O 设备与主机的联系方式</h4><ul><li>I&#x2F;O 设备编址方式<ul><li>统一编址: 使用取数 &#x2F; 存数指令即可</li><li>不统一编址: 需要使用专门的 I&#x2F;O 指令</li></ul></li><li>设备选址<ul><li>用设备选择电路识别是否被选中</li></ul></li><li>传送方式<ul><li>串行传送</li><li>并行传送</li></ul></li><li>联络方式<ul><li>立即响应</li><li>异步工作, 采用应答信号(常用于IO设备与主机工作速度不匹配时)</li><li>同步工作, 采用同步时标( <strong>要求 I&#x2F;O 设备与CPU工作速度完全同步</strong> )</li></ul></li><li>连接方式<ul><li>辐射式: 每台设备有一套专门的控制线路和信号线</li><li>总线连接: 通过总线连接所有的 I&#x2F;O 设备( <strong>便于增删设备</strong> )</li></ul></li></ul><h4 id="5-1-4-I-O-设备与主机信息传送的控制方式"><a href="#5-1-4-I-O-设备与主机信息传送的控制方式" class="headerlink" title="5.1.4 I&#x2F;O 设备与主机信息传送的控制方式"></a>5.1.4 I&#x2F;O 设备与主机信息传送的控制方式</h4><ul><li>程序查询方式: CPU 和 IO 串行工作, 踏步等待;</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.png" alt="程序查询方式"></p><ul><li>程序中断方式: CPU不查询, I&#x2F;O 设备准备好后向 CPU 发送中断请求, CPU 暂停当前程序, 进入中断服务程序;</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png" alt="程序中断方式"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F_%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="程序中断方式_流程图"></p><ul><li>DMA方式: 通过周期挪用(周期窃取)使得 CPU 和 I&#x2F;O 设备并行工作;</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E6%96%B9%E5%BC%8F.png" alt="DMA方式"></p><h3 id="5-2-I-O-设备"><a href="#5-2-I-O-设备" class="headerlink" title="5.2 I&#x2F;O 设备"></a>5.2 I&#x2F;O 设备</h3><p>外部设备大致分为三类</p><ul><li>人机交互设备: 键盘 &#x2F; 鼠标 &#x2F; 打印机 &#x2F; 显示器</li><li>计算机信息存储设备: 磁盘 &#x2F; 光盘 &#x2F; 磁带</li><li>机-机通信设备: 调制解调器</li></ul><p>不是计组的主要讲述内容, 这里不进行详细阐述</p><h3 id="5-3-I-O-接口"><a href="#5-3-I-O-接口" class="headerlink" title="5.3 I&#x2F;O 接口"></a>5.3 I&#x2F;O 接口</h3><p>所谓 IO 接口, 指的是主机与 IO 设备之间设置一个硬件电路以及其相应的软件控制.</p><p>设置接口的目的主要是</p><ul><li>实现设备选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串-并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反应设备状态</li></ul><h4 id="5-3-1-接口的功能和组成"><a href="#5-3-1-接口的功能和组成" class="headerlink" title="5.3.1 接口的功能和组成"></a>5.3.1 接口的功能和组成</h4><p>1.总线连接方式</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/IO%E6%8E%A5%E5%8F%A3_%E6%80%BB%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F.png" alt="IO接口_总线连接方式"></p><p>其组成主要为:</p><ul><li>设备选择电路</li><li>命令寄存器 &#x2F; 命令译码器<ul><li>完成触发器 D</li><li>工作触发器 B</li><li>中断请求触发器 INTR</li><li>屏蔽触发器 MASK</li></ul></li><li>数据缓冲寄存器</li><li>设备状态标记</li></ul><h3 id="5-4-程序查询方式"><a href="#5-4-程序查询方式" class="headerlink" title="5.4 程序查询方式"></a>5.4 程序查询方式</h3><h4 id="5-4-1-程序查询流程"><a href="#5-4-1-程序查询流程" class="headerlink" title="5.4.1 程序查询流程"></a>5.4.1 程序查询流程</h4><p>对于单个设备而言, 程序查询方式十分简单:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E5%8D%95%E4%B8%AA%E8%AE%BE%E5%A4%87.png" alt="程序查询_单个设备"></p><p>多个设备, 则需要将很多个这样的电路组合在一起:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87.png" alt="程序查询_多个设备"></p><p>对于程序查询这种方式, 总流程如下:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2_%E6%80%BB%E6%B5%81%E7%A8%8B.png" alt="程序查询_总流程"></p><h4 id="5-4-2-程序查询的接口电路和具体流程"><a href="#5-4-2-程序查询的接口电路和具体流程" class="headerlink" title="5.4.2 程序查询的接口电路和具体流程:"></a>5.4.2 程序查询的接口电路和具体流程:</h4><p>见书 $ P_{191} $ ~ $ P_{192} $</p><h3 id="5-5-程序中断方式"><a href="#5-5-程序中断方式" class="headerlink" title="5.5 程序中断方式"></a>5.5 程序中断方式</h3><p>中断的概念前面有提及, 这里不再详细叙述了, 简而言之, 就是 <strong>暂存程序断点-&gt;进入中断服务程序-&gt;返回程序断点继续执行</strong> 这样的过程.</p><h4 id="5-5-1-I-O-中断的产生"><a href="#5-5-1-I-O-中断的产生" class="headerlink" title="5.5.1 I&#x2F;O 中断的产生"></a>5.5.1 I&#x2F;O 中断的产生</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/IO%E4%BA%A7%E7%94%9F%E4%B8%AD%E6%96%AD_%E4%BE%8B.png" alt="IO产生中断_例"></p><h4 id="5-5-2-中断方式的接口电路"><a href="#5-5-2-中断方式的接口电路" class="headerlink" title="5.5.2 中断方式的接口电路"></a>5.5.2 中断方式的接口电路</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF_%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.png" alt="接口电路_中断方式"></p><p>由于计算机连接的 I&#x2F;O 设备肯定不止一个, 因此不同的中断请求需要被排序, 这涉及到 <strong>排队器</strong> 的设计.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E6%8E%92%E9%98%9F%E5%99%A8.png" alt="中断排队器"></p><p>在中断被触发后, 需要根据对应的中断请求给出相应的中断程序地址(比如打印机的中断请求需要对应打印机的中断服务程序), 因此还涉及到 <strong>中断向量地址形成部件</strong> ;</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E5%9C%B0%E5%9D%80%E5%BD%A2%E6%88%90%E9%83%A8%E4%BB%B6.png" alt="中断向量地址形成部件"></p><p>关于 <strong>中断方式的完整接口电路</strong> , 见书 $ P_{196} $</p><p>此外, 有一道关于中断排队器以及中断向量地址的综合设计例题, 请看书 $ P_{196} $ 的例5.2</p><h3 id="5-5-3-I-O-中断处理过程"><a href="#5-5-3-I-O-中断处理过程" class="headerlink" title="5.5.3 I&#x2F;O 中断处理过程"></a>5.5.3 I&#x2F;O 中断处理过程</h3><ul><li>CPU相应中断的条件<ul><li>允许中断触发器 EINT &#x3D; 1;</li><li>EINT的更改可以通过: <ul><li>开中断: 1 -&gt; EINT</li><li>关中断: 0 -&gt; EINT</li><li>硬件自动复位: 0 -&gt; EINT</li></ul></li></ul></li><li>CPU相应中断的时间<ul><li>D &#x3D; 1 且 MASK &#x3D; 0;</li><li>在每条指令执行阶段的结束前CPU发送中断查询信号(相当于在上面的中断接口电路中将 INTR 置1)</li></ul></li></ul><p>关于 <strong>终端服务程序的流程</strong> :</p><ul><li>保护现场</li><li>中断服务</li><li>恢复现场</li><li>中断返回</li></ul><p>关于 <strong>单重中断与多重中断</strong> :</p><ul><li>单重中断: 一旦某一中断程序开始, 则必须运行完后才能进行下一次中断处理</li><li>多重中断: <strong>允许级别更高的中断源 中断 现行的中断服务程序</strong></li></ul><h3 id="5-6-DMA方式"><a href="#5-6-DMA方式" class="headerlink" title="5.6 DMA方式"></a>5.6 DMA方式</h3><h4 id="5-6-1-DMA方式的特点"><a href="#5-6-1-DMA方式的特点" class="headerlink" title="5.6.1 DMA方式的特点"></a>5.6.1 DMA方式的特点</h4><p>DMA方式与前两者的数据通路并不相同, I&#x2F;O 设备的DMA接口直接与主存相连.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E6%96%B9%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF.png" alt="DMA方式数据通路"></p><p>因此, DMA有三种与主存交换数据的方式:</p><ul><li>停止CPU访问主存: 即让CPU暂停一段时间, 把总线的控制权交给DMA</li><li>周期挪用(周期窃取): <ul><li>CPU此时不访存, 则DMA直接拿到控制权</li><li>CPU此时正在访存, DMA等待</li><li>CPU与DMA同时请求访存, 则CPU将总线控制权交给DMA;</li></ul></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA_%E5%91%A8%E6%9C%9F%E7%AA%83%E5%8F%96.png" alt="DMA_周期窃取"></p><ul><li>CPU与DMA交替访问: 将CPU的工作周期分为两部分, 一部分专供DMA访存, 另一部分供CPU访存.(这种方式 <strong>不需要申请建立和归还总线的使用权</strong> )</li></ul><h4 id="5-6-2-DMA接口的功能和组成"><a href="#5-6-2-DMA接口的功能和组成" class="headerlink" title="5.6.2 DMA接口的功能和组成"></a>5.6.2 DMA接口的功能和组成</h4><p>DMA接口需要实现的功能如下:</p><ul><li>向CPU申请DMA传送</li><li>处理总线控制权的移交</li><li>管理系统总线 &#x2F; 控制数据传送</li><li>确定数据传送的首地址 &#x2F; 长度</li><li>传送结束后, 给出操作完成信号</li></ul><p>其 <strong>工作过程</strong> 主要分三步:</p><ul><li>预处理<ul><li>CPU向DMA输出指令, 预置一些必要信息<ul><li>主存起始地址</li><li>设备地址</li><li>传送数据个数</li></ul></li><li>可看作是DMA接口的初始化过程</li></ul></li><li>数据传送<ul><li>以数据块为单位传送数据</li><li>CPU此时继续执行主程序</li><li>传送结束后DMA向CPU申请中断</li></ul></li><li>后处理<ul><li>CPU停止主程序的执行, 进入中断服务程序</li><li>进行DMA的结束工作<ul><li>是否继续传送<ul><li>继续传送则初始化</li><li>否则停止外设</li></ul></li><li>检查传送过程是否出错</li></ul></li></ul></li></ul><h4 id="5-6-3-DMA方式与中断方式的比较"><a href="#5-6-3-DMA方式与中断方式的比较" class="headerlink" title="5.6.3 DMA方式与中断方式的比较"></a>5.6.3 DMA方式与中断方式的比较</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/DMA%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83.png" alt="DMA与中断方式的比较"></p><h4 id="5-6-4-DMA接口类型"><a href="#5-6-4-DMA接口类型" class="headerlink" title="5.6.4 DMA接口类型"></a>5.6.4 DMA接口类型</h4><ul><li>选择型: 物理上连接多个设备, 但逻辑上只能同时连接一个设备</li><li>多路型: 物理上连接多个设备, 逻辑上允许多个设备同时工作</li></ul><h2 id="Chap-3-系统总线"><a href="#Chap-3-系统总线" class="headerlink" title="Chap.3 系统总线"></a>Chap.3 系统总线</h2><h3 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h3><p>总线, 即 <strong>各个部件共享的传输介质</strong>, 分串行传送和并行传送.</p><p>总线结构的计算机举例:</p><p>1.面向CPU的双总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF.png" alt="面向CPU的双总线"></p><p>2.单总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%95%E6%80%BB%E7%BA%BF.png" alt="单总线"></p><p>3.面向存储器的双总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E9%9D%A2%E5%90%91%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF.png" alt="面向存储器的双总线"></p><h3 id="3-2-总线分类"><a href="#3-2-总线分类" class="headerlink" title="3.2 总线分类"></a>3.2 总线分类</h3><p>大体上, 总线可分为</p><ul><li>片内总线: 即芯片内部的总线</li><li>系统总线<ul><li>数据总线: 双向, 与机器字长 &#x2F; 存储字长有关</li><li>地址总线: 单向, 与存储地址 &#x2F; I&#x2F;O 地址有关</li><li>控制总线: 有出有入</li></ul></li><li>通信总线: 用于 <strong>计算机系统之间</strong> 或 计算机系统与其它系统之间</li></ul><h3 id="3-3-总线的特性与性能指标"><a href="#3-3-总线的特性与性能指标" class="headerlink" title="3.3 总线的特性与性能指标"></a>3.3 总线的特性与性能指标</h3><h4 id="3-3-1-总线的物理实现"><a href="#3-3-1-总线的物理实现" class="headerlink" title="3.3.1 总线的物理实现"></a>3.3.1 总线的物理实现</h4><p>总线位于 <strong>主板</strong> 上, 而连接不同设备是由 <strong>插板</strong> 实现的.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E7%9A%84%E7%89%A9%E7%90%86%E5%AE%9E%E7%8E%B0.png" alt="总线的物理实现"></p><h4 id="3-3-2-总线的特性"><a href="#3-3-2-总线的特性" class="headerlink" title="3.3.2 总线的特性"></a>3.3.2 总线的特性</h4><p>总线有以下几种值得关注的特性</p><ul><li>机械特性: 尺寸 &#x2F; 形状 &#x2F; 管脚数目 &#x2F; 排列顺序</li><li>电气特性: 传输方向 &#x2F; 有效电平范围</li><li>功能特性: 每根传输线的功能</li><li>时间特性: 信号的时序关系</li></ul><h4 id="3-3-3-总线的性能指标"><a href="#3-3-3-总线的性能指标" class="headerlink" title="3.3.3 总线的性能指标"></a>3.3.3 总线的性能指标</h4><ul><li>总线宽度: 数据线根数</li><li>总线带宽: 每秒传输的最大字节数(MBps)</li><li>时钟类型: 同步 &#x2F; 异步</li><li>总线复用: 地址线与数据线复用</li><li>信号线数: 地址线 &#x2F; 数据线 &#x2F; 控制线的总和</li><li>总线控制方式: 并发 &#x2F; 自动 &#x2F; 仲裁 &#x2F; 逻辑 &#x2F; 计数</li><li>其他指标: 负载能力等</li></ul><h3 id="3-4-总线结构"><a href="#3-4-总线结构" class="headerlink" title="3.4 总线结构"></a>3.4 总线结构</h3><h4 id="3-4-1-单总线结构"><a href="#3-4-1-单总线结构" class="headerlink" title="3.4.1 单总线结构"></a>3.4.1 单总线结构</h4><p>前面有所提及:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%95%E6%80%BB%E7%BA%BF.png" alt="单总线"></p><h4 id="3-4-2-多总线结构"><a href="#3-4-2-多总线结构" class="headerlink" title="3.4.2 多总线结构"></a>3.4.2 多总线结构</h4><p>1.双总线:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" alt="双总线结构"></p><hr><p>2.三总线:</p><p>有两种方式.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%281%29.png" alt="三总线结构(1)"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E4%B8%89%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%282%29.png" alt="三总线结构(2)"></p><hr><p>3.四总线</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%9B%9B%E6%80%BB%E7%BA%BF.png" alt="四总线"></p><h3 id="3-5-总线控制"><a href="#3-5-总线控制" class="headerlink" title="3.5 总线控制"></a>3.5 总线控制</h3><h4 id="3-5-1-总线判优控制"><a href="#3-5-1-总线判优控制" class="headerlink" title="3.5.1 总线判优控制"></a>3.5.1 总线判优控制</h4><p>主线中的模块有优先之分:</p><ul><li>主设备(模块): 它对总线有控制权</li><li>从设备(模块): 它响应从主设备发来的总线命令</li><li>判优控制有两种方式<ul><li>集中式<ul><li>链式查询</li><li>计数器定时查询</li><li>独立请求方式</li></ul></li><li>分布式</li></ul></li></ul><hr><p>1.链式查询:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2.png" alt="总线判优_链式查询"></p><p>通过BS &#x2F; BR &#x2F; BG三个信号来决定总线的操作</p><p>2.计数器定时查询:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2.png" alt="总线判优_计数器定时查询"></p><p>通过计数器进行计时, 定时查询各个接口是否需要进行操作</p><p>3.独立请求方式:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98_%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82.png" alt="总线判优_独立请求"></p><p>在总线控制部件内部内置排队器, 接受来自各个接口的请求, 通过排队器决定处理顺序</p><h4 id="3-5-2-总线通信控制"><a href="#3-5-2-总线通信控制" class="headerlink" title="3.5.2 总线通信控制"></a>3.5.2 总线通信控制</h4><p>通信控制的目的在于解决双方的 <strong>协调配合问题</strong> .</p><p>总线传输周期有四个阶段:</p><ul><li>申请分配阶段: 主模块申请, 总线仲裁决定</li><li>寻址阶段: 主模块向从模块给出地址 &#x2F; 命令</li><li>传数阶段: 主模块和从模块交换数据</li><li>结束阶段: 主模块撤销有关信息</li></ul><p>主模块通过总线与从模块的数据通信也分四种:</p><ul><li>同步通信: 通过 <strong>统一时标</strong> 控制数据传送</li><li>异步通信: 采用 <strong>应答方式</strong> , 没有公共时钟标准</li><li>半同步通信: 同步 + 异步</li><li>分离式通信: 为了充分挖掘总线潜力而出现</li></ul><hr><p><strong>1.同步通信:</strong></p><p>通过统一时钟进行数据交互</p><p>以同步式数据输入为例:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.png" alt="同步式数据输入"></p><p>这种方式使得 <strong>速度快的模块必将需要等待速度慢的模块准备完成</strong> 才能进行下一步, 因此会造成资源浪费.</p><p><strong>2.异步通信:</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1.png" alt="异步通信"></p><p>主模块发送请求信号时, 会一直等待从模块的应答信号, 而后再开始传输</p><ul><li>不互锁: 主模块确认从模块接收到请求后, 就撤销请求申请</li><li>半互锁: 主模块收到来自从模块的回答信号后, 再撤销其请求申请</li><li>全互锁: 主模块必须等待从模块回答后, 撤销其请求信号; 同时, 从模块必须等待主模块已经撤销其请求信号后, 才能撤销其应答信号.</li></ul><p><strong>3.半同步通信:</strong></p><p>增加一个 WAIT 信号, 即如果从模块速度过慢, 必须 <strong>在下一个时钟到来前给出 $ \overline{WAIT} $ 信号(低电平)</strong> , 主模块如果检测到这个低电平, 则会主动插入一个 $ T_w $ 进行等待, 直到 $ \overline{WAIT} $ 信号变为高电平了为止.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_Fin/%E5%8D%8A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1.png" alt="半同步通信"></p><p><strong>4.分离式通信</strong></p><p>上述三种通信方法, 都分三个过程:</p><ul><li>主模块发地址 &#x2F; 命令(占用总线)</li><li>从模块准备数据( <strong>占用总线, 但总线空闲</strong> )</li><li>从模块向主模块发送数据(占用总线)</li></ul><p>分离式通信希望将 <strong>第二个过程浪费的总线传输也利用起来</strong> .</p><p>分离式通信将一个传输周期(总线周期)分成了两部分: </p><ul><li>$ T_1 $ : 主模块发送地址 &#x2F; 命令 &#x2F; <strong>自己的编号(在有多个主模块时, 这很重要, 涉及到从模块在下半个周期中的寻址)</strong> , 然后立即放弃总线使用权</li><li>$ T_2 $ : 从模块准备好后, 将收到主模块的编号 &#x2F; 自己的地址 &#x2F; 主模块所需数据发送到总线上, 供对应主模块接受.</li></ul><p>该方法:</p><ul><li>各模块都有权申请占用总线</li><li>采用同步方式通信, 不等对方回答</li><li><strong>在准备数据时不会占用总线(节省了时间)</strong></li><li>总线被占用时, 不会空闲, 一直在传输数据</li></ul><p>充分提高了总线的有效占用.</p><h3 id="3-6-几个名词"><a href="#3-6-几个名词" class="headerlink" title="3.6 几个名词"></a>3.6 几个名词</h3><ul><li>串行传送: 只有一条传输线, 按顺序传送表示一个数码的所有二进制位脉冲信号, 通常 <strong>第一位为最低位, 最后一位为最高位</strong> ;</li><li>位时间: 一个二进制位在传输线上占用的时间长度;</li><li>波特率: 单位时间内传送码元(要用若干个比特表示的最小单位)的数目;</li><li>比特率: 单位时间内传送有效数据比特的数目;</li></ul><hr><p>这篇博文应该是至今以来最长的一篇, 并未分片.</p><p>至此，计算机组成原理这门课的大部分内容就梳理完毕了.</p><p>希望这篇博文能对后来的读者有所帮助, 此外, 博主限于水平有限, 难免出现各种知识上的纰漏与笔误, 还请各位谅解.</p><p>在这里再次对本文引用到PPT的作者致以诚挚的谢意.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Composition Principles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信安数学基础_Fin</title>
      <link href="/posts/56920.html"/>
      <url>/posts/56920.html</url>
      
        <content type="html"><![CDATA[<h1 id="信安数学基础"><a href="#信安数学基础" class="headerlink" title="信安数学基础"></a>信安数学基础</h1><blockquote><p>写在前边，本文是作者应对期末考试写的复习文, 感觉应该有点用, 就顺带着传上来, 其中有些直接标注了ppt页数, 是作者得到的课件, 读者不必太在意.</p><p>另外, 本文大量使用了Mathjax语法, 希望不会引起很多渲染错误吧…</p></blockquote><h2 id="Chap-1-整除，带余除法"><a href="#Chap-1-整除，带余除法" class="headerlink" title="Chap.1 整除，带余除法"></a>Chap.1 整除，带余除法</h2><h3 id="1-1-基础概念阐述"><a href="#1-1-基础概念阐述" class="headerlink" title="1.1 基础概念阐述"></a>1.1 基础概念阐述</h3><p>全体整数的集合Z，全体自然数的集合N</p><p>整除的记法： <strong>a|b</strong> ，称为 <strong>b被a整除</strong> ，意味着 <strong>b是a的倍数，a是b的因子</strong> 。</p><h3 id="1-2-整除的性质"><a href="#1-2-整除的性质" class="headerlink" title="1.2 整除的性质"></a>1.2 整除的性质</h3><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%95%B4%E9%99%A4%E7%9A%84%E6%80%A7%E8%B4%A8.png" alt="整除的性质"></p><h3 id="1-3-素数"><a href="#1-3-素数" class="headerlink" title="1.3 素数"></a>1.3 素数</h3><p>素数即 <strong>其正因子只有1和它自己</strong> 的整数。反之，则称为 <strong>合数</strong> 。</p><p>对于素数和合数，有几个定理：</p><ul><li>合数的最小真因子一定是素数（Chap1 P14）</li><li>素数有无穷多个（Chap1 P15）</li></ul><p>素数分布： <strong>$ \pi(x) $</strong> 表示 <strong>不超过x的素数的个数</strong> 。</p><p>比较好的估计方法——素数定理： <strong>$ \pi(x) \approx \frac{x}{lnx}, x\to\infty $</strong></p><p>具体去看Chap1 P19</p><h3 id="1-4-带余除法"><a href="#1-4-带余除法" class="headerlink" title="1.4 带余除法"></a>1.4 带余除法</h3><p>$$ b &#x3D; qa + r $$</p><p>显然，r &#x3D; 0 是 a|b 的充要条件</p><p>这里有两个取法：</p><ul><li>最小正剩余：r取值范围为 (0, a-1);</li><li>最小绝对剩余：r取值范围围绕0左右；</li></ul><p>一般都取最小正剩余。</p><hr><p>根据这种带余除法，可以根据除数对于整个整数集Z分类。即</p><p>$$ S_{a, j} &#x3D; a*k+j $$</p><p>这其中：</p><ul><li>$ j &#x3D; 0, 1, …, a-1 $</li><li>$ k &#x3D; 0, \pm 1, \pm2, … $</li></ul><p>相当于将Z分成了a类，每类中的数字除以a所得的余数就是j。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%95%B4%E6%95%B0%E5%88%86%E7%B1%BB.png" alt="整数分类的性质"></p><p>关于 <strong>进制转换，见 Chap1 P34</strong> ，这里不再赘述。</p><h2 id="Chap-2-最大公因子，欧几里得算法"><a href="#Chap-2-最大公因子，欧几里得算法" class="headerlink" title="Chap.2 最大公因子，欧几里得算法"></a>Chap.2 最大公因子，欧几里得算法</h2><h3 id="2-1-公因子-最大公因子"><a href="#2-1-公因子-最大公因子" class="headerlink" title="2.1 公因子 &amp; 最大公因子"></a>2.1 公因子 &amp; 最大公因子</h3><p>公因子： <strong>d|a 且 d|b</strong> ，则d是a、b的公因子。</p><p>最大公因子就是其中最大的那个。</p><p>记法： <strong>$ gcd(a_1, a_2, …, a_n) $</strong></p><p>性质：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BE%8B.png" alt="最大公因子性质_例子"></p><p>更严谨一点的说法：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8.png" alt="最大公因子性质"></p><p>关于这些性质的证明, 见Chap.2 P9</p><p>这其中第二条用的尤其多, 意味着最大公因子前后是可以互相加减的. </p><h3 id="2-2-互素"><a href="#2-2-互素" class="headerlink" title="2.2 互素"></a>2.2 互素</h3><p>如果 $ gcd(a_1, a_2) &#x3D; 1 $ , 则称a1, a2是互素的.</p><p>$ gcd(a_1, a_2, a_3, …, a_n) &#x3D; 1 $ , 称他们整体互素.</p><p>如果他们之间任意两个都互素, 则称 a1, a2, …, ak <strong>两两互素</strong> .</p><p>显然, 根据上面的性质5, $ 两两互素\implies整体互素 $ , <strong>反之不然</strong> .</p><hr><p>费马数:</p><p>$$ F_n &#x3D; 2^{2^n}+1 , n为非负整数$$</p><p>任意两个不同的费马数互素. 关于这个定理的证明, 见Chap2 P13</p><p>明确一点: <strong>两个合数也有可能互素, 即便它们是合数</strong> , 如8和15, 或者费马数F5(这是个合数).</p><hr><p>有关互素的最大公因子性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BA%92%E7%B4%A0%E7%9B%B8%E5%85%B3%281%29.png" alt="最大公因子性质_互素(1)"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%E6%80%A7%E8%B4%A8_%E4%BA%92%E7%B4%A0%E7%9B%B8%E5%85%B3%282%29.png" alt="最大公因子性质_互素(2)"></p><p>最后这一条比较重要, 欧几里得算法成立的基础就是这玩意.</p><p>更多最大公因子的性质, 见Chap.2 P18 以及 Chap.2 P21</p><h3 id="2-3-最小公倍数"><a href="#2-3-最小公倍数" class="headerlink" title="2.3 最小公倍数"></a>2.3 最小公倍数</h3><p>公倍数: a|d 且 b|d, 称d为a, b的公倍数.</p><p>最小公倍数, 即其中最小的那个, 记作 $ [a, b] $ .</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E6%80%A7%E8%B4%A8.png" alt="最小公倍数性质"></p><p>有一个需要摁记住的, <strong>$ [a_1, a_2](a_1, a_2) &#x3D; |a_1a_2| $</strong></p><h3 id="2-4-最大公因子的求解-欧几里得算法"><a href="#2-4-最大公因子的求解-欧几里得算法" class="headerlink" title="2.4 最大公因子的求解-欧几里得算法"></a>2.4 最大公因子的求解-欧几里得算法</h3><p>基本思路:</p><p>$$ (a, b) &#x3D; (qb+r, b) &#x3D; (r, b) $$</p><p>将大的数字换成小的数字的带余除法形式, 而后依据最大公因子性质2, 直接将乘积去掉.</p><p>这个方法也叫做 <strong>辗转相除法</strong> .</p><p>直到没有余数为止, 此时的数字被就是二者的最大公因子.</p><hr><p>扩展欧几里得算法, 可以将 gcd(a, b) 表示成 a, b的线性组合的形式.</p><p>具体过程就是从下向上推, 每一次将余数换掉就可以了.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Euclid%E7%AE%97%E6%B3%95%E4%BE%8B.png" alt="Euclid算法例"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%89%A9%E5%B1%95Euclid%E7%AE%97%E6%B3%95%E4%BE%8B.png" alt="扩展Euclid算法例"></p><p>关于这个,可以扩展出一个性质: </p><p><strong>a, b的整系数线性组合恰好构成了 gcd(a, b)的所有整数倍.</strong></p><p>而如果a, b互素, 即gcd(a, b) &#x3D; 1, 则任何整数都可以被表示成a, b的整系数线性组合了.</p><hr><p>这里还要给一个方法, 用于给出一个整数x 如何用a, b线性组合表示出来.</p><p>首先, 如果x可以用a, b的线性组合表示, 则 gcd(a, b)|x 必定成立.</p><p>那么, 我们先用欧几里得算法以及扩展欧几里得算法算出gcd(a, b), 以及gcd(a, b)如何用a, b线性表示.</p><p>而后在式子前面乘上x与gcd(a, b)的倍数即可.</p><hr><p>关于其它的性质, 见Chap.2 P48</p><h3 id="2-5-一次不定方程的求解"><a href="#2-5-一次不定方程的求解" class="headerlink" title="2.5 一次不定方程的求解"></a>2.5 一次不定方程的求解</h3><p>一次不定方程:</p><p>$$ a_1x_1+a_2x_2+…+a_nx_n &#x3D; c $$</p><p>其有解的充要条件是, $ gcd(a_1, a_2, …, a_n)|c $</p><hr><p>主要看二元一次不定方程: $ ax+by &#x3D; c $</p><p>如果该方程已经有一组解: $ (x_0, y_0) $ , 则我们可以给出其全部解:</p><p>$$<br>\begin{cases}{c}<br>    x &#x3D; x_0+\frac{b}{(a, b)}t \\<br>    y &#x3D; y_0+\frac{a}{(a, b)}t \<br>\end{cases}<br>$$</p><p>由此, 我们明确了二元一次不定方程的求解:</p><ul><li>验证是否有解: 即 $ gcd(a, b)|c $ 是否成立</li><li>如果有解, 利用扩展欧几里得算法求出一组特解(相当于通过扩展欧几里得算法将c表达成a, b的线性组合的形式), 而后根据上面的公式给出通解.</li></ul><h3 id="2-6-算术基本定理"><a href="#2-6-算术基本定理" class="headerlink" title="2.6 算术基本定理"></a>2.6 算术基本定理</h3><p>通俗的讲, 就是 <strong>任何大于1的整数都能化为有限个素数的乘积</strong> .</p><p>利用公式表达:</p><p>$$ a&gt;1 \implies a &#x3D; p_1p_2…p_s $$</p><p>这其中, p1, p2, …都是素数</p><hr><p>推论: <strong>标准素因数分解式</strong></p><p>$$ a &#x3D; p_1^{\alpha_1}p_2^{\alpha_2}…p_n^{\alpha_n} $$</p><p>通过这个式子,我们可以给出求最大公因式以及最小公倍数的比较简单的方法:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%A0%87%E5%87%86%E7%B4%A0%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3_%E9%87%8D%E8%A6%81%E6%8E%A8%E8%AE%BA.png" alt="标准素因数分解_重要推论"></p><ul><li>最大公因数: 把每个素因子取最小值,相乘即可.</li><li>最小公倍数: 把每个素因子取最大值,相乘即可.</li></ul><p>这个玩意也能用于证明一些东西, 具体见Chap.2 P79.</p><hr><p>素因式的更多推论, 见Chap.2 P82</p><h2 id="Chap-3-同余"><a href="#Chap-3-同余" class="headerlink" title="Chap.3 同余"></a>Chap.3 同余</h2><h3 id="3-1-同余-概述"><a href="#3-1-同余-概述" class="headerlink" title="3.1 同余_概述"></a>3.1 同余_概述</h3><p>若m, a, b 满足 $ m|a-b $ , 则我们称a, b同余, 记作:</p><p>$$ a \equiv b\space (mod\space m) $$</p><p>跟前面带余除法其实挺像的, 也分非负最小剩余和绝对最小剩余, 这里一般用非负最小剩余来写.</p><hr><p>同余的性质:</p><p>显然, 既然叫同余了, 自然能得到如下定理, 即 <strong>a, b被m除后所得余数相同</strong> .</p><p>对于同余式左右而言, 加法 \ 减法 \ 乘法均成立, 但除法比较特殊. </p><p>$$ ca \equiv cb\space(mod\space m) \iff<br>a \equiv b \space (mod \space \frac{m}{(c, m)}) $$</p><p>显然, 当且仅当c, m互素, 即(c, m) &#x3D; 1时, 消去律(除法)才能成立.</p><h3 id="3-2-乘法逆元-重要概念"><a href="#3-2-乘法逆元-重要概念" class="headerlink" title="3.2 乘法逆元(重要概念)"></a>3.2 乘法逆元(重要概念)</h3><p>若 $ m&gt;1 $ , 且 $ (a, m) &#x3D; 1 $ , 如果存在 c 使:</p><p>$$ ca \equiv 1 \space(mod \space m) $$</p><p>我们就可以把c称为a对m的逆元, 记为 $ a^{-1}(mod \space m) $</p><hr><p>乘法逆元的求法?</p><p>利用欧几里得算法.</p><p>因为 (a, m) &#x3D; 1 , 则有 $ sa + tm &#x3D; 1 $ , 即1可以通过 a 和 m 的线性组合表示, 只需要取 c &#x3D; s 即满足要求.</p><p>至于怎么求解线性组合, 这是第二章的事情, 忘了往回看.</p><hr><p>乘法逆元的性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E6%80%A7%E8%B4%A8.png" alt="乘法逆元的性质"></p><hr><p>给两类典型题目:</p><p>1.分数的最小剩余:</p><p>求 $ \frac{53}{46} \space (mod \space 25) $</p><p>相当于: $ 3 * (46)^{-1} \space (mod \space 25) $</p><p>就需要算一个46关于25的乘法逆, 也就是21关于25的乘法逆.</p><p>给出过程供参考:</p><ul><li>$ (21, 25) &#x3D; 1 $</li><li>$ 1 &#x3D; 6*21 + (-5)*25 $</li><li>21关于25的乘法逆就是6</li></ul><p>因此 $ \frac{53}{46} \space (mod \space 25)  &#x3D; 3*6 &#x3D; 18 $</p><p>2.大数带余除法</p><p>求 $ 3^{1001} mod\space 13 $</p><p>利用同余式子的可乘性质(最好找一个除以模数模1的, 这样能直接消掉):</p><p>$ 3^3 \equiv 1\space(mod\space 13) $</p><p>则:</p><p>$ 3^{3*333} &#x3D; 3^{999} \equiv 1\space(mod\space 13) $</p><p>因此:</p><p>$ 3^{1001}\space(mod\space 13) &#x3D; 3^2\space(mod\space 13) &#x3D; 9 $</p><hr><p>关于换模的条件:</p><p>如果 $ d&gt;1 且 d|m $ , 并且同余式 $ a\equiv b \space (mod\space m) $ 成立;</p><p>则能推出 $ a\equiv b\space(mod\space d) $</p><p>由上面这个式子, 可以得到推论:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%8D%A2%E6%A8%A1%E6%8E%A8%E8%AE%BA.png" alt="换模推论"></p><h3 id="3-3-剩余类和剩余系"><a href="#3-3-剩余类和剩余系" class="headerlink" title="3.3 剩余类和剩余系"></a>3.3 剩余类和剩余系</h3><h4 id="3-3-1-剩余类"><a href="#3-3-1-剩余类" class="headerlink" title="3.3.1 剩余类"></a>3.3.1 剩余类</h4><p>根据除以模数 m 所得的余数对于整数集合Z进行分类.</p><p>总共m个剩余类, 每个剩余类的代表元是: 0, 1, 2, …, m-1</p><p>如果该剩余类的 <strong>代表元与模数m互素</strong> , 称这个剩余类为m的 <strong>既约剩余类</strong> , 既约剩余类的总个数即欧拉函数(Eular函数), 记作 $ \varphi(m) $</p><p>两个记法:</p><p>所有m的剩余类组成的集合:</p><p>$$ Z_m $$</p><p>所有m的既约剩余类组成的集合:</p><p>$$ Z_m^* $$</p><p>有时候为了简写, 会通过一个代表元来表示一整个集合:</p><p>$$ Z_{12} &#x3D; \lbrace 0, 1, 2, 3, …, 11\rbrace $$</p><p>$$ Z_{12}^* &#x3D; \lbrace 1, 5, 7, 11 \rbrace $$</p><blockquote><p>剩余类是一堆同余的整数组成的集合</p></blockquote><h4 id="3-3-2-剩余系"><a href="#3-3-2-剩余系" class="headerlink" title="3.3.2 剩余系"></a>3.3.2 剩余系</h4><p>从 <strong>每个剩余类中取出一个元素</strong> (即共取出m个元素), 组成一个集合, 叫做m的一个完全剩余系.</p><p>相应的, 从 <strong>每个既约剩余系中取出一个元素</strong> (即共取出 $ \varphi(m) $ 个元素), 组成一个集合, 叫做m的一个既约剩余系.</p><p>完全剩余系最简单的取法就是取 {0, 1, …, m-1}</p><p>既约剩余系最简单的取法就是取 <strong>小于m的,与m互素的元素</strong> .</p><h3 id="3-4-欧拉函数-欧拉定理-Euler定理"><a href="#3-4-欧拉函数-欧拉定理-Euler定理" class="headerlink" title="3.4 欧拉函数 &amp; 欧拉定理(Euler定理)"></a>3.4 欧拉函数 &amp; 欧拉定理(Euler定理)</h3><p>前面提到, $ \varphi(m) $ 是m的既约剩余类的个数.</p><p><strong>三条性质:</strong> </p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8.png" alt="欧拉函数的性质"></p><p><strong>这三条能够解决全部整数欧拉函数的求法</strong></p><hr><p><strong>两条推论:</strong> </p><p>除了 $ \varphi(1) &#x3D; \varphi(2) &#x3D; 1 $ , 对于其余的欧拉函数, 都有:</p><p>$$ 2|\varphi(m) $$</p><p>对于任意n:</p><p>$$ \sum_{d|n} \varphi(d) &#x3D; n $$</p><p>即 <strong>n的所有因子 (包括n自己) 的欧拉函数相加等于n</strong></p><hr><p><strong>欧拉定理:</strong></p><p>如果 (a, m) &#x3D; 1(a与m互素), 则:</p><p>$$ a^{\varphi(m)} \equiv 1 \space(mod\space m) $$</p><p><strong>费马小定理:</strong></p><p>p为素数, 则:</p><p>$$ \varphi(p) &#x3D; p-1 $$</p><p>这定理挺好理解的, 就是素数有p-1个既约剩余系(把代表元为0的既约剩余系抛了就行)</p><p>结合欧拉定理, 有:</p><p>$$ a^{\varphi(p)} &#x3D; a^{p-1} \equiv 1\space(mod\space p) $$</p><hr><p>欧拉定理给出了另一种求a对于m乘法逆元的方式:</p><p>$$ a^{-1} \equiv a^{\varphi(m)-1}\space(mod\space m) $$</p><hr><p>有了欧拉带余除法, 我们再看这类题:</p><p>2.大数带余除法</p><p>求 $ 3^{1001} mod\space 13 $</p><p>利用同余式子的可乘性质(最好找一个除以模数模1的, 这样能直接消掉):</p><p>要找一个除以模数余1的就很简单: 因为 $ 3^{\varphi(13)} &#x3D; 3^{12} \equiv 1\space(mod\space 13) $</p><p>此后消去 $ 3^{12} $ 的元即可, 即:</p><p>$$ 3^{1001} &#x3D; 3^{12*83}*3^{5} $$</p><p>即计算:</p><p>$$ 3^5 \space(mod\space 13) $$</p><p>结果相同.</p><h2 id="Chap-4-同余方程"><a href="#Chap-4-同余方程" class="headerlink" title="Chap.4 同余方程"></a>Chap.4 同余方程</h2><h3 id="4-1-一元高次同余方程的概念"><a href="#4-1-一元高次同余方程的概念" class="headerlink" title="4.1 一元高次同余方程的概念"></a>4.1 一元高次同余方程的概念</h3><p>同余方程：</p><p>$$ f(x) &#x3D; a_nx^n + … + a_1x+a_0 $$</p><p>形如: </p><p>$$ f(x) \equiv 0\space(mod\space m) $$</p><p>的同余式叫做模m的同余方程.</p><p>我们将满足上面的式子的x&#x3D;c称作该方程的一个解.</p><p>显然, 如果c是上面方程的一个特解, 那么c对于m的同余类中的所有数都应当是上面这个方程的解(有关m的因子可以直接消掉)</p><p><strong>同余方程的次数就是多项式的次数</strong></p><p><strong>从本质上, 同余方程就是系数取自 $ Z_m $ 的方程</strong></p><p>接下来是两个问题:</p><ul><li>有没有解?</li><li>有多少解?</li><li>如何求解?</li></ul><hr><p>关于有没有解这个问题:</p><p><strong>同余方程 $ f(x) \equiv 0\space(mod\space m) $ 有解的必要条件是, 对于m的每个因子d (即d|m) , $ f(x) \equiv 0\space(mod\space d) $ 均有解.</strong></p><p>这个定理使得可以 <strong>通过简单的枚举来判断一个同余方程是不是无解.</strong></p><p>如: $ f(x) \equiv 0\space(mod\space 15) $</p><p>可以先枚举 $ f(1), f(2), f(3) $ , 判断 $ f(x) \equiv 0\space(mod\space 3) $ 有没有解, 如果模3都无解, 则模15必定无解.</p><hr><p>关于有多少解这个问题:</p><p>考虑模数是素数的情况:</p><p>$$ f(x) \equiv 0\space(mod\space p) $$</p><p>的解数不会超过 f(x) 的次数 n.</p><hr><p>关于如何求解这个问题:</p><p><strong>穷举法:</strong></p><p>首先, 也是最简单的方法, 直接从1到p-1穷举.</p><p><strong>多项式化简:</strong></p><p>其次, 通过多项式的性质来化简系数和次数.</p><p>1.化简系数:</p><p>如将 $ 15x^2 + 20x + 12(mod\space 11) $ 化简为 $ 4x^2+9x+1(mod\space 11) $ .</p><p>2.化简次数:</p><p>如果 $ f(x) &#x3D; q(x)h(x) + r(x) $ , 并且 $ h(x) \equiv 0(mod\space m) $ 是恒等同余式, 则可以将原方程化简为 $ r(x) \equiv 0(mod\space m) $</p><p><strong>关键在于找这个h(x)</strong></p><p>如果m是素数, 那这个式子可以用欧拉-费马小定理直接给出:</p><p>$$ x^{\varphi(p)} \equiv 1(mod\space p) $$</p><p>即(把1挪到左边, 两侧同乘x):</p><p>$$ x^{p} - x \equiv 0(mod\space p) $$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B_%E5%8C%96%E7%AE%80%E6%AC%A1%E6%95%B0.png" alt="同余方程_化简次数"></p><blockquote><p>上面这两个方法其实本质目的在于 <strong>把f(x)变得更简单</strong> , 从而更轻松的进行枚举.</p></blockquote><h3 id="4-2-一次同余方程"><a href="#4-2-一次同余方程" class="headerlink" title="4.2 一次同余方程"></a>4.2 一次同余方程</h3><p>一次同余方程是最简单的情况:</p><p>$$ ax \equiv b(mod\space m) $$</p><p>1.a,m同余的情况:</p><p>根据同余式的除法性质, 当(a, m) &#x3D; 1时(即a, m互素), 可以直接将a除到右边.</p><p>此时就一个解: $ x \equiv a^{-1}b(mod\space m) $</p><p>2.一般情况:</p><p>此时有解的充要条件是:</p><p>$$ (a, m)|b $$</p><p>同时, 解数也正好是 (a, m);</p><p>其通解正好是: $ x \equiv x_0 + \frac{m}{(a,m)}t(mod\space m) $</p><p>这里: t &#x3D; 0, 1, …, (a, m)-1;</p><p><strong>可以类比一次不定方程的解法, 事实上, 这俩几乎一模一样</strong></p><p>因为可以直接将上面这个同余方程等价于:</p><p>$$ ax + my &#x3D; b $$</p><p><strong>因此</strong> ,我们继续类比一次不定方程的解题过程:</p><ul><li>判断有没有解: 即(a,m)|b是否成立</li><li>如果有解, 通过扩展Euclid算法计算一个特解</li><li>利用公式给出通解</li></ul><h3 id="4-3-一次同余方程组"><a href="#4-3-一次同余方程组" class="headerlink" title="4.3 一次同余方程组"></a>4.3 一次同余方程组</h3><p>一次同余方程组的通用形式:</p><p>$$ f_i(x) \equiv 0(mod\space m_i) $$</p><p>i可以取多个值.</p><p>通过 <strong>孙子定理</strong> 可以对一次同余方程组进行刻画与求解</p><hr><p>孙子定理:</p><p>设 $ m_1, m_2, …, m_k $ <strong>两两互素</strong> , 则对于任意整数 $ a_1, a_2, …, a_k $ , 一次同余方程组:</p><p>$$ x \equiv a_i(mod\space m_i) , \space 1\leq i\leq k$$</p><p>一定有解, 并且解在模m的意义下唯一.</p><p>这个唯一解是:</p><p>$$ x \equiv a_1t_1M_1 + … + a_kt_kM_k(mod\space m) $$</p><p>其中:</p><ul><li>$ a_i $ : 就是每个方程后面的整数</li><li>$ m &#x3D; m_1 * m_2 * … * m_k &#x3D; m_i * M_i $</li><li>$ t_iM_i \equiv 1(mod\space m_i) $ , 即ti是Mi在模mi意义下的乘法逆元 (Mi的定义上面已经给出)</li></ul><hr><p>给个例子:</p><p>$$<br>    \begin{cases}{c}<br>        x \equiv 2(mod\space 3) \\<br>        x \equiv 3(mod\space 5) \\<br>        x \equiv 2(mod\space 7) \<br>    \end{cases}<br>$$</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86_%E4%BE%8B.png" alt="孙子定理_例"></p><hr><p>如果 <strong>模数两两不互诉?</strong></p><p>$$<br>    \begin{cases}{c}<br>        4x \equiv 14(mod\space 15) \\<br>        9x \equiv 11(mod\space 20) \<br>    \end{cases}<br> $$</p><p>先要将其拆开, 如下:</p><p>$$<br>    \begin{cases}{c}<br>        4x \equiv 14(mod\space 3) \\<br>        4x \equiv 14(mod\space 5) \\<br>        9x \equiv 11(mod\space 4) \\<br>        9x \equiv 11(mod\space 5) \<br>    \end{cases}<br> $$</p><p>对上面的方程式一一化简即可</p><p>$$<br>    \begin{cases}{c}<br>        x \equiv 2(mod\space 3) \\<br>        x \equiv 1(mod\space 5) \\<br>        x \equiv 3(mod\space 4) \\<br>        x \equiv -1(mod\space 5) \<br>    \end{cases}<br> $$</p><p>而后, 有矛盾则无解, 无矛盾则依照正常解法求解即可</p><h2 id="Chap-5-二次剩余"><a href="#Chap-5-二次剩余" class="headerlink" title="Chap.5 二次剩余"></a>Chap.5 二次剩余</h2><h3 id="5-1-二次剩余概述"><a href="#5-1-二次剩余概述" class="headerlink" title="5.1 二次剩余概述"></a>5.1 二次剩余概述</h3><p>二次同余方程:</p><p>$$ ax^2 + bx + c &#x3D; 0(mod\space p) $$</p><p>解法如下:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B_%E8%A7%A3%E6%B3%95.png" alt="一元二次同余方程_解法"></p><p>这玩意看一眼就行, 主要为了引出二次剩余.</p><hr><p><strong>二次剩余:</strong></p><p>素数 p&gt;2 , (p, d) &#x3D; 1.</p><p>如果 $ x^2 \equiv d(mod\space p) $ 有解, 称d是模p的二次剩余.</p><p>如果无解,则称d是模p的二次非剩余.</p><p>记法:</p><p>二次剩余全体组成的集合:</p><p>$$ QR_p &#x3D; \lbrace a|a\in Z^*_p, 存在x\in Z^*_p使得x^2 \equiv a(mod\space p)\rbrace $$</p><p>二次非剩余组成的集合:</p><p>$$ QR_p &#x3D; \lbrace a|a\in Z^*_p, 任意x\in Z^*_p均有x^2 \ne a(mod\space p)\rbrace $$</p><blockquote><p>这里直接表明了a属于p的既约非剩余系, 是因为前面提到了(p, d) &#x3D; 1</p></blockquote><p>给个例子:</p><p>$$ QR_7 &#x3D; \lbrace 1, 2, 4 \rbrace $$</p><p>$$ NQR_7 &#x3D; \lbrace 3, 5, 6 \rbrace $$</p><hr><p>关于既约剩余系中二次剩余与二次非剩余的个数:</p><p><strong>二次剩余与二次非剩余各占一半, 即: $ |QR_p| &#x3D; |NQR_p| &#x3D; \frac{p-1}{2} $</strong></p><hr><p><strong>如何判别 d 是否是 模p 的二次剩余?</strong></p><p>欧拉判别法:</p><p><strong>d 是 模p 的二次剩余的充要条件:</strong></p><p>$$ d^{\frac{p-1}{2}} \equiv 1(mod\space p) $$</p><p><strong>d 是 模p 的二次非剩余的充要条件:</strong></p><p>$$ d^{\frac{p-1}{2}} \equiv -1(mod\space p) $$</p><p>推论: Chap.5 P16 P17</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99_%E4%B9%98%E7%A7%AF%E5%88%A4%E5%88%AB%E6%8E%A8%E8%AE%BA.png" alt="二次剩余_乘积判别"></p><blockquote><p>这个d的次方可能很大,具体该怎么算,参见前面的大数带余除法问题(3.4 &amp; 3.2)</p></blockquote><h3 id="5-2-Legendre符号"><a href="#5-2-Legendre符号" class="headerlink" title="5.2 Legendre符号"></a>5.2 Legendre符号</h3><p><strong>Legendre符号定义:</strong></p><p>设素数p &gt; 2, 令:</p><p>$$ (\frac{d}{p}) &#x3D;<br>    \begin{cases}{c}<br>        0, 当p|d时 \\<br>        1, 当d是p的二次剩余时 \\<br>        -1, 当d是p的二次非剩余时 \<br>    \end{cases}<br> $$</p><p>我们称 $ (\frac{d}{p}) $ 为 <strong>模p的Legendre符号</strong></p><hr><p>Legendre符号性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Legendre%E7%AC%A6%E5%8F%B7%E6%80%A7%E8%B4%A8.png" alt="Legendre符号性质"></p><blockquote><p>由第一条, Legendre符号就是欧拉判别式的另一种写法.</p></blockquote><hr><p>Legendre符号的有效计算: Gauss二次互反律</p><p>设p, q都是奇素数, 那么:</p><p>$$ (\frac{q}{p})(\frac{p}{q}) &#x3D; (-1)^{(\frac{p-1}{2})(\frac{q-1}{2})} $$</p><blockquote><p>如果p, q不是奇素数, 请利用Legendre符号的性质3, 将其转化为奇素数.<br>划出来的2, 可以用性质5求解</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/Gauss%E4%BA%8C%E6%AC%A1%E4%BA%92%E5%8F%8D%E5%BE%8B_%E4%BE%8B.png" alt="Gauss二次互反律_例"></p><p>更复杂的例子, 见Chap.5 P28.</p><h2 id="Chap-6-原根与指数"><a href="#Chap-6-原根与指数" class="headerlink" title="Chap.6 原根与指数"></a>Chap.6 原根与指数</h2><h3 id="6-1-阶-原根"><a href="#6-1-阶-原根" class="headerlink" title="6.1 阶 &#x2F; 原根"></a>6.1 阶 &#x2F; 原根</h3><p>讨论：</p><p>$$ a^x \equiv b(mod\space m) $$</p><p>这方程目前不会涉及, 但一种最简单的情况需要考虑: 即</p><p>$$ a^x \equiv 1(mod\space m) $$</p><p>使得这个式子成立的 <strong>最小的正整数</strong> x 被称为 <strong>a模m的阶</strong> , 记作 $ ord_m(a) $ .</p><p>特别的, 如果 <strong>$ ord_m(a) &#x3D; \varphi(m) $</strong> 时, 称a是 <strong>模m的原根</strong> .</p><hr><p>阶的性质:</p><ul><li><strong>与代表元无关:</strong></li></ul><p>如果a和b在关于模m的同一个 <strong>既约剩余类</strong> 中, 即:</p><p>$$ b \equiv a(mod\space m) , \space (a, m) &#x3D; 1$$</p><p>则我们一定能推出:</p><p>$$ ord_m(a) &#x3D; ord_m(b) $$</p><ul><li><strong>阶的周期性:</strong></li></ul><p>即如果有:</p><p>$$ a^d \equiv 1(mod\space m) $$</p><p>则必定能推出:</p><p>$$ ord_m(a)|d $$</p><blockquote><p>相当于阶这个概念自己划定了一个周期, 每经过一个周期, 都会再次回到1.</p></blockquote><ul><li><strong>阶与欧拉函数:</strong></li></ul><p>对任何正整数m, 均有:</p><p>$$ ord_m(a)|\varphi(m) $$</p><blockquote><p>说明任何元素模m的阶, 都必定是m欧拉函数的因子.</p></blockquote><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/17%E7%9A%84%E5%8E%9F%E6%A0%B9.png" alt="17的原根"></p><ul><li><strong>性质4见Chap.6 P15(a的乘方同余, 则乘方之间有关系)</strong></li><li><strong>乘法逆元的阶:</strong></li></ul><p>有:</p><p>$$ ord_m(a) \equiv ord_m(a^{-1}) $$</p><ul><li><strong>a的k次幂的阶与a有关(Chap.6 P17)</strong></li></ul><p>有: </p><p>$$ ord_m(a^k) &#x3D; \frac{ord_m(a)}{(ord_m(a), k)} $$</p><ul><li><strong>原根个数:</strong></li></ul><p><strong>如果m有原根(这是大前提)</strong> , 则m的原根个数必然是:</p><p>$$ \varphi(\varphi(m)) $$</p><p>并且所有原根的集合:</p><p>$$ \lbrace g^i|(i, \varphi(m)) &#x3D; 1, 1\leq i&lt;\varphi(m) \rbrace $$</p><p>这其中:</p><ul><li>g是m的其中一个原根;</li><li>i是乘方数, 必须满足与m的欧拉函数互素;</li></ul><p>举例而言:(还是上面那个17的原根的例子)</p><p>17的原根个数:</p><p>$$ \varphi(\varphi(17)) &#x3D; \varphi(16) &#x3D; \varphi(2^4) &#x3D; 2^3*(2-1) &#x3D; 8 $$</p><p>最后这步是欧拉函数的性质1. (详见3.4)</p><ul><li><p><strong>性质7, 8见Chap.6 P20, 21</strong></p></li><li><p><strong>一个数有原根的充要条件:</strong></p></li></ul><p>当:</p><p>$$ m &#x3D; 2, 4, p^\alpha, 2p^\alpha $$ </p><p>时, m一定有原根.</p><p>这其中:</p><ul><li>p 是奇素数;</li><li>$ \alpha $ 是任意正整数;</li></ul><p>这条性质, 和上面那条原根个数的性质, 能够轻松的判断出 <strong>一个正整数是否有原根, 有多少原根.</strong></p><hr><p>原根的有效求解:</p><p>在m有原根的前提下, 对于 $ \varphi(m) $ 所有的素因子 $ q_1, q_2, …, q_s $ , g是模m的原根的充要条件是:</p><p>$$ g^{\frac{\varphi(m)}{q_j}} \neq 1(mod\space m), \space j &#x3D; 1, 2, …, s $$</p><p>上面这个式子其实不是一个直接计算的式子, 只能算一个检验式.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%B1%82%E5%8E%9F%E6%A0%B9_%E4%BE%8B.png" alt="求原根_例"></p><hr><p><strong>关于原根生成的剩余系:</strong></p><p>任意原根g都可以生成模m的既约剩余系, 即</p><p>$$ \lbrace g^0, g^1, …, g^{\varphi(m)-1} \rbrace $$</p><p>这时, 我们称呼g为模m既约剩余系的一个生成元.</p><blockquote><p>请务必明确, 每个原根都能生成一个既约剩余系, 但这 <strong>不代表每个既约剩余类的代表元都是原根.</strong></p></blockquote><h3 id="6-2-指数"><a href="#6-2-指数" class="headerlink" title="6.2 指数"></a>6.2 指数</h3><p>指数的概念由原根引出.</p><p>g为m的原根, 给定与m互素的元素a, 则必定存在一个指数 $ \gamma $ , 使得:</p><p>$$ a \equiv g^{\gamma}(mod\space m) $$</p><p>我们称这个 $ \gamma $ 为 <strong>a对模m的以g为底的指数</strong>.</p><p>这个概念建议结合上面原根能够生成既约剩余系的性质来理解. 因为原根必定能够生成一个剩余系, 所以这个指数必定存在(这里的a就相当于一个既约剩余类的代表元).</p><hr><p>引入指数, 主要是为了这个性质:</p><p>g是模m的原根, a与m互素(即(a, m) &#x3D; 1), 则:</p><p>$$ ord_m(a) &#x3D; \frac{\varphi(m)}{(ind_{m, g}(a), \varphi(m))} $$</p><p>这性质的推论很重要.</p><p>推论即: <strong>当模m有原根时, 对于每个正除数d| $ \varphi(m) $ , 在模的一个既约剩余系中, 恰好有 $ \varphi(d) $ 个元素的阶等于d.</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%8C%87%E6%95%B0%E6%80%A7%E8%B4%A8_%E4%BE%8B.png" alt="指数性质_例"></p><p><strong>这个结论后来证明对一般循环群也是对的.</strong></p><h2 id="Chap-7-多项式"><a href="#Chap-7-多项式" class="headerlink" title="Chap.7 多项式"></a>Chap.7 多项式</h2><blockquote><p>从这一章开始, 会将讨论范围扩大到多项式, 而不仅仅限制在整数域内</p></blockquote><h3 id="7-1-多项式的概念"><a href="#7-1-多项式的概念" class="headerlink" title="7.1 多项式的概念"></a>7.1 多项式的概念</h3><p>$$ K[x] &#x3D; \lbrace a_nx^n + a_{n-1}x^{n-1} + … + a_1x+a_0|\space a_i \in K \rbrace $$</p><p>这里的K可以指代整数Z, 有理数Q, 实数R, 复数C中的任意一个.</p><p>多项式的运算此处不再赘述, 仅定义一个多项式的次数:</p><p>$$ deg\space f $$</p><p>表示多项式f(x)中最高次项的次数.</p><h3 id="7-2-多项式上的整除-不可约-唯一分解"><a href="#7-2-多项式上的整除-不可约-唯一分解" class="headerlink" title="7.2 多项式上的整除 \ 不可约 \ 唯一分解"></a>7.2 多项式上的整除 \ 不可约 \ 唯一分解</h3><p>类似于整数域, 多项式域内也可以定义整除的概念:</p><p>$$ f(x) &#x3D; g(x)h(x) $$</p><p>记作: $ g(x)|f(x) $</p><p>相似的, 如果找不到这么个 h(x) , 那么记作: $ g(x) \nmid f(x) $ .</p><hr><p>多项式整除的性质:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%A4%9A%E9%A1%B9%E5%BC%8F_%E6%95%B4%E9%99%A4%E6%80%A7%E8%B4%A8.png" alt="多项式_整除性质"></p><hr><p>多项式的不可约性:</p><p>$ deg\space p \geq 1$ , 并且在K[x]这个域中仅有平凡分解(就是因子只有1和它自己), 则称p(x)是K[x]内的不可约多项式.</p><p>虽然多项式的不可约性随着K所指向的域的变化而变化, 但至少有两个域中, 可以划等号:</p><p>$$ f(x)在Z[x]中不可约 \iff f(x) 在Q[x]中不可约 $$</p><hr><p>多项式在K[x]上的唯一分解:</p><p>因为有不可约多项式的存在(可以理解为 <strong>多项式域上的素数</strong> ), 因此每个多项式也必然能够通过一系列不可约多项式表示出来.</p><p>$$ f(x) &#x3D; c * p_1(x)^{e1} * p_2(x)^{e2} * … * p_t(x)^{e_t} $$</p><h3 id="7-3-不可约多项式的判别方法"><a href="#7-3-不可约多项式的判别方法" class="headerlink" title="7.3 不可约多项式的判别方法"></a>7.3 不可约多项式的判别方法</h3><p>又称爱森斯坦判别法(Eisenstein判别法)</p><p>$$ f(x) &#x3D; a_nx^n + …+ a_0 $$</p><p>f(x)是整系数多项式, 如果存在一个素数p, 使得 $ p\nmid a_n $ , $ p^2 \nmid a_0 $ , 但对于剩余的 $ i&lt;n $, 都存在 $ p|a_i $, 则f(x)在Z(Q)上均不可约.</p><h3 id="7-4-模p约化"><a href="#7-4-模p约化" class="headerlink" title="7.4 模p约化"></a>7.4 模p约化</h3><p>将多项式f(x)的所有系数化为它们的模p剩余类的代表元(就相当于模p)的过程.</p><p>为什么要引入这个概念, 因为以下这个定理是一个非常重要的判别不可约多项式的定理:</p><p>如果f(x)的模p约化的多项式 $ \overline{f} $ 在 $ Z_p[x] $ 中不可约, 那么f(x) 在 Z[x] 中一定不可约.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E6%A8%A1p%E7%BA%A6%E5%8C%96%E5%88%A4%E5%AE%9A%E4%B8%8D%E5%8F%AF%E7%BA%A6%E2%80%94%E2%80%94%E4%BE%8B.png" alt="模p约化判定不可约_例"></p><h2 id="Chap-8-域上的一元多项式"><a href="#Chap-8-域上的一元多项式" class="headerlink" title="Chap.8 域上的一元多项式"></a>Chap.8 域上的一元多项式</h2><h3 id="8-1-环和域"><a href="#8-1-环和域" class="headerlink" title="8.1 环和域"></a>8.1 环和域</h3><blockquote><p>就是离散中的概念, 这里不会很详细的说明.</p></blockquote><p>(R, +)构成交换群, (R, *)构成半群, 则(R, +, *)称为环, 特别的, 如果 * 运算 <strong>也满足交换律, 则称为交换环</strong> .</p><p>显然, 对于多项式环, 就是一个很典型的交换环.</p><hr><p>域:</p><p>交换环的基础上, R中的所有元素都 <strong>乘法可逆</strong> , 则称为域.</p><ul><li>$ Z_p $ 是域, 这里p是素数</li><li>$ Z_m $ , 如果m是合数, 那就不是域, 因为并非所有的元素都有乘法逆元(乘法逆元存在的前提是必须互素, 而合数并不是跟其中所有元素都互素, 比如2在 $ Z_4 $ 中就没有乘法逆元).</li></ul><h3 id="8-2-域上的一元多项式"><a href="#8-2-域上的一元多项式" class="headerlink" title="8.2 域上的一元多项式"></a>8.2 域上的一元多项式</h3><p>我们上面介绍的多项式的整除 \ 可约 \ 不可约 均可以类似的搬下来. 不过要注意, 这里的域可能会由于带余除法的存在导致一些此前不成立的性质.</p><p>显然, K[x] 上有无穷多个首项系数为 1 的不可约多项式.</p><p>同时还有定理:</p><p>设p(x)不可约, 如果 $ p(x) | f(x)g(x)…h(x) $ , 那么p(x)至少整除它们其中之一(即p(x)至少是它们其中之一的因子).</p><blockquote><p>上面这个定理, 类比整数上由很多素数乘积组成的合数.</p></blockquote><h3 id="8-3-域上多项式的不可约性判定"><a href="#8-3-域上多项式的不可约性判定" class="headerlink" title="8.3 域上多项式的不可约性判定"></a>8.3 域上多项式的不可约性判定</h3><p>上面提到了, 只要多项式在 $ Z_m $ 域上不可约, 则多项式在Z上就是不可约的.</p><p>如何判断多项式在 $ Z_m $ 上不可约?</p><hr><p>1.当m较小时, 可以用筛法:</p><p>如 $ Z_2 $上全部小于等于三次的不可约多项式:</p><ul><li>1次多项式均不可约</li><li>2次多项式可约当且仅当它有1次多项式因子 -&gt; 将全部因子两两相乘枚举出来所有可约的, 剩下的就是不可约的.</li><li>3次多项式同理.</li></ul><hr><p>2.当m较大时, 二次多项式是否可约可以通过二次剩余解决:</p><p>由于二次多项式的形式: $ f(x) &#x3D; ax^2+bx+c $</p><p>其可约代表着: $ f(x) \equiv 0(mod\space m) $ 有解.</p><p>即令 $ X &#x3D; b^2 + 4 * a * c $ ;</p><p>如果X是模m的二次剩余, 则方程有解, f(x)可约;</p><p>如果X是模m的二次非剩余, 则方程无解, f(x)不可约;</p><p>至于X是不是模m的二次剩余, 则利用Legendre符号 $ (\frac{X}{m}) $ 来进行判断.</p><blockquote><p>Legendre符号的计算见5.2</p></blockquote><h3 id="8-4-最大公因式-欧几里得算法"><a href="#8-4-最大公因式-欧几里得算法" class="headerlink" title="8.4 最大公因式 &amp; 欧几里得算法"></a>8.4 最大公因式 &amp; 欧几里得算法</h3><p>同理, 域上的多项式也有其最大公因式, 同样可以利用欧几里得算法进行求解, 只不过要把整数带余除法变更为多项式带余除法.</p><p>比如: $ (x^2-1, x^2+x-2) $ 的求解过程:</p><ul><li>$ x^2+x-2 &#x3D; 1*(x^2-1) + (x-1) $ , 转变为求 $ (x^2-1, x-1) $</li><li>$ x^2-1 &#x3D; (x+1)*(x-1) $</li><li>最大公因式: x-1;</li></ul><p>相应的, 这个过程也可以逆推回去, 跟整数的欧几里得扩展算法一个道理, 这里不再详述.</p><blockquote><p>提一下, 每次求出结果之后别忘了根据域的范围化简, 比如在 $ Z_2 $ 中, 所有的带2的项都可以直接消掉</p></blockquote><hr><p>很显然, 当两个多项式的最大公因式为1时(类比整数互素), <strong>两个多项式可以通过扩展欧几里得算法求得一个关于另一个的乘法逆元.</strong></p><p>具体步骤与整数那里完全相同:</p><ul><li>利用欧几里得算法求出 $ (f(x), g(x)) &#x3D; 1 $ ;</li><li>利用扩展欧几里得算法将1表示成两个多项式的线性组合 $ 1 &#x3D; f(x)*h(x) + g(x)*\varphi(x) $</li><li>h(x)就是该域上f(x)关于g(x)的乘法逆元, 可以表达为: $ f(x)*h(x) \equiv 1(mod\space g(x)) $</li></ul><h2 id="Chap-9-多项式同余"><a href="#Chap-9-多项式同余" class="headerlink" title="Chap.9 多项式同余"></a>Chap.9 多项式同余</h2><h3 id="9-1-多项式同余-剩余类环"><a href="#9-1-多项式同余-剩余类环" class="headerlink" title="9.1 多项式同余 \ 剩余类环"></a>9.1 多项式同余 \ 剩余类环</h3><p>我们还是要类比整数域上的同余计算, 即</p><p>$$ f(x) \equiv g(x)(mod\space m(x)) $$</p><p>只不过这里全换成了多项式.</p><p>显然, 对于m(x), 肯定也存在很多个剩余类, 但这里的剩余类的个数与域有关:<br>比如, 在 $ Z_2[x] $ 中, $ x^2+1 $ 的所有剩余类代表元:</p><p>$$ 0, 1, x, x+1, x^2 $$</p><p>由m(x)在域K[x]上的所有剩余类构成的环, 叫做模m(x)的剩余类环, 记作:</p><p>$$ K[x] &#x2F; (m(x)) $$</p><h3 id="9-2-多项式剩余类域"><a href="#9-2-多项式剩余类域" class="headerlink" title="9.2 多项式剩余类域"></a>9.2 多项式剩余类域</h3><p>当m(x)不可约时(类比到整数域中m是素数), 此时除了0所在剩余类, 其他的剩余类均可逆.</p><p>此时这个剩余类环构成了一个域.</p><blockquote><p>关于多项式的乘法逆怎么求: 类比整数域, 通过多项式域中的扩展欧几里得算法进行计算.(见8.4)</p></blockquote><h3 id="9-3-多项式版本中国剩余定理"><a href="#9-3-多项式版本中国剩余定理" class="headerlink" title="9.3 多项式版本中国剩余定理"></a>9.3 多项式版本中国剩余定理</h3><p>当遇到多项式同余方程组时, 可以用多项式版本的中国剩余定理来求解, 具体形式与整数域完全相同.</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80_Fin/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%89%88%E6%9C%AC%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86.png" alt="多项式版本中国剩余定理"></p><ul><li>先将后面的模数改为两两互素的形式</li><li>套公式, 求逆</li><li>得到通解即可</li></ul><p>至此, 信安数学基础这门课的主要内容就结束了.</p><hr><p>这篇博文就到这里.</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematical basis of Information Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blockchain</title>
      <link href="/posts/41829.html"/>
      <url>/posts/41829.html</url>
      
        <content type="html"><![CDATA[<h1 id="区块链（Blockchain）"><a href="#区块链（Blockchain）" class="headerlink" title="区块链（Blockchain）"></a>区块链（Blockchain）</h1><blockquote><p>写在前面, 本文主要针对区块链的技术原理与实际应用进行说明.<br>当前, 区块链的技术主要应用领域仍然是加密货币, 因此不可避免地本文需要对加密货币进行一些相关的说明. 但本文完全不推荐, 或推崇无谓的挖矿行为, 烦请读者不要先入为主, 理性看待本文所描述的技术.</p><p>本文主要基于 《区块链技术与应用》(北京大学 肖臻教授) 的课程进行笔记整理与内容扩展, 文中除开视频内容外,也会涉及到一些博主自己的思考, 烦请读者理性看待. 在此也附上视频链接(<a href="https://www.bilibili.com/video/BV1Vt411X7JF?p=1&vd_source=4565edcb254cb6582d6382ac80011294">https://www.bilibili.com/video/BV1Vt411X7JF?p=1&amp;vd_source=4565edcb254cb6582d6382ac80011294</a>), 有了他们的工作, 才能让区块链这一技术为更多人所知.</p><p>在此, 对 肖臻教授 以及 北京大学相应课程组 表达诚挚的敬意与感激!</p></blockquote><h2 id="Part1-区块链是个啥？"><a href="#Part1-区块链是个啥？" class="headerlink" title="Part1. 区块链是个啥？"></a>Part1. 区块链是个啥？</h2><p>引用一段来自维基百科的定义：</p><blockquote><p><em>A blockchain is a distributed ledger with growing lists of records (blocks) that are securely linked together via <strong>cryptographic hashes</strong>.</em></p></blockquote><p>根据这段定义我们可以得知，区块链这玩意其实就是一个账本，它可以通过哈希算法将一串东西连在一起，这也是它被称作“链”的原因。</p><p>更形象的一段话：</p><blockquote><p><em>Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data (generally represented as a Merkle tree, where data nodes are represented by leaves). Since each block contains information about the previous block, they effectively form a chain (compare linked list data structure), with each additional block linking to the ones before it.</em></p></blockquote><p>意味着这玩意大小可变，后续增加进去的“块”会附带着前一个区块的信息（包括哈希值、时间戳、交易数据）。同时这个过程事实上是不可逆的：</p><blockquote><p><em>once they are recorded, the data in any given block cannot be altered retroactively without altering all subsequent blocks.</em></p></blockquote><p>同时，区块链往往和 Web3.0 联系紧密，即分布式互联网的思想。这意味着你只违规的修改自己手中的账本是无用的，因为它并没有被大众所认可，只有遵循相应的规则，才能够在所有拥有这个账本的人的文件中，添上一笔。</p><h2 id="Part2-密码学原理"><a href="#Part2-密码学原理" class="headerlink" title="Part2. 密码学原理"></a>Part2. 密码学原理</h2><p>上方引用的定义中，有一个词还挺引人注目的： <em><strong>Cryptographic hashes</strong></em>。</p><p>事实上，我们很容易想象到这个玩意的意义，要确定一个规则不易被攻破，则自然需要一个算法（也可称为密码算法），我们称呼这个密码学标准为： <em><strong>Cryptographic hash function</strong></em> ，即加密哈希函数。</p><h3 id="2-1-哈希（Hash）"><a href="#2-1-哈希（Hash）" class="headerlink" title="2.1 哈希（Hash）"></a>2.1 哈希（Hash）</h3><h4 id="2-1-1-Collision-Resistance"><a href="#2-1-1-Collision-Resistance" class="headerlink" title="2.1.1 Collision Resistance"></a>2.1.1 Collision Resistance</h4><p>我们在排序的时候其实对哈希这个玩意做过一定的说明，这里引出一个哈希中比较重要的概念：“Collision Resistance” ，中文称为该哈希函数的抗碰撞性。哈希碰撞是一个哈希算法中常有的情况，即：给出了两个不同的输入x，y，而通过哈希函数算出的函数值H(x)，H(y) 却是相同的。很显然，我们需要尽可能降低这种情况发生的可能性。</p><blockquote><p>注意：我们需要明确，哈希碰撞理论上是不可避免的，因为哈希函数的取值范围是人为框定的，而哈希函数的输入值（或者说自变量取值）可以趋近于无穷大。因此我们说的 “Collision Resistance” 要做到的是 <em><strong>没有一个非常高效的方法来人工制造哈希碰撞</strong></em> ，这个概念其实还挺重要的。我们无法阻止攻击者采取暴力破解（Brute-force）的方式来破解哈希算法，我们能做到的是尽可能拉长他们需要花费的时间，使得它们破解这个哈希算法的行为在这个时间长度的影响下趋近于无意义。</p></blockquote><p>哈希这个玩意的另一个作用在于可以保证一个文件（message，我们简称为M）不被篡改，因为这个M里面的值一旦被改了，其哈希函数值H(M)也必定会发生改变，这就被其他人所共知了。</p><p>但很遗憾的是，Collision Resistance这么重要的性质，在数学上的严谨证明是不存在的，因此我们只能凭借现实中的经验来判断一个哈希函数的抗碰撞系数高与低。</p><blockquote><p>这一点在维基百科的 <em><strong>Collision resistance</strong></em> 词条中有一段阐述：<br><em>Cryptographic hash functions are usually designed to be collision resistant. However, many hash functions that were once thought to be collision resistant were later broken. MD5 and SHA-1 in particular both have published techniques more efficient than brute force for finding collisions. However, some hash functions have a proof that finding collisions is at least as difficult as some hard mathematical problem (such as integer factorization or discrete logarithm). Those functions are called provably secure.</em><br>这段话指出很多曾经被认为非常安全的哈希函数后来被找到了比暴力破解更加高效的破解方法，也由此被攻破（如MD5, SHA-1）</p></blockquote><h4 id="2-1-2-Hiding"><a href="#2-1-2-Hiding" class="headerlink" title="2.1.2 Hiding"></a>2.1.2 Hiding</h4><p>即隐匿的，不可知的。啥意思呢，就是哈希函数的计算过程是单向的，完全不可逆的。这意味着我们可以通过一个输入x来求解一个H(x)，但通过H(x)却完全不能确定x的任何信息。</p><p>当然，我们上面提到了，由于暴力破解（Brute-force）这种方法的存在，因此完全不可逆的哈希函数是不存在的，顶到天上，我们可以把所有自变量枚举一遍，而后哪个自变量算出的哈希函数值与H(x)相同，则哪个值就是原函数值即可。</p><p>这就代表着，要写出一个尽可能 “Hidding” 的算法，首先需要输入空间（自变量取值）足够大，其次需要哈希函数值分布比较均匀。这才能尽可能加大攻击者破解这个算法的难度。</p><h4 id="2-1-3-Digital-Commitment"><a href="#2-1-3-Digital-Commitment" class="headerlink" title="2.1.3 Digital Commitment"></a>2.1.3 Digital Commitment</h4><p>这个概念也被称为 <strong>Digital Equivalent of a sealed envelope</strong></p><p>这玩意不是很好理解，东西可以看成一个电子密封信封，信封外的东西是完全公开的，而信封内的东西我们并不知道。但是我们又可以通过信封外公开的信息来确保信封内的东西没有被篡改过。</p><p>具体怎么达成的呢？<br>利用我们上方提到的 <strong>Hiding</strong> 特性，达成了通过公开内容（哈希值）无法得到私密内容（原输入）<br>利用上方的 <strong>Collision Resistance</strong> 特性，保证了只要私密内容被篡改了，则公开内容必然发生变化。</p><p>当然，上述两个目标是任何一个哈希算法都要兼顾的，但有些哈希算法的输入控件不够大，那就不满足 <strong>Hiding</strong> 这个基本要求。<br>此时我们常常采用附加随机数的方法，即在原输入后方加一个足够大的随机数，然后一并算出它们的哈希值。我们一般用 <strong>H(x||nonce)</strong> 来表示这个值。</p><ul><li>H:哈希函数</li><li>x:原输入</li><li>nonce:附加随机值</li></ul><h4 id="2-1-4-Puzzle-Friendliness"><a href="#2-1-4-Puzzle-Friendliness" class="headerlink" title="2.1.4 Puzzle Friendliness"></a>2.1.4 Puzzle Friendliness</h4><blockquote><p>注意，这个性质，是比特币（Bitcoin）中所额外要求的性质。</p></blockquote><p>维基百科上这样描述这个性质：</p><p><em>Puzzle friendliness is a property of cryptographic hash functions. Not all cryptographic hash functions have this property.</em></p><p><em>Informally, a hash function is puzzle friendly if no solution exists, which is better than just making random guesses and the only way to find a solution is the brute force method. Although the property is very general, it is of particular importance to proof-of-work, such as in Bitcoin mining.</em></p><p>其意义为这个哈希算法目前为止不存在有效预测方法（只能 Brute-force）。它要求这个哈希值的计算是不能准确预测的，即我希望得到一个特定的哈希值，我只能通过枚举自变量来确定其正确输入。</p><p>看到这里，如果此前的内容都理解了，读者大概率会碰到这么个问题： Hidding 和 Puzzle Friendliness 这俩不是一个东西吗？</p><hr><p>Difference between Hidding &amp; Puzzle Frientliness</p><p>我们给出一个哈希值：y &#x3D; H(x|r)，这里 y 是输出， x; r 是输入</p><p>对于Hiding而言，我们干的是这么一件事：</p><p>Given an output of a hash function (y), it is infeasible to find an input (x).</p><p><em><strong>Note, r is not given.</strong></em></p><p>而对于Puzzle Frientliness而言，我们干的是另一件事：</p><p>Given an output of a hash function (y) and part of the input (r), it is difficult to find an input (x).</p><p><em><strong>Note, r is given.</strong></em></p><p>所以 Hiding 希望你无法高效的找到完整的输入，而 Puzzle Frientliness 是已经给了你一部分输入，希望你无法高效的找到另一部分的输入。</p><hr><p>好的，现在我们搞明白了两个性质的区别，那这又跟 Bitcoin 有啥关系呢？</p><p>我们在这里简要的讲述一下 Bitcoin 的获取方法（即挖矿过程）</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Total%20space%20%26%20Target%20space.png" alt="Total space &amp; Target space"></p><p>如上图所见，Total space 其实就是你能取到的所有哈希值（函数值域），而 Target space 是我们的目标，我们需要找到一个特定的输入，使得这个输入在进行哈希运算后取到的值恰好处于 Target space 内。</p><p>而在 Bitcoin 中，给出的输入格式是这样的：H(Block Header)，这其中，Block Header 内有很多的 <strong>域</strong> ，这茫茫多的 域 中有一个名叫 <strong>nonce</strong> ，它就是我们能够设置的随机数。</p><p>挖矿的过程就是通过 Brute Force 的方法，持续不断的取随机数，算哈希，并找到了符合要求的哈希值的过程。而我们上面说的 Puzzle Friendliness 这个性质，就意味着这个过程没有捷径，只能暴力求解。</p><p>这种没有捷径的过程能够提供 <strong>工作量证明</strong> ，即 <strong>Proof of work</strong> ，代表着你确实做出了足够的工作量来得到这样一个输入。</p><h4 id="2-1-5-Difficult-to-Solve-Easy-to-Verify"><a href="#2-1-5-Difficult-to-Solve-Easy-to-Verify" class="headerlink" title="2.1.5 Difficult to Solve &#x2F; Easy to Verify"></a>2.1.5 Difficult to Solve &#x2F; Easy to Verify</h4><p>通过上面的性质，我们很容易就能理解这个条目在讲什么。</p><p>我寻找一个有效的随机数 nonce 的过程是非常难的，需要大量的工作量。但我只要找到了这个 nonce ，别人要验证这个 nonce 是否正确是很容易的，因为验证过程仅仅需要一次哈希运算即可</p><hr><p>额外提一嘴：</p><p>SHA-256 是 Bitcoin 中所采用的哈希算法。其全称为 <strong>Secure Hash Algorithm</strong> 。</p><hr><h3 id="2-2-签名（Digital-Signature）"><a href="#2-2-签名（Digital-Signature）" class="headerlink" title="2.2 签名（Digital Signature）"></a>2.2 签名（Digital Signature）</h3><h4 id="2-2-1-Symmetric-Encryption-Algorithm"><a href="#2-2-1-Symmetric-Encryption-Algorithm" class="headerlink" title="2.2.1 Symmetric Encryption Algorithm"></a>2.2.1 Symmetric Encryption Algorithm</h4><p>即 <strong>对称的加密体系</strong> ，也称 <strong>Symmetric-key algorithm</strong> 。</p><p>这个体系的目的很明确，在于加密，保证信息传输过程中不被窃取或篡改。</p><p>它采用的方法是：收发两端采用相同（或者经过简单的转化）的密钥来进行加密 &#x2F; 解密操作。</p><p><em>Symmetric-key algorithms are algorithms for cryptography that use the same cryptographic keys for both the encryption of plaintext and the decryption of ciphertext. The keys may be identical, or there may be a simple transformation to go between the two keys.</em><br>—— Wikipedia</p><p>这种方法的前提在于有一个安全的渠道，能够将密钥安全的由 发送方 送给 接收方。这也是对称加密体系的弱点之一，密钥的分发非常不方便。</p><h4 id="2-2-2-Asymmetric-Encryption-Algorithm"><a href="#2-2-2-Asymmetric-Encryption-Algorithm" class="headerlink" title="2.2.2 Asymmetric Encryption Algorithm"></a>2.2.2 Asymmetric Encryption Algorithm</h4><p>即 <strong>非对称的加密体系</strong> ，也称 <strong>Asymmetric cryptography</strong> 。</p><p>非对称的加密体系采用了一对钥匙，即 <strong>公钥</strong> 和 <strong>私钥</strong> 。加密使用公钥，而解密使用私钥。在信息传输时，发送方 利用 <strong>接收方的公钥</strong> 来加密信息，并传给接收方，而后接收方再用自己的私钥来解密发送方传来的信息。</p><p>显然，公钥是公开的，而私钥必须要保管好，自己留着。</p><p>通过这个模式，解决了对称加密体系中密钥分发过于繁琐的问题。</p><h4 id="2-2-3-与-Bitcoin-的关联？"><a href="#2-2-3-与-Bitcoin-的关联？" class="headerlink" title="2.2.3 与 Bitcoin 的关联？"></a>2.2.3 与 Bitcoin 的关联？</h4><p>在 Bitcoin 中，由于其采用 <strong>去中心化</strong> 的思想，因此是没有所谓的 银行 来管理你的账户的，一个(公钥；私钥)对就是一个账户。</p><p>我们形象的理解一下，公钥相当于你的账号，这是可以公开的，别人给你转账必须要得知你的公钥。而私钥相当于你的密码，只有知道你的密码的人才能够取出这个账户上的钱。</p><p>但是问题来了， Bitcoin 中好像并不需要这个对？因为它的哈希算法是完全公开的。</p><p>这就要引出这一主题的概念： <strong>签名</strong> 。</p><h4 id="2-2-4-签名"><a href="#2-2-4-签名" class="headerlink" title="2.2.4 签名"></a>2.2.4 签名</h4><p>签名这一概念是为了保证一笔交易是真正由 <strong>署名的发起方</strong> 发起的，而不是有人冒名顶替的。</p><p>那这里如何保证这个发起方就是我呢？答案是我利用 私钥 来进行签名，而后所有人看到这笔交易之后都有权利利用我所公开的公钥来验证这个签名。</p><p><em>Two main properties are required:<br>First, the authenticity of a signature generated from a fixed message and fixed private key can be verified by using the corresponding public key.<br>Secondly, it should be computationally infeasible to generate a valid signature for a party without knowing that party’s private key. A digital signature is an authentication mechanism that enables the creator of the message to attach a code that acts as a signature.</em><br>—— Wikipedia</p><p>在 Bitcoin 中，一般是先对 message 进行哈希，而后对产生的哈希值进行签名。</p><h2 id="Part3-数据结构"><a href="#Part3-数据结构" class="headerlink" title="Part3. 数据结构"></a>Part3. 数据结构</h2><h3 id="3-1-哈希指针（Hash-Pointers）"><a href="#3-1-哈希指针（Hash-Pointers）" class="headerlink" title="3.1 哈希指针（Hash Pointers）"></a>3.1 哈希指针（Hash Pointers）</h3><p>指针这玩意我们很熟悉了，在C和C++里面用的很多。</p><p>哈希指针概念与其类似，但额外加了点东西。它不仅要存储一个结构体的地址，同时要存储 <strong>这个结构体对应的哈希值</strong> ，我们用 <strong>H()</strong> 来表示一个哈希指针。</p><p><em>A regular pointer gives you a way to retrieve the information. A hash pointer will let us ask to get the information back and verify that the information hasn’t changed. So a hash pointer tells us where something is and what it’s value was.</em></p><p>上面这段话很好的描述了哈希指针的好处，它不光可以获得信息存储的位置，同时也可以检测存储的信息是否遭到了修改。（具体方式可以回顾此前的 <strong>密码学原理</strong> 部分）</p><p>为什么我们要提到哈希指针呢？我们需要引出 <strong>区块链</strong> 这个重要内容。</p><h3 id="3-2-哈希链表"><a href="#3-2-哈希链表" class="headerlink" title="3.2 哈希链表"></a>3.2 哈希链表</h3><p>字如其名，区块链本身是由一个个区块组成的链表。但这个链表有其特殊之处。其中一个最显著的特点，区块链中使用的指针是哈希指针。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Blockchain_chain.png" alt="HashChain"></p><p>我们这里着重强调几个概念：</p><ul><li>Genesis Block: 即起始区块</li><li>H(): 后续每个区块中都会有的哈希指针，这个哈希指针的哈希值是通过对它前面一整个区块的 <strong>所有内容（包括里面的哈希指针）</strong> 运算得到的。</li><li>Most recent Block: 整个链条的最后一个区块，这个区块的哈希指针被保存在系统中。</li><li>Tamper-evident log: 区块链能够实现的一个性质，我们能够看出，这一整个链条中无论哪个块的内容被篡改了，都会导致最终存储在系统内的哈希值发生更改。这代表着我们只要 <strong>记住最后的这个哈希值</strong> ，就能够检测 <strong>一整个链表</strong> 是否被篡改过。</li></ul><p>这种存储方式还有个好处：区块链是很长的，因此一个节点内不可能存储一整个链表的内容，这就表示如果我需要一个我没有保存的节点（我们称之为 节点1 ）的内容，则我需要向别的保存过 节点1 的节点（我们称之为 节点2 ）索取相应的信息。而哈希指针能够保证 节点2 给我的内容是正确的，而非经过篡改的。</p><blockquote><p>我们需要额外提一嘴，哈希链表 <strong>不能是循环链表</strong> ，因为如果带有环状结构，则会出现循环依赖，一个节点被篡改了，最终哪个节点的哈希值都定不下来。</p></blockquote><h3 id="3-3-Merkle-Tree-Binary-hash-Tree"><a href="#3-3-Merkle-Tree-Binary-hash-Tree" class="headerlink" title="3.3 Merkle Tree (Binary hash Tree)"></a>3.3 Merkle Tree (Binary hash Tree)</h3><p>我们应该比较熟悉 Binary Tree，就是普通的二叉树。</p><p>这里我们看到括弧里面的名字应该能想个大概，即哈希二叉树。</p><p><em>A hash tree, also known as a Merkle tree, is a tree in which each leaf node is labeled with the cryptographic hash of a data block, and each non-leaf node is labeled with the cryptographic hash of its child nodes’ labels.</em></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Merkle%20Tree.png" alt="Merkle Tree"></p><p>我们还是说几个概念：</p><ul><li>Data block: 即 <strong>数据块</strong> ，指整个 Merkle Tree 最底层的节点。</li><li>Hash block: 即 <strong>指针块</strong> ，指 Merkle Tree 上层的节点，每个节点内储存了其左右孩子的哈希指针。</li><li>Root hash: 即 <strong>根哈希值</strong> ，指对整个 Merkle Tree 最上面的节点取哈希，保存在系统中。</li></ul><p>我们可以发现，与哈希链表很相似的是，只要整个 Merkle Tree 中哪一个节点被篡改了，最上面我们保存的哈希值就会发生改变。这也可以让我们很方便的得知整个数据是否遭到过篡改。</p><hr><p>在Bitcoin中，每个区块之间利用哈希指针连接在一块，而每个区块内所包含的交易则通过一颗Merkle Tree进行组织。而每个区块内的 Block Header 内存放着这棵 Merkle Tree 的 Root Hash ；每个区块内的 Block Body 中存放着各项交易的交易记录。</p><hr><h3 id="3-4-Merkle-Proof（Proof-of-Membership-Proof-of-Inclusion）"><a href="#3-4-Merkle-Proof（Proof-of-Membership-Proof-of-Inclusion）" class="headerlink" title="3.4 Merkle Proof（Proof of Membership &#x2F; Proof of Inclusion）"></a>3.4 Merkle Proof（Proof of Membership &#x2F; Proof of Inclusion）</h3><p>我们说回 Merkle Tree 。</p><p>Merkle Tree 的一大作用是提供 <strong>Merkle Proof</strong> 。这个玩意的意思是我需要证明 <strong>某一笔交易确确实实的发生了</strong> 。</p><p>在Bitcoin中，节点被分为 <strong>全节点</strong> 与 <strong>轻节点</strong> ，全节点中包含了 Block Header 与 Block Body，这使得查询某一笔交易是否发生变得十分可行。</p><p>但轻节点中只保存了 Block Header（即只保留了哈希值），我们应该怎么证明这笔交易发生了呢？</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Merkle%20Proof.png" alt="Merkle Proof"></p><p>具体过程是这样：</p><ul><li>首先，这个轻节点向某一个全节点发送请求，并附上它需要查询的交易位置（即图中的黄色块）。</li><li>此后，这个全节点计算出一条从这个底层交易节点一直连接到 Merkle Tree 的根节点的路径，这一条路径叫做 <strong>Merkle Proof（即图中红色箭头附加的路径）</strong> 。</li><li>全节点将路径上 <strong>未涉及到的全部哈希值（即图中红色的哈希值）</strong> 发送给轻节点。</li><li>轻节点接收到这些哈希值，从底层开始进行哈希运算【算出 <strong>指定交易的哈希（即第二层中的蓝色哈希值）</strong> -&gt; 与第二层的红色哈希值 <strong>（在第三步中由全节点发给轻节点）</strong> 拼接起来，再次进行哈希运算，算出再上一层的蓝色哈希 -&gt; 以此类推，直到 Merkle Proof 路径到头后，最后求一次哈希，与自己的 Block Header 中的内容相比较，判断出这笔交易是否发生过。</li></ul><p>上面这个过程，就是从底向上进行验证的一个过程。</p><p>我们回头捋一下，这个从下向上的过程，时间复杂度是多少？<br>不难看出，是log(N)。</p><hr><p>既然说了 Proof of membership ，那读者有没有想过，是否存在一种证明 Proof of non-membership （即证明某个交易并不存在）的方法？</p><p>有一种比较简单的证明方法是直接将整棵树发给轻节点，让轻节点验证一下这棵树没错，而后就完成了证明。但很显然，这种方法的时间复杂度是线性的。</p><p>我们需要申明，如果我们 <strong>对叶节点的排列不做任何假设</strong> 的话，是没有更高效的方法的。</p><p>但当我们能够对叶结点的排列做假设的时候，这个问题有一个很巧妙的解法。</p><p>我们假设叶节点是按照它们的哈希值进行有序排列的，现在要证明一笔交易（我们称之为交易1）并不存在。</p><ul><li>我们先对 交易1 求一个哈希值，找到如果它在这棵 Merkle Tree 中时应当所在的位置。并根据这个位置找到其两侧的交易（我们称之为 交易0 和 交易2 ）。</li><li>而后轻节点向全节点发出请求，进行 交易0 与 交易2 的 Merkle Proof ，如果最终获得的结果是正确的，则说明 交易0 与 交易2 之间并没有插入一个 交易1 ，这就证明了 交易1 其实是不存在的。</li></ul><p>上面这个过程通过两次 Merkle Proof 达成了 Proof of non-membership ，时间复杂度仍然是 log(N)。其代价是必须要对叶子节点（交易）进行基于哈希值的排序。</p><p>我们称这种针对哈希值排序的 Merkle Tree 为 <strong>Sorted Merkle Tree</strong> 。</p><p>在Bitcoin中，并没有采用 Sorted Merkle Tree ，因为 Bitcoin 中并没有 Proof of non-membership 的需要。</p><hr><h2 id="Part4-共识协议"><a href="#Part4-共识协议" class="headerlink" title="Part4. 共识协议"></a>Part4. 共识协议</h2><h3 id="4-1-Double-spending-attack"><a href="#4-1-Double-spending-attack" class="headerlink" title="4.1 Double spending attack"></a>4.1 Double spending attack</h3><p>我们先来考虑一下数字货币与实体货币的区别：</p><p>实体货币很简单，一手交钱，一手交货。因此交易双方只需要考虑这个货币究竟是不是真的，即现实中各种验钞机、货币上的各种防伪证明干的事情。</p><p>但数字货币不太一样。我们之前提到过非对称的密码体系（即公私钥体系），通过在货币上利用私钥签名，可以保证每个人都能通过公钥来对货币的真实性进行验证（如果读者对这个点不熟悉，请返回2.2.4）。但我们需要明确，数字货币是可以 <strong>被复制的</strong> ，如果仅仅通过公私钥进行保护，那不能阻止某些人无限复制手中的这一份货币。因此这显然不能作为完整的货币体系。</p><p>我们称这种问题为 “双花攻击” ，即 <strong>double spending attack</strong> 。</p><p>这个问题在中心化的系统中也不算难解决，给每一份数字货币一个唯一的编号，并让唯一的一个中心机构维持一个数据库，里面记录一下当前这份货币在谁手里。双花问题看似很方便的被解决了。</p><p>但很遗憾，我们需要的数字货币是 <strong>分布式的</strong> ，是 <strong>去中心化的</strong> 。</p><p>由此，我们转变一下思路，需要思考两个主要的问题：</p><ul><li>在去中心化的货币系统中，谁有权力发行数字货币？</li><li>在去中心化的货币系统中，如何保证一个交易的有效性？</li></ul><h3 id="4-2-交易有效性保证"><a href="#4-2-交易有效性保证" class="headerlink" title="4.2 交易有效性保证"></a>4.2 交易有效性保证</h3><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Hashchain%26double%20spent.png" alt="hashchain&amp;double_spend"></p><p>在Bitcoin中，存在两种哈希指针：</p><ul><li>区块指针</li><li>交易源指针</li></ul><p>其中，区块指针与我们此前讲解的区块链大相径庭，它负责指向上一个区块。</p><p>而交易源指针需要指向这笔交易的货币来源。比如：上图中A希望向B和C各转5个虚拟货币，则需要有一个指针指向A这10个虚拟货币的来源。</p><p>通过交易源指针，能够很好的防范双花问题，假设A再次尝试向外转账时，系统会进行交易回溯，从而查询到A手中的货币已经被花出去了，进而阻止这一次交易的发生。</p><p>好了，基本的原理我们搞明白了，我们现在需要详细的考虑一下一次交易的过程。</p><p>我们就以 A转给B 5个虚拟货币为例：</p><ul><li>A需要知道B的地址（也可以理解为账号），在Bitcoin中，这个账号是通过对B的公钥进行哈希，此后再进行一系列处理得到的。</li><li>B要验证这笔交易是否合法，因此需要通过A的公钥验证A的签名，意味着B也需要知道A的公钥。</li><li>进一步思考，Bitcoin中全部用户都有权利验证一个交易的合法性（因为这是个去中心化的系统，这一步交易需要得到全部节点的认可），因此其实所有节点都需要知道A的公钥。</li></ul><p>我们得知了上述三点要求后，需要引出区块链中每一笔交易的 <strong>输入与输出</strong> 。</p><p>其中，输入要求给出两点：</p><ul><li>发起交易者虚拟货币的来源（即交易源指针）</li><li>发起交易者的公钥</li></ul><p>输出要求给出一点：</p><ul><li>收款人公钥的哈希</li></ul><hr><p>这里可能会有读者想到些安全问题，因为一个交易的公钥是由交易的发起人自己给出的，那如果B想要冒充A，但他通过自己的私钥进行 <strong>B的签名</strong> 并附上了 <strong>B的公钥</strong> ，伪造了一个 <strong>由A向B的交易</strong> 呢，应该如何判别出这种窃取行为？</p><p>我们可以发现输入的要求中不仅要求一个公钥，还要求虚拟货币的来源。而这个来源也必定是一个区块，即 <strong>它也会有相应的输出</strong> 。</p><p>我们想想这个输出是什么？</p><p>这个输出必定是 <strong>A公钥的哈希</strong> 。</p><p>因此，防范上面的那种安全问题，只需要保证 <strong>这笔交易中提供的公钥</strong> 与 <strong>这笔交易中货币来源提供的输出（公钥哈希）</strong> 相匹配 即可。</p><p>（这地方有点绕，读者可以对着上面的图示比划比划）</p><hr><h3 id="4-3-区块"><a href="#4-3-区块" class="headerlink" title="4.3 区块"></a>4.3 区块</h3><h4 id="4-3-1-Block-Header-Block-Body"><a href="#4-3-1-Block-Header-Block-Body" class="headerlink" title="4.3.1 Block Header &amp; Block Body"></a>4.3.1 Block Header &amp; Block Body</h4><p>我们上面提到的案例，是一个非常简化的样例，因为我们假设每个区块内仅仅存在一个交易。显然，现实中一个区块内有很多交易，它们被存储在Merkle Tree中（关于这部分的内容，读者可以前往3.3进行回顾）。</p><p>我们还讲了，一个区块中一般包括区块头（Block Header）与区块主体（Block Body）。下面，我们详细给出其中的内容：</p><p>Block Header需要包括以下内容：</p><ul><li>Version: 使用的比特币协议版本</li><li>Hash of previous Block Header: 指向前一个区块头的哈希指针</li><li>Merkle Root Hash: 当前区块Merkle Tree根节点的哈希值</li><li>Timestamp: 当前区块的时间戳，表示当前区块被挖出来的时间</li><li>Target: 难度目标阈值</li><li>Nonce: 随机数</li></ul><p>Block Body需要包括以下内容：</p><ul><li>Transaction list: 交易列表</li></ul><p>这其中，最后两个域是与挖矿相关的，读者可以回顾 2.1.4 部分的内容进行回顾，这里先不详述。</p><p>Version 的含义很简单明了。</p><p>Hash of pervious Block Header 需要强调一下，它指的是前一个 <strong>区块头</strong> 的哈希指针，并不包含区块主体。至于区块主体是否被篡改，则通过每个头中的 Merkle Root Hash 来进行保证。</p><h4 id="4-3-2-Full-node-Light-node"><a href="#4-3-2-Full-node-Light-node" class="headerlink" title="4.3.2 Full node &amp; Light node"></a>4.3.2 Full node &amp; Light node</h4><p>在此之上，我们进一步明确一个在 3.4 中提到过的概念，即 <strong>全节点(Full node)</strong> 与 <strong>轻节点(Light node)</strong> ，全节点又称为 <strong>Fully validating node</strong> ，轻节点又称为 <strong>Light weight node</strong> 。</p><p>全节点与轻节点的区别在于是否存储了 Block Body 中的内容。</p><p>因此，一般而言，轻节点是无法仅仅依靠自己来进行各种验证的，它需要向全节点进行查询请求，依靠全节点给出的各种信息来辅助验证。但由于轻节点比较节省空间，因此一个区块链内大部分的节点其实都是轻节点。</p><p>我们这里给出一个更合理，更详细的区块链图：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Blockchain_detailed.png" alt="Blockchain_detailed"></p><h3 id="4-4-Distributed-Consensus"><a href="#4-4-Distributed-Consensus" class="headerlink" title="4.4 Distributed Consensus"></a>4.4 Distributed Consensus</h3><p>该概念即 <strong>分布式共识</strong> 。由于区块链是个分布式账本，那这个账本应该如何决定一个区块 <strong>是否应该写入</strong> ，以及 <strong>按照什么顺序写入</strong>，又应当如何保证 <strong>各个本地系统上能够保存相同的一个链条</strong> ？这就是区块链内需要解决的分布式共识的问题。</p><p><em>A fundamental problem in distributed computing and multi-agent systems is to achieve overall system reliability in the presence of a number of faulty processes. This often requires coordinating processes to reach consensus, or agree on some data value that is needed during computation.</em><br>—— Wikipedia</p><hr><p>这里得稍微提一嘴分布式共识的一些知识，有一个理论叫 <strong>CAP Theorem</strong> ，描述了分布式系统的三个希望能够达成的性质，但很可惜，三者之中至多只能选择两个。</p><p>这三个性质为：</p><ul><li>Consistency: 一致性 (Every read receives the most recent write or an error.)</li><li>Availability: 可用性 (Every request receives a (non-error) response, without the guarantee that it contains the most recent write.)</li><li>Partition tolerance: 分区可用性 (The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes.)</li></ul><p><em>In database theory, the CAP theorem, also named Brewer’s theorem after computer scientist Eric Brewer, states that any distributed data store can provide only two of the three guarantees.</em><br>—— Wikipedia</p><p>这个理论其实挺重要，但在区块链的文章中，我们不会过于详述。</p><hr><h3 id="4-5-Consensus-in-Bitcoin"><a href="#4-5-Consensus-in-Bitcoin" class="headerlink" title="4.5 Consensus in Bitcoin"></a>4.5 Consensus in Bitcoin</h3><p>在Bitcoin中，我们需要基于一个最基本的假设，即 <strong>有恶意的节点永远是少数</strong> 来实现分布式共识。</p><h4 id="4-5-1-Sybil-Attack"><a href="#4-5-1-Sybil-Attack" class="headerlink" title="4.5.1 Sybil Attack"></a>4.5.1 Sybil Attack</h4><p>一种实现分布式共识的方法是基于所有节点的投票结果，即每个节点都进行对当前区块的合法性验证，如果判断它合法则投赞成票，如果赞成票过半，将当前区块写入链中。</p><p>这种方法是有很明确的破解方法的，我们此前提及过（2.2.3），在Bitcoin中，一个(公钥, 私钥)对就是一个账户，那恶意节点完全可以生成茫茫多的恶意账户，对于自己希望加入的非法区块（illegal block），让自己能够控制的所有恶意账户全部投赞成票。如果这些恶意账户数目足够多，则可以轻易破解这种投票机制。</p><p>我们称呼这种攻击方式为 <strong>Sybil Attack(女巫攻击)</strong> 。</p><p><em>Sybil attack is a type of attack on a computer network service in which an attacker subverts the service’s reputation system by creating a large number of pseudonymous identities and uses them to gain a disproportionately large influence.</em><br>—— Wikipedia</p><p>很显然，仅仅依据账户数目来进行简单投票的方案，是不行的。</p><h4 id="4-5-2-算力优先"><a href="#4-5-2-算力优先" class="headerlink" title="4.5.2 算力优先"></a>4.5.2 算力优先</h4><p>简单的投票方案不成立，并不能意味着我们就要放弃投票。</p><p>在Bitcoin中，采取的是一种很巧妙的限制方式。</p><p>我们此前提及，挖矿时需要通过取nonce值，计算nonce与Block Header其他部分拼接过后的哈希值来决定我们是否找到了正确的随机数。显然，这个计算过程需要大量的算力，而当我们找到了正确的随机数后，我们就得到了 <strong>记账权</strong> ，即 <strong>向Bitcoin这个去中心化的账本中写入下一个区块的权力</strong> 。</p><p>显然，算力越强大，每秒钟能够尝试的nonce数目就越多（我们称这个数目为 <strong>Hash Rate</strong>），得到正确nonce的可能性自然越高，也就意味着我们有更大的权值来 “记账” 了。</p><p>这个机制在Bitcoin乃至Blockchain中都是极其重要的，因为它保证了，只要一个区块链的大部分Miner都是 <strong>诚实的</strong> ，那么这一整个区块链的安全性就能得到相当程度上的保证。</p><hr><p>当然，我们算出了正确的nonce，还是需要接受其他用户的验证的。因此我们需要将这个区块发布出来，让其他用户来检查我的nonce是正确的，并且我放进去的交易列表都是合法的。</p><hr><h4 id="4-5-3-Forking-Attack"><a href="#4-5-3-Forking-Attack" class="headerlink" title="4.5.3 Forking Attack"></a>4.5.3 Forking Attack</h4><p>读者大概第一次读到这里还是一头雾水，上面这个原则看起来还是不十分严谨。比如：我如果挖出的区块不在主干上，额外挖到一个小分支呢？这账本不久分叉了吗？</p><p>事实上，有这种攻击方式，即 <strong>Forking Attack(分支攻击)</strong> ，通过专门在Bitcoin这个帐本上附加分支来达到对交易的回滚目的。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Forking%20Attack.png" alt="Forking Attack"></p><p>我们可以看到，图中的链条出现了一条全新的分支，而显然，这条分支上 <strong>A-&gt;C的这笔交易与原链条④上A-&gt;B的交易是冲突的</strong> ，但在写入区块时，如果不加限制，它们都会被判定为合法的，因为 <strong>两者都能通过回溯查询到有②中D-&gt;A的交易发生</strong> 。</p><p>这种情况显然是不应当发生的，它相当于对已经发生过的交易进行了一次 <strong>回滚</strong> 。因此Bitcoin中有相应的规定，称最长的那个链条为 <strong>Longest valid chain(最长合法链)</strong> ，并人为限制，每次新写入Bitcoin中的区块，都应当是在扩展最长合法链。</p><hr><p>当然，还有一种合法的分叉可能性出现，即两个用户同时发现了正确的区块，并立即发布了出来，在这种情况下，其他用户都将暂时保留这两个区块，使得区块链变成下面这个样子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Forking%20valid.png" alt="Valid Forking"></p><p>这时，处理方法就是看谁快了，Block1 与 Block2 的哪个区块的下一个区块被先挖出来，系统就保留哪个。而另一个区块则被舍弃，被称为 <strong>Orphan Block</strong> 。</p><hr><h3 id="4-6-Block-Reward"><a href="#4-6-Block-Reward" class="headerlink" title="4.6 Block Reward"></a>4.6 Block Reward</h3><p>我们说完了记账权的争夺规则，但问题来了，这玩意又费电又费资源， <del>（甚至搞得很多人为了这件事疯狂的去挖矿）</del> ，图个啥，就图在那个账本里面记一笔嘛？</p><p>不知道读者还记不记得在Part4最开始提及的两个问题，我们现在只解决了第二个，即如何保证交易有效性。</p><p>现在要明确的，就是第一个问题，即 <strong>谁有权力发行货币</strong> 。</p><p>在Bitcoin中，发行新的比特币，只有唯一的方法，称为 <strong>Coinbase transaction</strong> ，除此之外的任何交易，都是将已有的比特币从一个账户上转到另一个账户上的过程。</p><p>相对应的，这个产生速度是在浮动的，在最开始的阶段，甚至达到了 50BTC per Block 。根据协议中的规定，每当21万个区块被发现过后，就需要将区块奖励减半。目前，这个产生速度已经降低至 3.125 BTC per block （May, 2024）。</p><p>在这里，还需要明确一点，对于Bitcoin而言，其产生新区块的速度为 <strong>10 minutes per block</strong> ，因此我们可以大概算出 Block Reward 减半一次所需的时间： <strong>大约4年左右</strong> 。</p><p>我们可以通过 <a>blockchain.info</a> 这个网站对于当前各类虚拟货币的情况进行查询，这里给出一个区块的例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Block%20Example%28%23842278%29.png" alt="Block Example #842278"></p><p>同样，区块内所有的交易都会被公示：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Transaction%20Example.png" alt="Transaction Example"></p><p>有兴趣的读者可以自己前往上面提到的网站上看一看。</p><h2 id="Part5-实现"><a href="#Part5-实现" class="headerlink" title="Part5. 实现"></a>Part5. 实现</h2><p>经过上面的描述，我们应该能够理解Bitcoin的大体原理，也能明白这是一个以交易为基础（ <strong>Transaction-based Ledger</strong> ）的虚拟货币类型。</p><hr><p>这里还需要提一下，另一种虚拟货币，以太坊(Ethereum)采用的并非与比特币相同的 交易基础模型 ，而是以账号为基础的另一种类型，我们称之为 <strong>Account-based Ledger</strong> 。这种模型我们会在后文中提及。</p><hr><h3 id="5-1-UTXO"><a href="#5-1-UTXO" class="headerlink" title="5.1 UTXO"></a>5.1 UTXO</h3><p>我们先介绍一个概念， <strong>UTXO</strong> ，即 <strong>Unspent Transaction Output</strong> 。</p><p><em>In cryptocurrencies, an unspent transaction output (UTXO) is a distinctive element in a subset of digital currency models. A UTXO represents a certain amount of cryptocurrency that has been authorized by a sender and is available to be spent by a recipient.</em><br>—— Wikipedia</p><p>简单的来讲，Bitcoin中具有很多的交易（包括 转账交易 以及 铸币交易），这一堆交易中，有些交易的交易额 <strong>已经被接收方再次花出去了</strong> ，而另一些交易额 <strong>仍然可被接收方所支配</strong> 。我们称这些还未被花出去的交易额所构成的集合为 <strong>UTXO</strong> 。</p><p>UTXO中的每一个条目，都需要给出两部分内容：</p><ul><li>产生当前交易的哈希值</li><li>这个输出是当前交易中的第几个输出</li></ul><p>写到这可能有点产生歧义，我们给个图：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/UTXO%20Example.png" alt="UTXO Example"></p><p>我们看到，在第二个区块中，A转给了B &#x2F; C 各 5BTC ，而B在这之后将其花掉了，但C并未花掉。因此B在UTXO中就不存在一个条目来记录它（或者说，是原先记录的那个条目被删掉了），而对于C则存在一条UTXO（如图中红色框内所示）。</p><p>上述例子说明，每一次交易，都意味着删除一部分UTXO，同时又新产生一部分UTXO。同时，对于整个UTXO而言，总输入应当始终等于总输出，即 <strong>Total inputs &#x3D; Total outputs</strong> 。</p><p>当然，在现实状况中，Total inputs &gt;&#x3D; Total outputs 的情况要更常见一些。这是由于区块链本身是个账本，而一笔笔交易（一条条账目）想要放入这个账本的话，是应当交一笔手续费的。而这笔手续费，就交给当前区块的记账权拥有者（把这个区块挖出来的人）。</p><p>这个机制被称作 <strong>Transaction fee</strong> 。</p><p><em>A Blockchain transaction fee is an amount that a user has to pay to the miners to have their transaction validated on the Blockchain.</em></p><p>到此，我们已经明确了Bitcoin中除转账外获得BTC的两种方式：即 <strong>Block Reward</strong> 以及 <strong>Transaction fee</strong> 。</p><hr><p>读者可能会疑惑于后续的手续费应该如何收取？难不成再单开一个交易嘛？</p><p>事实上， Transaction fee 是与 Block Reward 一同通过区块中的铸币交易（Coinbase Transaction）一并转给记账权拥有者的。</p><p>在Bitcoin中，所有没有被确认的交易会放在一个单独的池子里面（暂且按照池子来理解吧），这个池子叫做 <strong>mempool</strong> ，而后一个矿工挖出了一个区块，系统会挑选合法的交易放入这个区块中（交易数额越大，优先级越高），而后再将这个区块发布出来，供所有人验证。</p><p>因此，当这个区块被发布出来后，意味着里面有什么交易已经定下来了，因此总共的 Transaction fee 也就被算出来了。</p><hr><hr><p>为什么要维护这个UTXO呢，这与我们此前在4.1 &#x2F; 4.2中所说的 对于Double Spending Attack的防范工作有关。</p><p>每次交易之前，都需要查询这个UTXO，确保发起交易者的账户上有相应的金额，即UTXO中有相应的条目。否则这笔交易就不会通过。显然，有UTXO的存在，可以快速检测Double Spending。</p><p>由于Bitcoin是个分布式系统，因此UTXO的维护是每一个全节点的任务（应该还记得这个概念吧）。</p><hr><h3 id="5-2-难度升格"><a href="#5-2-难度升格" class="headerlink" title="5.2 难度升格"></a>5.2 难度升格</h3><h4 id="5-2-1-Block-Header的数据结构"><a href="#5-2-1-Block-Header的数据结构" class="headerlink" title="5.2.1 Block Header的数据结构"></a>5.2.1 Block Header的数据结构</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">public:    &#x2F;&#x2F; header    int32_t nVersion;    uint256 hashPrevBlock;    uint256 hashMerkleRoot;    uint32_t nTime;    uint32_t nBits;    uint32_t nNonce;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码块给出了Bitcoin中Block Header所包含的数据类型。</p><h4 id="5-2-2-如何提升难度？"><a href="#5-2-2-如何提升难度？" class="headerlink" title="5.2.2 如何提升难度？"></a>5.2.2 如何提升难度？</h4><p>显然，在当前这个时代，算力膨胀，挖矿者的数目也膨胀，这代表着仅仅调整一个32位无符号的随机数nonce所带来的挖矿难度已经远远不够了。</p><p>Bitcoin需要尽可能控制挖矿难度使得每个新区块的发布时间在10分钟左右。因此，人们找到了另一个可以更改的内容，即上述结构中的 <strong>hashMerkleRoot</strong> 。</p><p>这玩意的数据类型叫 <strong>uint256</strong> 。</p><p><em>uint256 is an unsigned integer that can hold a maximum value of 2^256-1</em></p><p>那问题来了，这玩意不是MerkleTree的根节点哈希吗，怎么改？</p><p>我们应该还记得，Bitcoin中有一种交易是在区块被挖出来的时候由获得记账权的人自动得到的，即 <strong>铸币交易</strong> （详见4.6）。这个交易内有一个单独的域被称为 Coinbase 域, 这个域内想些啥都无所谓, 而铸币交易也被包含在区块内的MerkleTree中, 因此可以通过进一步调整 Coinbase 域中的值来划定 hashMerkleRoot.</p><p>我们通常称呼这个 Coinbase 域内可调整的部分为 extra nonce, 在历史上, 它曾经取过 $ 2\space bytes &#x2F; 4 \space bytes &#x2F; 8 \space bytes $</p><p>因此，我们可以要求挖矿者在需要额外调整 extra nonce 的前提下来提高挖矿者的操作难度，进而一定程度上控制区块生成时间。</p><h3 id="5-3-交易合法性验证"><a href="#5-3-交易合法性验证" class="headerlink" title="5.3 交易合法性验证"></a>5.3 交易合法性验证</h3><p>我们在 (4.2) 中提及，一笔交易合法需要提供交易发起者的公钥，以及此前的货币来源（一笔交易）的输出。前者就是一个公钥，后者则是一个公钥哈希。只需要保证二者配对，交易发起者再利用自己的私钥进行签名，即可保证这笔交易是合法的。</p><p>具体这个公钥和公钥哈希该如何配对呢？</p><p>在Bitcoin的区块公示中，每一笔交易的输入与输出都会有一个脚本，在我们上文提到的网站 <a>blockchain.info</a> 中长这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Inputscript.png" alt="Inputscript"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Outputscript.png" alt="Outputscript"></p><p>当然，上面两个图片仅仅是举个例子，并不是配对的一组。</p><p>具体验证时，会将两个脚本（一个输入脚本，另一个输出脚本）拼在一起，尝试运行，如果能够成功跑通，则代表这笔交易的货币来源与交易发起者没问题。</p><h3 id="5-4-简要的数学分析"><a href="#5-4-简要的数学分析" class="headerlink" title="5.4 简要的数学分析"></a>5.4 简要的数学分析</h3><p>我们对于挖矿的过程稍微分析一下。</p><p>每次取随机数，都可以看做一次 <strong>伯努利试验(Bernoulli trial)</strong> ，而挖矿的长期过程（一系列的尝试）可以看作一个 <strong>伯努利过程(Bernoulli process)</strong> 。</p><p><em>a Bernoulli trial (or binomial trial) is a random experiment with exactly two possible outcomes, “success” and “failure”, in which the probability of success is the same every time the experiment is conducted.</em></p><p><em>a Bernoulli process (named after Jacob Bernoulli) is a finite or infinite sequence of binary random variables, so it is a discrete-time stochastic process that takes only two values, canonically 0 and 1.</em><br>—— Wikipedia</p><p>而由于挖矿这个过程所需要尝试的次数实在过多，这个伯努利过程可以通过 <strong>泊松分布(Poisson process)</strong> 来进行近似估计。</p><p>与此同时，对于Bitcoin，系统设计的出块时间为10分钟，而出块所遵从的概率模型，为 <strong>指数分布(Exponential distribution)</strong> 。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/f%28x%29%20for%20Exponential%20distribution.png" alt="f(x) for Exponential distribution"></p><p>至于为什么要按照指数分布来设计出块时间，是为了达成一个叫做 <strong>Progress Free</strong> 的性质。</p><h4 id="5-4-1-Progress-Free-Memoryless"><a href="#5-4-1-Progress-Free-Memoryless" class="headerlink" title="5.4.1 Progress Free (Memoryless)"></a>5.4.1 Progress Free (Memoryless)</h4><p>这个性质的意义是： <strong>此前做过的工作并不能影响此后工作所需要花费时间的期望值</strong> 。</p><p>无情地说，此前如果未能挖出一个区块，那么此后挖出这个区块所需要花费的期望时间还是10分钟。</p><p>其实这个概念在概率论中叫做两次实验之间 <strong>相互独立</strong> 。说明上一次实验不会影响下一次实验成功的机率。</p><p>我们想想，如果没有这个性质，则算力高的人会理所应当的有不成比例的优势，因为他们失败的次数更多，会使得他们挖出新区块的概率相比于算力低的人们高十分多。事实上，这个性质恰恰是挖矿公平性的体现。</p><h4 id="5-4-2-Geometric-series"><a href="#5-4-2-Geometric-series" class="headerlink" title="5.4.2 Geometric series"></a>5.4.2 Geometric series</h4><p>关于Bitcoin的总量，也可以通过数学的方法进行推导，这由Bitcoin中不断减半的铸币交易额度来决定。</p><p>具体来说，Bitcoin的发型会形成一个无限长的序列，前21万个数为50，随后21万个数为25，接下来12.5，6.25，3.125，…</p><p>上述数值持续相加：得到 <strong>210000 * 50 * (1+0.5+0.25+0.125+…)</strong></p><p>最终有一个极限：两千一百万BTC(21 million)，这是Bitcoin设计的极限值。</p><p>当Block Reward最终减少到一定程度时，Bitcoin就相当于达到了其发行极限。</p><h3 id="5-5-安全性说明"><a href="#5-5-安全性说明" class="headerlink" title="5.5 安全性说明"></a>5.5 安全性说明</h3><p>我们上面提到过 <strong>算力优先（4.5.2）</strong> 这个概念，并且在其中提到过这个机制极大程度上确保了区块链的安全性。</p><p><strong>Bitcoin is secured by mining.</strong></p><p>我们现在假使 <strong>诚实的节点拥有大部分算力</strong> ，有恶意的节点仍然占有小部分算力。</p><p>可能会有读者产生疑惑，这意味着有恶意的节点仍然有几率挖出一个区块并获得其记账权，这也不安全啊？</p><p>因此，我们不妨考虑当有恶意的节点获得了区块记账权后，会发生些什么。</p><h4 id="5-5-1-能偷走别人的货币吗？"><a href="#5-5-1-能偷走别人的货币吗？" class="headerlink" title="5.5.1 能偷走别人的货币吗？"></a>5.5.1 能偷走别人的货币吗？</h4><p>假使，这个有恶意的节点希望从别人的账目上将货币转到自己账目上。</p><p>我们在 4.2 以及 5.3 中了解到了相应的保护机制，通过对应的机制，这个恶意节点永远无法 <strong>以合法交易的形式将别人账目上的货币转走</strong> 。</p><p>那假设恶意节点破罐子破摔了，我就是要把非法交易写进我这个账本中，会发生什么？</p><p>结果是，当他将非法交易写入时，由于这个过程是公开的，其它的诚实节点都能够检测到这个区块中的非法交易，因此，这个区块 <strong>不会被诚实节点所接受</strong> ，又由于诚实节点占大多数，因此，这个含有非法交易的节点会如同 4.5.3 节中的 Orphan Block 一样被直接放弃掉。</p><p>显然，这样的攻击方式不仅无法让攻击者得到额外的货币，反而让他将原本能够拿到手的 Block Reward 也丢掉了。因此这种攻击手段并不成立。</p><h4 id="5-5-2-Irrevocable-Ledger"><a href="#5-5-2-Irrevocable-Ledger" class="headerlink" title="5.5.2 Irrevocable Ledger"></a>5.5.2 Irrevocable Ledger</h4><p>我们在这一部分中考虑一种很偷鸡的Double Spending。</p><p>之所以说它偷鸡，是因为我们这里所提及的 Double Spending 指的并非前面简单的双花，因为那种情况下，会很容易被系统检测出来，并判断为非法区块。</p><p>我们这里所指的 Double Spending ，是现实中通过比特币交易获利，而后通过分支攻击（Forking Attack）回滚那一笔比特币转账，最终达成不付出任何代价却现实中获利的效果。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Forking%20Attack%26Double%20spending.png" alt="Forking Attack&amp;Double Spending"></p><p>举例来说，M先在上方的区块内向A发起了交易，相应的，A在现实中也给予M相应的代价，而后M转头又挖出了底下那个区块，并使得底下那个区块变成了最长合法链（我们假设M有这个能力）。这使得M未支付相应的比特币就在现实中获取了相应的利益。</p><p>Bitcoin考虑到了这一点，并做出了相应的限制，即 <strong>只有交易发起的区块后方跟了5个区块后（即加上交易本身所在区块总共6个区块），才能算做交易成功</strong> 。这代表着即使M挖出了下侧的区块，由于上方的链条已经有一定的长度，因此进行上述的Forking Attack的难度大大增加（几乎不可能）。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Confirmation.png" alt="Confirmation"></p><p>我们管这种接在交易所在区块以及后方后面防范Forking Attack的区块统一取了个名字，叫该交易的 <strong>Confirmation</strong> 。显然，一笔交易的 Confirmation 需要等待长达1小时。但同样可以得到的是，这个确认的过程，能够使得交易的风险呈指数式的降低。</p><hr><p>我们这里需要额外提一嘴，由于铸币交易(Coinbase Transaction)的特殊性(铸币交易产生了新的BTC)，它所需的Confirmation数目要远远高于正常的交易，它需要100个确认，即记账权拥有者需要等待接近1000分钟后才能真正将他通过一个区块铸币交易所获得的BTC花出。</p><hr><p>当然，如果Bitcoin的交易非得让用户停在交易界面等一个小时，那未免太不便了一点。</p><p>一般而言，收款方收到交易通知与其发货之间是天然有时间间隔的。这意味着收款方只需要一直监听着区块的情况，等到最长合法链持续延伸，够长之后发货即可，这个过程可以完全由算法完成，不需要付款方或收款方一直等待。</p><h4 id="5-5-3-控制交易写入"><a href="#5-5-3-控制交易写入" class="headerlink" title="5.5.3 控制交易写入"></a>5.5.3 控制交易写入</h4><p>5.5.1 与 5.5.2 的目的是让这个有恶意的节点自己获利，现在我们都封死了。</p><p>那有没有一种可能，这个有恶意的节点故意不把某一部分合法交易写入来达成破坏呢？</p><p>答案是，应该不会，因为交易既然是合法的，则势必能被写入某个区块内（除非恶意节点能获得后方所有的区块的记账权，这几乎是不可能的），而恶意节点这么做的话，反而使得自己无法获得这笔交易的手续费（Transaction fee，详见5.1），降低了自己的收益。</p><h4 id="5-5-4-Selfish-Mining"><a href="#5-5-4-Selfish-Mining" class="headerlink" title="5.5.4 Selfish Mining"></a>5.5.4 Selfish Mining</h4><p>有读者可能会有大胆的想法，我就摁想实现上面的那种 Double Spending ，我往前猛猛挖，挖出来6个块然后不发布，然后等到别人挖到相应的区块了，我一股脑把6个块的链条甩出来，直接使得最长合法链转移到我这里，不就实现了Forking Attack了吗。</p><p>显然，这种攻击的可能性在理论上存在，但需要考虑，挖出区块的可能是与算力成正相关的，因此，恶意节点算力占比如果比诚实节点低，则这种攻击的成功可能性仍然很低，因为理论上来讲，恶意节点挖的不可能比诚实节点快。</p><p>如果恶意节点占了大多数算力，这种攻击的成功概率才比较高。 <del>（一种货币让恶意节点在投票基础中占据了大多数的权重，那这种货币离报废也不远了…）</del></p><h2 id="Part6-网络"><a href="#Part6-网络" class="headerlink" title="Part6. 网络"></a>Part6. 网络</h2><blockquote><p>这一部分的内容涉及到一些计算机网络原理的内容，不会太深</p></blockquote><h3 id="6-1-Basic-description"><a href="#6-1-Basic-description" class="headerlink" title="6.1 Basic description"></a>6.1 Basic description</h3><p>Bitcoin的协议运行在应用层（ <strong>Application Layer</strong> ），也是整个计算机网络七大层中的最上层。</p><p>而由于Bitcoin基于分布式系统进行工作，因此在最底层的应用层原理上, 运行着一个 P2P 协议.</p><p>至于更下层的传输层和网络层, 则是常规的 TCP &#x2F; IP 协议</p><hr><p>关于 Peer to Peer overlay network</p><p><em>A peer-to-peer overlay network is a computer network built on top of an existing network, usually the Internet. Peer-to-peer overlay networks enable participating peers to find the other peers not by the IP addresses but by the specific logical identifiers known to all peers. Usually, peer-to-peer overlays have the advantage over the traditional client-server systems because of their scalability and lack of single-point-of-failure. Peer-to-peer overlays are commonly used for file sharing and realtime data streaming.</em></p><p>P2P 协议与传统的 客户端-服务器协议并不一致，在该协议中，所有的终端的地位是对等的，而他们也不需要通过传统的IP来寻找对方，而是可以更便捷的通过特别的逻辑标识符在互相之间建立连接通道。</p><p>需要特殊说明的一点是， <strong>有些P2P网络</strong> 并非 <strong>完全的去中心化</strong> ，在它们的网络中，还存在着 <strong>Super Node(Master Node)</strong> 这种核心节点。</p><hr><p>在Bitcoin中，是完全去中心化的，即每个节点的地位 <strong>完全对等</strong> 。用户想要加入这个网络，只需向一个种子节点( <strong>Seed Node</strong> )发送连接请求，而后种子节点就会将它已知的所有节点告知这个新人节点，周而复始。</p><p>这一过程中，通常在介于 <strong>Application Layer</strong> 与 <strong>Network Layer</strong> 之间的 传输层( <strong>Transport Layer</strong> )上，使用的是TCP协议，这一方面是保证连接稳定性，另一方面目的也在于更好的穿透防火墙（如果读者对于计网的知识有一定的了解，应该听说过很多防火墙是拦截UDP流量的）。</p><p>至于退出整个区块链网络，则不需要用户做些什么事情，当别的节点长时间未能从你这里获得报文时，会自动将你从网络中删除。</p><h3 id="6-2-Simple-Robust-but-not-Efficient"><a href="#6-2-Simple-Robust-but-not-Efficient" class="headerlink" title="6.2 Simple, Robust but not Efficient"></a>6.2 Simple, Robust but not Efficient</h3><p>如标题所言，Bitcoin的网络的设计原则是： <strong>简单，鲁棒但并不高效</strong> 。</p><p>我们这样说的原因如下：</p><ol><li><p>TCP, not UDP: 显然，TCP中要求的三次握手过程相比于UDP的尽力而为，在时延上要慢很多。</p></li><li><p>Flooding Network: Bitcoin中的信息传输采取泛洪策略，即每个节点向他周边的节点发送它新收到的消息。</p><p>具体而言，一个节点收到了一个合法的交易，它会向所有与它相邻的节点发送这条交易，以便于让所有节点将这笔交易放入当前区块中。同时，每个收到这条交易的节点都会对这笔交易进行相应的标记，这是用于防止交易重复记录的。</p><p>当然，还需要说明的是， <strong>与它相邻的节点</strong> 并不意味着地理意义上的相邻，Bitcoin中的相邻是不考虑底层的拓扑结构的，这意味着很可能两个相邻的节点所处的位置相隔大洋两岸。</p></li></ol><hr><p><strong>Gossip Protocol</strong></p><p>这玩意是比特币使用的泛洪协议，简单描述如下：</p><p><em>A gossip protocol or epidemic protocol is a procedure or process of computer peer-to-peer communication that is based on the way epidemics spread. Some distributed systems use peer-to-peer gossip to ensure that data is disseminated to all members of a group.</em></p><hr><p>上述两个原因也决定了，Bitcoin中区块的大小是有严格限制的，这个限制值是 1M 。</p><p>看起来很小对吧，但是由于以上的网络设计，即使是 1M 大小的区块，要传遍大多数节点，也需要10s以上的时间。</p><h2 id="Part7-挖矿难度"><a href="#Part7-挖矿难度" class="headerlink" title="Part7. 挖矿难度"></a>Part7. 挖矿难度</h2><h3 id="7-1-系统定义"><a href="#7-1-系统定义" class="headerlink" title="7.1 系统定义"></a>7.1 系统定义</h3><p>我们在这一部分再对挖矿的难度进行一定的说明。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Total%20space%20%26%20Target%20space.png" alt="Total space &amp; Target space"></p><p>我们还是搬出这张图，明确以下条件，成功发现区块的条件是H(block header)&lt;&#x3D;target，并且再强调一下，Bitcoin使用的是SHA-256的哈希算法，这意味着它的哈希输出空间只有 2^256 这么大。</p><p>显然，有一种关系很好理解，即挖矿难度与目标阈值的取值是成反比的。</p><p>用一种更加严谨的定义来说：</p><p>$$ difficulty &#x3D; \frac{difficulty \ 1 \ target}{target} $$</p><p>上式中我们解释几个量：</p><ul><li>difficulty: 挖矿难度，最低为1</li><li>target: 目标阈值</li><li>difficulty 1 target: 难度为1时的目标阈值(即目标阈值的最大值)</li></ul><p>因此我们明确了调整难度的方法，对target目标阈值进行调整即可。</p><p>我们在5.2中提及过难度升格的问题，由于算力膨胀，设备先进程度的上涨，如果不对挖矿难度进行调整，则必定会使出块时间不断变短。</p><h3 id="7-2-为什么要划定出块时间？"><a href="#7-2-为什么要划定出块时间？" class="headerlink" title="7.2 为什么要划定出块时间？"></a>7.2 为什么要划定出块时间？</h3><p>我们不妨思考一下，出块时间太短会发生什么。</p><p>我们前方提到过一个概念，叫做分支(Forking)。而有一种分支是合法的，即在很相近的时间内，两个节点同时挖出了当前区块的后续区块(详见4.5.3)。</p><p>如果出块时间太短，显然出现这种合法分支的可能性会大大增加。而每一个分支都必定会有一定的算力分配到上面进行进一步的挖掘工作（这取决于节点先收到哪个分支的声明，详见6.2），这意味着诚实节点的算力被更大程度上的分散了。</p><p>算力分散会发生什么事情？</p><p>我们考虑Forking Attack，原先二分支的情况下，恶意节点想要回滚交易，如果需要保证成功率，需要占据51%的算力总额（这样它才有把握挖的比诚实节点快，抢走最长合法链条），但出块时间过快，导致诚实节点算力分散了，分配到每个分支上的算力只占总算力的10% ~ 15%，那么，恶意节点只需要20% ~ 30%的总额算力，就能极大程度上保证分支攻击的成功率。</p><p>这很大程度上降低了安全性。</p><h3 id="7-3-怎么调整目标阈值"><a href="#7-3-怎么调整目标阈值" class="headerlink" title="7.3 怎么调整目标阈值"></a>7.3 怎么调整目标阈值</h3><p>首先，我们得明确目标阈值的调整间隔。</p><p>具体而言，对于Bitcoin，规定为每隔2016个区块，要调整一次目标阈值（换算下来大概两个星期调一次）</p><p>具体怎么调整呢：遵循这个公式：</p><p>$$ target &#x3D; target * \frac{Actual \ Time}{Expected \ Time} $$</p><p>这个公式我们解释一下：</p><ul><li>ActualTime: 指的是系统最近产出2016个区块花费的时间</li><li>ExpectedTime: 指的是系统期望的产出2016个区块应当花费的时间，即 2016*10 min(almost 2 weeks)</li></ul><p>通过这样的设置，我们实现了令target阈值与当前算力的微妙同步。</p><p>在实际代码中，为了避免一些意外情况，ActualTime比8个星期还大，抑或是比半个星期还小，系统中也只会将其控制在 [1&#x2F;2weeks, 8weeks] 这个区间内。即target的变动阈值在 [1&#x2F;4target, 4target]之间。</p><hr><p>请注意甄别： <strong>挖矿难度</strong> &amp; <strong>阈值</strong></p><p>对于Bitcoin而言，挖矿难度与阈值负相关的，即阈值越小，挖矿难度越高。（读者可以对照着2.1.4的图理解一下这句话）</p><p>我们给出另一个公式，也是正确的，不过这次我们的主元是挖矿难度 <strong>difficulty</strong> ：</p><p>$$ next \ difficulty &#x3D; previous \ difficulty * \frac{Expected \ Time}{Actual \ Time} $$</p><p>可以发现，后面的分数反过来了，这正是挖矿难度与阈值负相关的证明。</p><p>至于为啥要再写个概念呢，因为实际代码里用的是目标阈值target，但这个东西有点反直觉，因此又设置了一个挖矿难度，方便理解，量化。</p><hr><h2 id="Part8-关于挖矿本身"><a href="#Part8-关于挖矿本身" class="headerlink" title="Part8. 关于挖矿本身"></a>Part8. 关于挖矿本身</h2><h3 id="8-1-挖矿设备"><a href="#8-1-挖矿设备" class="headerlink" title="8.1 挖矿设备"></a>8.1 挖矿设备</h3><p>随着事件发展, 挖矿的设备逐渐趋于专业化, 这是因为传统的PC与挖矿的需求并不相同.</p><p>传统PC的部件中有一大部分的部件都用做与挖矿无关的方向, 如 <strong>显示方面, 意外处理方面等</strong> , 但挖矿显然并不需求这些方面的专业性, 挖矿的唯一标准, 在于 <strong>算力</strong> .</p><p>最初的挖矿是利用 <strong>CPU</strong> 进行挖矿, 但很显然, 挖矿这个对于随机值的计算过程, 使得CPU只有数值运算的相关部件(详见 <strong>计算机组成原理 章节</strong> )在全程运转, 而其余很多部件都处于闲置状态, 效率不高.</p><hr><p>而后, 挖矿这个过程使用的设备, 就走向了GPU的方向. GPU相比于CPU, 尤其擅长 <strong>通用并行计算</strong> , 这就代表着它确实更加长于挖矿.</p><p>但仍然需要明确, 即使利用 <strong>GPU</strong> , 仍然是一种相当程度上的资源浪费, 这是因为GPU里面很多的部件仍然处于闲置状态, 一个典型案例即 <strong>GPU中的浮点计算模块</strong> , 这个模块在机器学习等过程中是相当重要的, 但对于BTC挖矿(只涉及到整数运算的各种操作), 则几乎无用.</p><hr><p>为了进一步提升资源利用率, 有一类专门的芯片被设计出来, 它被称为 <strong>ASIC(Application-specific integrated circuit)</strong> :</p><p><em>An application-specific integrated circuit (ASIC &#x2F;ˈeɪsɪk&#x2F;) is an integrated circuit (IC) chip customized for a particular use, rather than intended for general-purpose use, such as a chip designed to run in a digital voice recorder or a high-efficiency video codec.</em></p><p>这一类芯片是专门针对某一类型的应用特化的芯片, 它没有多余的运算部件, 仅仅针对于应用需求最重的领域进行特化, 可以达到相当高的利用率, 性价比是最高的.</p><p>当然, 不同的加密货币可能注重的计算方面也不同, 这代表着针对某一种加密货币设计的ASIC芯片, 也只能挖这一特定的加密货币(说明其通用性不高). 因此, 如果读者对于前些年的矿潮有所了解, GPU仍然是最火热的挖矿设备.</p><p>当然, 使用ASIC芯片挖矿的群体仍不在少数, 这就代表着通用性也是某些新型加密货币所需要考虑的内容. 因此, 有些新的加密货币会使用与此前火热的加密货币(如BTC) <strong>相同的 Mining Puzzle</strong> , 这使得本来设计出用于挖传统加密货币的ASIC也可以用于挖这种全新的货币. 这通常用于 <strong>新型加密货币打开市场, 提升人气的时期</strong> 使用.</p><h3 id="8-2-挖矿规模"><a href="#8-2-挖矿规模" class="headerlink" title="8.2 挖矿规模"></a>8.2 挖矿规模</h3><p>挖矿的另一种趋势, 是 <strong>矿池</strong> 的出现.</p><p>这种现象的本质原因在于, 如果所有矿工均以个体作战, 则对于每一个个体, 这种收益是非常不稳定的. <del>(三年不开张, 开张吃三年)</del></p><p>而为了保证收益的稳定, 出现了一种团体, 它将很多矿机集体集合起来统一调配.</p><p>在明确矿池的出现的根本原因前, 我们需要回顾一下 <strong>全节点</strong> 与 <strong>轻节点</strong> 的概念:</p><ul><li>全节点<ul><li>一直在线</li><li>在本地硬盘上维护完整的区块链信息</li><li>在内存中维护UTXO集合, 便于快速检验交易的正确性</li><li>监听BTC网络中的交易信息, 验证每个交易的合法性</li><li>决定哪些交易会被打包到区块中</li><li>监听别的矿工挖出来的区块, 验证其合法性</li><li>挖矿<ul><li>决定沿着哪条链挖下去?</li><li>出现等长分叉时, 选择哪一个分叉?</li></ul></li></ul></li><li>轻节点<ul><li>偶尔在线</li><li>只保存每个区块的块头(Block Header)</li><li>只保存与自己相关的交易</li><li>只能检验与自己相关的那些交易的合法性</li><li>可以验证挖矿的难度</li><li>可以检测哪个是最长链, 但没有判断最长合法链的能力</li></ul></li></ul><p>显然, 如果想要挖矿, 则必须保证全节点的稳定性.</p><p>我们前面在挖矿设备中提到了, ASIC芯片只能从事挖矿本身需要的计算功能, 只有ASIC是无法维护全节点的其余功能的.</p><p>因此, 我们上面的挖矿团体, 即 <strong>矿池</strong> 就出现了:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/%E7%9F%BF%E6%B1%A0.png" alt="矿池"></p><ul><li>Pool manager<ul><li>也称矿主</li><li>负责除了计算之余的全节点内容</li><li>负责组装区块, 将需要计算的哈希值任务通过特定的通讯协议分配给矿工</li></ul></li><li>Miner<ul><li>也称矿工</li><li>负责哈希值相关的计算</li><li>当运算出对应的结果后, 通过特定的通讯协议将结果回馈给矿主</li><li>当出块后, 参与分红</li></ul></li></ul><p>这带来的一种隐性好处在于, 每个个体只需要购买相应的设备, 加入矿池, 然后让矿主控制所有矿机的调度即可, 很简单. 此外, 如果一个人的收益过于不稳定, 那就一群人一块挖, 挖到了大家分红, 由于总算力的大幅提升, 这就使得收益稳定了不少.</p><hr><p>那么, 问题又来了, 如何分红? </p><p>读者应该能想到, 这里又涉及到了我们此前提到的 <strong>工作量证明</strong> 这个概念. 矿池中的所有矿工需要向矿主提交自己的工作量证明, 以达到在最终分红环节中拿到更多的份额.</p><p>这个工作量证明如何提交呢?</p><p>我们回到最初矿池的建立根源上, 即找到区块当前要求的 nonce 的难度太高了, 这个限制区域太小了, 很难找到.</p><p>因此有一种很简单的工作量证明, 即矿主 <strong>人工划定一个较低的难度区间, 它比原区块要求的nonce的要求要低不少(我们称之为 share ) , 符合这个 share 要求的区块被称作 Almost valid Block</strong> , 同时矿主维护一个 <strong>每个矿工挖到 Almost valid Block 数目的列表</strong> , 当一个矿工挖到了一个符合 share 的随机数后, 它向矿主提交这个值, 矿主将其对应列表中的值+1. 最终出块奖励按照这个列表中的值进行分配.</p><p>需要明确, 这种Almost valid Block除了作为工作量证明之外, 是完全无用的. 换言之, 它只能作为一种分红凭证在矿池的机构中起作用.</p><p>此外, 为了保证矿工 <strong>挖出区块后会如期交给矿主, 而不会自行发布</strong> , 矿主会在组装的区块中的铸币交易的收款人地址中填入自己的地址.(铸币交易以及相应的更改见 5.2.2)</p><p>这里也给出当前矿池的国家分布:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Mining%20pool%20concentartion.png" alt="矿池分布(2024/6/28)"></p><p>—— From <a href="https://www.buybitcoinworldwide.com/mining/pools/">https://www.buybitcoinworldwide.com/mining/pools/</a></p><hr><p>矿池的出现固然有其好处, 但它本质上其实是一种对 <strong>去中心化</strong> 的破坏, 想象一下, 有一个矿池吸引了足够多的矿工, 使得这个矿池的算力总和达到了51%以上, 那么他其实可以很容易的发起各种各样的攻击, 因为他占据了大部分的算力. (更恐怖的是, 其下属的矿工甚至不会意识到这一点, 这是因为下属矿工 <strong>只会接收到具体任务, 而并不知道这个任务是在以什么为目的</strong> . 举例而言, 矿主可以很轻易的将下属的所有算力都转向另一条链, 达成分支攻击)</p><p>同时, 矿池的矿主是需要收取一定的管理费的, 他们经营矿池也需要盈利手段. 而矿池的火热程度, 很大程度上取决于矿主收取管理费的多少.</p><h2 id="Part9-BTC的脚本语言"><a href="#Part9-BTC的脚本语言" class="headerlink" title="Part9. BTC的脚本语言"></a>Part9. BTC的脚本语言</h2><p>谈及脚本, 可能大部分读者会想到C, C++等编程语言, 与之不同, 比特币的脚本语言相当简单, 其唯一能够访问的对象就是一个堆栈, 这也意味着它不存在所谓 “全局变量” , “局部变量” 等概念. 也由于BTC的脚本主要基于堆栈, 因此也称之为 <strong>Stack based Language</strong> .</p><h3 id="9-1-BTC的交易结构"><a href="#9-1-BTC的交易结构" class="headerlink" title="9.1 BTC的交易结构"></a>9.1 BTC的交易结构</h3><pre class="line-numbers language-none"><code class="language-none">result&#123;  txid: \\Transaction id  hash: \\Transaction hash  version:  size:  locktime: \\Could be included in a block after ...  vin: \\Input  vout: \\Output  blockhash: \\The hash of its Block&#39;s Head  confirmations:  time: \\the time when this transaction appears  blocktime:  \\the time when its block appears&#125;vin&#123;  txid:  vout: \\this transcation spent which output of last transaction  \\(one transaction may conclude many output)  scriptSig&#123; &#x2F;&#x2F;or input_script    asm:    hex:  &#125;&#125;vout&#123;  value: &#x2F;&#x2F;the amount of BTC this output spent  n: &#x2F;&#x2F;output number  scriptPubKey&#123; &#x2F;&#x2F;or output_script    asm:    hex:    reqSigs: &#x2F;&#x2F;number of Signature which is required in this output    type:    addresses:  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-2-BTC交易脚本的执行方式"><a href="#9-2-BTC交易脚本的执行方式" class="headerlink" title="9.2 BTC交易脚本的执行方式"></a>9.2 BTC交易脚本的执行方式</h3><h4 id="9-2-1-交易脚本执行顺序"><a href="#9-2-1-交易脚本执行顺序" class="headerlink" title="9.2.1 交易脚本执行顺序"></a>9.2.1 交易脚本执行顺序</h4><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/BTC%E2%80%98s%20script.png" alt="How to run a BTC&#39;s Script"></p><p>这幅图的原理其实在 4.2 节中有所提及, 读者如有遗忘可以再次前去复习一下;</p><p>实际执行中, 通常将输入脚本放在输出脚本的前方, 分别执行(为了安全性考虑).</p><h4 id="9-2-2-几种具体的交易脚本"><a href="#9-2-2-几种具体的交易脚本" class="headerlink" title="9.2.2 几种具体的交易脚本"></a>9.2.2 几种具体的交易脚本</h4><p>BTC中, 有以下几种十分常用的交易脚本:</p><ul><li>P2PK: Pay to Public Key</li><li>P2PKH: Pay to Public Hash <strong>(Most Common)</strong></li><li>P2SH: Pay to Script Hash</li></ul><p>我们一个个来看</p><hr><p><strong>1.P2PK</strong></p><p>这种最简单的脚本中:</p><ul><li>input script:<ul><li>Signature</li></ul></li><li>output script:<ul><li>Public Key</li><li>CheckSig</li></ul></li></ul><blockquote><p>请注意, 这里的output script 是 <strong>这笔交易使用的货币来源的输出, 并不是这笔交易本身的输出</strong> !</p></blockquote><p>按照堆栈的方法, 该类型脚本会将签名先压入栈底, 随后将交易来源的输出(即对应的公钥)压入栈顶, 最后利用CheckSig压入栈顶进行验证, 返回值只会是 True 或 False, 对应合法或不合法.</p><hr><p><strong>2.P2PKH</strong></p><p>这种脚本中:</p><ul><li>input script:<ul><li>Signature</li><li>Public Key</li></ul></li><li>output script:<ul><li>DUP(Duplicated)</li><li>Hash160</li><li>Public Key Hash</li><li>EqualVerify</li><li>CheckSig</li></ul></li></ul><p>与P2PK不同, 这种脚本的输入既需要给出签名, 还需要给出本人的公钥, 而输出脚本给出的是 <strong>收款人公钥的哈希</strong></p><p>从上往下看:</p><blockquote><p>由于这种方式其实是最常用的, 因此这里会详细解释一下整个验证过程. 我们用Bottom表示栈底, Top表示栈顶</p></blockquote><p>首先, 签名入栈, 公钥紧随其后入栈, DUP代表将栈顶元素复写一份, 即当前:</p><p>$$ Bottom \leftarrow Sig \leftarrow Pub Key \leftarrow Pub Key \leftarrow Top $$</p><p>Hash160表示将栈顶元素取哈希:</p><p>$$ Bottom \leftarrow Sig \leftarrow Pub Key \leftarrow Pub Key Hash(from \space input) \leftarrow Top $$</p><p>下面将输出脚本中的公钥哈希压入栈:</p><p>$$ Bottom \leftarrow Sig \leftarrow Pub Key \leftarrow Pub Key Hash(from \space input) \leftarrow Pub Key Hash(from \space output) \leftarrow Top $$</p><p>这里需要再次明确, 此处 <strong>靠近栈顶的公钥哈希, 是来自输出脚本的</strong> (即别人把这个钱转给你的时候写的公钥哈希); 而 <strong>它下面的公钥哈希, 是来自输入脚本的</strong> (即你要花这个钱了, 你自己给出的公钥通过哈希算法求出来的)</p><p>随后EqualVerify, 代表弹出栈顶两个元素, 比较两者是否相等.</p><p>最后一条CheckSig, 给出最终返回结果.</p><blockquote><p>读者如果有兴趣, 可以返回 5.3 节看看我们在那里给出的脚本, 使用的就是P2PKH.</p></blockquote><hr><p><strong>3.P2SH</strong></p><p>这种方式是最复杂的一种方式, 其结构如下:</p><ul><li>input script<ul><li>…</li><li>Signature</li><li>…</li><li>serialized Redeem script</li></ul></li><li>output script<ul><li>HASH 160</li><li>Redeem script Hash</li><li>EQUAL</li></ul></li></ul><p>本处, 输出脚本中给出的不再是公钥或公钥哈希, 而是一种特殊的脚本的哈希, 该脚本名为 <strong>赎回脚本</strong> , 而输入脚本中给出的是 <strong>赎回脚本的具体内容</strong> , 以及 <strong>能使这个赎回脚本正确运行所需要的签名</strong> .</p><p>当验证时首先验证输入脚本中的赎回脚本是否能与输出脚本中的哈希匹配(即 Serialized Redeem script 与 Redeem script Hash 的匹配), 随后还需要验证赎回脚本是否能够正确运行. 只有两步验证都通过, 该交易才能够视作合法.</p><p>至于这个赎回脚本的方式, 可能是前面提到的P2PK, P2PKH其中之一.</p><p>这种方式有点类似于编程语言中的函数封装, 将前两种验证方法封装成了一个单独的赎回脚本.</p><hr><h3 id="9-3-MultiSig-多重签名"><a href="#9-3-MultiSig-多重签名" class="headerlink" title="9.3 MultiSig(多重签名)"></a>9.3 MultiSig(多重签名)</h3><p>三种方式讲完了, 现在我们来说说这第三种到底干嘛使的, 因为P2SH这东西实在是有点复杂, 看起来很不必要.</p><p>第三种P2SH的最主要应用在于 <strong>实现多重签名(MultiSig)</strong> .</p><h4 id="9-3-1-多重签名的概念与最初实现"><a href="#9-3-1-多重签名的概念与最初实现" class="headerlink" title="9.3.1 多重签名的概念与最初实现"></a>9.3.1 多重签名的概念与最初实现</h4><p>所谓多重签名, 即一个账户中的钱由多个主体共同管理, 比如3个人管理同一个账户中的钱, 只需要两个人的签名, 就能够将钱取出. 最早的BTC所支持的多重签名如下:</p><ul><li>input script<ul><li>False</li><li>Sig_1</li><li>Sig_2</li><li>…</li><li>Sig_M</li></ul></li><li>output script<ul><li>M</li><li>PubKey_1</li><li>PubKey_2</li><li>…</li><li>PubKey_N</li><li>N</li><li>CheckMultiSig</li></ul></li></ul><p>其中 M 代表所需要的签名数, N 代表总共有几个签名. 至于Input script中的False, 那是Bitcoin最初设计MultiSig时的代码错误, 但由于其完全分布式的特性, 导致通过系统更新的方式修正它又显得代价过大, 因此采取的一种补偿措施.</p><p>这种方式在运行上没有任何问题, 但很明显, output script实在是过于冗余了, 同时我们考虑一下, output script通常是别人给你转账的时候需要使用的, 因此这就显得十分不方便.</p><h4 id="9-3-2-利用P2SH实现多重签名"><a href="#9-3-2-利用P2SH实现多重签名" class="headerlink" title="9.3.2 利用P2SH实现多重签名"></a>9.3.2 利用P2SH实现多重签名</h4><p>如何利用P2SH实现多重签名? 即将上述内容中的输出脚本单独封装:</p><ul><li>redeem script<ul><li>M</li><li>PubKey_1</li><li>PubKey_2</li><li>…</li><li>PubKey_N</li><li>N</li><li>CheckMultiSig</li></ul></li><li>input script<ul><li>False</li><li>Sig_1</li><li>Sig_2</li><li>…</li><li>Sig_M</li></ul></li><li>output script<ul><li>Hash160</li><li>Redeem script Hash</li><li>Equal</li></ul></li></ul><p>此时, 输出脚本变得十分的简单, 这个Redeem script可以直接通过收款方主动公布得知, 因此大大提升了用户生成转账交易的便利性. 同时, 也对收款方的转账策略有了更高的保密性.</p><h3 id="9-4-Proof-of-Burn-BTC销毁证明"><a href="#9-4-Proof-of-Burn-BTC销毁证明" class="headerlink" title="9.4 Proof of Burn(BTC销毁证明)"></a>9.4 Proof of Burn(BTC销毁证明)</h3><p>这是一种非常特殊的BTC输出脚本, 该脚本中有一行语句:</p><ul><li>output script<ul><li>RETURN</li><li>…(nothing or more operations or text)</li></ul></li></ul><p>在BTC的机制中, 当脚本运行识别到 <strong>RETURN</strong> 这个语句时, 会无条件返回False, 而其后方的操作, 或任何文字都不会被执行. 这就意味着, 如果有一笔交易的输出脚本包含了 RETURN, 那么这笔钱就永远花不出去了, 也就代表着这一部分 BTC 被 <strong>销毁</strong> 了.</p><p>为啥要销毁比特币呢?</p><p>第一种可能是以一定的代价来换取某一些小币种(AltCoin, or Alternative Coin), 这些小币种通常需要你付出一定的代价来获取一定量的它们的货币.</p><p>第二种可能, 这种方式可以用来永久存储一些信息, 这是因为RETURN后方的一切内容都不会执行, 但也不会被删除(区块链的不可篡改性). 典型的例子比如Digital Commitment(详见2.1.3节) , 你可以将你所拥有的任何信息的哈希值写入这笔交易输出脚本RETURN的后方, 当需要证明你的所有权时, 只需要公布该交易内容以及相应的原件即可.</p><p>这种证明代表着, 任何一个用户, 哪怕是一个普通的使用者, 都可以以及其小额的代价, 换取在区块链中记上一笔, 写一些东西的机会.</p><h2 id="Part10-BTC中的分叉"><a href="#Part10-BTC中的分叉" class="headerlink" title="Part10. BTC中的分叉"></a>Part10. BTC中的分叉</h2><p>在此前的章节中曾经提及过多次 <strong>分叉(Forking)</strong> 这个概念, 在本章中我们进一步明确分叉的各种类型与作用.</p><p>分叉, 一般分为:</p><ul><li>State Fork: 对于区块记账权的争夺, 或由于本身区块链状态导致的分叉<ul><li>Normal Fork: 两个节点几乎同时挖到了符合要求的区块, 这种分叉是合理的</li><li>Forking Attack(Deliberate Fork): 即有意产生的意见分歧导致的分叉(见4.5.3)</li></ul></li><li>Protocol Fork: 由于协议本身需要更新导致了分歧, 导致的分叉<ul><li>Hard Fork: 即 <strong>硬分叉</strong></li><li>Soft Fork: 即 <strong>软分叉</strong></li></ul></li></ul><p>由于此前我们对于第一种 <strong>State Fork</strong> 的内容已经有了比较详细的解释, 因此我们这里主要针对 <strong>Protocol Fork</strong> 进行阐述. Protocol Fork 针对着对区块链本身的协议进行更新.</p><h3 id="10-1-Hard-Fork"><a href="#10-1-Hard-Fork" class="headerlink" title="10.1 Hard Fork"></a>10.1 Hard Fork</h3><p>所谓 <strong>硬分叉(Hard Fork)</strong> 即当比特币的协议需要进行根本性改变(即不认可这个更新的节点, 我们称之为 <strong>旧节点</strong> 对于新协议是不兼容的), 但有一部分节点对这种新的更新不认同时, 就会产生所谓的硬分叉.</p><p>一个非常典型的案例即 <strong>增加BTC中划定的区块大小上限</strong> . 显然, 不认可大区块的旧节点无法认可新产生的链条.</p><hr><p><strong>为啥要增加区块大小</strong> ?</p><p>比特币的区块大小最初被规定为 <strong>1MB</strong> , 即 $ 1 * 10^{6} \space byte $ , 这是什么概念? 传统一笔交易的平均大小约 $ 250 \space byte $ .</p><p>这代表着一个区块内可以包含的交易数目:</p><p>$$ \frac{10^6}{250} \approx 4000 $$</p><p>我们将其平摊到 10分钟 之内, 可以算出每秒钟的平均交易数目:</p><p>$$ \frac{4000}{10 * 60} \approx 7 \space tx&#x2F;sec $$</p><p>显然, 这个每秒交易量太少了, 也代表着比特币的交易效率其实相当的低下.</p><p>因此, 有人提出需要增加BTC的区块大小.</p><hr><p>我们现在想一想增加区块大小的具体情况:</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/Blockchain/Hard%20Fork.png" alt="Hard Fork Example"></p><p>即使有大部分节点同意这个决定, 即增大区块大小, 但少数保守派不配合, 始终不认可这个决策, 那么这部分节点永远不会沿着上面的链条挖掘(因为在他们看来, 上面的链条是非法的), 而是继续沿着下侧链条继续工作. 这就形成了一个 <strong>硬分叉</strong> .</p><p>需要明确, 这种分叉是无法消除的, 因为意见分歧一般无法统一(分布式系统就是会产生这种情况), 那么上下两侧的区块奖励怎么算?</p><p>一般而言, 出现硬分叉后, 会出现币种分裂, 即挖上侧链条的人们任何上面的记账人, 下侧同理, 长此以往, 两条链条就分家了.(一个很典型的案例是 ETH 与 ETC).</p><p>很遗憾, 还有大问题, 因为币种分家后, 只有协议发生了改变, 而每个账户的公钥 &#x2F; 私钥都没有变化, 这会导致本来只想被囊括在上侧链条中的交易被重复囊括在下侧链条中. 这就又会可能导致各种各样的双花攻击.</p><p>有一种简单的处理方法即在两侧分家后的交易中都加上 <strong>chain ID</strong> 这个变量, 这能使得两侧的链条均得知一个交易是应当在哪一个链条上进行的.</p><h3 id="10-2-Soft-Fork"><a href="#10-2-Soft-Fork" class="headerlink" title="10.2 Soft Fork"></a>10.2 Soft Fork</h3><h4 id="10-2-1-软分叉概念"><a href="#10-2-1-软分叉概念" class="headerlink" title="10.2.1 软分叉概念"></a>10.2.1 软分叉概念</h4><p>所谓 <strong>软分叉(Soft Fork)</strong> 指的是旧节点能够兼容新的更新改动. 举一个假设, 比如 <strong>降低比特币区块大小上限</strong> (注意, 这只是个例子, 现实中没有发生过)</p><p>为什么叫做软分叉, 我们还是假设多数人认可这个更新, 因此从算力投票的角度, 必定是小区块产生的速率更快一些(链条更长一些).</p><p>此时, <strong>由于旧节点认可新链条</strong> , 根据最长合法链原则, 它会自动抛弃当前链条, 而转向新的小区块链条.</p><p>这代表着, 如果它坚持不更新, 它的收益会受损(它挖出的所有大区块都白挖了), 而整个区块链仍然会长时间保持一条最长合法链, 也就代表着此时的分支是 <strong>暂时的</strong> .</p><h4 id="10-2-2-软分叉实例"><a href="#10-2-2-软分叉实例" class="headerlink" title="10.2.2 软分叉实例"></a>10.2.2 软分叉实例</h4><p>一种比较典型的案例即对某些目前协议中未曾规定的域赋予一些新的含义(规则). 比如我们之前提到的 Coinbase Transaction 中的 Coinbase 域(详见5.2.2).</p><p>我们提及过, Coinbase 域内有一部分可能被作为 extra nonce , 但 Coinbase 域很大, 只用作这个多少有点浪费, 因此有人曾经提及, 剩余的部分可以用于存储 UTXO 集合的根哈希值, 这就是一个典型的软分叉.(但最终未被实行)</p><p>比特币中一个很著名的软分叉加入的功能, 就是 <strong>Pay to Script Hash</strong> 功能(详见 9.2.2 和 9.3)的加入, 这个脚本功能在最初的 BTC 中是不存在的, 但后续通过软分叉进行加入.</p><p>另一个十分著名的通过软分叉加入的功能被称作 <strong>隔离见证(SegWit &#x2F; Segregated Witness)</strong> , 这个功能使得每一笔交易中的 <strong>签名(Signature)</strong> 和 <strong>交易本身的信息(Tx Information)</strong> 被隔离开来, 将所有的签名相关信息放入 Coinbase Transaction 中. 这个更新 <strong>显著降低了交易平均大小</strong> , 使得比特币的交易效率大幅提升.</p><h2 id="Part11-BTC中的匿名性"><a href="#Part11-BTC中的匿名性" class="headerlink" title="Part11. BTC中的匿名性"></a>Part11. BTC中的匿名性</h2><p>所谓 <strong>匿名性(Anonymity)</strong> , 指的是一个人的身份在其进行某个事项时可以不被泄露, 进而他在现实中的身份不会公开, 也无法被攻击.</p><p><em>Anonymity describes situations where the acting person’s identity is unknown. The important idea here is that a person be non-identifiable, unreachable, or untrackable.</em></p><p>从这个角度来理解, 现金的匿名性其实是最好的, 因为当钱花出之后, 无人能够得知这张钱曾经经过你的手中. 当然, 现金的局限性也很高, 因为它不好管理, 不好存储.</p><p>BTC的匿名性体现在任何人只需要创建一个 <strong>&lt; 公钥 , 私钥 &gt;</strong> 对, 就可以成为一个用户, 而无需实名制. 但相对应的, 其账本是公开的.</p><p>现今社会中银行的匿名性体现在其账本不公开, 只有交易双方能得知这笔交易的存在, 但需要对一个中心管理机制实名.</p><h3 id="11-1-输入地址-输出地址之间的关联"><a href="#11-1-输入地址-输出地址之间的关联" class="headerlink" title="11.1 输入地址 &#x2F; 输出地址之间的关联"></a>11.1 输入地址 &#x2F; 输出地址之间的关联</h3><p>这里所说的输入地址 &#x2F; 输出地址通常指的是一笔交易中输入货币的原账户与输出货币的目的账户. 我们通过本节的论述可以发现其中有一些特殊情况下, 二者是可以建立联系的.</p><p>我们假设一笔交易有四个账户</p><ul><li>输入账户(Input Address): $ Add_1(spend \space 4 \space BTC), Add_2(spend \space 5 \space BTC)$</li><li>输出账户(Output Address): $ Add_3(receive \space 6 \space BTC), Add_4(receive \space 3 \space BTC) $</li></ul><hr><p>为什么需要有多个输出账户呢? </p><p>因为通常而言, 一个BTC账户上的钱很少能够等于商品的价格, 因此, 通常输入的BTC数量是要高于商品价格的, 至于剩余的BTC怎么处理, 则由支付方再额外提供一个 <strong>找零账户</strong> , 将多余的BTC单独创建一个输出, 转到那个找零账户上.</p><hr><p>我们考虑上面举的例子, 通常的情况下, 上面的情况都代表着:</p><ul><li>$ Add_3 $ 应当是收款方的账户, 而 $ Add_4 $ 应当是付款方的找零账户.(如果后者是收款方账户, 则无需两个付款账户一并付款)</li><li>某些情况, $ Add_1, Add_2 $ 这两个账户可能有关联, 甚至干脆属于同一个人.</li></ul><p>显然, 通过这一个交易就能分析出一些 <strong>交易用户之间的关联信息</strong> , 这本身就是对交易匿名性的一种破坏(更甚, 可以系统的分析大量的交易记录, 从而得到一些确定性较高的信息, 虽然这难度颇高).</p><h3 id="11-2-与个人实际身份的关联"><a href="#11-2-与个人实际身份的关联" class="headerlink" title="11.2 与个人实际身份的关联"></a>11.2 与个人实际身份的关联</h3><p>我们考虑, 当比特币一旦与现实生活中的某些行为产生关联, 比如大额法币 &#x2F; 比特币的转入 &#x2F; 转出时, 显然会引起司法部门的关注, 而由于最终都要置换为现实生活中有实际消费价值的法定货币, 因此这代表着个人肯定能被某些手段推测到的. 这从一定意义上讲, 也是对匿名性的一种破坏.</p><p>从这个角度上来讲, 参与比特币这个链条最久的, 比特币的发明者 <strong>中本聪</strong> , 是保证自己匿名性最好的人, 因为他从始至终从未花费自己的任何比特币财产, 也就意味着他从始至终没有将自己的账户与任何现实生活中的行为产生任何关联.</p><p>上述两个章节, 主要目的在于说明比特币的匿名性并没有达到十全十美, 请各位读者不要有什么危险的想法(笑)</p><h3 id="11-3-保证匿名性的手段"><a href="#11-3-保证匿名性的手段" class="headerlink" title="11.3 保证匿名性的手段"></a>11.3 保证匿名性的手段</h3><p>我们此前(6.1)提及过, 比特币是基于传统的TCP &#x2F; IP协议进行协议设计的. 这就意味着, 要想增强其匿名性, 需要从应用层的协议设计入手.</p><blockquote><p>至于为何不急于传统的传输层与网络层进行进一步工作, 这是因为传输层的TCP &#x2F; IP协议的设计已经相对完备, 并且加密手段也已经比较完善, 这里不会将重点放在它上.</p></blockquote><h4 id="11-3-1-Coin-Mixing"><a href="#11-3-1-Coin-Mixing" class="headerlink" title="11.3.1 Coin Mixing"></a>11.3.1 Coin Mixing</h4><p>所谓Coin Mixing, 指的是 <strong>对一定量的货币进行多次操作(即使这些操作是不必要的), 以使得最终交易双方转出 &#x2F; 收到的货币无法被溯源</strong> 的一种方式.</p><p><em>Coin mixers allow users to mix up transactions between different cryptocurrency addresses, so they become untraceable and cannot be followed back to the initial sender or receiver.</em></p><p>Coin Mixing这个功能通常以协议的方式被设计出来, 被广泛采用, 如各类货币交易所 &#x2F; 虚拟货币钱包APP等.</p><p>当然, Coin Mixing本身是存在风险的, 因为这个操作本质上是一种货币的支出 &#x2F; 收入, 因此如果参与者所选择的中介不值得相信, 则很容易造成严重的个人损失.</p><h3 id="11-4-Zero-Knowledge-Proof"><a href="#11-4-Zero-Knowledge-Proof" class="headerlink" title="11.4 Zero-Knowledge Proof"></a>11.4 Zero-Knowledge Proof</h3><p><em>In cryptography, a zero-knowledge proof or zero-knowledge protocol is a method by which one party (the prover) can prove to another party (the verifier) that a given statement is true, while avoiding conveying to the verifier any information beyond the mere fact of the statement’s truth.</em></p><p>通俗而言, <strong>零知识证明</strong> 指的是 <strong>证明者向验证者证明一个陈述是正确的, 但又无需向验证者透露任何除了该陈述是正确的之外的任何信息</strong> .</p><p>比特币采用的思想有点类似这里的思路, 在比特币中, 如果证明者A希望证明一个账户是自己的, 往往需要发布一个 <strong>自己私钥的签名</strong> , 而其余的验证者可以通过该签名能否与对应账户的公钥相匹配来验证 <strong>账户属于证明者A</strong> 这个命题是真实的.</p><p>这一整个过程中, 证明者A达成了 <strong>不将自己的私钥透露出去的同时, 也能够证明账户属于自己</strong> 的目的.</p><h2 id="Part12-总结-一些细碎的具体化工作"><a href="#Part12-总结-一些细碎的具体化工作" class="headerlink" title="Part12. 总结 &#x2F; 一些细碎的具体化工作"></a>Part12. 总结 &#x2F; 一些细碎的具体化工作</h2><h3 id="12-1-区块链究竟是如何存储的-哈希指针怎么实现的"><a href="#12-1-区块链究竟是如何存储的-哈希指针怎么实现的" class="headerlink" title="12.1 区块链究竟是如何存储的 &#x2F; 哈希指针怎么实现的?"></a>12.1 区块链究竟是如何存储的 &#x2F; 哈希指针怎么实现的?</h3><p>我们在此前的叙述中, 一直通过 <strong>哈希指针(Hash Pointer)</strong> 这个比较抽象的概念对区块链进行数据结构化工作, 但这个过程并不十分具体.</p><p>事实上, 在大部分全节点处, 一个个的区块被存储在 <strong>数据库</strong> 中, 存储形式是键值对, 即&lt;key, value&gt;形式(一个相当出名的数据库被称作Level DB).</p><ul><li>key: 区块的哈希值</li><li>value: 区块内容(Block Header &#x2F; Block Body)</li></ul><p>在实际系统中, 所谓的哈希指针, 就是一个哈希值, 因为可以通过哈希值来借由全节点查找到相应的区块内容, 这也就变相实现了指针的功能.</p><h3 id="12-2-共享账户的实现方式"><a href="#12-2-共享账户的实现方式" class="headerlink" title="12.2 共享账户的实现方式?"></a>12.2 共享账户的实现方式?</h3><p>曾经有一些人采用过一种风险相当大的方式进行共享账户, 即 <strong>私钥切割</strong> , 每个人保管私钥中的其中一部分.</p><p>这是一种风险相当大的方式, 比特币的私钥采用SHA-256哈希算法, 有256位, 我们假设一人保管128位, 两个人的共享账户, 这意味着另一个人 <strong>破解这个私钥</strong> 的难度大大降低, 因为他只需要尝试 $ 2^{128} $ 种可能就可以了, 这远远小于比特币最初设计的 $ 2^{256} $ . 这个破解难度会随着合伙人增加而显著降低.</p><p>因此, 如果存在合伙人共享账户的情况, 请务必 <strong>使用多重签名(MultiSig)</strong> 的方式!</p><h3 id="12-3-比特币中的有限共识"><a href="#12-3-比特币中的有限共识" class="headerlink" title="12.3 比特币中的有限共识"></a>12.3 比特币中的有限共识</h3><p>我们此前提及分布式系统共识时, 提及过CAP, 即一个共识系统是无法保证 <strong>一致性(Consistency) &#x2F; 可用性(Availability) &#x2F; 分区可用性(Partition tolerance)</strong> 同时满足的, 那比特币怎么还能通过共识的形式成立?</p><p>事实上, 比特币系统中实现的也是 <strong>有限共识</strong> , 它并没有打破学术界的已知结论, 但它做到了在一些额外机制的参与下尽可能维护这个系统的持续运行. 一个典型的 <strong>有限共识</strong> 例子即分支攻击, 当分支攻击发生时, 原先已经被建立的共识也会被推翻.</p><hr><p>我们对于区块链第一部分(Bitcoin)的概述就到这里.</p><p>再次对北京大学对应课程组表达感激与敬意!</p><p>希望本篇博文能对读者系统的了解区块链的原理有一定的作用, 同时也权当对于知识的记录, 以供再度查阅.</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part6</title>
      <link href="/posts/5693.html"/>
      <url>/posts/5693.html</url>
      
        <content type="html"><![CDATA[<h1 id="元素显示的进一步优化"><a href="#元素显示的进一步优化" class="headerlink" title="元素显示的进一步优化"></a>元素显示的进一步优化</h1><h2 id="元素层级"><a href="#元素层级" class="headerlink" title="元素层级"></a>元素层级</h2><h3 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h3><blockquote><p>上一节结尾我们留了一个问题，即一堆元素仍在一个HTML里面，这些玩意的层级怎么控制？需要记很多的结论嘛？</p></blockquote><p>我们在这里给出答案，完全不必要。</p><p>我们在Css中有这样一个属性， <strong>z-index</strong> 其存在最重要的意义就是调整页面中一堆元素的显示层级。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">z-index</span><span class="token punctuation">:</span> 100<span class="token punctuation">;</span><span class="token comment">/* 后面跟一个整数，这数越大，显示的就越靠上，默认值为0 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提一嘴，这个玩意是可以设置成负值的，全看读者的习惯。</p><p>当然，这玩意必须是用于定位（position）存在的情况下的，毕竟如果没有position的属性，页面上的元素压根不会相互遮挡是不是。</p><h3 id="父子关系-vs-元素层级？"><a href="#父子关系-vs-元素层级？" class="headerlink" title="父子关系 vs 元素层级？"></a>父子关系 vs 元素层级？</h3><p>有的读者可能挺好奇的，那我们平常子盒子总会默认显示在父盒子的上侧，我们有没有可能通过这个元素层级来让父盒子完全盖住子盒子？</p><p>答案是肯定的，但需要一定的方法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.father</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.son</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token property">left</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token property">z-index</span><span class="token punctuation">:</span> -1<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>father<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>son<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哎，我们一看，挺成功，就显示了父盒子的颜色。</p><p>但需要说明的是，如果我们这样设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">.father&#123;    ...    z-index:100;&#125;.son&#123;    ...    <span class="token comment">&lt;!-- z-index: --></span>    <span class="token comment">&lt;!-- 即子盒子不写z-index属性，仅通过父盒子设置 --></span>&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会发现没法子，子盒子还是在父盒子上边。<br>所以，这位置需要读者记忆一下。</p><h2 id="定位（确实，还是定位）"><a href="#定位（确实，还是定位）" class="headerlink" title="定位（确实，还是定位）"></a>定位（确实，还是定位）</h2><h3 id="居中，彻彻底底的居中！"><a href="#居中，彻彻底底的居中！" class="headerlink" title="居中，彻彻底底的居中！"></a>居中，彻彻底底的居中！</h3><p>此前第五部分说过了定位的事，为什么这里还要提？</p><p>这是因为通过定位，我们可以实现一个之前没试过的效果： <strong>让元素垂直居中</strong> 。</p><p>我们知道，让元素水平居中是很容易做到的：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但我们现在学了定位了，竖直居中就可以通过 <strong>绝对定位</strong> 来实现。</p><p>我们首先想到的应该是这个：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">position</span><span class="token punctuation">:</span> absoulte<span class="token punctuation">;</span><span class="token property">top</span><span class="token punctuation">:</span>50%<span class="token property">left</span><span class="token punctuation">:</span>50%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>读者可以试一下，我们会发现，这样搞的话就移大劲了，它移到了页面的中间偏右下方，这是由于两个50%分别是 <strong>页面顶部距离上边框的距离</strong> 和 <strong>页面左侧距离左边框的距离</strong> 。</p><p>那咋办捏？<br>好办，我们在说margin的时候单独提了一嘴，这玩意是支持负值的设置的，这时候就显出作用了。</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token property">position</span><span class="token punctuation">:</span> absoulte<span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> 50%<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>    <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哎，我们把这玩意通过负的margin再给它拽回来就完事了嘛。</p><p>相似的，我们如果要实现子盒子在父盒子里面的居中，自然也可以使用这种方法，无非是在父盒子里面设定一个 <strong>position: relative</strong> 而已。</p><h3 id="绝对定位-vs-浮动"><a href="#绝对定位-vs-浮动" class="headerlink" title="绝对定位 vs 浮动"></a>绝对定位 vs 浮动</h3><p>这俩玩意相信很多读者都懵的慌。</p><p>这里笔者仅仅给出一个不十分严谨的说法，即浮动是 <strong>半脱离文档流</strong> ，而绝对定位是 <strong>完全脱离文档流</strong> 。</p><p>这会造成一个什么差别捏？</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>            <span class="token comment">/* float: left; */</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Iusto debitis expedita delectus. Voluptates odit recusandae earum praesentium, quia incidunt suscipit expedita magni labore nemo velit animi molestias, odio voluptate aliquam!    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 ⬆ ，展现了绝对定位的情况，我们发现这绝对定位的盒子是一点面子也不给，直接碾着下面盒子里的内容。</p><p>如果我们改成:</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">.box2</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token selector">.box1</span><span class="token punctuation">&#123;</span>    <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    <span class="token comment">/* position: absolute; */</span>    <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们会发现下边的盒子虽然上来了，但其内部的文字会绕着上面浮动的盒子走。形成了一个非常初步的 <strong>文字环绕</strong> 的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS 杂项</title>
      <link href="/posts/65424.html"/>
      <url>/posts/65424.html</url>
      
        <content type="html"><![CDATA[<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><blockquote><p>本部分是一个很杂乱的整理，目的在于收集一些博主学习HTML，CSS，JS这一套内容时看到的，值得写下来的花里胡哨的玩意。</p></blockquote><h2 id="画三角画三角"><a href="#画三角画三角" class="headerlink" title="画三角画三角"></a>画三角画三角</h2><p>我们常常在网页上看到三角形，而这玩意在CSS中就能实现，通过边框的重叠。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">text-indent</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1 .triangle_icon</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid transparent<span class="token punctuation">;</span>            <span class="token property">border-top</span><span class="token punctuation">:</span> 5px solid <span class="token function">rgb</span><span class="token punctuation">(</span>55<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 255<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> 2.5px        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1:hover .triangle_icon</span><span class="token punctuation">&#123;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid transparent<span class="token punctuation">;</span>            <span class="token property">border-bottom</span><span class="token punctuation">:</span> 5px solid <span class="token function">rgb</span><span class="token punctuation">(</span>55<span class="token punctuation">,</span> 0<span class="token punctuation">,</span> 255<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> -2.5px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        导航        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>triangle_icon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个例子展示了通过空盒子，加上仅对一边的边框进行设置，来进行三角形的实现。<br>同时，利用hover状态来实现鼠标移上去后的三角形变化。</p><h2 id="行内元素-块元素"><a href="#行内元素-块元素" class="headerlink" title="行内元素-&gt;块元素"></a>行内元素-&gt;块元素</h2><p>这玩意其实正文里面说过，但是还有几种 <del><em>歪门邪道</em></del></p><ul><li>display: block; 这是最平常的一种</li><li>float属性 当给一个行内元素设置上浮动属性的时候，会发现它会直接变成块元素</li><li>position: absolute 当设置绝对定位时，行内元素也会直接转为块元素</li></ul><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>即在页面内实现跳转的功能（有点类似于本博客右边栏的目录，只不过不加动画，仅用css实现）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">*</span><span class="token punctuation">&#123;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">ul</span><span class="token punctuation">&#123;</span>            <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>            <span class="token property">right</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>            <span class="token property">top</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">li</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">line-height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black        <span class="token punctuation">&#125;</span>        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 1000px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#Part1</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#Part2</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">#Part3</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> chartreuse<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">a</span><span class="token punctuation">&#123;</span>            <span class="token property">text-decoration-line</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#Part1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#Part2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#Part3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Part1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Part2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Part3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Part3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现方式是通过为跳转目标设定id，而后通过页面内a链接，将href设定为id选择器即可。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part5</title>
      <link href="/posts/6013.html"/>
      <url>/posts/6013.html</url>
      
        <content type="html"><![CDATA[<h1 id="溢出-元素显示"><a href="#溢出-元素显示" class="headerlink" title="溢出 元素显示"></a>溢出 元素显示</h1><blockquote><p>上一部分重点讲述了盒子模型，并了解了一些相关的性质，相信读者目前已经能够做出一些初级的网页了。</p></blockquote><h2 id="溢出属性"><a href="#溢出属性" class="headerlink" title="溢出属性"></a>溢出属性</h2><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>本部分首先需要了解的，是一个叫 <strong>溢出属性</strong> 的玩意，这东西的存在意义是当你的内容过多了，盒子放不下了的时候，提供一个美观的解决方法，我们用属性 <strong>overflow</strong> 来进行控制。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">overflow: visible / hidden / scroll / auto / inherit;<span class="token comment">&lt;!-- 表示正常显示（接在盒子后面） / 隐藏溢出内容 /  --></span><span class="token comment">&lt;!-- 增加滚动条（即使没有溢出也会有） / 自动（只有超出边界才会出现滚动条） / 继承父元素的设置--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当然，如果我们只想要某一方向单独设置滚动条，那可以这样做：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">overflow-x: auto;overflow-y: hidden;<span class="token comment">&lt;!-- 只在x方向上自动生成滚动条，y方向上超出部分直接隐藏 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="空余空间"><a href="#空余空间" class="headerlink" title="空余空间"></a>空余空间</h3><p>与上面的属性相似，这个属性是用于设置如何处理元素内的空白的，即 <strong>white-space</strong> 。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">white-space: normal / nowrap / pre / pre-wrap / pre-line;默认值(浏览器直接忽略空白地区) / 不折行，占满空白(忽视本身盒子的限制) / 预格式化文本 / 预格式化+可折行 / 预格式化+不显示空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以提一嘴的是，pre这个玩意同时也是个标签，可以保留你在编辑器中文本的格式。</p><p>之所以要讲这个空余空间，是为了进一步实现让浏览器自动省略溢出内容的效果（即在后方加…）</p><p>我们可以这样设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">white-space: nowrap;overflow: hidden;text-overflow: ellipsis;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后这个玩意， <strong>text-overflow</strong> 是专门应对文本溢出的属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-overflow: clip / ellipsis;表示裁切 / 省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以上，我们就达成了使浏览器自动处理溢出的文本的目的。</p><h2 id="元素显示类型"><a href="#元素显示类型" class="headerlink" title="元素显示类型"></a>元素显示类型</h2><blockquote><p>有的读者看到这标题可能挺疑惑的，为啥还要接着讲元素的显示？</p><p>事实上，如果读者尝试的次数比较多，尝试的元素类别也比较多的话，可以发现有些玩意加属性的时候，是成功不了的，比如给一个 <strong>span标签加宽高</strong> ，这就涉及到了我们接下来要聊一聊的元素显示相关的问题。</p></blockquote><p>css中将元素分为了三类：</p><ul><li>块元素</li><li>行内（内联）元素</li><li>行内块元素</li></ul><p>咱还是，一类一类来：</p><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>所谓块元素，就是通常而言以 <strong>矩形</strong> 的形式展示在HTML中的元素，它们是可以定义自己的宽高的，同时会按照书写顺序自上而下排列。</p><p>也正因为这种元素比较规矩，所以它们一般会作为其他元素的容器。</p><p>比较典型的块元素有：</p><ul><li>div</li><li>p</li><li>ul-li</li><li>ol-li</li><li>dt-dd</li><li>h(标题)</li></ul><p>当然，我们想要辨别一个网页里面什么是块元素也比较简单，我们可以通过浏览器的 <strong>检查</strong> 功能，选中该元素，而后在它的Style属性中查看到它的所有样式，其中应该会有这么一条:</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">display: block;<span class="token comment">&lt;!-- 额外说一嘴，在ul的li中，会显示 display: list-item; --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里还有一点要提，p标签（段落标签）中，只能放文本以及行内元素， <strong>不能在里面嵌套块元素</strong> 。这里不进行理由的详述，读者可以自行尝试以下在p中嵌套一个块状元素会发生什么。</p><h3 id="行内元素（内联元素）"><a href="#行内元素（内联元素）" class="headerlink" title="行内元素（内联元素）"></a>行内元素（内联元素）</h3><p>内联元素与块元素不同，它们可以不经过浮动设置就呈现在浏览器的同一行，因为它们本身是没有自己的形状的，也正因如此，无法定义它们的宽高，它们的宽高是被内容撑起来的，包括内外边距也无法设置。</p><p>典型的行内元素有：</p><ul><li>a</li><li>b</li><li>em</li><li>i</li><li>span</li><li>strong</li></ul><p>(里面可能有些玩意读者忘了，可移步至本部分Part.1进行再次复习)</p><p>跟上边那块元素一样，这玩意在扔到浏览器里面也会默认自动加一行属性：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">display: inline;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h3><p>这种玩意比较特殊，它具有行内元素和块元素两者的部分特点，它们可以设置宽高，但还是会优先在同一行内显示。</p><p>典型的行内块元素有：</p><ul><li>img</li><li>input</li></ul><p>这位，就跟之前那两位不是很一样。在img这个标签里，如果你不设置，它的element-style中啥都不写，而input（表单）标签会在它的样式里加一个：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">display: inline-block;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="元素类型转换"><a href="#元素类型转换" class="headerlink" title="元素类型转换"></a>元素类型转换</h3><blockquote><p>这玩意如果有一定编程基础应该挺好理解的，就很类似强转嘛</p></blockquote><p>有想法的读者估计又要说了，既然元素的类型是通过style设置的，我们是不是可以手动设置它的类型？</p><p>答案是肯定的。</p><p>我们可以通过在任何一个元素的style中加display属性，来实现它们元素类型的强制转化。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 再写一遍 --></span>display: block / inline / inline-block<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这玩意有啥用呢？</p><p>我们假设一种情况，我们要做一个上边栏，里面插几个超链接，那我们如果不进行强转，直接就摁堆上去，会是种什么效果？</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">a</span><span class="token punctuation">&#123;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> 18px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>分区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>类别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>状况<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>实际<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>咱们会发现它们挤在一个小疙瘩里面，非常的不美观。</p><p>那我们学了盒子模型了，我们就寻思要不然给他加个外边距，内边距之类的，肯定能更好看一些。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">a</span><span class="token punctuation">&#123;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> 18px<span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>分区<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>类别<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>状况<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://baidu.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>实际<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者把上面这俩都运行一下，会发现下面这个明显要好看一些。<br>当然，可以在对a的hover之类的属性进行编辑，在外边再套一个div之类的，这里就不细讲了。此处仅仅是为了说明元素类型强制转化的作用。</p><h3 id="元素的隐藏"><a href="#元素的隐藏" class="headerlink" title="元素的隐藏"></a>元素的隐藏</h3><p>既然咱提到了display，咱就再聊一聊这东西还能干啥。</p><p>我们在有些网页里面经常看到一种效果，你把鼠标移上去的时候，它会在一侧弹出一个菜单，或者二级分类，这种效果我们其实现在能够简易的实现一下（因为咱们还没说JS，动画搞不了）：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">div:hover ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>这是个类别        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>二级菜单-类别1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>二级菜单-类别2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>二级菜单-类别3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <strong>display: none;</strong> 这个属性，可以使得原本写在页面上的元素先不显示出来，而我们在对其从属的盒子加一个鼠标移动上去的效果，即 <strong>hover</strong> ，就可以简单的达成我们的目的。</p><h2 id="二级菜单"><a href="#二级菜单" class="headerlink" title="二级菜单"></a>二级菜单</h2><blockquote><p>好嘞，咱说到了 display: none; 这玩意，那我们继续扩展一下子，用这个属性搞点切实有用的菜单出来呗。</p></blockquote><p>咱首先定下一个大框架：菜单的样式是横着排列的，当鼠标移上去，需要产生相应的颜色变更，此外，还需要在其下侧产生相应的二级选项。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">*</span><span class="token punctuation">&#123;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 300px<span class="token punctuation">;</span>            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box .item</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 148px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> #00f2ffa2<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 1px solid #00f2ffa2<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">ul</span><span class="token punctuation">&#123;</span>            <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aliceblue<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item:hover</span><span class="token punctuation">&#123;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> #24c1caa2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item:hover ul</span><span class="token punctuation">&#123;</span>            <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.item li:hover</span><span class="token punctuation">&#123;</span>            <span class="token property">color</span><span class="token punctuation">:</span> #24c1caa2<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Category-1            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token punctuation">></span></span>Study Notes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Review<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Blog<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Category-2            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>tag1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>tag2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>tag3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里其实没啥好讲的，因为用的都是之前说过的玩意，读者有遗忘的话可以善用本博客的搜索功能 <del>（笑）</del> 。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>咱继续往深了延申，我们目前已经实现了对于一个页面的二级菜单实现，但是很明显，我们搞出来的那玩意十分的不美观，它会很严重的挤压掉原先的内容（表现为直接使原先内容进行平移），这是令我们很不爽的事情。</p><p>我们当然首先想到的是将一个盒子直接摁死在页面的一个位置，在此前的内容中，我们会尝试着使用外边距 &#x2F; 内边距等属性进行实现，但其实css中对于这类情况单独给定了一个属性，即 <strong>position</strong> 。</p><h3 id="静态定位-相对定位"><a href="#静态定位-相对定位" class="headerlink" title="静态定位 &amp; 相对定位"></a>静态定位 &amp; 相对定位</h3><p>其实静态定位就是咱们之前不进行定位时达成的效果，其原则在于最大化的利用浏览器窗口空间，让一个个元素以其元素类型进行相应的位置放置。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: static;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而相对定位也比较简单，其效果为 <strong>使当前元素在相对于自己原先位置的基础上进行移动</strong> ，其标志物是自身原先的位置。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: relative;<span class="token comment">&lt;!-- 表示相对定位，常常会跟top，left等元素一并使用 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两种定位方式的共同点在于，它们都 <strong>不会脱离文档流</strong> 。<br>啥意思呢？就是虽然你的这个元素可能看上去没有显示在原先的位置，但这个位置实际上被它占据着，后方的元素不会挤占这个元素最初始的位置。</p><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>所谓绝对定位，就是被设置这个属性的元素，会在 <strong>父盒子有定位的基础上</strong> <strong>在相对于其父元素的绝对位置进行显示</strong> （如果没有父元素则为浏览器窗口的 <strong>第一屏</strong>）。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: absolute;<span class="token comment">&lt;!-- 代表绝对定位 --></span>top: 100px;left: 100px;<span class="token comment">&lt;!-- 相对于父元素下偏100px，右偏100px --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般而言，我们如果想要实现一个子盒子在相对于父盒子的某一个位置显示，则可以 <strong>将父盒子设置为相对定位，再将子盒子设置为绝对定位，即 “子绝父相”</strong> 。</p><p>需要明确的是，绝对定位会使得当前元素脱离文档流，即其它的元素会直接占据它原本的位置。</p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>固定定位，目的在于实现一个无论什么时候都显示在浏览器一个固定位置的元素。</p><p>有的人要问了，这玩意应该能用之前的绝对定位轻而易举地实现啊？<br>答案是否定的，我们再度会看此前绝对定位的说法：</p><blockquote><p>如果没有父元素则为浏览器窗口的 <strong>第一屏</strong></p></blockquote><p>读者应该理解我在说什么了，即绝对定位只能使得我们在浏览器不进行滚动时看到固定在那个位置的元素，而当我们浏览器中内容过多，一屏放不下，需要进行滚动下滑时，原先利用绝对定位固定的元素也会跟着一块划走。这是不符合我们所需要的效果的。</p><p>因此，产生了固定定位这个玩意：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: fixed;<span class="token comment">&lt;!-- 代表固定定位，后续也需要相应的位置说明，这里不再详述 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样的，固定定位也会使得当前元素脱离文档流。</p><h3 id="粘性定位"><a href="#粘性定位" class="headerlink" title="粘性定位"></a>粘性定位</h3><p>粘性定位是相对而言比较新的一个玩意，这东西能使得一个元素在 <strong>滑动过它之后一直黏在窗口的某一个位置上</strong> 。</p><p>要举例的话，比如本博客的导航栏，它会在你下滑过后一直黏在上面，不随着页面滚动而消失。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">position: sticky;<span class="token comment">&lt;!-- 代表粘性定位，后面也需要相应的位置说明 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，其实吧，这种顶部粘性导航栏其实用JavaScript来做更好。 <del>（那当然了，一个傻大框子一直摁在上面确实比较难看哈）</del></p><hr><p>到这，读者可能就意识到一个关于HTML中层级显示的问题。即各种什么浮动，什么粘性显示、定位之类的玩意到底怎么判断显示方法。我们搁到下一篇博文说。</p><p>至此，我个人认为这篇博文差不多了。</p><p>这篇写的比较杂，没什么章法，烦请读者见谅。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part4</title>
      <link href="/posts/51901.html"/>
      <url>/posts/51901.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-4-CSS属性详述（2）"><a href="#Part-4-CSS属性详述（2）" class="headerlink" title="Part.4 CSS属性详述（2）"></a>Part.4 CSS属性详述（2）</h1><blockquote><p>在第三部分中，我们了解了文字属性，列表属性以及背景属性，在这一部分，咱们继续将css中的属性说完。</p></blockquote><h2 id="浮动属性"><a href="#浮动属性" class="headerlink" title="浮动属性"></a>浮动属性</h2><p>相信各位应该已经有所疑惑了，HTML中纵向排列貌似是一件非常简单的事情，但我们如果想要让一些元素在标签页上横向排列，就需要涉及到另一种css的内容， <strong>浮动属性</strong> 。</p><p>浮动属性在HTML中主要起两个作用：</p><ul><li>定义网页中的其它元素围绕某一特定元素显示</li><li>让原先纵向排布的元素横向排列</li></ul><blockquote><p>这里希望读者先理解为什么这玩意叫做 <strong>浮动</strong> ，它的意思是你可以让一个元素上浮到浏览器的另一个图层上（笔者其实也不确定图层这个说法准不准确，权且这么叫着吧），而下方的元素会顺次上移到原图层空出的位置，以此达到两个元素在同一个x轴的位置显示的效果。</p></blockquote><p>我们首先介绍一下最基本的浮动属性：</p><h3 id="浮动属性：float"><a href="#浮动属性：float" class="headerlink" title="浮动属性：float"></a>浮动属性：float</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">float: left / center / right;<span class="token comment">&lt;!-- 分别表示浮动于左侧 / 中间 / 右侧 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此，我们如果尝试着利用浮动属性，来让三个div横向显示：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.red</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.green</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.blue</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者可以将这段代码运行尝试一下，我们会发现，我们成功的使得三个色块从左至右的显示了出来，顺序为红 &#x2F; 绿 &#x2F; 蓝。</p><h3 id="清浮动"><a href="#清浮动" class="headerlink" title="清浮动"></a>清浮动</h3><p>问题来了，我们如果将上面代码中最后一个蓝色的div的浮动属性去掉，读者可以想象一下会产生什么效果？</p><p>答案是蓝色由于补上了红色和绿色空出的原图层的位置，它会被更高图层的红色方块挡住，这显然是有些难以接受的，它影响了我们后续内容的布局，这个问题在HTML中被称为 <strong>高度塌陷</strong> 。我们如果不希望蓝色被遮挡，这里有三种解决方案：</p><ul><li>固定代码</li><li>清浮动</li></ul><p>我们一种一种讲：</p><hr><p>第一种，所谓固定代码，即将横向布局的内容外再套上一层容器，给这个容器固定一个高度和宽度，使得这个容器能够在原图层占据浮动起来的高度，从而达到解决高度塌陷的目的。</p><p>以上面的例子做改动：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.red</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.green</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.blue</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.floating_area</span><span class="token punctuation">&#123;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>floating_area<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们对需要横向排列的两个玩意单独框了起来，而后对最外层的容器进行了高度设置。</p><hr><p>第二种，所谓清浮动，是css中提供的一个属性 <strong>clear</strong> ，它可以使得一个元素左侧或右侧没有浮动元素与它重叠，从而达到解决高度塌陷的效果。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">clear: none / left / right / both<span class="token comment">&lt;!-- 代表允许有浮动对象 / 不允许左侧有浮动对象 / 不允许右侧有浮动对象 / 不允许有浮动对象 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个属性要正确使用，需要加给 <strong>原先被遮挡的元素</strong> ，我们还是以上面的例子做修改：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.red</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.green</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.blue</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">clear</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 这里其实也可以在蓝色方块上直接加一个什么都没有的div，单独写一个行内样式： --></span>    <span class="token comment">&lt;!-- &lt;div style="clear: left;">&lt;/div> --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们为蓝色的方块加上了clear属性，使得它不再被遮挡了。</p><hr><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote><p>上面说完了浮动属性的一些基础内容，但我们现在如果想让两个div之间产生一些距离，可能还是有些无能为力（当然，读者可以直接加空的div设置宽度，但多少显得有些繁琐），这时，需要引入css中一个充当基石的模型， <strong>盒子模型</strong> 。</p></blockquote><p><strong>盒子模型</strong> ，即把每个内容都看作是一个盒子，这个模型主要包含四部分的内容：</p><ul><li>内容模块：盒子内需要显示些什么</li><li>内间距：内容模块与边框之间的距离</li><li>边框：一个盒子的外壳（有点类似于表格的最外层）</li><li>外间距：盒子与盒子之间的距离</li></ul><p>我们可以很轻易地想到，在HTML网页这个2D平面内，盒子自然是有上下左右四个方向的，因此，内间距 &#x2F; 边框 &#x2F; 外间距都可以进一步细分成四个量。</p><p>关于内容模块，其实没什么可说的，就是咱们要展示给读者的内容，在此略过不表。</p><h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p>在盒子模型中，内边距用属性 <strong>padding</strong> 进行控制，我们举个例子：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">div</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Et id, minus unde ad cumque, at animi modi dolorem voluptatibus, delectus voluptates ullam! Facilis autem illo vero distinctio nulla corrupti a!    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读者可以跑一下试试，我们可以很清晰的看到，文字和边框是有一个很明显的间隔的，这就是内边距。</p><p>这时，我们又更挑剔了，我们希望能够分别设置内边距，即上下左右分别设置，也有方法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">padding: 20px 30px;<span class="token comment">&lt;!-- 只写两个值，代表上下，左右的两个值 --></span>padding: 20px 30px 10px;<span class="token comment">&lt;!-- 写三个值，代表上，左右，下的三个值 --></span>padding: 10px 20px 30px 40px<span class="token comment">&lt;!-- 写四个值，代表上，右，下，左的四个值（其实就是顺时针） --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，我们如果就想拿一个属性来控制某一个方向的内边距，也有相应的设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">padding-top: 20px;padding-bottom: 20px;padding-left: 20px;padding-right: 20px;<span class="token comment">&lt;!-- 分别代表上下左右的内边距 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要提一嘴的时，当设置padding时，会导致盒子本身的大小有相应的增大。因此背景色是可以蔓延到内边距的位置的。</p><p>与此同时，如果我们需要手动设置某些元素的内边距为0 （比如ul中的左内边距），我们也可以通过这种方式达成目的。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>我们继续外延，在内边距的外侧紧跟着一圈边框，也是可以设置的属性，利用 <strong>border</strong> 进行控制。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">border: 5px solid red;<span class="token comment">&lt;!-- 第一个属性是边框的宽度 --></span><span class="token comment">&lt;!-- 第二额属性是边框的样式，有实线（solid）、双实线（double）、虚线（dashed）、点状线（dotted） --></span><span class="token comment">&lt;!-- 第三个属性是边框的颜色 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与内边距相似的，边框也可以对四个方向分别进行设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">border-topborder-bottomborder-leftborder-right<span class="token comment">&lt;!-- 后续跟的值与上述单写border时的形式完全相同 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，也有另一种写法，即将 border 拆分成 <strong>border-width border-style border-color</strong> ，而后在每个属性后多写几个值，也能达成分别控制四周的效果，具体逻辑与上文中相同，即：</p><ul><li>两个值：上下，左右</li><li>三个值：上，左右，下</li><li>四个值：上，右，下，左</li></ul><p>额外提一嘴，背景色是同样可以延伸到边框处的</p><h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p>咱们继续外延，紧接着边框的，就是外边距。利用 <strong>margin</strong> 进行控制。</p><p>这里的设置方式与padding几乎一致，同样的紧跟一个宽度；也可以设置1，2，3，4个值，控制的边框也与上方的原则相同；也可以分成 <strong>margin-top margin-bottom margin-left margin-right</strong> 四个属性进行书写。因此在这里不再详细叙述了，读者可参考上面的padding的写法。</p><p>二者明显的不同是背景色无法延伸至外边距处，此外，margin是支持负值的设置的：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">padding-top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-right</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid red<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background-color</span><span class="token punctuation">:</span> blueviolet<span class="token punctuation">;</span>            <span class="token property">padding-top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-bottom</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">padding-right</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>            <span class="token property">text-align</span><span class="token punctuation">:</span> justify<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 5px solid red<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们将第二个盒子的上侧外边距设置成了-50px，运行过后可以发现两个盒子纵向重叠到一块了。</p><p>除此之外，我们还有一种很常用的横向居中方案：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">margin:0 auto;<span class="token comment">&lt;!-- 上下外间距为0，左右外间距自动（即居中） --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>好了，我们已经大体搞明白了外边距这个玩意的作用，现在我们需要明确两个很容易碰到的问题：</p><ul><li>兄弟关系的盒子的垂直 &#x2F; 水平外边距问题</li><li>父子关系的盒子的外边距问题</li></ul><p>咱一个个说：</p><hr><p>所谓兄弟关系，就是这俩玩意在html中的地位是相同的，而俩盒子又在水平或竖直方向上相邻。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1, .box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上面的这两个盒子为例，我们原本的想象是，第一个盒子下外边距为100px，第二个盒子上外边距为50px，俩盒子应该距离150px才对，但我们发现最终俩盒子只隔了100px。</p><p>这个位置就需要额外记忆一下： <strong>竖直方向外边距取最大值</strong></p><p>但这个结论对于水平方向并不成立：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1, .box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token property">margin-right</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">background</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">margin-left</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们改成这个水平相邻的状况，会发现它们俩之间确实隔了150px，这证明了另一个结论： <strong>水平方向外边距会合并</strong> 。</p><hr><p>接下来我们谈父子关系的盒子，即外面一个大盒子包着里面一个小盒子。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> aqua<span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这边，我们将一个小盒子包在一个大盒子里面，为小盒子设置一个上边距，我们本来想着应该可以达到小盒子与大盒子的边框之间相隔一个距离，但很遗憾，最终显示结果是大盒子距离上边界隔了一段距离，而小盒子仍然显示在大盒子的左上角。</p><p>要解决这个问题，有三种方法：</p><ul><li>变通方法，给父盒子加一个内边距（padding），缺点在于padding本身会扩大盒子的大小。</li><li>给父盒子设置边框，缺点同上，仍然会扩大盒子的大小。（可以把颜色设置为transparent，即透明的）</li><li>给子盒子 &#x2F; 父盒子添加浮动属性，使二者不在同一个图层上。</li><li>在父盒子的属性中加入overflow: hidden; 这个方法涉及到BFC相关的内容，在将来的博文中会进一步讲解。</li></ul><hr><p>好了，本篇博文主要针对浮动与盒子模型进行了对应的讲解。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part3</title>
      <link href="/posts/2300.html"/>
      <url>/posts/2300.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-3-CSS属性详述（1）"><a href="#Part-3-CSS属性详述（1）" class="headerlink" title="Part.3 CSS属性详述（1）"></a>Part.3 CSS属性详述（1）</h1><blockquote><p>从这一部分开始，我们来了解CSS中具体有哪些属性，各个属性的具体写法，具体作用。</p></blockquote><p>CSS中大体的属性类别有以下几类：</p><ul><li>文本属性</li><li>列表属性</li><li>背景属性</li><li>边框属性</li><li>浮动属性</li></ul><h2 id="CSS文本属性"><a href="#CSS文本属性" class="headerlink" title="CSS文本属性"></a>CSS文本属性</h2><p>写在前面，文本属性，目的在于对页面内的各类文本进行各种各样的修饰。</p><h3 id="大小和字体"><a href="#大小和字体" class="headerlink" title="大小和字体"></a>大小和字体</h3><p>在css中，文本大小用属性 <strong>font-size</strong> 来进行调整，其单位为 px ，即像素；而字体则通过属性 <strong>font-family</strong> 来进行调整：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">p</span><span class="token punctuation">&#123;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>        <span class="token comment">/* 16px是默认值，设计图中常用12px */</span>        <span class="token property">font-family</span><span class="token punctuation">:</span> 宋体<span class="token punctuation">;</span>        <span class="token comment">/* 直接写字体名字，默认值是微软雅黑 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>    Lorem.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意，当字体名称中有空格时，两侧需要加引号。</p><p>还有一种为了兼容性考虑的写法，即font-family属性后可以写多个字体，两两用逗号相隔开，这时系统会从第一个字体开始逐个加载，直到找到成功加载的字体为止。</p><h3 id="字体颜色"><a href="#字体颜色" class="headerlink" title="字体颜色"></a>字体颜色</h3><p>在css中，字体颜色用属性 <strong>color</strong> 来进行调整。这个属性其实此前的博文有提及过，就不再赘述，但有几个别的写法可以在这里提一嘴：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">color: rgb(0, 0, 255);<span class="token comment">&lt;!-- 利用rgb的强度来混合颜色，三种颜色的强度值由0~255 --></span>color: #0000ff;<span class="token comment">&lt;!-- 利用16进制来进行rgb调色，六位数每两位分别代表red，green，blue的强度值。 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加粗和倾斜"><a href="#加粗和倾斜" class="headerlink" title="加粗和倾斜"></a>加粗和倾斜</h3><p>加粗，用属性 <strong>font-weight</strong> 进行控制；倾斜，用属性 <strong>font-style</strong> 进行控制。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">font-weight: bolder / bold / normal / lighter;<span class="token comment">&lt;!-- 三个可取值分别代表 更粗 / 加粗 / 正常 / 最细--></span>font-style: italic / oblique / normal;<span class="token comment">&lt;!-- 三个可取值分别代表 斜体字 / 微微倾斜 / 正常 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以再提一句：font-weight其实可以进一步细化调整，即后面直接跟数字，取值范围为100 ~ 900，100是最细的细体，400为正常，700为加粗，900为最粗</p><h3 id="文本水平的对齐-居中"><a href="#文本水平的对齐-居中" class="headerlink" title="文本水平的对齐 &#x2F; 居中"></a>文本水平的对齐 &#x2F; 居中</h3><p>文本的水平对齐通常利用 <strong>text-align</strong> 这个属性进行编辑</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-align: left / center / right / justify;<span class="token comment">&lt;!-- 左对齐 / 居中 / 右对齐 / 两端对齐--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但我们如果想让一段文本显示在一个中靠左的位置呢？<br>答案是先通过width来对一个单元占用的总宽度进行设置，而后再进行text-align的操作即可：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">width: 500px;text-align: right;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，只有左右对齐还不是很够，我们如果希望让文本两端都整整齐齐的，则需要利用到 justify，即两端对齐。</p><h3 id="文本的行高"><a href="#文本的行高" class="headerlink" title="文本的行高"></a>文本的行高</h3><p>说完文本的水平对齐，读者可能想着能否对竖直方向上的属性也进行一定的编辑，这里给出一种比较初级的方法，即调整行高：<br>在css中，行高通过 <strong>line-height</strong> 这个属性进行调整。单位为px，即我们很熟悉的像素。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">height: 100px;lineheight: 100px;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以先通过height设置区域的总高度，而后对行高进行对应的设置，即可达到文本居中显示的效果。</p><p>当然，这种方法在多行文本显示时显然就不是那么的友善了，这就要看此后提及的另一种方法了。</p><h3 id="文本间距"><a href="#文本间距" class="headerlink" title="文本间距"></a>文本间距</h3><p>在css中，文本间距由两部分组成：</p><ul><li>词间距</li><li>字符间距</li></ul><p>字符间距，即字符之间相隔的距离。我们通过 <strong>letter-spacing</strong> 这个属性进行调整，单位为px。</p><p>而对于英文，还有一个词间距的概念，即两个单词之间的距离。我们通过 <strong>word-spacing</strong> 这个属性进行调整，单位同样为px。</p><h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p>首行缩进，这玩意其实可以通过我们在 Part1 中提到的 <strong>&amp;emsp</strong> 这个玩意实现，但是多少有点麻烦，因此css提供了另一种方式，即 <strong>text-indent</strong> 属性，这个属性可以手动控制你网页的首行缩进大小，单位仍然是px。</p><p>额外提一嘴，还有个单位可以用，即 <strong>em</strong> ，意为全角空格（可以理解为当前字体的单位大小）。这个单位存在主要是为了防止当字体大小被改变后原先设置的缩进值看起来不合适这一现象。<br>举个例子，中文缩进两个字符，就可以这么写：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-indent: 2em;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文本修饰线"><a href="#文本修饰线" class="headerlink" title="文本修饰线"></a>文本修饰线</h3><p>css中，也有相对应的文本修饰线的写法，利用 <strong>text-decoration</strong> 这个属性进行控制：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-decoration: underline / overline / line-through / none<span class="token comment">&lt;!-- 分别对应下划线 / 上划线 / 删除线（中划线） / 无线--></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>读者应该会有些好奇none的意义，这个玩意主要用于修饰a链接，它可以使得一个超链接不带有下划线。</p><p>同时，其实可以同时设置多条线，即在一个text-decoration中写多个值，两个值之间用空格分隔即可。</p><h3 id="大小写检索"><a href="#大小写检索" class="headerlink" title="大小写检索"></a>大小写检索</h3><p>在css中，提供了一个对文本字母进行快速编辑的方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">text-transform: capitalize / lowercase / uppercase / none;<span class="token comment">&lt;!-- 代表单词首字母大写 / 全部字母小写 / 全部字母大写 / 不设置 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="文字混合属性-font"><a href="#文字混合属性-font" class="headerlink" title="文字混合属性 font"></a>文字混合属性 font</h3><p>font这玩意是为了偷懒用的，目的在于所见文本编辑时需要的代码量，它是 <strong>fong-style font-weight font-size&#x2F;line-height font-family</strong> 这一大串的缩写。</p><p>这上面的一串在使用时顺序不能改变，并且必须同时指定font-size和font-family。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">font: italic bolder 20px/1em 宋体; <span class="token comment">&lt;!-- 创建了一个斜体加粗，20像素大，一单位高的宋体文本格式 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="CSS列表属性"><a href="#CSS列表属性" class="headerlink" title="CSS列表属性"></a>CSS列表属性</h2><blockquote><p>接下来，咱们进入下一个部分，谈一谈列表的相关属性。</p></blockquote><p>我们还记得，在HTML中，列表（list）前方显示的分类标志可以进行初步的自定义，这是通过列表本身带有的属性 <strong>type</strong> 达成的。</p><p>而相似的，在css中，列表的分类符号也有自定义的方法。</p><h3 id="基本分类符"><a href="#基本分类符" class="headerlink" title="基本分类符"></a>基本分类符</h3><p>类似的，css也能实现HTML本身能够实现的几种基本图像，我们通过属性 <strong>list-style-type</strong> 进行编辑：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">ul</span><span class="token punctuation">&#123;</span>        <span class="token property">list-style-type</span><span class="token punctuation">:</span> disc / circle / square / none<span class="token punctuation">;</span>        <span class="token comment">/* 分别代表实心圆 / 空心圆 / 实心方块 / 不设置 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，都进入css这个领域了，再只能实现这样子的分类符，就显得有点简陋了。</p><h3 id="图片分类符"><a href="#图片分类符" class="headerlink" title="图片分类符"></a>图片分类符</h3><p>利用css，我们可以实现将列表前的分类符改为图片的效果，我们通过属性 <strong>list-style-image</strong> 进行控制：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">list-style-image: url()<span class="token comment">&lt;!-- 括号里放图片的存储位置 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里提一下，可以对ul里面的每个li分别进行设置，从而达到出现不同的分隔符的效果。</p><h3 id="列表项标记的放置位置"><a href="#列表项标记的放置位置" class="headerlink" title="列表项标记的放置位置"></a>列表项标记的放置位置</h3><p>css中还提供了一个属性，可以用于控制分类符的位置，但它其实只有两个取值：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">list-style-position: outside / inside<span class="token comment">&lt;!-- 分别代表显示在列表外 / 显示在列表内 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>html的默认值是outside，但这个属性用的非常少，读者了解即可。</p><h3 id="列表混合属性-list-style"><a href="#列表混合属性-list-style" class="headerlink" title="列表混合属性 list-style"></a>列表混合属性 list-style</h3><p>与文本属性类似，列表也给了一个偷懒的写法，即 <strong>list-style</strong> ，它是 <strong>list-style-type list-style-image list-style-position</strong> 的简写，当使用它时，只需要把上面三个属性用空格分开书写即可，并且在这里位置可替换。</p><p>其实上述提到的列表属性，用的最多的还是直接写一个：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">list-style: none;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是因为list-style-image这个属性插入的图片可定义程度不高，因此通常还是仅仅去除分类符即可。</p><h2 id="CSS背景属性"><a href="#CSS背景属性" class="headerlink" title="CSS背景属性"></a>CSS背景属性</h2><p>背景，即我们之前接触过的background，在此前的简要描述中，我们常用background-color这个属性，它就属于背景属性的一种。</p><h3 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h3><p>如我们很熟悉的，css中编辑背景颜色利用属性 <strong>background-color</strong> 来进行。</p><p>值得提一嘴的是，这里的颜色同样支持利用此前提过的三种写法进行书写，同时，介绍第四个写法，它比此前的写法多了一个透明度的数字：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-color: red / rgb(255, 0, 0) / #ff0000 / rgba(255, 0, 0, 0.5);<span class="token comment">&lt;!-- rgba是带透明度的写法，最后一个值取值范围在0~1之间，代表透明度 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="背景颜色渐变"><a href="#背景颜色渐变" class="headerlink" title="背景颜色渐变"></a>背景颜色渐变</h3><p>这里其实css提供了一种背景颜色渐变的方法，可以用属性 <strong>gradient</strong> 来进行设置：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background: linear-gradient(black, white);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，这只是最基础的渐变方法，这里给出一个说明链接，读者自行查看即可：</p><blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Images/Using_CSS_gradients</a></p></blockquote><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>类似，我们可以给一个区域贴上一个图片，这就可以通过 <strong>background-image</strong> 这个属性进行实现：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-image: url()<span class="token comment">&lt;!-- 括号里填图片地址 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，图片本身占用像素与我们设定的区域很大可能并不相同，这就需要另一个属性来进行协调，即图片平铺。</p><h3 id="图片显示方法"><a href="#图片显示方法" class="headerlink" title="图片显示方法"></a>图片显示方法</h3><p>我们可以更改背景图片的显示模式，从而达到更好的预览效果，通过属性 <strong>background-repeat</strong> 来达成：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-repeat: repeat / repeat-x / repeat-y / no-repeat;分别代表正常平铺 / 在x轴平铺 / 在y轴平铺 / 不平铺<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="图片显示位置"><a href="#图片显示位置" class="headerlink" title="图片显示位置"></a>图片显示位置</h3><p>相对应的，当区域大于图片大小，或者区域小于图片大小时，我们可以通过对属性 <strong>background-position</strong> 进行定义，从而实现图片展示位置（或区域的不同）：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 默认置于左上角 --></span>background-position:20px 20px<span class="token comment">&lt;!-- 距离左上角多少像素 --></span>10% 10%<span class="token comment">&lt;!-- 距离左上角的距离占整个区域的大小百分比 --></span>left/center/right top/center/bottom<span class="token comment">&lt;!-- 水平位置和竖直位置 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图片显示大小"><a href="#图片显示大小" class="headerlink" title="图片显示大小"></a>图片显示大小</h3><p>此后，我们还可以通过调节图片显示在区域内的大小来实现更好的显示效果，用 <strong>background-size</strong> 进行编辑：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-size: 500px 500px;100% 100%;cover;<span class="token comment">&lt;!-- 这个值代表等比例放大，直到它能够完全覆盖整个区域为止 --></span>contain;<span class="token comment">&lt;!-- 这个值代表等比例放大，直到再放大就会导致图片不能完整展示为止 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相当于对图片进行了拉伸。</p><h3 id="背景图片的固定"><a href="#背景图片的固定" class="headerlink" title="背景图片的固定"></a>背景图片的固定</h3><p>css额外提供了一个属性叫 <strong>background-attachment</strong>，它用于控制背景是否会随着鼠标滚轮的滚动而随网页一起滑动。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">background-attachment: scroll / fixed;<span class="token comment">&lt;!-- 分别代表正常滚动 / 不随网页一起滚动 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当设置成fixed时，相当于在当前页面呼出了一个独立页面单独显示这个背景，而相应的这个背景就被你固定在了网页的那个位置。</p><p>这个属性常常用于制作视差效果。</p><p>这里给出一个简要的例子：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">        <span class="token selector">.box1</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 3000px<span class="token punctuation">;</span>            <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>../image/test_image1.webp<span class="token punctuation">)</span></span><span class="token punctuation">;</span>            <span class="token property">background-size</span><span class="token punctuation">:</span> 500px 300px<span class="token punctuation">;</span>            <span class="token property">background-repeat</span><span class="token punctuation">:</span> no-repeat<span class="token punctuation">;</span>            <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token selector">.box2</span><span class="token punctuation">&#123;</span>            <span class="token property">width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> 3000px<span class="token punctuation">;</span>            <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>../image/test_image2.jpg<span class="token punctuation">)</span></span><span class="token punctuation">;</span>            <span class="token property">background-size</span><span class="token punctuation">:</span> 500px 300px<span class="token punctuation">;</span>            <span class="token property">background-repeat</span><span class="token punctuation">:</span> no-repeat<span class="token punctuation">;</span>            <span class="token property">background-attachment</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 上面的图片地址读者可以自行替换成自己的图片地址 */</span>    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>box2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用上述方法，我们放了两个fixed的背景图片，会显示在浏览器窗口的同一个位置，而只有当滚轮滚到这个图片属于的区域时，这个图片才会显示出来，这就实现了随着滚轮下滑，第一个图片消失，而第二个图片同时出现的效果。</p><h3 id="背景混合属性-background"><a href="#背景混合属性-background" class="headerlink" title="背景混合属性 background"></a>背景混合属性 background</h3><p>同理，与文字 &#x2F; 列表类似，背景的属性也是可以被混合书写的，就是简单的 <strong>background</strong> ，它里面可以包含 <strong>background-color background-image background-repeat background-position background-attachment</strong> 等等一系列属性，只需要使其中间利用空格分隔开即可。</p><blockquote><p>background-size是不能扔进去的，必须单独写。</p></blockquote><blockquote><p>另外，background这个玩意只要写了，它会把此前除了background-size之外对background进行的一系列设置全部覆盖掉。</p></blockquote><h3 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h3><p>这里可以还需要加一栏，关于透明度的说明。</p><p>css中单独提供了一个属性，即 <strong>opacity</strong> 来对相应元素的透明度进行控制，取值范围为 0 ~ 1 ，1为完全不透明，0为完全透明。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">opacity: 0.7;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>这篇博文将博主目前能想到的都写上了，至于后续如果看到一些别的属性，也会相应的在这里进行更新。</p><p>至此，还差浮动属性和边框属性没写，咱们留给后续的博文吧。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part2</title>
      <link href="/posts/54588.html"/>
      <url>/posts/54588.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-2-进入CSS"><a href="#Part-2-进入CSS" class="headerlink" title="Part.2 进入CSS"></a>Part.2 进入CSS</h1><blockquote><p>第一部分中，我们谈完了html的一些基本标签，但是它们的样式多少还有些简朴，要想加点花里胡哨的玩意，就还得看css的内容</p></blockquote><h2 id="样式表"><a href="#样式表" class="headerlink" title="样式表"></a>样式表</h2><p>读者如果进行了一些尝试的话，可以发现HTML的表格，表单都十分的简朴，甚至简陋， <del>不够花里胡哨</del> ，这在前端设计中是不可接受的，因此我们这里引出CSS的样式表。</p><blockquote><p>CSS，cascading style sheets，译为层叠样式表，是web中的表现标准语言，可以达成修改网页显示信息的样式的目的，目前遵循CSS3.0的标准</p></blockquote><h3 id="CSS的组成部分"><a href="#CSS的组成部分" class="headerlink" title="CSS的组成部分"></a>CSS的组成部分</h3><p>CSS的基本组成部分有 <strong>选择符</strong> 和 <strong>声明</strong> ，而每条声名内又由 <strong>属性</strong> 与 <strong>属性值</strong> 组成</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">选择符</span><span class="token punctuation">&#123;</span>    <span class="token property">属性</span><span class="token punctuation">:</span> 属性值<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要说明的是，css的书写是和html同时存在的，但显然直接把css的玩意扔到body中，显得就有些突兀，也很杂乱，因此，我们通常利用html中的 <strong>style</strong> 标签框住css的内容。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        这是个例子        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">            <span class="token selector">h1:</span><span class="token punctuation">&#123;</span>                <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>第一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过上述的例子实现了将所有的第一级标题都更改为红色。</p><p>这里有个众人一块规定的事情，因为文中出现太多style有点影响观感，也不方便阅读，因此我们一般将style写到head中。</p><h3 id="内部样式-外部样式"><a href="#内部样式-外部样式" class="headerlink" title="内部样式 &amp; 外部样式"></a>内部样式 &amp; 外部样式</h3><p><strong>内部样式</strong> ，即 <strong>将对当前html文件起作用的css直接通过style标签写在html内部</strong> ，也就是上方咱们进行css引入的方法。</p><p>但这种方式对于html结构很复杂，内容很繁多的情况就不是很友好，每次想要修改标签还需要翻到文件最上方，不方便。</p><p>因此 <strong>外部样式</strong> 是更常用的一种方法，即在文件外单独写一个css，在需要使用这个css的html中利用 <strong>链接</strong> 来告知html文件需要套用的css内容。</p><p>关于外部样式的链接方式，通常有以下两种：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 第一种 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">herf</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>Css文件路径<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 第二种 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    @import <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>      <span class="token comment">/* 括号里是Css文件的路径 */</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两种方式还是有一定的区别的：</p><ul><li>link标签是XHTML提供的标签，而@import是css提供的方式</li><li>当一个页面被加载时，link引用的css会被同时加载，但@import引用的css会等待页面加载完成后再进行加载，这会导致使用@import引用的css在网速比较慢时页面会出现闪烁</li><li>@import在较老的浏览器（IE5以下）是不兼容的</li></ul><p>因此，在引入标签时，还是建议更多的使用link标签的方式。</p><h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><p><strong>行内样式</strong> ，即在html中的某一行单独运用style属性对该标签的样式进行个性化编辑</p><p>像这样：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token special-attr"><span class="token attr-name">style</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>11111111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这玩意尽量不要用太多，因为这东西还是会影响文件可读性的。</p><h3 id="样式表的优先级"><a href="#样式表的优先级" class="headerlink" title="样式表的优先级"></a>样式表的优先级</h3><p>上面讲了三种样式：内部样式、外部样式、行内样式，如果这仨全都存在，则它们总归会有一个顺序优先级的问题。</p><p>这里给出明确结论，内部样式和外部样式的作用取决于谁在head标签更靠下的位置（即谁最后加载），但一般html的书写习惯是将link标签写在style标签上方。</p><p>同理，外部标签与内部标签的优先级都不如行内标签高。</p><p>因此基本上可以说：行内样式 &gt; 内部样式 &gt; 外部样式</p><p>当然，还有一种特殊情况，即 <strong>!important</strong> 标签的存在会使当前指向的样式优先生效。</p><p>总结一下：!important &gt; 行内样式 &gt; 内部样式 &gt; 外部样式</p><p>这里推荐以代码的自上而下的执行顺序来对优先级进行理解。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p><strong>选择器</strong> 的存在是为了实现对html内元素的一对一，一对多的控制。</p><p>存在以下几种类别：</p><ul><li>元素选择器</li><li>类选择器</li><li>id选择器</li><li>通配符选择器</li><li>群组选择器</li><li>包含选择器</li><li>伪类选择器</li></ul><h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><p>元素选择器就是之前咱们css的写法，即通过选择某一类的元素并添加相应的样式。</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>元素选择器的范围有些太广了，因此我们还需要进行进一步的细分，这就催生了 <strong>类选择器</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* 在指定样式时需要前方加. */</span>    <span class="token selector">.type1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.type2</span><span class="token punctuation">&#123;</span>        <span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 一个标签可以有多个类，中间用空格分隔 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>type1 type2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以理解为，类选择器就是人工将各种标签重新进行了分类。</p><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>id选择器与类选择器有些相似，但是id选择器是一对一的，相当于对一个单独的玩意起一个单独的id，在css文件中单独开一片区域来对其进行单独的样式设置。（有点类似身份证号）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token comment">/* 在指定id之前加# */</span>    <span class="token selector">#box1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 一个标签相应的只能有一个id --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>box1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>111111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p><strong>通配符</strong> 顾名思义，即选择所有元素的意义，在html中用 * 进行表示。</p><p>这种选择器会直接选择到一个html中所有的标签，通常用于对所有标签的属性进行整体调试，比如间距等。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">*</span><span class="token punctuation">&#123;</span>        <span class="token comment">/* 外边距 */</span>        <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token comment">/* 内边距 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="群组选择器-包含选择器"><a href="#群组选择器-包含选择器" class="headerlink" title="群组选择器 &amp; 包含选择器"></a>群组选择器 &amp; 包含选择器</h3><p>其实群组选择器这玩意就是偷懒用的，如果一个html中存在多个不同的标签，但是想要设置成一个样式，一方面可以用类，但更方便的方法则是利用群组选择器：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">div, p, h1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 当然，也可以直接把类也写进去 */</span>    <span class="token selector">div, .class1, h1</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token comment">/* 相当于所有的class1类也都设置了背景颜色 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们可以直接将不同的标签一块写，用逗号隔开即可。</p><p>由此，我们又衍生出了一个叫做包含选择器的玩意（也叫后代选择器），其意义在于选择一个包含在一个标签内的标签。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">div p</span> <span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span>blue<span class="token punctuation">;</span>        <span class="token comment">/* 在div内的p都会受到影响 */</span>    <span class="token punctuation">&#125;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>2222222222    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>This is first paragraph.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器主要针对标签进行个性化编辑。主要有四种语法，对应标签具有的四种状态：</p><ul><li>a:link{} 标签的初始状态</li><li>a:visited{} 标签被访问后的状态</li><li>a:hover{} 鼠标悬停在标签上的状态</li><li>a:active{} 标签被激活（即鼠标按下标签时其状态）</li></ul><p>这里需要明确，即这四个状态在css中的顺序是固定的，即上方列举的顺序，请务必注意。</p><h3 id="选择器的权重"><a href="#选择器的权重" class="headerlink" title="选择器的权重"></a>选择器的权重</h3><p>上边讲了一堆选择器，针对的是不同的标签，但当多个选择器选中了一个标签，并且它们的属性发生了冲突的时候，就涉及到了一个选择器的权重的问题（即哪个选择器中的样式真正对其起作用）</p><p>从尝试结果上来讲，规律为：</p><p>!important &gt; id选择器 &gt; 类选择器 &gt; 元素选择器</p><p>至于包含选择器，其权重为层级权重之和，此后再根据上方的规则进行生效判断。</p><p>当然，上述除了important之外的玩意，在行内样式面前，都无法生效（即在标签内直接写一个style）</p><p>这里额外说一句，上面写过 <strong>样式表的优先级</strong> ，那只是一个大致叙述，而这里则细化到了 <strong>选择器的权重</strong> 。一个样式表是可以包括很多选择器的。</p><hr><p>至此，我们算是初步了解了css的作用，并明确了css应当如何书写，如何与html相关联。这时候读者大概率会想大展宏图，对自己的html网页一同改头换面了。</p><p>下一节，将进入各种css中各种属性的详细设置。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML&amp;CSS Part1</title>
      <link href="/posts/54396.html"/>
      <url>/posts/54396.html</url>
      
        <content type="html"><![CDATA[<h1 id="Part-1-概述-一些基础"><a href="#Part-1-概述-一些基础" class="headerlink" title="Part.1 概述 &amp; 一些基础"></a>Part.1 概述 &amp; 一些基础</h1><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML（HyperText Markup Language）是一种用于创建网页的标准标记语言，这种语言与此前的C，Java并不十分相同，它的用处主要停留在前端开发的层面上，不会像先前的两门那样那么复杂。</p><p>相应的，目前的浏览器支持的主流格式也以相应的语言后缀进行命名，即（）.html</p><h3 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h3><p>浏览器千千万，不同的浏览器对HTML的标记支持也不尽然相同，这就催生了一群大佬在一块商讨了一个标准出来，规定web的格式规范等等内容，即我们说的 <strong>W3C</strong> 万维网联盟</p><p>这个联盟制定了相应的标准，使得同样的HTML文件在大部分浏览器下能够正常，正确的显示。</p><p>当然，总有个例，在目前已经停用的IE6浏览器中，由于当年微软独树一帜地决定不遵循W3C的标准，因此导致当年写HTML时还要专门对IE6进行一定的适配工作，也是导致IE6名声很臭的原因之一。<del>（后续微软没办法还是在后续的IE版本中进行了W3C的支持）</del></p><h3 id="Web的组成部分"><a href="#Web的组成部分" class="headerlink" title="Web的组成部分"></a>Web的组成部分</h3><p>总而言之，前端的需求内容有三部分：</p><ul><li>HTML结构</li><li>CSS表现</li><li>JS（JavaScript）行为</li></ul><p>HTML规定了网页的结构，但它局限于静态，不好看。<br>CSS可以对网页进行进一步的布局，配色，以及动画制作<br>Javascript则负责一些网页行为的实现，比如点按操作，动画播放，暂停等等。</p><h2 id="第一个HTML文件"><a href="#第一个HTML文件" class="headerlink" title="第一个HTML文件"></a>第一个HTML文件</h2><pre class="line-numbers language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt; &lt;!--    我的第一个网页--&gt;&lt;html lang &#x3D; &quot;en&quot;&gt;    &lt;head&gt;        &lt;title&gt;My first HTML pages&lt;&#x2F;title&gt;    &lt;&#x2F;head&gt;    &lt;body&gt;        &lt;center&gt;            Hello,&lt;br&#x2F;&gt;World.        &lt;&#x2F;center&gt;    &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;!--    html: 最外层标签    head: 头部标签    body: 主体标签    常规标记：类似上述的，有头有尾的    单标记（空标记）：&lt;标记&#x2F;&gt;，可以没尾    这里的&lt;br&#x2F;&gt;是换行的意思--&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的玩意大伙看一眼就成，下面会分块的进行基本概述</p><h2 id="标签详述"><a href="#标签详述" class="headerlink" title="标签详述"></a>标签详述</h2><h3 id="文档声明与字符编码"><a href="#文档声明与字符编码" class="headerlink" title="文档声明与字符编码"></a>文档声明与字符编码</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在html中，第一步要做的永远是先声明文档类型，即告诉你的浏览器你写的是个什么玩意，在2024年的今天，主流的文档类型是HTML5。</p><p>而后，可以选择性的写入你这个文档的编码类型，由于不同的字符编码规则不同，因此声明编码类型可以帮助浏览器了解应该按照哪种原则进行解码，解决一些兼容性问题。</p><p>需要保证你写的编码格式与你编写HTML程序时的编码类型相同。</p><h3 id="文本的语义化"><a href="#文本的语义化" class="headerlink" title="文本的语义化"></a>文本的语义化</h3><blockquote><p>读一段文字，我们必然希望文字是有重点，有分隔的，而并非是杂糅成一团来进行呈现，这一过程就叫做 <strong>文本的语义化</strong></p></blockquote><p>这里，给出一些常用的语义化标签：</p><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>一级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>二级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>三级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>四级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span><span class="token punctuation">></span></span>五级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>六级标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>额外说一嘴，一级标题的数量不建议过多，这是因为网页爬虫会将一级标题放到权重最大的位置，因此一级标题应该是你书写HTML时最简练，最精准的内容概括。</p><h4 id="段落-换行-水平线"><a href="#段落-换行-水平线" class="headerlink" title="段落 &#x2F; 换行 &#x2F; 水平线"></a>段落 &#x2F; 换行 &#x2F; 水平线</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>段落文本内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这三者中，换行与水平线是两个空标记。</p><h4 id="加粗-倾斜-各种线"><a href="#加粗-倾斜-各种线" class="headerlink" title="加粗 &#x2F; 倾斜 &#x2F; 各种线"></a>加粗 &#x2F; 倾斜 &#x2F; 各种线</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 加粗 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span>加粗的内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>strong</span><span class="token punctuation">></span></span>突出的文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>strong</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 倾斜 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">></span></span>强调文本<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">></span></span>斜体内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 删除线 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>s</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>s</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>del</span><span class="token punctuation">></span></span>删除线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>del</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 下划线 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span><span class="token punctuation">></span></span>下划线<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 上下标 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sub</span><span class="token punctuation">></span></span>下标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sub</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sup</span><span class="token punctuation">></span></span>上标<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sup</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了便于爬虫处理，在处理时推荐使用</p><ul><li>strong</li><li>em</li><li>del</li></ul><h3 id="关于属性值的一些说明"><a href="#关于属性值的一些说明" class="headerlink" title="关于属性值的一些说明"></a>关于属性值的一些说明</h3><p>我们可以看到HTML给了我们很大的操作空间，但同时也有问题，如果我们希望更改一条线的颜色，长度这一类的 <strong>属于其标记本身的属性</strong> ，那这时， <strong>标记的属性值</strong> 就显得尤为重要了。</p><p>我们回到两类标记上：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 双标记 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标记</span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>标记</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 单标记 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>标记</span> <span class="token attr-name">属性</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到标记本身后方是可以附加属性的。</p><p>我们拿很常见的分割线 hr 来举例</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">color</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>green<span class="token punctuation">"</span></span> <span class="token attr-name">width</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>300<span class="token punctuation">"</span></span> <span class="token attr-name">align</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">noshade</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过第一个操作，我们可以达成：</p><ul><li>线的颜色为绿色: color</li><li>线的长度为300px（像素）: width</li><li>线的位置在右侧: align</li></ul><p>通过第二个操作，可以达成：</p><ul><li>去除默认分割线的阴影效果</li></ul><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>由于HTML本身是个标签语言，在我们需要用到标签内的字符是，这是就涉及到了特殊符号的问题<br>（其实这个玩意挺像C里面想要打反斜杠&#x2F;时候的办法）</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 左尖角 --></span><span class="token entity named-entity" title="&lt;">&amp;lt;</span><span class="token comment">&lt;!-- 右尖角 --></span><span class="token entity named-entity" title="&gt;">&amp;gt;</span><span class="token comment">&lt;!-- 空格 --></span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span> //这玩意受到字体的影响，可能会导致一些问题<span class="token entity named-entity" title="&emsp;">&amp;emsp;</span> //稍微好一些<span class="token comment">&lt;!-- 当然，其实用CSS进行空格的书写才是更应当推广的方式，这里先权且这样放着 --></span><span class="token comment">&lt;!-- 版权符 --></span><span class="token entity named-entity" title="&copy;">&amp;copy;</span><span class="token comment">&lt;!-- 商标 --></span><span class="token entity named-entity" title="&trade;">&amp;trade;</span><span class="token entity named-entity" title="&reg;">&amp;reg;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="div-span"><a href="#div-span" class="headerlink" title="div &amp; span"></a>div &amp; span</h3><blockquote><p>这两个标签是没有具体意义的，但这二者对于一个HTML页面的分割，划分很有作用</p></blockquote><p>div在直接使用时，会独占一行，作为一个区域的元素。</p><p>span在使用时，能实现内容多宽，就占用多宽的空间距离，常用于独立修饰文本。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>I like <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token special-attr"><span class="token attr-name">style</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>gray<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>HTML<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- 我们实现了一个标题中对于一个单词的单独修饰 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要提一嘴的是，span单独写是没什么用的，span一般而言需要配合各类属性，样式来进行使用</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><blockquote><p>列表常用于对分类的事物进行罗列</p></blockquote><p>在HTML中，列表有这么几类：</p><ul><li>无序列表：前面没有标号</li><li>有序列表：前面有相应的行号</li><li>自定义列表：形式更加多样</li></ul><p><del>(这玩意尝试写过markdown的看官应该会比较熟悉)</del></p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表的标签：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ol</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ol</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- orderlist --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ol</strong> 标签里面只能包含 <strong>li</strong> 标签，而 li 标签里面就可以加一些花里胡哨的玩意了。</p><p>此外，ol标签本身也可以加一些属性：</p><ul><li>type属性：有序列表前方的标号从什么符号开始：<ul><li>“a” : 小写字母开始</li><li>“A” : 大写字母开始</li><li>“i” : 小写罗马数字开始</li><li>“I” : 大写罗马数字开始</li><li>“1” : 数字1开始</li></ul></li><li>start属性：有序列表从哪个位置开始计数，其取值只能是一个数字</li></ul><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表本身没有顺序之分，因此比有序列表相对简单一些</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>Part<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token comment">&lt;!-- unorderlist --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，ul标签里面也只能放li标签，至于花里胡哨的玩意请放在li内搞</p><p>无序列表前面默认是一个黑色实心圆，其样式可以通过type属性来进行更改：</p><ul><li>“disc” : 黑色实心圆</li><li>“circle” : 黑色空心圆</li><li>“square” : 黑色实心正方形</li><li>“none” : 隐藏，什么都不显示</li></ul><h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dl</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dt</span><span class="token punctuation">></span></span>这里可以放图片<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dt</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dd</span><span class="token punctuation">></span></span>这里可以放文字<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dd</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dl</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>自定义列表通常整体进行复制，从而方便对每个自定义列表进行单独的样式编辑</p><h3 id="一种缩写"><a href="#一种缩写" class="headerlink" title="一种缩写"></a>一种缩写</h3><p>当我们需要进行多个标签的书写时，可以通过Emmet缩写进行快捷写入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">ol>li&#123;Part&#125;*3<span class="token comment">&lt;!-- 一个具有三个项的有序列表，每个项的内容都是Part --></span>dl>dt&#123;图片&#125;+dd&#123;文字&#125;<span class="token comment">&lt;!-- 一个自定义列表 --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片在html中使用 <strong>img</strong> 标签进行插入</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>图片的相对路径<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，一般进行html的图片插入时，使用 <strong>相对路径</strong> 。（绝对路径在服务器中不起效果）</p><p>具体相对路径的写法，建议读者自行上网进行了解，这其中涉及到一些Linux的相关知识。</p><h3 id="图片的属性"><a href="#图片的属性" class="headerlink" title="图片的属性"></a>图片的属性</h3><p>对于图片，主要有以下属性：</p><ul><li>src : 即图片的路径（通常为相对路径）</li><li>title : 即鼠标悬停到图片上会显示什么信息</li><li>alt : 图片如果加载不出来会显示的提示信息</li><li>width : 宽度</li><li>height : 高度</li></ul><p>当我们需要让图片自动缩放时，可以只对宽度或高度中一个属性进行预设，可以达到自动缩放的效果。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>超链接，目的在于在不同的html界面中进行跳转</p><p>其具体写法：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">herf</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">title</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">target</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>超链接内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这其中：</p><ul><li><strong>超链接内容</strong> 表示这个跳转链接的显示内容（就是哪个蓝底字的具体内容）</li><li><strong>herf</strong> 表示链接路径</li><li><strong>title</strong> 表示鼠标悬停上去后的显示信息</li><li><strong>target</strong> 表示在哪个位置打开文档<ul><li>“_self” : 默认值，在当前窗口打开新页面</li><li>“_blank” : 在新窗口打开跳转页面</li></ul></li></ul><p>还需要说个事，就是超链接的内容可以是多种多样的，可以是文字，也可以是个图片（利用img标签），这样可以实现点击图片跳转的效果，思路要打开。</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>这部分就顾名思义，就是咱们平常常见的表格了，其有 <strong>行</strong> ， <strong>列</strong> 等等属性。</p><p>在HTML中，表格的创建如下：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span>        <span class="token comment">&lt;!-- tr表示行 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>            <span class="token comment">&lt;!-- td表示单元格 --></span>            1        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>            2        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="表格-table-的相关属性"><a href="#表格-table-的相关属性" class="headerlink" title="表格(table)的相关属性"></a>表格(table)的相关属性</h3><p>表格总共有8个属性：</p><ul><li>边框线：border &#x3D; “1” ，后方这个数字是表格外边框的像素大小</li><li>宽度：width &#x3D; “500”，同理（也可以写成width &#x3D; “50%”，表示相对于父元素的百分比，直接写的话就是窗口）</li><li>高度：height &#x3D; “500”，同理（同上，也可以通过百分比，但是高度的父元素（即body部分）是由内容决定的，因此不会达到直接占据页面一半这么高的效果）</li><li>位置：align &#x3D; “left &#x2F; center &#x2F; right”，表示表格在横向占据的位置</li><li>背景颜色：bgcolor &#x3D; “blue”</li><li>边框颜色：bordercolor &#x3D; “red”</li><li>单元格之间的间距：cellspacing &#x3D; “0”</li><li>单元格与内容之间的间距：cellpadding</li></ul><h3 id="表格行-tr-的相关属性"><a href="#表格行-tr-的相关属性" class="headerlink" title="表格行(tr)的相关属性"></a>表格行(tr)的相关属性</h3><p>表格行总共有4个属性：</p><ul><li>高度：height</li><li>颜色：color &#x3D; “yellow”，在表格本身有颜色时，这一行会相应的覆盖掉之前的颜色</li><li>文字对齐相关：<ul><li>水平对齐：align &#x3D; “left &#x2F; right &#x2F; center”，同理</li><li>竖直对齐：valign &#x3D; “top &#x2F; middle &#x2F; bottom”，同理</li></ul></li></ul><h3 id="表格单元格-td-的相关属性"><a href="#表格单元格-td-的相关属性" class="headerlink" title="表格单元格(td)的相关属性"></a>表格单元格(td)的相关属性</h3><p>表格单元格总共有5个属性：</p><ul><li>宽度：width，这里要注意，一个单元格设置了宽度，会影响一整列的宽度</li><li>高度：height，同理，一个单元格设置了高度，也会影响一整行的高度</li><li>颜色：bgcolor</li><li>文字对齐相关：<ul><li>水平对齐：align</li><li>竖直对齐：valign</li></ul></li></ul><h3 id="表格的合并列-合并行"><a href="#表格的合并列-合并行" class="headerlink" title="表格的合并列 &amp; 合并行"></a>表格的合并列 &amp; 合并行</h3><p>表格合并列 &#x2F; 行通常这样写：</p><ul><li>colspan &#x3D; “2”，合并列，后方的值即合并后其占据的单元格数目</li><li>rowspan &#x3D; “3”，合并行，后方的值同理</li></ul><p>这里要注意，在合并后，需要将被合并的单元格注释掉，否则会呈现出一种被合并的单元格被 <strong>挤出去</strong> 的感觉。</p><p>咱们要想了，咱这表格都整出来了，是不是该进行一点点自定义化，比如说能在里面输入各种各样的东西之类的？</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单，其最重要的目的，就在于收集信息。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>from</span> <span class="token attr-name">action</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    用户信息：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里咱们得一个个讲：</p><ul><li>form的属性：<ul><li>method &#x3D; “get &#x2F; post”</li><li>action &#x3D; “向何处发送数据”</li></ul></li><li>input内的属性：<ul><li>type &#x3D; “text &#x2F; password &#x2F; submit &#x2F; button &#x2F; reset” 他们分别表示文本输入区，密码输入区，提交按钮，常规按钮，重置功能</li><li>placeholder &#x3D; “显示的简短提示信息”</li><li>name 必须设置，表示提交给后端时能被识别到的名字</li><li>value 常常与按钮一并使用，可以表示按钮上显示的内容</li><li>outline 表示输入框外侧是否会存在一圈边框</li></ul></li></ul><p>我们需要明确，既然要收集信息，就必定有发射端与接收端，而接收端就在form的action属性内进行说明，而 get &#x2F; post 目的在于提交过后不会对你提交的信息在网址框内进行明确显示。</p><p>在后面的工作中，我们常常使用 “input type &#x3D; button” ，这意味着我们创建了一个完全可自定义的按钮，会在此后的JS行为中对其进行进一步的定义（如校验密码之类的操作可以在这个过程内完成）</p><hr><p>这个坑开的十分的突然，其实主要是博主有了相应的需求，需要了解一下前端相关的知识，因此权且作为一个栏目放在博客中吧。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML&amp;CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-7</title>
      <link href="/posts/55458.html"/>
      <url>/posts/55458.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><blockquote><p>这标题看着多友善~<br>话说在前，其实从博主的学习顺序上来看，这第七章应该是 图 这一部分的内容，但一来认为刚刚说完树，应该让读者（也是让博主）缓一缓节奏，二来排序这一章在C语言的章节中就想着要进一步扩展一下，正好在此直接说完了事。<br>好嘞，咱正式开始。</p></blockquote><p>在我们C语言的章节中，曾经提过 <strong>冒泡排序</strong> 这一种最基础，最简单的排序方式。诚然，这种排序方式清晰且易懂，但还是那个问题，耗时太长了，时间复杂度太高。因此本章会介绍更多种排序方式，权当为读者扩展思路。</p><h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h3><p>虽然读者应该大体了解了，但这里为了仪式感还是提一嘴。</p><p><strong>排序</strong> 指的是将一个 <strong>无序</strong> 的记录序列调整为 <strong>有序</strong> 的记录序列的过程。</p><h3 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h3><p><strong>排序的稳定性</strong> 指的是排序算法对于 <strong>相同关键字</strong> 进行排序前后的 <strong>相对次序</strong> 是否有改变。</p><p>这个词算是个新词，咱举个例子说一下，比如有如下这么个数组：</p><p>2, 1, 5<sub>(1)</sub>, 8, 7, 5<sub>(2)</sub></p><p>可以看出，这个序列中有两个 <strong>5</strong> ，而在排序之前，这俩元素是有先后顺序的。<br>如果通过一种排序算法，本来在前面的5<sub>(1)</sub>还会稳定的处于5<sub>(2)</sub>的前侧，我们则称这种排序算法是 <strong>稳定的</strong> ，反之，如果排完序不确定哪个5在前，我们则称这种排序算法是不稳定的。</p><h3 id="内排和外排"><a href="#内排和外排" class="headerlink" title="内排和外排"></a>内排和外排</h3><p><strong>内排</strong> 是 <strong>内部排序</strong> 的简称，其意义为将数据存储在计算机的内存中直接进行排序过程。</p><p>相对应的， <strong>外排</strong> 是 <strong>外部排序</strong> 的简称，其意义为当需要排序的纪录很多时，内存无法全部一次性容纳，则我们在排序的过程中还需要多次访问外存来完成排序的全过程。</p><p>在本章中，我们探讨的主要内容为内部排序。</p><h3 id="内部排序的方法"><a href="#内部排序的方法" class="headerlink" title="内部排序的方法"></a>内部排序的方法</h3><p>本章中主要涉及到的排序方法有：</p><ul><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>基数排序</li></ul><p>它们进行排序的方法有区别，进而导致了其时间复杂度的区别，但总归，内部排序的目标，都在于 <strong>逐步扩大有序序列长度</strong> 。</p><p>与以往不同的是，我们这里先对待排序的数据类型进行定义，这是因为不同排序的方法操作的对象总是需要统一的，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">1000</span> </span><span class="token comment">//顺序表长度</span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> KeyType<span class="token punctuation">;</span> <span class="token comment">//你需要定义的关键词类型（也可以直接写，这里不必要太纠结）</span><span class="token comment">//待排序的数据类型定义</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    KeyType key<span class="token punctuation">;</span> <span class="token comment">//关键字</span>    InfoType otherinfo <span class="token comment">//其他数据</span><span class="token punctuation">&#125;</span>RcdType<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    RcdType r<span class="token punctuation">[</span>MAXSIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//在排序中，往往第一个存储区域（即r[0]）处于闲置状态</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//顺序表长度</span><span class="token punctuation">&#125;</span>SqList<span class="token punctuation">;</span> <span class="token comment">//顺序表类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，接下来我们正式进入算法部分。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="插入排序的基本思想"><a href="#插入排序的基本思想" class="headerlink" title="插入排序的基本思想"></a>插入排序的基本思想</h3><p><strong>插入排序</strong> ，简称插排，基本思想在于将待排序区域划分为已排序区域(R<sub>1</sub>, R<sub>2</sub>, …, R<sub>i-1</sub>)以及未排序部分(R<sub>i</sub>, R<sub>i+1</sub>, …, R<sub>n</sub>)，我们在涉及到 R<sub>i</sub> 这个元素时，会先找到其在这个有序序列中应当插入的位置，将其插入，同时其原位置上的元素至原先的已排序区域结尾元素顺序后移一位。</p><p>根据上述思路，我们可以将 <strong>一趟插入排序</strong> 分为以下三步：</p><ul><li>在有序区域找到插入位置</li><li>后移后续的有序区元素</li><li>将设计元素插入到该位置上</li></ul><p>与此同时，基于实现方法的不同，插排还有进一步的细分：</p><ul><li>直接插入</li><li>折半插入</li><li>希尔排序</li><li>表插入</li></ul><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>直接插入排序是最简单的，它直接从后往前找，并每次都进行一次比较，直到找到应当插入的位置为止：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//直接插入排序</span><span class="token keyword">void</span> <span class="token function">InsertionSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//第一个元素不用进行插排，因为它肯定在第一轮时在第一个位置</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//还记得之前定义待排序列空出的下标为0的位置吗，这个位置叫做监视哨。</span>            <span class="token comment">//每次排序时会先将待插入的元素赋给监视哨</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//当没到达插入位置时，将该位置的元素往后移一位</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//for跑完了，就到达插入位置了</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//再把监视哨的内容插入到这个位置即可</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码应该注释的很清楚了，读者只需要注意一下这个叫做 <strong>监视哨</strong> 的玩意，这东西在后续的排序算法中会有很广泛的应用。</p><p>这种排序的时间复杂度其实还是挺高，因为其相当于每一次都还得跑两层循环，为O(n<sup>2</sup>)，正因如此，它也还是只适用于排序的元素非常少的情况。</p><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>我们一寻思了，本来前面的序列就是有序的，那我们干脆用折半查找的方式来找插入位置多好，确实，这就是折半插入排序的基本思路。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//折半插入排序</span><span class="token keyword">void</span> <span class="token function">BiInsertionSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//下面需要通过折半查找找到插入位置</span>        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> high <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            m <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//折半</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                high <span class="token operator">=</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//插入点在前半部分</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                low <span class="token operator">=</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//插入点在后半部分</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//当找到插入点时，会将low变到high+1（或将high变到low-1），此时不满足循环条件，退出循环</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//记录后移</span>        <span class="token punctuation">&#125;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//插入</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，这种排序算法其实时间复杂度总体还是O(n<sup>2</sup>)，但好在当数据很多时，其寻找插入位置比此前直接插入的方式要快很多，因此还是很值得考虑的。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的思路跟此前两者的思路并不相同，它意图先对待排序序列做出 <strong>宏观</strong> 的调整，此后再将调整范围逐步缩小至 <strong>微观</strong> 层面。</p><p>这个思路确实非常令人眼前一亮，其具体实现方式为先进行 <strong>跳跃式的插入排序</strong> ，比如我们将整个序列分为 <strong>d个子序列</strong>：</p><p>R[1], R[1+d], R[1+2d], …, R[1+kd];<br>R[2], R[2+d], R[2+2d], …, R[2+kd];<br>…<br>R[d-1], R[2d-1], R[3d-1], …, R[(k+1)d-1];<br>R[d], R[2d], R[3d], …, R[(k+1)d];</p><p>这个 <strong>d</strong> 被称为排序过程的增量，而这个量是在逐渐减小的，直到最后一趟排序时它会变成1。</p><p>我们在每次排序时，先对每一组中的元素进行排序，最后将d降为1时，就相当于对整体再进行一次直接插入排序。</p><p>到这读者可能会问了，这有啥用呢？最后反正都得进行一次插排？</p><p>别忘了希尔排序的思想，这个方式使得我们在进行最后的整体插排时，整个序列已经 <strong>基本有序</strong> 了，这使得最后的直接插排耗时大幅度降低，这就是希尔排序在前面对宏观顺序的调整的价值。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.7/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.jpg" alt="希尔排序"></p><p>理解了方式，我们给代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//希尔排序</span><span class="token keyword">void</span> <span class="token function">ShellInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//每一趟希尔排序的函数，该趟增量为d</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//对于增量为d的每一组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span>d<span class="token punctuation">;</span> j<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">+=</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//遍历这一组中的每个元素</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将当前元素放在哨兵位</span>            <span class="token keyword">int</span> t<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>t <span class="token operator">=</span> j<span class="token operator">-</span>d<span class="token punctuation">;</span> t<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">>=</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span> t<span class="token operator">-=</span>d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//对每一个元素，找到其插入位置</span>                L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//每个插入位置之后的每个元素后移一位</span>            <span class="token punctuation">&#125;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>t<span class="token operator">+</span>d<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//将该元素插入到这一组的适当位置上</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> dlta<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//dlta数组用于存放每一趟希尔排序的增量，而t用于存储dlta数组的大小</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">&lt;</span>t<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">ShellInsert</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> dlta<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对每一趟希尔排序单写函数</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，希尔排序的时间复杂度是一个关于dlta序列（即增量序列）的函数。</p><hr><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>这种排序咱们很熟悉了，在C语言的篇章中就提及过，但是问题在于效率太低了。</p><p>其具体思想在于每一轮排序会逐次进行前后元素的比较并交换，达到每一次将最大元素 &#x2F; 最小元素放到数组最后的效果，这样进行n-1轮，就能够将数组排序完成。</p><blockquote><p>提一嘴，冒泡排序是可以进行改进的，即单独设置一个变量在每次进行排序时检测是否有交换次数的产生，如果没有交换则可以直接退出该次排序进程（数列已有序）</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//冒泡排序</span><span class="token keyword">void</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">,</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//flag用于标记是否有交换现象产生</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//在每一轮冒泡之前将标记位置0</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">></span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token function">Swap</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        i<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//如果有交换现象则继续</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序（Qsort）"><a href="#快速排序（Qsort）" class="headerlink" title="快速排序（Qsort）"></a>快速排序（Qsort）</h3><p>快排的思想也是分轮的，其思想在于分轮排序：</p><ul><li>一轮快速排序：</li></ul><p>目标在于选出一个枢轴，将比它小的元素放到它的左边，再将比它大的元素放到它的右边：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//单轮快速排序</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pivotkey <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>    <span class="token comment">//这个元素作为枢轴</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> pivotkey<span class="token punctuation">;</span> <span class="token comment">//放入哨兵位置</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">>=</span>pivotkey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            high<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment">//如果high指向的元素比枢轴大，则继续搜索</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//当此时high指向的元素比枢轴小了，将high的元素与low的元素交换</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token operator">&lt;=</span>pivotkey<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            low<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//最终low会与high相同，停止循环，此时low / high的位置就是枢轴应该放到的位置</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span> <span class="token comment">//把最后枢轴所在的位置返回</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>快速排序</li></ul><p>有了一轮排序，我们可以通过多轮快排进行对一整个数组的快排：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//多轮快排</span><span class="token keyword">void</span> <span class="token function">QSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//对L.r的s至t的位置进行快速排序</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">&lt;</span>t<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//当前需要排序的长度序列大于1</span>        pivotloc <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> s<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对s到t进行一次划分</span>        <span class="token function">QSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> s<span class="token punctuation">,</span> pivotloc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对比pivotloc小的序列进行递归</span>        <span class="token function">QSort</span><span class="token punctuation">(</span>R<span class="token punctuation">,</span> pivotloc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//对比pivotloc大的序列进行递归</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排的时间复杂度为nlog(n)。</p><p>但还存在一个问题，当快速排序要处理的对象本身就有序时，这就势必导致快排效率的退化（因为每次都拿第一个元素当枢轴），这时，快排会退化为冒泡的时间复杂度。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>简单排序的思路很简单，我们将数组分为一部分有序序列以及另一部分无序序列，将无序序列中最小 &#x2F; 最大的元素挑出来，放到有序序列与无序序列分界处的位置。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//简单选择排序</span><span class="token keyword">void</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//j存储数组中第i小的元素</span>        <span class="token comment">//此时前[1, i]的数组已经排序完成，因此在[i+1, L.length]之间寻找最小值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> k<span class="token operator">&lt;=</span>L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                j <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//交换到位</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其时间复杂度为O(n<sup>2</sup>)</p><h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p>树形选择排序的主要优化点在于将 <strong>选择最小值</strong> 这一过程的时间复杂度降低了。</p><p>其采用类似于锦标赛的思路，在无序序列中先让元素两两一组，互相比较，记录两者之间最小的那个，而后在挑选出来的新一组中继续两两一组，如此循环，直至最后只剩下一个元素时，这时就是最小的那个。</p><p>这种算法，每一次选出最小值的复杂度是log<sub>2</sub>(n)，而显然我们需要进行n次这样的选择，故整体算法的时间复杂度为nlog<sub>2</sub>(n)</p><blockquote><p>注：log<sub>2</sub>(n)其实就是一棵完全二叉树的深度。</p></blockquote><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>这块咱得重点说一下，因为涉及到了一个全新的玩意，叫 <strong>堆</strong></p><p>堆的定义为满足如下规定的数组：</p><ul><li>r<sub>i</sub> &lt;(&gt;) r<sub>2i</sub></li><li>r<sub>i</sub> &lt;(&gt;) r<sub>2i+1</sub></li></ul><p>这样的数组可以被称为 <strong>小顶堆（大顶堆）</strong></p><p>其实形象地了解一下，我们借助一下上一章中讲的二叉树的知识，就是将一个数组写成一个二叉树，而其每个双亲结点都要比其子节点要小（大）</p><p>那这玩意又跟排序怎么扯上关系呢？</p><p>我们拿小顶堆举例子，显然，小顶堆虽然后面的元素顺序不确定，但是其最顶部的元素则很显然是整个数组中最小的那个。</p><p>那么，我们只需要对这个数组的n个元素先进行建堆操作，将其调整成小顶堆，而后将最小的那个元素扔到最后边，在对前面的n-1个元素继续进行建堆操作，如此循环往复，就能将这个数组变成一个从大到小的有序数组了。</p><p>到这里，就可以引出我们要解决的两个问题了：</p><ul><li>怎么建堆？</li><li>堆顶元素扔到最后去了，那我们怎么对剩余元素建立新堆？</li></ul><p>咱先说第二个：</p><hr><p>我们假设有一个大顶堆：</p><p>98, 81, 49, 73, 36, 27, 40, 55, 64, 12</p><p>现在把最大的那个元素扔到最后面（即98与12交换）<br>数组变为：</p><p>12, 81, 49, 73, 36, 27, 40, 55, 64, 98</p><p>现在要对前n-1个元素继续建堆，其实是一个自上而下 <strong>筛选</strong> 的过程：<br>我们先比较12与其两个子节点81，49；<br>因为要建大顶堆，因此肯定要把最大的元素放到最上边，这三个元素显然81最大，因此将81放到12的位置，交换：</p><p>81, 12, 49, 73, 36, 27, 40, 55, 64, 98</p><p>好的，继续筛选，12现在下标为2，对应的子结点为4、5，即比较12，73，36；<br>显然，73要和12换位置：</p><p>81, 73, 49, 12, 36, 27, 40, 55, 64, 98</p><p>继续筛选，12的下标为4，对应的子节点为8、9，即比较12，55，64；<br>继续，64和12换位置：</p><p>81, 73, 49, 64, 36, 27, 40, 55, 12, 98</p><p>好了，目前我们发现12没数可比了，就结束调整，我们发现此时前n-1个元素又变成了一个大顶堆。</p><blockquote><p>注：别忘了在排序中，数组下标从1开始哦（0号元素是哨兵位）。</p></blockquote><p>通过这种方式，我们可以达成调整大顶堆的目的。</p><hr><p>那再回到第一个问题，我们就可以用与第二个问题类似的思路继续往下走：</p><p>我们想到了，其实建堆的过程就是一个逐层递进，一层一层建立堆的过程：</p><p>上面的过程中根结点的两棵子树其实没有变，这就意味着我们如果能把根结点的两棵子树分别调整成大顶堆，就可以再进行一次上面的算法，将整棵树都变成大顶堆。</p><p>这就形成了一个循环的思路。</p><p>给出代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//调整大顶堆</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token comment">//哨兵位暂存堆顶元素</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>s<span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span> i<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>m <span class="token operator">&amp;&amp;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">&lt;</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//将i指向子节点中最大的那个元素</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">>=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//如果堆顶元素比两个元素都大</span>            <span class="token comment">// 说明这个当前位置就是堆顶元素应该插入的位置，退出循环</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> s <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//否则将比较大的那个元素移到顶部，继续下一轮判断</span>        <span class="token comment">//这里之所以不是交换是因为L.r[0]已经暂存了我们要调整的元素</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//结束循环后，s会指向堆顶元素需要插入的位置</span>    L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">HeapSort</span><span class="token punctuation">(</span>SqList <span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//堆排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//从底层树开始一层层调整为大顶堆</span>        <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">,</span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">//将整个数组建成大顶堆</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> L<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        L<span class="token punctuation">.</span>r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token punctuation">.</span>r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//将最前面的元素（最大的元素）与未经排序的最后一个元素交换</span>        <span class="token function">HeapAdjust</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调整成大顶堆</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>堆排序的时间复杂度为O(nlogn);</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的思路又不一样了，其思路在于逐次排序，并两两合并。</p><p>比如一个数组有8个元素，归并排序是 12 &#x2F; 34 &#x2F; 56 &#x2F; 78 ，将元素分为四组，先将这四组都改为有序列，而后两两合并，即变为 1234 &#x2F; 5678，再对这两组元素分别排成有序序列，而后继续合并为 12345678，并排序。最终变为有序序列。</p><p>每一趟归并的时间复杂度是O(n)，而归并排序总共需要进行O(log<sub>2</sub>n)趟</p><p>因此归并排序的总时间复杂度为O(nlogn)</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序针对多关键字，同时根据关键字数位不同，需要进行多次 <strong>分配-收集</strong> 的过程。</p><p>咱举个例子</p><hr><p>假如说，有如下这些关键字：<br>209, 386, 768, 185, 247, 606, 230, 834, 539</p><p>我们如果想要将其进行有序排列，除了可以直接进行数字之间的比较外，我们还可以将其看为一个个的个体，即由个位数，十位数，百位数三个部分组成的一个整体。</p><p>那我们只需要对三个部分按照合适的顺序分别进行排序即可成功将这个序列变为有序序列。</p><p>我们先按个位数来一遍：<br>230, 834, 185, 386, 606, 247, 768, 209, 539</p><p>在个位数的基础上，再按十位数进行排序：<br>606, 209, 230, 834, 539, 247, 768, 185, 386</p><p>而后，在以上两次排序排出序列的基础上，我们再按百位数进行排序：<br>185, 209, 230, 247, 386, 539, 606, 768, 834</p><p>会发现数组已经有序。</p><hr><p>以上，是基数排序的一个经典的案例，这个例子很恰当的说明了这种排序方法在多关键字的情况下的适用性。</p><p>时间复杂度是O(d(n+rd));</p><p>d是 <strong>分配-收集</strong> 的趟数，rd是 <strong>基数的取值范围</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OK，这么多种排序过去，咱做个总结。</p><h3 id="时间性能："><a href="#时间性能：" class="headerlink" title="时间性能："></a>时间性能：</h3><ul><li>O(nlogn) : 快速排序（QSort），堆排序（HeapSort），归并排序（MergeSort）</li><li>O(n<sup>2</sup>) : 直接插入排序，冒泡排序，简单选择排序</li><li>O(n) : 基数排序（有限制）</li></ul><p>如果本来待排序列就有序，则直接插入排序，冒泡排序的时间复杂度进化为 O(n)，而快速排序退化为 O(n<sup>2</sup>)</p><h3 id="空间性能："><a href="#空间性能：" class="headerlink" title="空间性能："></a>空间性能：</h3><p>空间性能指排序过程中需要的辅助空间大小：</p><ul><li>O(1) : 所有简单排序（插入，冒泡，选择），堆排序</li><li>O(logn) : 快速排序（递归过程占用的栈空间）</li><li>O(n) : 归并排序（需要复制一个数组进行归并的操作）</li></ul><h3 id="稳定性："><a href="#稳定性：" class="headerlink" title="稳定性："></a>稳定性：</h3><p>在文章开头介绍了稳定性的概念。</p><p>像快速排序，直接选择排序，堆排序，希尔排序这种有 <strong>频繁元素交换操作</strong> 的排序方法往往是不稳定的。</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-6</title>
      <link href="/posts/6243.html"/>
      <url>/posts/6243.html</url>
      
        <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><blockquote><p>本节，是数据结构的第一部分重难点 <strong>树</strong> 的知识梳理。其涉及到的知识体系极其繁杂，同时会常常与前面的数据结构有所联系。</p></blockquote><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树——概述"><a href="#树——概述" class="headerlink" title="树——概述"></a>树——概述</h3><blockquote><p>我们首先需要了解，树这个玩意到底是个啥？</p></blockquote><p>我们在学习前面的数据结构时，往往其结构都是 <strong>线性的</strong> ，这意味着其结构中的每一个元素都只有一个前驱，也只有一个后继。</p><p><strong>树</strong> 与之不同，树中的每个节点（除根结点外）只有一个前驱，但其可以包含多个后继，这就是其与此前的数据结构在根本上的区别。</p><h3 id="树——常用术语"><a href="#树——常用术语" class="headerlink" title="树——常用术语"></a>树——常用术语</h3><p>由于树的结构复杂性，我们需要先做出一些术语上的约定，以防止此后我们在进行描述时，产生歧义。</p><ul><li>树的 <strong>根</strong> ：一棵树中的第一个元素，它没有前驱，只有后继</li><li>树的 <strong>结点</strong> ：包含一个元素，以及若干个指向其子树（后继）的分支；</li><li>结点的 <strong>度</strong> ：一个节点所连接的子树的数目；</li><li>树的度：这棵树里面所有结点度的最大值；</li><li><strong>叶子结点</strong> ：没有子树的结点；</li><li>分支节点：有子树的结点；</li><li><strong>孩子结点</strong> ：一个结点的两个子树的根；</li><li><strong>双亲结点</strong> ：一个结点的前驱结点；</li><li><strong>兄弟结点</strong> ：两个具有相同双亲结点的结点互相称为兄弟；</li><li><strong>堂兄弟结点</strong> ：两个双亲结点在同一层的结点互相称为堂兄弟；</li><li>结点的 <strong>层次</strong> ：从根结点到该结点的路径长度+1；</li><li>树的 <strong>深度</strong> ：树中所有叶子结点的层次的最大值；</li></ul><p>相信看到这一堆名词已经能让一部分读者感到头疼了…<br>别着急，我们先从最简单的树——二叉树讲起。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><strong>二叉树</strong> 是最简单的树，其特殊性在于规定了每个结点最多只能有两棵子树，这这两棵子树被称为 <strong>左 &#x2F; 右子树</strong> 。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>二叉树的形式非常特殊，因此在这里我们浅谈一下其具体性质：</p><ul><li>在二叉树的第 i 层上至多有 2<sup>i-1</sup> 个结点</li><li>深度为 k 的二叉树上至多有 2<sup>k</sup> - 1 个结点<blockquote><p>注：考虑结点最多的情况，即 2<sup>0</sup> + 2<sup>1</sup> + … + 2<sup>k-1</sup> &#x3D; 2<sup>k</sup> - 1</p></blockquote></li><li>对任意的一棵二叉树，若其度为0的结点（叶子结点）的数目为N，度为2的结点的数目为N<sub>2</sub>，则N &#x3D; N<sub>2</sub> + 1<blockquote><p>注：这里我们不给严谨证明，我们只给一个思路，即在任意一棵二叉树中，多一个度为2的结点就必定意味着多出了一个叶子节点，而一棵二叉树在只有根结点的时候叶子节点数量为1，因此可以推出上式</p></blockquote></li></ul><p>在叙述第四个性质之前，我们需要先了解两类特殊的二叉树：</p><hr><ul><li>满二叉树：深度为k，且含有 2<sup>k</sup> - 1 个结点的二叉树<blockquote><p>顾名思义，这个二叉树里面除了叶子结点之外，所有的结点的度都是2，因此得名</p></blockquote></li><li>完全二叉树：树中所含的n个结点和满二叉树编号为 1 -&gt; n 的结点一一对应。<blockquote><p>啥意思呢，这里得给两个图来解释一下：</p></blockquote></li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><hr><p>好的，了解完这两种特殊的二叉树，我们接下来回到此前性质的学习中：</p><ul><li>具有n个结点的 <strong>完全二叉树</strong> 的深度为：[log<sub>2</sub>n] +1<blockquote><p>证：我们设完全二叉树的深度 k ；由于第二条性质的存在，得到 2<sup>k-1</sup> &lt; 2<sup>k</sup> ，对该式进行化简，即可得到 k-1 &lt; [log<sub>2</sub>n] &lt; k ，同时k又只能是整数，因此得到这个性质。</p></blockquote></li><li>对于任意的 <strong>完全二叉树</strong> ，我们对其进行从上至下，从左至右的编号（就类似上图的编号方式），可以得到如下性质：<ul><li>若结点编号 i &#x3D; 1 ，则这个结点是其根结点，否则编号为 [i&#x2F;2] 的结点就是其双亲结点。</li><li>对于任意结点，如果对于其编号 i 满足 <strong>2i &gt; n</strong> ，则该结点没有左孩子。否则，编号为 <strong>2i</strong> 的结点是其左孩子。</li><li>对于任意结点，如果对于其编号 i 满足 <strong>2i +1 &gt; n</strong> ，则该结点没有右孩子。否则，编号为 <strong>2i + 1</strong> 的结点是其右孩子。</li></ul></li></ul><p>关于二叉树的性质，大体就这么些，其中大部分的性质是比较容易就能推出来的，最后两个关于完全二叉树的性质也可以在读者对于完全二叉树的理解加深之后轻易写出。 <del>（实在不行咱画一个图看一眼，举例嘛，不寒碜）</del></p><h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><blockquote><p>说了挺多，现在咱来看看这东西在计算机里面该怎么实现</p></blockquote><h4 id="二叉树的顺序存储"><a href="#二叉树的顺序存储" class="headerlink" title="二叉树的顺序存储"></a>二叉树的顺序存储</h4><p>相信挺多读者一看顺序存储应该挺诧异，觉着不是很好实现。确实，顺序存储（即利用数组的方式存储二叉树）仅比较适用于完全二叉树，这是因为其标号是有规律可循的（详见上面的最后一条性质）。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="完全二叉树的顺序存储"></p><p>如果想在非完全二叉树的基础上进行顺序存储，那我们为了保持结构以及访问的便利性，只能先创建一个与之相对的完全二叉树的数组，而后将其不存在的结点值赋值为0。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91%20%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png" alt="非完全二叉树的顺序存储"></p><p>读者应该看出来了，如果这样存储二叉树，会产生极大的内存浪费，因为需要占用很大的空间来存储中间的0元素，这是得不偿失的。</p><h4 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h4><ul><li>二叉链表</li></ul><p>非常自然地，加入二叉树的每一个结点都最多有两个孩子，那我们自然可以利用一个链表结构，只不过这个链表中的每个结点都有两个指针，分别指向其左孩子以及右孩子。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span> <span class="token comment">//节点内存储的内容</span>    BiTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span> <span class="token comment">//分别指向其左孩子与右孩子</span><span class="token punctuation">&#125;</span><span class="token operator">*</span>BiTree<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><ul><li>三叉链表</li></ul><p>有二叉链表，我们又想了，能不能达成一个通过子节点能够找到它双亲结点的结构呢？当然可以，无非就是加一个指针的事情：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">TriTNode</span><span class="token punctuation">&#123;</span>    ElemType data<span class="token punctuation">;</span>    TriTNode <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>    TriTNode <span class="token operator">*</span>parent<span class="token punctuation">;</span> <span class="token comment">//新增一个指向双亲结点的指针，但是维护起来会更费时</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>三叉链表的存储比二叉链表更加清晰一些，但是维护起来明显更加费时，这里的选择可以由读者自行决定，本文中大部分的代码演示会通过二叉链表来进行。</p></blockquote><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><blockquote><p>我们说完了这玩意该怎么在计算机里面实现存储，现在就需要说一说它的一些基础操作了。</p></blockquote><p>我们首先需要明确遍历的原则，即二叉树中的每个结点均 <strong>被访问且仅被访问一次</strong> 。</p><p>对于二叉树而言，有两种遍历思路可选：</p><ul><li>深度优先遍历：先进行左（右）子树的遍历，待这一过程完毕后，再遍历右（左）子树。</li><li>广度优先遍历：从上至下按照树的层次一层层遍历。</li></ul><p>我们从广度优先的先左后右的遍历说起。</p><h4 id="先左后右的深度优先遍历算法"><a href="#先左后右的深度优先遍历算法" class="headerlink" title="先左后右的深度优先遍历算法"></a>先左后右的深度优先遍历算法</h4><p>这种思路又分为三种子思路，即我的根结点应该在什么时候进行访问：</p><ul><li>先序遍历：即先访问根结点，再依次访问左子树，右子树</li><li>中序遍历：即先访问左子树，再访问根结点，最后访问右子树</li><li>后序遍历：即先访问左子树，右子树，最后访问根结点</li></ul><p>这里额外说一句，构建二叉树的时候，我们是可以通过不同的遍历方式作为依据的，具体来说，我们可以通过中序遍历以及其余任意一种遍历方式来唯一确定一棵二叉树。</p><hr><ul><li>递归遍历算法</li></ul><p>由于二叉树的特殊性，我们很容易想到递归的遍历方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//先序遍历</span><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印当前节点的值</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PreOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//分别先后利用递归遍历左子树与右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//中序遍历</span><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先遍历左子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印当前节点的值</span>        <span class="token function">InOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后遍历右子树</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//后序遍历</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//T不为空</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//先遍历左子树</span>        <span class="token function">PostOrder</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//再遍历右子树</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> T<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//最后打印当前节点的值</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种遍历算法利用递归，写起来简单明了，但存在效率问题。<br>相信写C语言递归的读者经常遇到递归深度过深的问题，我们试想一下，如果有一棵树，其深度达到100，那几乎不用考虑，这种算法肯定直接报错退出。</p><p>这也就需要引出我们的第二种算法。</p><hr><ul><li>非递归遍历算法</li></ul><p>在这种算法中，我们使用此前我们学过的 <strong>栈</strong> 这种结构来对树进行遍历。</p><p>我们先把思想搞明白，然后再上代码，以中序遍历为例：</p><p>这种算法的思路为：</p><ul><li>我们先从根结点一直向左下找，途中只要遇到一个结点，我们就将其入栈；</li><li>直到我们找到了NULL结点，这说明它上一个结点是整棵树最靠左下的结点了，这时我们将其出栈，并访问它，而后继续访问其右子树；</li><li>访问其右子树的过程与上述过程相同，直到整棵右子树被访问完毕。</li><li>此后，我们可以继续出栈一个结点，重复上述过程。</li><li>当栈空时，整棵二叉树就被我们遍历完毕了</li></ul><p>上面的文字描述比较晦涩难懂，这里给出一棵具体的树作为例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%20%E5%AE%9E%E4%BE%8B%E6%A0%91.png" alt="实例树"></p><p>我们将遍历过程写一遍：</p><ul><li>对于这一棵二叉树，我们单独设置一个栈，初始为空。</li><li>从根结点找到最左下的结点，路径上所有的结点均入栈。即 1入栈 、 2入栈 、 4入栈；<ul><li>现在栈中的元素：1, 2, 4;</li></ul></li><li>到达4的左孩子，发现是NULL，因此此时出栈一个元素（4），访问它，并遍历它的右子树。</li><li>我们发现4的右子树是NULL，因此直接退出遍历，此时再次检测栈中是否有元素，发现栈不空，再次出栈一个元素（2），访问它，并遍历它的右子树。<ul><li>此时根结点是5，同样的向左下找，路径上所有的结点均入栈。即5入栈 、 6入栈；<ul><li>此时栈中的元素：1, 5, 6;</li></ul></li><li>到达6的左子树，发现是NULL，因此此时出栈一个元素（6），访问它，遍历它的右子树（NULL）；</li><li>检测栈中是否有元素，发现栈不空，出栈一个元素（5），访问它，遍历其右子树</li><li>此时根结点是7，向左下找，路径上元素入栈。即7入栈；<ul><li>此时栈中元素：1, 7;</li></ul></li><li>到达7的左孩子，发现是NULL，出栈一个元素（7），访问它，遍历其右子树（NULL）；</li></ul></li><li>此时再次检测栈中元素，栈非空，出栈一个元素（1），访问它，遍历其右子树；</li><li>3入栈；<ul><li>此时栈中元素：3;</li></ul></li><li>3的左孩子是NULL，3出栈，同时遍历3的右子树（NULL）；</li><li>检测栈中元素，栈空，退出算法</li></ul><p>上述过程就是这种算法进行遍历的方式，请读者务必理解，下面我们给出具体代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//中序遍历——非递归算法</span><span class="token keyword">void</span> <span class="token function">InOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    BiTNode <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m根据你的树的深度来决定，足够大就行</span>    BiTNode <span class="token operator">*</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//来表示栈顶的位置</span>    p <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            top<span class="token operator">++</span><span class="token punctuation">;</span>            stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">//p入栈</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment">//p指向其左孩子</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//这个循环在p指向的左孩子是NULL的时候会停止</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>top <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//判断栈不空</span>            p <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>            top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//出栈一个元素</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//访问刚刚出栈的元素（打印）</span>            p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//继续扫描右子树，开始下一层循环</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">||</span> top <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//当 p不空或者栈不空时，继续该循环</span>    <span class="token comment">//额外提一嘴，这里最外层的do_while循环的停止条件是p为NULL，并且栈空，此时才会退出循环</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在读者能够看明白上述代码的时候，我们可以继续将先序遍历以及后序遍历的非递归算法给出。</p><p>下面是先序遍历的算法，其思路为：</p><ul><li>检测栈中是否为空</li><li>双亲结点出栈访问；</li><li>检测该结点有没有左右孩子，按照先右后左的顺序入栈；</li><li>回到第二步继续循环，直到栈空，算法结束</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//先序遍历——非递归算法</span><span class="token keyword">void</span> <span class="token function">PreOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BiTNode<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//类似的，m可以由读者自行决定，够大就可以</span>  BiTNode<span class="token operator">*</span> p<span class="token punctuation">;</span>  <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>b<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//b不空，开始遍历</span>    stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">//根结点入栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//当栈不空时，循环</span>      p <span class="token operator">=</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//先将一个结点出栈（先序遍历的特点）</span>      top<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//p有右孩子</span>        top<span class="token operator">++</span><span class="token punctuation">;</span>        stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//p的右孩子先入栈</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//p有左孩子</span>        top<span class="token operator">++</span><span class="token punctuation">;</span>        stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span> <span class="token comment">//p的左孩子后入栈</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//当栈空时，所有的结点均被访问完毕</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个先序遍历算法有一点需要额外说明一下：在访问完当前结点，随后入栈当前结点的左右孩子时，为了保证程序能 <strong>先访问左孩子，再访问右孩子</strong> ，我们需要 <strong>先将右孩子入栈，随后再将左孩子入栈</strong> 。这是由栈的后进先出原则决定的。</p><p>最后是后序遍历，这是三种遍历中最难写的一种。</p><p>这玩意涉及到了一个重复访问的问题：即我们先找到左节点，随后返回其双亲结点，再访问双亲结点的子树，再返回双亲结点，这就产生了问题：<br>我们如何判断返回双亲结点时，这是从左子树返回过来的，还是从右子树返回过来的？</p><p>因此，很遗憾的，我们可能又需要写一个辅助栈，来额外设置一个标记位，便于我们判断返回情况。</p><p>还是先给出大体思路：</p><ul><li>沿着根结点一直向左下走，直到走到NULL，途中所有的结点入栈，同时辅助栈相应的位置添加标记0；</li><li>走到NULL后，检测当前栈顶结点，并将其对应标记位设置为1，开始访问其右子树；</li><li>右子树的访问规则与第一步相同；</li><li>当我们访问完右子树再次返回这个结点时（即总有一次我们检测栈顶元素，发现这个结点的标记位已经被我们之前置成1了），我们将其出栈，并打印。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//后序遍历——非递归写法</span><span class="token keyword">void</span> <span class="token function">PostOrder</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  BiTNode<span class="token operator">*</span> stack <span class="token operator">=</span> <span class="token punctuation">(</span>BiTNode<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  BiTNode<span class="token operator">*</span> p <span class="token operator">=</span> b<span class="token punctuation">;</span>  <span class="token keyword">int</span><span class="token operator">*</span> sub <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//辅助栈</span>  <span class="token keyword">int</span> top<span class="token punctuation">;</span> <span class="token comment">//由于辅助栈的栈顶与主栈栈顶同步，因此只需要设置一个表示栈顶的变量即可</span>  <span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      top<span class="token operator">++</span><span class="token punctuation">;</span>      stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>      tag<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//第一次入栈时，将其标志位置为0</span>      p <span class="token operator">=</span> p<span class="token operator">-></span>lchild<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">//向左下一直找到NULL</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sub<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//如果当前栈顶元素的左右子树都被访问过了</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>      top<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//出栈</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>top<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sub<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//当前栈顶元素的右子树还没被访问过</span>      p <span class="token operator">=</span> p<span class="token operator">-></span>rchild<span class="token punctuation">;</span> <span class="token comment">//把p指向右子树，用于下一次的循环</span>      tag<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//将其标志位置成1</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token operator">||</span> top<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//当p为NULL且栈空时才停止循环</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="按层次遍历的广度优先算法"><a href="#按层次遍历的广度优先算法" class="headerlink" title="按层次遍历的广度优先算法"></a>按层次遍历的广度优先算法</h4><p>相对于深度优先算法而言，广度优先的算法要显得友好许多。</p><p>我们采用队列这种数据结构来遍历这棵二叉树，其思路为：</p><ul><li>创建一个队列；</li><li>先将二叉树的根结点入队；</li><li>对任意一个队列中的结点，我们先将其出队并打印，同时将其左孩子和右孩子入队列。</li><li>依照上述过程循环，直到队列空为止</li></ul><p>读者可以依照上面给过的二叉树的例子试着手过一遍这种算法，写过一遍的理解总是要比直接看代码要清晰许多，下面我们给出代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//广度优先遍历</span><span class="token keyword">void</span> <span class="token function">TransLevel</span><span class="token punctuation">(</span>BiTree b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">Queue</span><span class="token punctuation">&#123;</span>    BiTree<span class="token operator">*</span> vec <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一个道理，m够大就行</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">//指示队列头尾的变量</span>  <span class="token punctuation">&#125;</span>q<span class="token punctuation">;</span>  BiTree<span class="token operator">*</span> temp<span class="token punctuation">;</span>  q<span class="token punctuation">.</span>front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span>rear <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//树空，则直接返回</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token comment">//否则，树根入队</span>    q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>    q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>front<span class="token operator">!=</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//当队列不空时，循环</span>    temp <span class="token operator">=</span> q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>    q<span class="token punctuation">.</span>front<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> temp<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//队头的元素出队并打印</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-></span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//出队的元素有左孩子</span>      q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token operator">-></span>lchild<span class="token punctuation">;</span>      q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>temp<span class="token operator">-></span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token comment">//出队的元素有右孩子</span>      q<span class="token punctuation">.</span>vec<span class="token punctuation">[</span>q<span class="token punctuation">.</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token operator">-></span>rchild<span class="token punctuation">;</span>      q<span class="token punctuation">.</span>rear<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>好的，二叉树的遍历至此，就差不多讲完了。这部分难度不小，读者可以缓口气。</p><p>之所以这么重视这一部分，并且花费很大的篇幅来讲解，是为了下一个部分，二叉树的基础应用来做铺垫，没有二叉树的遍历，我们没法进入下一部分。</p><blockquote><p>注：如果深度遍历的非递归算法读者未能理解，可以暂时跳过，递归算法先用着嘛，不寒碜。</p></blockquote><h3 id="二叉树的基础应用"><a href="#二叉树的基础应用" class="headerlink" title="二叉树的基础应用"></a>二叉树的基础应用</h3><h4 id="统计叶子结点的个数"><a href="#统计叶子结点的个数" class="headerlink" title="统计叶子结点的个数"></a>统计叶子结点的个数</h4><p>这应用在咱说完遍历算法之后应该不算很难了，我们只需要在算法中加入一个计数器，再把打印那一步改成一个判断语句，即如果这个结点没有左右孩子，则计数器+1即可。</p><p>这里就不写代码了，读者照着上面的代码自行改一改就好。</p><h4 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h4><p>求深度这一算法类似于后序遍历，我们根据二叉树的定义，应该能看出来树的深度等于其左子树与右子树深度的最大值+1；因此，这算法用递归相当好写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Depth</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> depthval<span class="token punctuation">,</span> depthleft<span class="token punctuation">,</span> depthright<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//树空，返回0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    depthleft <span class="token operator">=</span> <span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    depthright <span class="token operator">=</span> <span class="token function">Depth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>    depthval <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span>depthleft<span class="token operator">></span>depthright<span class="token operator">?</span>depthleft<span class="token operator">:</span>depthright<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> depthval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><blockquote><p>线索二叉树这玩意其实笔者没找到非常具体的应用场景，但是无可奈何这东西确实在数据结构的书上有，这里稍微提一嘴</p></blockquote><p><strong>线索二叉树</strong> 是为了提高遍历速度而建立的一种类似于链表的结构，因此也被称为线索链表，主要用于深度遍历，也分为以下三类：</p><ul><li>先序线索链表</li><li>中序线索链表</li><li>后序线索链表</li></ul><p>其与二叉树的具体区别在于，二叉树中的空节点就是空节点，但线索二叉树并不，它将所有的空结点连接上了它遍历时的前驱与后继。</p><p>但这里又产生了一个问题，即我们如何区分一个结点的左右指针指向的是孩子还是线索呢？<br>对喽，引入了两个标记位，它们一个用于标记左指针，另一个用于标记右指针，当标记位为0时，它正常指向左 &#x2F; 右孩子，但当标记位为1时，则代表着它指向相应遍历顺序中的前驱与后继。</p><p>这里举一例：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%20%E5%AE%9E%E4%BE%8B%E6%A0%91.png" alt="线索二叉树例图"></p><p>我们还是拿这棵树来举个例子，其中序遍历时的顺序为：</p><p>4, 2, 6, 5, 7, 1, 3</p><p>正常而言，6没有左右孩子，其两个指针都是NULL，但在线索二叉树中，6这个结点的两个标记位都为1，即其左右指针均指向其前驱与后继，在这里即6的左指针指向了2，右指针指向了5</p><p>线索链表的具体结点结构为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span><span class="token punctuation">&#123;</span>  TElemType data<span class="token punctuation">;</span>  BiThrNode<span class="token operator">*</span> lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span>  <span class="token keyword">int</span> Ltag<span class="token punctuation">,</span> Rtag<span class="token punctuation">;</span> <span class="token comment">//新增加的左右标记位</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线索二叉树的相关内容我们就写这么些。</p><h2 id="树——回归"><a href="#树——回归" class="headerlink" title="树——回归"></a>树——回归</h2><blockquote><p>前面的二叉树是树的一种最基础的表现形式，现在让我们回到树，继续谈树的一些存储和应用。</p></blockquote><h3 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h3><p>与二叉树相似，树的表示方式也有很多种，但其复杂性在于一个结点可能有多个孩子。这里介绍几种常见的存储方式。</p><h4 id="孩子链表表示法"><a href="#孩子链表表示法" class="headerlink" title="孩子链表表示法"></a>孩子链表表示法</h4><p>我们可以把每一个结点的孩子结点排列起来，以单链表作为存储结构。这也就代表着，一棵树有n个结点，也就有n个孩子链表。</p><p>又由于这n个头指针又形成了一个线性表，因此我们可以采取线性存储结构。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%A0%91%20%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子链表表示法"></p><p>在这种表示方式中，显然我们需要定义两种结点类型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTNode</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> child<span class="token punctuation">;</span> <span class="token comment">//表示这个孩子所在的下标</span>  CTNode<span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//指向下一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//孩子结点</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  CTNode<span class="token operator">*</span> firstchild<span class="token punctuation">;</span> <span class="token comment">//指向第一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//双亲结点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们希望在双亲结点中能够直接找到自己的双亲结点，我们只需要在PTNode中增加一个变量即可：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E5%B8%A6%E5%8F%8C%E4%BA%B2%E7%9A%84%E5%AD%A9%E5%AD%90%E9%93%BE%E8%A1%A8.png" alt="带双亲的孩子链表"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  <span class="token keyword">int</span> parent<span class="token punctuation">;</span> <span class="token comment">//存储双亲结点的下标</span>  CTNode<span class="token operator">*</span> firstchild<span class="token punctuation">;</span> <span class="token comment">//指向第一个孩子</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">//双亲结点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="树的二叉链表表示法（孩子-兄弟表示法）"><a href="#树的二叉链表表示法（孩子-兄弟表示法）" class="headerlink" title="树的二叉链表表示法（孩子-兄弟表示法）"></a>树的二叉链表表示法（孩子-兄弟表示法）</h4><p>前面铺垫了半天二叉树，这里肯定得用一下子。</p><p>我们如果想将一棵多叉树转换成一棵二叉树，应该怎么做呢？</p><p>比较通用的做法是将二叉树的左指针指向自己的第一个孩子，右指针指向自己下一个兄弟。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">&#123;</span>  ElemType data<span class="token punctuation">;</span> <span class="token comment">//结点内容</span>  CSNode <span class="token operator">*</span>firstchild<span class="token punctuation">,</span> <span class="token operator">*</span>nextsibling<span class="token punctuation">;</span> <span class="token comment">//分别存储自己的第一个孩子和下一个兄弟</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>举个例子，上图的树，我们如果利用这种方式进行存储：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.6/%E6%A0%91%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8.png" alt="树的二叉树存储"></p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>类似于二叉树，树也有不同的遍历法：</p><ul><li>先根遍历（对应二叉树的先序遍历）：先访问根根结点，然后依次访问各棵子树</li><li>后根遍历（对应二叉树的中序遍历）：先依次访问各棵子树，再访问根结点</li><li>按层次遍历：类似于二叉树的广度优先遍历</li></ul><p>这里先根遍历与对应二叉树的先序遍历对应；但后根遍历是与其对应二叉树的中序遍历对应的，举个例子：</p><p>我们还是以上面这棵树为例：</p><p>后根遍历的顺序：<br>B G E F C D A</p><p>我们再用之前讲的中序遍历二叉树顺序对上面转化完的二叉树来一遍：<br>B G E F C D A</p><p>可以发现完全一致。</p><h3 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a>树的应用</h3><h4 id="树的深度"><a href="#树的深度" class="headerlink" title="树的深度"></a>树的深度</h4><p>树的深度写起来其实跟求二叉树的深度那个算法差别不大，我们需要先将树转化为二叉树（即孩子-兄弟表示），此后对这个二叉树求深，但需要额外考虑到走兄弟这条道路时深度不变。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//求树的深度</span><span class="token keyword">int</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>CSTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> h1<span class="token punctuation">,</span> h2<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    树为空，则返回<span class="token number">0</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    h1 <span class="token operator">=</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>firstchild<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//走左侧第一个孩子时，深度+1；</span>    h2 <span class="token operator">=</span> <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token operator">-></span>nextsibling<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//走右侧兄弟结点时，深度不变</span>    <span class="token keyword">return</span> h1<span class="token operator">></span>h2<span class="token operator">?</span>h1<span class="token operator">:</span>h2<span class="token punctuation">;</span> <span class="token comment">//返回其中最大的那个</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><p>哈夫曼树是一种在查找时尽可能减少查找所用时间的优化树，其思路在于将查找频次最低的值放在最远端，将频次较高的值放在尽可能近的位置。</p><p>博主在这里实在谈不上很擅长，就不在这里详细叙述了。</p><hr><p>至此，树的相应章节应该算是基本结束了。</p><p><del>真费劲啊，我靠</del></p><p>博主的水平有限，文中的某些代码或文本难免会有些谬误，已经尽可能的加上了注释，希望能对读者的理解有所裨益。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-5</title>
      <link href="/posts/6435.html"/>
      <url>/posts/6435.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组与广义表"><a href="#数组与广义表" class="headerlink" title="数组与广义表"></a>数组与广义表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>C语言中，我们已经多次接触过 <strong>数组</strong> 这一概念，这里我们给出数组的具体概念。</p></blockquote><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>在数据结构中， <strong>数组</strong> 指有限个数据元素的集合，这些数据元素具有相同的特性，并都有与之相对应的下标来表征它们的位置。</p><p>一维数组，与我们在第一章中介绍的 <strong>线性表</strong> 几乎是同一个东西。但这里，我们数组的维数理论上可以无限延申。</p><p>但向外延伸的复杂度则也带来了些许不便，即数组的删改操作会变得极其复杂（尤其在维数过多的情况下），因此我们不妨一刀切掉，数据结构中定义的数组，除了初始化与销毁两种操作之外，只有两种运算：</p><ul><li>给定下标，存储相应的元素</li><li>给定下标，修改相应下标内元素的值</li></ul><blockquote><p>很多读者可能会想起C中的relloc操作，但relloc操作常见于一维数组，即线性表的范畴内，因此这里不再对数组的删改进行叙述。</p></blockquote><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><p>如上所述，数组仅仅包含以下几种操作：</p><ul><li>InitArray：初始化</li><li>DestroyArray：销毁</li><li>Value：取出数组的元素值</li><li>Assign：给数组赋值</li></ul><h3 id="数组的顺序表示"><a href="#数组的顺序表示" class="headerlink" title="数组的顺序表示"></a>数组的顺序表示</h3><blockquote><p>以二维数组为例</p></blockquote><p>数组既然是多维的，则必然存在存储顺序优先级的问题，由于普遍已经适应了 <strong>以行序为主序</strong> 的存储方法，因此本文中会采用行序主序的映像方式进行说明。</p><blockquote><p>上面的说法有点抽象，举个例子：<br>存在一个2*3的数组，如果使用行序主序的方式，则在计算机内存中的存储顺序即：0 0、0 1、0 2、1 0、1 1、1 2。<br>相反的，如果使用列序主序的方式，则在计算机内存中的存储顺序即：0 0、1 0、0 1、1 1、0 2、1 2</p></blockquote><p>因此，一个m行n列的数组采用行序主序的形式时，存储a<sub>ij</sub>的位置时，其位置即：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + (n*i + j) * L;</p><p>如果以列序为主序，则：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + (m*j + i) * L;</p><p>这里，LOC(0, 0)被称为基地址（即数组第一个元素所在的地址），L则是数组一个元素所占有的内存大小。</p><h3 id="矩阵相关"><a href="#矩阵相关" class="headerlink" title="矩阵相关"></a>矩阵相关</h3><p>了解过高等数学的读者可能看出来了，我们拿来举例子的二维数组，在数学上有个另外的名字，叫 <strong>矩阵</strong> 。</p><p>但我们又想了，这矩阵里面可能有很多 <strong>值相同的元素</strong> 或 <strong>0元素</strong> ，显然，它们用处不大，但是占据了很大一部分的存储空间，这就显得很浪费。因此，我们需要研究一下压缩存储的相关问题。</p><p>那首先，我们讨论一下压缩的基本规则：</p><ul><li>多个值相同的元素，我们只分配一个存储空间</li><li>0元素，我们不分配存储空间</li></ul><p>我们先看一些特殊的矩阵：</p><h4 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h4><p><strong>对称矩阵</strong> ，即 a<sub>ij</sub> &#x3D; a<sub>ji</sub> ，我们可以只为每对对称的元素分配一个存储空间，即我们可以只存储其下三角（包括对角线）中的元素。</p><blockquote><p>说的详细点，在内存中的下标存储方式：0 0、1 0、1 1、2 0、2 1、2 2、……、n-1 0、n-1 n-1。</p></blockquote><p>由这个规律，我们得出对称矩阵压缩存储时其下标计算公式：</p><p>LOC(i, j) &#x3D; LOC(0, 0) + [i*(i+1)&#x2F;2 + j] * L;</p><blockquote><p>i*(i+1)&#x2F;2 是一个从1到i，公差为1的等差数列的求和公式，读者自己推一下即可。</p></blockquote><h4 id="三角矩阵的压缩存储"><a href="#三角矩阵的压缩存储" class="headerlink" title="三角矩阵的压缩存储"></a>三角矩阵的压缩存储</h4><p><strong>三角矩阵</strong> 即一个矩阵中只有其上（下）三角的位置有元素，其余部分为0元素或常数C。</p><p>因此，其实与对称矩阵非常类似，我们留出相应的三角矩阵的存储空间，而后增加一个存储常数C的存储空间即可</p><h3 id="稀疏矩阵相关"><a href="#稀疏矩阵相关" class="headerlink" title="稀疏矩阵相关"></a>稀疏矩阵相关</h3><p><strong>稀疏矩阵</strong> 即矩阵中零元素的出现没有规律的矩阵</p><p>在了解它如何压缩之前，我们先来了解一个概念—— <strong>稀疏因子</strong> 。<br>其定义为如果m行n列的矩阵中含有t个非零元素，我们称：</p><p>d &#x3D; t &#x2F; m*n</p><p>为稀疏因子，即数组中非零元素个数与非零元素个数的比。</p><p>如果这个稀疏因子的大小小于0.05，则我们称这个矩阵为稀疏矩阵。<br>这种稀疏矩阵造成了两种问题：</p><ul><li>零元素占据空间过大</li><li>进行运算时（除法 &#x2F; 取余），需要频繁的判断当前的除数是否为0</li></ul><p>这就代表着压缩存储的操作非常的必要</p><h4 id="三元组表示法"><a href="#三元组表示法" class="headerlink" title="三元组表示法"></a>三元组表示法</h4><p>这种压缩方法大概是最容易想到的了，即我们用一个线性表来表示稀疏矩阵，这个线性表中每个元素都是一个结构体，结构体里有三个元素，分别为非零元素的行下标、列下标、值。</p><p>相应的，习惯使然，我们在存储它时也已行下标优先的存储方法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span> <span class="token comment">//行、列下标</span>    Elemtype v<span class="token punctuation">;</span> <span class="token comment">//非0元素的值</span><span class="token punctuation">&#125;</span>Triple<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Triple data<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> num<span class="token punctuation">;</span> <span class="token comment">//矩阵的行数、列数、非零行个数</span><span class="token punctuation">&#125;</span>TSMatrix<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三元素表示法的加、减都挺简单，但一旦涉及到矩阵的 <strong>转置</strong> ，则事情就变得有些复杂。</p><hr><ul><li>三元组的转置——常规转置</li></ul><p>我们知道，常规矩阵的转置：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>line<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>col<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>放到三元组里面，我们可以采如下的转置方法：</p><ul><li>将矩阵的行、列值互相调换</li><li>将三元组存储行、列下标的变量互换</li><li>将三元组重新排成以行序为主序的顺序表</li></ul><p>这前两步非常简单，但第三步的实现需要琢磨一下，我们这里也给出两种方法：</p><ul><li>按照原先三元组列序的顺序查找（因为原先三元组的列序就是转置后三元组的行），而后按照顺序进行转置，转置后依次添加进一个新的三元组里面。</li><li>直接按照原先三元组中的顺序进行转置，此后将转置的每个元素置入与之对应的新位置里。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第一种方法</span><span class="token function">Trans</span><span class="token punctuation">(</span>TSMatrix M<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//M是需要被转置的矩阵，N是一个全新的矩阵</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//M非空</span>        N<span class="token punctuation">.</span>line <span class="token operator">=</span> M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>col <span class="token operator">=</span> M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>num <span class="token operator">=</span> M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> line <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">//从M的第一列开始转置</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>                    N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>temp<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>                    <span class="token comment">//行列互换，值直接赋入新三元组</span>                    temp<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一种方法非常清晰明了，但是显然效率不够，因为我们需要将三元组所有的元素都扫描很多遍，这显然不是很优雅。</p><p>这种转置方法存在循环的嵌套，因此其时间复杂度为：</p><p><strong>O(M.num * M.col);</strong></p><p>我们再想一想，我们如果能知道M中每一列的 <strong>第一个非零元</strong> 在N中应该存储的位置，那么我们在对M中的元素进行转置时，我们就可以直接将相应的元素放到N中合适的位置上，这就显得非常的理想。</p><p>问题来了，这法子需要怎么实现呢？</p><hr><ul><li>三元组的转置——快速转置</li></ul><p>我们想知道新矩阵每一行开始的位置，我们自然需要对原数组先进行一次遍历，通过这次遍历的结果得到我们想要的数据并进行储存。</p><p>因此，我们再设置两个数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">nums<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token comment">//表示原矩阵中第col列中含有多少个非零元素</span>cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token comment">//表示原矩阵中第col列的第一个非零元素在新矩阵中的起始位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：这里需要再啰嗦一嘴，原矩阵中的第col列其实就是新矩阵中的第col行，因此cpot[col]中的元素就是新矩阵里面第col行的起始下标。</p><p>我们可以通过以上的关系得到这个式子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">cpot<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//第一行的第一个非零元的起始下标为1</span>cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> cpot<span class="token punctuation">[</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//第col行的第一个非零元的起始下标 = 上一行的起始下标 + 上一行的元素数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果将上述式子写成代码也非常简单，只需要用for循环遍历一遍，就能将nums数组中的所有元素得到，而后再通过nums遍历一遍得到cpot数组即可：</p><p>得到这个cpot数组后，转置的工作就很简单了，这里给出具体的转置代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//第二种方法</span><span class="token function">Trans</span><span class="token punctuation">(</span>TSMatrix M<span class="token punctuation">,</span> TSMatrix <span class="token operator">&amp;</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>num<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//M非空</span>        N<span class="token punctuation">.</span>num <span class="token operator">=</span> M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>line <span class="token operator">=</span> M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>        N<span class="token punctuation">.</span>col <span class="token operator">=</span> M<span class="token punctuation">.</span>line<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> nums <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token operator">*</span> copt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>col<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里之所以每个数组都多分配一个空间是因为想让下标从1开始，与三元组统一</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//初始化nums数组</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            nums<span class="token punctuation">[</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//遍历M中每一个元素，该元素是哪一列，就把nums相应下标的值+1</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//nums数组赋值完成</span>        cpot<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>col<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cpot<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cpot<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//通过遍历得到cpot每一个值</span>        <span class="token punctuation">&#125;</span> <span class="token comment">//cpot数组赋值完成</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>p<span class="token operator">&lt;</span>M<span class="token punctuation">.</span>num<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> col <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>            <span class="token keyword">int</span> place_in_N <span class="token operator">=</span> cpot<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">+</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>            <span class="token comment">//在新三元组N中的下标为：行起始下标+新矩阵中的列下标（也就是原矩阵中的行下标）</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j<span class="token punctuation">;</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i<span class="token punctuation">;</span>            N<span class="token punctuation">.</span>data<span class="token punctuation">[</span>place_in_N<span class="token punctuation">]</span><span class="token punctuation">.</span>v <span class="token operator">=</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>            <span class="token comment">//行，列下标互换，值不变</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述完整方法其实理解起来有一定难度，主要是因为需要定义以及捋清楚的变量非常多，如果读者暂时无法理解全部，也可以先放一放，或者跟着此前的梳理顺序再来一遍。</p><p>我们再来看这个算法的时间复杂度：</p><p>我们通过分别对M的列以及M的所有元素进行遍历，实现了这个算法，其时间复杂度为</p><p><strong>O(M.num + M.col);</strong></p><p>这个加式可比之前那个乘方式好看多了</p><hr><h4 id="行逻辑链接表示法"><a href="#行逻辑链接表示法" class="headerlink" title="行逻辑链接表示法"></a>行逻辑链接表示法</h4><p>三元组表示法的优点在于其内每个非零元素的行下标与列下标都非常清晰，可以直接提取出来，但是如果我们需要随机存取某一行中的非零元，则三元组需要从头开始遍历，不是非常的优雅。</p><p>我们参考三元组快速转置中的思路，直接将一个数组rpos添加到压缩后矩阵的结构体的定义中，其代表的就是每一行第一个非零元在三元组中的下标。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Triple data<span class="token punctuation">[</span>Maxsize<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> line<span class="token punctuation">,</span> col<span class="token punctuation">,</span> num<span class="token punctuation">;</span> <span class="token comment">//矩阵的行数、列数、非零行个数</span>    <span class="token keyword">int</span><span class="token operator">*</span> rpos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>RLSMatrix<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的话，我们如果给定一组下标(r, c)，我们就可以直接通过以下的算法进行取值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Elemtype <span class="token function">value</span><span class="token punctuation">(</span>RLSMatrix M<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//r:行数; c:列数</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> M<span class="token punctuation">.</span>rpos<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">==</span> r <span class="token operator">&amp;&amp;</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">&lt;</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>i <span class="token operator">==</span> r <span class="token operator">&amp;&amp;</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>j <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> M<span class="token punctuation">.</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="行-列链接存储表示法"><a href="#行-列链接存储表示法" class="headerlink" title="行 &#x2F; 列链接存储表示法"></a>行 &#x2F; 列链接存储表示法</h4><p>如果我们想用指针来对稀疏矩阵进行存储，思路也很简单：<br>我们可以以每行 &#x2F; 每列为单位，存储一个链表的头节点，在其后面存储每一个不为0的元素为一个节点。</p><p>这里以行链接表示法为例，给出具体定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LinkNode</span><span class="token punctuation">&#123;</span>    Elemtype v<span class="token punctuation">;</span>    <span class="token keyword">int</span> col <span class="token comment">// 每一个元素的列数</span>    LinkNode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CpMatrix</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> num<span class="token punctuation">,</span> line<span class="token punctuation">,</span> col<span class="token punctuation">;</span>    LinkNode<span class="token operator">*</span> Head<span class="token punctuation">;</span> <span class="token comment">//链表的头指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用图示表示一下：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.5/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E8%A1%8C%E9%93%BE%E6%8E%A5%E6%8C%87%E9%92%88.png" alt="行链接存储"></p><p>看到这里，有些读者可能就有些 <del>大胆的想法</del> ，哎？我如果行与列都加上一个链表来存储呢？当然可以，不过这种玩意维护起来就显得有亿点点麻烦了，有需求的读者可以自行尝试实现，这里权当抛砖引玉。让我们在读者的思想变得更危险之前进入下一个话题…</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><blockquote><p>广义表这个玩意其实目前用的已经很少了，因为它的定义方式决定着这玩意哪怕是用手画都很难理解，并且捋清楚层次，更别提用真正的计算机来实现它了，其实这玩意的思路跟后面要叙述的 <strong>多叉树</strong> 非常的接近，占用空间又比树大，所以嘛…</p></blockquote><p>说了这么多，毕竟这玩意也是数据结构的考点，还是在这里大体捋一下。</p><p><strong>广义表</strong> 是用递归形式定义的线性结构，是线性表的推广，它的元素可以是一个单元素，也可以是一个子表。</p><p>LS &#x3D; (α<sub>1</sub>, α<sub>2</sub>, α<sub>3</sub>, …, α<sub>n</sub>);</p><p>以上是它的书写形式，LS是其表名，而其中的α<sub>1</sub>, α<sub>2</sub> 等元素，可以是一个元素，也可以是又一个表 <del>（这不纯纯tm套娃吗）</del></p><p>上面的定义决定了广义表这玩意有以下性质：</p><ul><li>广义表里的元素是有顺序的</li><li>广义表的长度：最外层的表含有的元素个数</li><li>广义表的深度：广义表所含括弧的重数，即其最深的一枝能深到第几层</li><li>广义表可以是递归的</li></ul><h3 id="广义表的分解"><a href="#广义表的分解" class="headerlink" title="广义表的分解"></a>广义表的分解</h3><p>这里咱单开一块来说一说广义表分解这一茬事情，因为这玩意的定义方式使得分解很容易把人绕晕喽。</p><p>我们通常认为，任何一个广义表，都可以被分解成表头和表尾：</p><ul><li>表头是广义表的第一个元素</li><li>表尾是广义表的 <strong>剩余元素组成的新广义表</strong></li></ul><p>请希望学习这一部分的读者提高重视，表头是一个元素，而表尾必定是一个 <strong>广义表</strong> 。这个分解方式在学习时已经坑了笔者很多次了，希望读者能够不要像笔者一样踩这么多坑。</p><p>我们举个例子：<br>有个广义表：</p><p>D &#x3D; (E, F);<br>其中E &#x3D; (a, b, c); F &#x3D; z;</p><p>那么 <strong>D的表头</strong> 就是 <strong>E</strong> ，而 <strong>D的表尾</strong> 是 <strong>(F)</strong> 。<br>再写一个，加深一下印象：<strong>E的表头</strong> 是 <strong>a</strong> ，而 <strong>E的表尾</strong> 是 <strong>(b, c)</strong> 。</p><p>在读者能够清晰地分辨出表头和表尾的区别后，我们进入下面的章节。</p><h3 id="广义表的表示"><a href="#广义表的表示" class="headerlink" title="广义表的表示"></a>广义表的表示</h3><blockquote><p>由于广义表的定义过于复杂，拆解也很复杂，因此广义表的表示通常只能用链表这一结构来实现。</p></blockquote><p>我们首先明确一下，广义表中，存在两类节点：</p><ul><li>表节点（表示这里面是另一个表）</li><li>原子节点（表示这里面只有一个元素）</li></ul><p>这两类节点通过一个额外的表示符 <strong>tag</strong> 来区分。</p><p>我们这里只说一种表示方法</p><h4 id="表头、表尾分析法"><a href="#表头、表尾分析法" class="headerlink" title="表头、表尾分析法"></a>表头、表尾分析法</h4><p>这法子挺自然的，刚刚说了拆分方式嘛，所以我们干脆直接将节点中拆出两个玩意来，一个指向表头，一个指向表尾。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">GenNode</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//表节点</span>    GenNode<span class="token operator">*</span> ListHead<span class="token punctuation">,</span> ListTail<span class="token punctuation">;</span> <span class="token comment">//分别指向表头以及表尾</span><span class="token punctuation">&#125;</span>GenList<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Atom</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//原子节点</span>    Elemtype value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里举一个相对复杂的例子来让读者再次理解这个分析的方法</p><p>A&#x3D;( ) ; B&#x3D;(e) ; C&#x3D;(a,(b,c,d)) ; D&#x3D;(A,B,C)</p><p>我们把D用这种方法来表示出来：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.5/%E5%B9%BF%E4%B9%89%E8%A1%A8%20%E8%A1%A8%E5%A4%B4%E8%A1%A8%E5%B0%BE%E5%88%86%E6%9E%90%E6%B3%95.png" alt="D 表头表尾分析法"></p><p>可以得见，这玩意真要表示需要耗费多少空间…</p><blockquote><p>其实这玩意还有另一种表示方式叫 <strong>子表分析法</strong> ，这种法子相对而言比较节省空间，但是把这玩意写出来的话想必读者会更混乱，这里有需求的读者可以自行查阅其他资料。</p></blockquote><h3 id="广义表的相关算法"><a href="#广义表的相关算法" class="headerlink" title="广义表的相关算法"></a>广义表的相关算法</h3><p>这里我们只写一个广义表求深度的算法，我们利用递归的思想来求一个广义表的深度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">GetDepth</span><span class="token punctuation">(</span>GenList L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//L是空表，深度为1</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>tag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//L是原子节点，返回深度0</span>    <span class="token punctuation">&#125;</span>    GenNode<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>L<span class="token punctuation">;</span>    <span class="token keyword">int</span> max<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> p<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>ListTail<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> dep <span class="token operator">=</span> <span class="token function">GetDepth</span><span class="token punctuation">(</span>p<span class="token operator">-></span>ListHead<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>dep <span class="token operator">></span> max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//当前表头的深度比此前得到的深度更深</span>            max <span class="token operator">=</span> dep<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> max<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>至此，数组与广义表的内容就阐述的差不多了。</p><p>额外提一嘴，广义表的相关概念，考虑到日常生活中的应用概率较低，可以不必过于在意，但如果是因为数据结构考试的话，建议还是深入思考一下（苦笑</p><p>好啦，这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-4</title>
      <link href="/posts/55778.html"/>
      <url>/posts/55778.html</url>
      
        <content type="html"><![CDATA[<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><blockquote><p>本章是 <strong>串</strong> 这种结构的大体梳理</p></blockquote><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><p><strong>串</strong> 是由零个或多个字符组成的有限序列。</p><p>由于串实在过于常见，因此大多数语言都提供了一些基础的对串格式的支持，如C中的字符串拼接、复制、分割函数；C++中的string类，Java中的String类等。</p><p>很显然，不同的语言对串的支持程度不尽相同，因此这里仅仅提一个概念， <strong>串的最小操作子集</strong> ，即可以用这个集合里的函数实现任何想要对串进行的操作。</p><ul><li>串赋值（CharAssign）</li><li>串复制（Strcopy）</li><li>串比较（StrCompare）</li><li>求串长（StrLength）</li><li>串连接（Concat）</li><li>求子串（SubString）</li></ul><p>可以看出，其实串跟我们第一章所了解的 <strong>线性表</strong> 是很相似的，只不过，串存储的是一个个字符，同时串也常常以 <strong>一组字符</strong> 为单位进行增删改查，而不像线性表一样以 <strong>单个单元</strong> 为单位进行。</p><h2 id="串的存储"><a href="#串的存储" class="headerlink" title="串的存储"></a>串的存储</h2><h3 id="串的堆分配存储"><a href="#串的堆分配存储" class="headerlink" title="串的堆分配存储"></a>串的堆分配存储</h3><p>这种存储方式是串最常见的存储方式。其利用动态内存分配进行存储管理。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> HString<span class="token punctuation">;</span><span class="token comment">//当需要进行内存分配时</span>ch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>length<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他存储方式"><a href="#其他存储方式" class="headerlink" title="其他存储方式"></a>其他存储方式</h3><p>读者读到这里可能会产生两个疑惑：</p><ul><li>直接用数组不行吗</li><li>想用链表存储</li></ul><p>用数组，即被称为 <strong>串的定长顺序存储</strong> ，其弊端在于无法改变串的长度，当进行操作时很容易产生长度过长的问题，这种情况下，数组存储只能进行截断操作，这导致了串内容的丢失。</p><p>用链表，即被称为 <strong>串的块链存储</strong> ，其可以通过链表对串进行连接，同时链表每个节点中需要存储多少字符也可以由个人决定，但是这种存储方式使原本十分简单的复制、连接等操作变得极为复杂，一般不会采取这种存储方式。</p><h2 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h2><p>通常，字串的定位操作被称为 <strong>串的模式匹配</strong> ，表示为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">INDEX</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其意义表示为：如果主串S中存在与字串T相同的串，则返回其在字串下标pos后第一次出现的位置。<br>这定义听着挺拗口的，读者不妨把它理解成字串查找即可。</p><p>我们现在想一想，如果要实现这个功能，该如何设计？</p><h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>这是我们大概第一眼就会想到的算法，主串从前往后循环，遇到与字串相同的字符则开始一个子循环流程，子循环能跑完，则代表着串匹配了，返回当前主串循环的下标。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">INDEX</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> S<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            i <span class="token operator">=</span> i<span class="token operator">-</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>            j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">//匹配失败，指针回退</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//说明子循环跑完了，有字串</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种算法固然清晰，但其时间复杂度为O(m*n)，即字串与主串的长度的乘积，这太长了。</p><h3 id="首尾匹配算法"><a href="#首尾匹配算法" class="headerlink" title="首尾匹配算法"></a>首尾匹配算法</h3><p>这种算法算得上一种折中，即每次比较时，优先比较首尾的元素，再比较中间的剩余元素，但由于这种算法并算不上真正降低了时间复杂度，这里不再详述。</p><h3 id="KMP算法（重点）"><a href="#KMP算法（重点）" class="headerlink" title="KMP算法（重点）"></a>KMP算法（重点）</h3><h4 id="KMP概述"><a href="#KMP概述" class="headerlink" title="KMP概述"></a>KMP概述</h4><p>我们再次甚至暴力求解的第一个算法，发现其实主要的重复计算时间来源，是主串中 <strong>每次字符失配时的指针回退</strong> 。如果我们能够达到一种主串中指针永远不回退的算法，那将大大降低我们的算法耗时。</p><p>我们这里举一个例子：</p><p>主串的内容：A B A B A B C</p><p>字串的内容：A B A B C</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-1.png" alt="初始情况"></p><p>如果按照暴力求解的算法，第一次匹配，字串匹配到了C，发现与主串的A不相同，则主串指针回退至B，字串指针回退至A，再次匹配。</p><p>但我们想的理想情况是将字串的A与主串中第三个A齐平，同时可以跳过重复的AB，直接从第三个字符开始比较。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-2.png" alt="理想情况"></p><p>要实现这个跳跃过程，我们需要借助一个数组，这个数组的作用是当字串与主串的字符发生失配现象了，下一次比较时主串需要与哪一个字串中的字符相比较。</p><p>我们用具体的程序来表达一下这个算法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">INDEX_KMP</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> S<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> pos<span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span> S<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;=</span> T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">//当主串中的字符与字串的第一个字符失配，或者主串与字串还未失配时，继续向后比较</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//此时失配，则j回退至next[j]所指向的位置，i不变</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span>T<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i<span class="token operator">-</span>T<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h4><p>那么现在的问题就从如何降低时间复杂度变为这个next数组该怎么求了。</p><p>这里原理不进行详细叙述，给出公式：<br>next[j] &#x3D; 此前已成功匹配的字串中最长的相同前后缀+1</p><p>前缀，即不包含最后一个字符的字串（从前往后看）<br>后缀，即不包含第一个字符的字串（从后往前看）</p><p>特殊的，next[1] &#x3D; 0</p><p>比如上例：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-3.png" alt="next"></p><ul><li>第一个字符A: next[1] &#x3D; 0</li><li>第二个字符B: 不存在相同的前后缀，next[2] &#x3D; 0+1 &#x3D; 1</li><li>第三个字符A: 不存在相同的前后缀，next[3] &#x3D; 0+1 &#x3D; 1</li><li>第四个字符B: 前缀”A”与后缀”A”相等，next[4] &#x3D; 1+1 &#x3D; 2</li><li>第五个字符C: 前缀”AB”与后缀”AB”相等，next[5] &#x3D; 2+1 &#x3D; 3</li></ul><h4 id="nextval数组"><a href="#nextval数组" class="headerlink" title="nextval数组"></a>nextval数组</h4><p>next数组已经可以达到主串指针不回溯的目的了，但是还有最后一点点小遗憾：</p><p>我们假设字串为：A A A A B</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-4.png" alt="next"></p><p>我们假设程序在比较时，恰巧在B这一点失配了。接下来我们应该干什么？</p><p>根据我们此前的讲述：程序会根据 <strong>next[5] &#x3D; 4</strong> 来将主串指针当前字符与字串的第四个字符A比较。</p><p>如果能够匹配还好，如果不匹配呢？</p><p>那就会出现，继续根据 <strong>next[4] &#x3D; 3</strong> 、 <strong>next[3] &#x3D; 2</strong> …等等语句，与字串的第三个字符A，第二个字符A，第一个字符A，比了三次，然后发现，哦，第一个都对不上，那主串的指针往后移动一位。</p><p>发现问题了吗？ 字串的前几位其实都一样，那么如果我跟第四个字符A比完之后，其实再跟第三个、第二个、第一个A比较的过程完全可以省去，因为一定会失配。</p><p>这就是为什么我们会再引入一个数组，叫nextval，这个数组就是为了防止上述问题的发生而出现的。<br>其具体方法为：如果 <strong>next[j] &#x3D;&#x3D; k</strong> ，同时字串中 <strong>T[j] &#x3D;&#x3D; T[k]</strong> ，那么我们就不用让主串S再跟字串中T[k]比较了，因为必定失配，我们让S当前位置的字符直接跟 <strong>T[next[k]]</strong> 进行比较。</p><p>nextval的具体求法是通过next数组来的：</p><ul><li>如果T[k] &#x3D;&#x3D; T[j] : 则nextval[j] &#x3D; nextval[k]</li><li>如果T[k] !&#x3D; T[j] : 则nextval[j] &#x3D; next[j]</li></ul><p>我们还是拿刚才那个例子来举例：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84Chap.4/KMP-5.png" alt="nextval"></p><ul><li>第一个元素A：照常，nextval[1] &#x3D; 0</li><li>第二个元素A：next[2] &#x3D; 1, 并且T[1] &#x3D;&#x3D; T[2] &#x3D;&#x3D; ‘A’, 因此nextval[2] &#x3D; nextval[1] &#x3D; 0</li><li>第三个元素A：next[3] &#x3D; 2, 并且T[2] &#x3D;&#x3D; T[3] &#x3D;&#x3D; ‘A’, 因此nextval[3] &#x3D; nextval[2] &#x3D; 0</li><li>第四个元素A：next[4] &#x3D; 3, 并且T[3] &#x3D;&#x3D; T[4] &#x3D;&#x3D; ‘A’, 因此nextval[4] &#x3D; nextval[3] &#x3D; 0</li><li>第五个元素B：next[5] &#x3D; 4, 但(T[4] &#x3D;&#x3D; ‘A’) !&#x3D; (T[5] &#x3D;&#x3D; ‘B’), 因此nextval[5] &#x3D; next[5] &#x3D; 4</li></ul><p>至此，nextval这个next的改进版数组也讲解完毕了，我们实现了一个线性时间复杂度的串模式比对算法。</p><hr><p>至此，串的各种事项大致梳理完毕，该部分的重点就是KMP算法的理解。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数电-Chap.1</title>
      <link href="/posts/33374.html"/>
      <url>/posts/33374.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面：本课程会着重于半导体器件、逻辑代数以及逻辑门的学习，达到基本能够进行组合电路，时序电路以及运放（运算与放大）电路的识别、设计等操作。</p></blockquote><h1 id="数字逻辑基础"><a href="#数字逻辑基础" class="headerlink" title="数字逻辑基础"></a>数字逻辑基础</h1><h2 id="1-计数体制"><a href="#1-计数体制" class="headerlink" title="1. 计数体制"></a>1. 计数体制</h2><h3 id="1-1-数制"><a href="#1-1-数制" class="headerlink" title="1.1 数制"></a>1.1 数制</h3><p>我们将日常生活中由低位数向高位进位的规则称为 <strong>数制</strong> 。</p><p>在数字系统中，常用的数制包括：</p><ul><li>十进制（Decimal）</li><li>二进制（Binary）</li><li>八进制（Octal）</li><li>十六进制（Hexadecimal）</li></ul><p>它们分别表示逢几进一。</p><h3 id="1-2-进制的转换"><a href="#1-2-进制的转换" class="headerlink" title="1.2 进制的转换"></a>1.2 进制的转换</h3><h4 id="其他进制-十进制"><a href="#其他进制-十进制" class="headerlink" title="其他进制 -&gt; 十进制"></a>其他进制 -&gt; 十进制</h4><p>按权相加：将非十进制的各位权重乘以对应位的权重，再相加。<br>如：(10011.011)<sub>2</sub> -&gt; (?)<sub>10</sub><br>其计算过程为：1 * 2<sup>4</sup> + 1 * 2<sup>1</sup> + 1 * 2<sup>0</sup> + 1 * 2<sup>-2</sup> + 1 * 2<sup>-3</sup></p><h4 id="十进制-其他进制"><a href="#十进制-其他进制" class="headerlink" title="十进制 -&gt; 其他进制"></a>十进制 -&gt; 其他进制</h4><p>一般会将十进制的整数部分与小数部分分别转换并相加。<br>整数部分采用 <strong>除基取余法</strong> ，小数部分采用 <strong>乘基取整法</strong> 。<br>如：(25.25)<sub>10</sub> -&gt; (?)<sub>2</sub><br>整数25部分：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E9%99%A4%E5%9F%BA%E5%8F%96%E4%BD%99.png" alt="除基取余"></p><p>小数0.25部分：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E4%B9%98%E5%9F%BA%E5%8F%96%E6%95%B4.png" alt="乘基取整"></p><h4 id="其他进制之间的互相转换"><a href="#其他进制之间的互相转换" class="headerlink" title="其他进制之间的互相转换"></a>其他进制之间的互相转换</h4><ul><li><p>二进制 -&gt; 八进制 &#x2F; 十六进制：<br>通常可以采用三位 &#x2F; 四位二进制转为一位八进制 &#x2F; 十六进制的方法进行快速转化</p></li><li><p>八进制 &#x2F; 十六进制 -&gt; 二进制：<br>通常可以采用一位八进制 &#x2F; 十六进制转为三位 &#x2F; 四位二进制的方法进行快速转化</p></li></ul><p>注：上述方法运用时从小数点开始往左 &#x2F; 右进行转化，别忘记高位补0</p><h2 id="2-编码"><a href="#2-编码" class="headerlink" title="2. 编码"></a>2. 编码</h2><p>由于在计算机内，处理、存储、传输的都是二进制数据，因此将外界信息通过二进制进行表示这一过程就显得尤为重要，这一过程被称为 <strong>编码</strong></p><p>常见的编码有：</p><ul><li>BCD码</li><li>ASCⅡ</li></ul><h3 id="BCD编码"><a href="#BCD编码" class="headerlink" title="BCD编码"></a>BCD编码</h3><p>利用四位二进制数来表示一位十进制数的过程被称为 <strong>BCD编码</strong></p><p>常用的BCD编码有：</p><ul><li>8421码</li><li>余3码</li><li>2421码</li></ul><p>其中8421码尤为常用，其名称代表着各个位次上二进制数字的权值</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/BCD%E7%A0%81.png" alt="8421"></p><h3 id="ASCⅡ"><a href="#ASCⅡ" class="headerlink" title="ASCⅡ"></a>ASCⅡ</h3><p>ASCⅡ（American National Standard Code for Information Interchange）用于通过八位二进制数来表示生活中常用的数字与符号，其中低七位用于表示，最高一位用于奇偶校验。</p><p>具体图片烦请读者自行上网搜索。</p><h2 id="3-逻辑代数基础"><a href="#3-逻辑代数基础" class="headerlink" title="3. 逻辑代数基础"></a>3. 逻辑代数基础</h2><p>与现实中不尽相同，计算机由于采用二进制，因此其逻辑判断也仅有两种状态，即1（真）与0（假），在数字系统中，我们又常常将电位与真假相关联，即高电位（也称高电平）表示1，低电位（也称低电平）表示0。</p><h3 id="3-1-基本逻辑运算与基本逻辑门"><a href="#3-1-基本逻辑运算与基本逻辑门" class="headerlink" title="3.1 基本逻辑运算与基本逻辑门"></a>3.1 基本逻辑运算与基本逻辑门</h3><h4 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h4><p><strong>与运算</strong> 表示参与某一事件的全部条件都为真时，该事件才能发生。</p><h4 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h4><p><strong>或运算</strong> 表示参与某一事件的某一条件为真时，该事件就能发生。</p><h4 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h4><p><strong>非运算</strong> 表示将某一事件原本的真值倒置，1变0，0变1。</p><h4 id="同或运算"><a href="#同或运算" class="headerlink" title="同或运算"></a>同或运算</h4><p><strong>同或运算</strong> 表示参与某一事件的两个条件相同时，该事件才能发生。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%90%8C%E6%88%96%E8%BF%90%E7%AE%97.png" alt="同或运算真值表"></p><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p><strong>异或运算</strong> 表示参与某一事件的两个条件不同时，该事件才能发生。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.png" alt="异或运算真值表"></p><h3 id="3-2-常用化简公式"><a href="#3-2-常用化简公式" class="headerlink" title="3.2 常用化简公式"></a>3.2 常用化简公式</h3><p>数电中的化简方式繁多，这里给出一些常用的公式与定律，仅供参考<br><del>（有卡诺图谁用公式啊）</del></p><ul><li><strong>摩根定律</strong> ：$\overline{\text{A * B}}$ &#x3D; $\overline{\text{A}}$ + $\overline{\text{B}}$<br>注：该公式来源于 <strong>反演率</strong> ，即将公式中所有的乘加互换，01互换，原变量反变量互换，就可以得到原逻辑函数的反函数</li><li><strong>吸收率</strong> ：A * (A + B) &#x3D; A</li><li><strong>对偶规则</strong> ：若两个逻辑函数相等，则它们的对偶式也对应相等。（对偶式的写法与摩根定律反演率相同）</li></ul><h3 id="3-3-逻辑函数的表示"><a href="#3-3-逻辑函数的表示" class="headerlink" title="3.3 逻辑函数的表示"></a>3.3 逻辑函数的表示</h3><p>逻辑函数通常有以下五种表达方式：</p><ul><li>真值表</li><li>逻辑表达式</li><li>逻辑图</li><li>波形图</li><li>卡诺图</li></ul><p>这其中，在手动化简时，以卡诺图最为常用：<br>具体表示为一个表格，表格横坐标与纵坐标均表示一个或多个逻辑变量，在相应的最小项处标记0 &#x2F; 1表示假 &#x2F; 真，而后利用偶数对画圈法将所有的1都圈起来，根据圈写出逻辑表达式。</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E7%94%B5/%E6%95%B0%E7%94%B5%E7%AC%AC%E4%B8%80%E7%AB%A0/%E5%9B%9B%E5%8F%98%E9%87%8F%E5%8D%A1%E8%AF%BA%E5%9B%BE.png" alt="四变量卡诺图"></p><p>这里举个例子：<br>假如m0, m1, m12, m13, m15, m14均为1，其他项均为0，则m0, m1为一组，表示为：$\overline{\text{A}}$ * $\overline{\text{B}}$ * $\overline{\text{C}}$ 。而剩余四个为一组，表示为： A * B<br>整体表达式为：<br>（$\overline{\text{A}}$ * $\overline{\text{B}}$ * $\overline{\text{C}}$ ）+ （A * B）</p><hr><p>这篇博文就到这里~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Digital Logic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.4</title>
      <link href="/posts/35903.html"/>
      <url>/posts/35903.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h1><blockquote><p>上一篇博文中，我们大致对类及其特点进行了些许介绍，本文中将更进一步介绍一些常用的操作与注意事项</p></blockquote><h2 id="类方法中参数的传递"><a href="#类方法中参数的传递" class="headerlink" title="类方法中参数的传递"></a>类方法中参数的传递</h2><h2 id="类中的静态成员"><a href="#类中的静态成员" class="headerlink" title="类中的静态成员"></a>类中的静态成员</h2><p>试想一下，如果一个类中有这样的语句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Text</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> number<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        number<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然，上述语句中count与number的性质并不同，count是一个静态变量，只能进行一次初始化，而number是一个普通变量，可以多次初始化。</p><p>正由于这种区别的存在，我们称如count这种的变量为静态变量，其生命周期与类相同，而number这样的变量的生命周期则与其对象相同。也可以说，静态变量属于类，而常规变量属于对象。</p><p>这样的变量很特殊，在java中，可以直接通过类名在外部访问这个变量，如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Text</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>类似的，如果static加在方法前，则称为 <strong>类的方法</strong> ，它也可以通过 类名.方法名 的形式进行外部访问。比如java中的math类，就有相关的特点。</p></blockquote><h2 id="单态设计模式-Singleton"><a href="#单态设计模式-Singleton" class="headerlink" title="单态设计模式(Singleton)"></a>单态设计模式(Singleton)</h2><p>在java中常见一种特殊的类，为了保障数据的一致性，这种类的实例，在一次编译过程中仅有一个，我们称之为 <strong>单例类</strong> ，构造一个单例类的过程我们称之为 <strong>单态设计模式</strong> 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Company</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Company</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Vehicle</span><span class="token punctuation">[</span><span class="token punctuation">]</span> fleet<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Company</span> <span class="token function">getCompany</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Company</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种构造方法是私有的，保证了从外部无法访问相关的构造方法，此外其通过另一个静态函数getCompany来传入参数，间接进行唯一一个的Company的初始化。这样就保证了一个程序内只存在一个Company类。</p><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final在java中用途繁多，主要有以下三种：</p><ul><li>final加在变量前，表示常量，只能进行一次赋值</li><li>final加在方法前，表示该方法无法被重写</li><li>final加在类前，表示该类是最终类，无法被继承（没有子类）</li></ul><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>类似于C，java中也存在枚举类型，其定义方法为：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">enum</span> <span class="token class-name">Color</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Red</span><span class="token punctuation">,</span> <span class="token class-name">Green</span><span class="token punctuation">,</span> <span class="token class-name">Blue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="抽象类-Abstract-class"><a href="#抽象类-Abstract-class" class="headerlink" title="抽象类(Abstract class)"></a>抽象类(Abstract class)</h2><p>java中涉及到一些类，它们没有具体的参数值，仅有一些方法，具体的参数需要在其子类下进行定义，我们称这种类型为 <strong>抽象类</strong> 。</p><p>这样的类定义需要加入 <strong>abstract</strong> 关键字：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>抽象类常用于定义同一类型的对象的相似方法。</p><blockquote><p>其实，抽象类也可以没有抽象方法，如果这样的话，这种类就只能进行子类派生操作。</p></blockquote><h2 id="接口-Interfaces"><a href="#接口-Interfaces" class="headerlink" title="接口(Interfaces)"></a>接口(Interfaces)</h2><blockquote><p>上文中提到了利用抽象类来定义同一类型的实体的相似方法，但如果对象类型不同，就需要利用接口了</p></blockquote><p>接口用于定义不同对象的相同行为，其定义中仅有函数声明与静态常量，没有具体实现代码，需要在不同的类中重写。</p><p>接口的定义通常如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token generics"><span class="token punctuation">&lt;</span>interface_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> function1 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> function2 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>可见，接口的定义与C中的函数声明很相似，仅声明出这个函数的存在，不给出具体方法。</p><p>而具体需要使用接口的函数时，需要这样写出：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token generics"><span class="token punctuation">&lt;</span>interface_name<span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token comment">//对接口函数进行重写</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h3><p>从jdk-8开始，接口中引入了默认方法，用default关键字修饰，这样的方法可以有具体的实现代码，这种特性使得接口在添加方法时不需要对所有应用接口的类进行重写，主要目的在于提高兼容性。</p><hr><p>关于面向对象的内容肯定不仅仅这么多，上述博文会在进一步了解java后继续完善。</p><p>目前，本篇博文就到这里～</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.3</title>
      <link href="/posts/20094.html"/>
      <url>/posts/20094.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-类与方法"><a href="#Java-类与方法" class="headerlink" title="Java 类与方法"></a>Java 类与方法</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类是什么"><a href="#类是什么" class="headerlink" title="类是什么"></a>类是什么</h3><p><strong>类</strong> 有些类似C中的结构体，不过Java中的类除了变量外，也可以包含函数，我们称之为 <strong>方法</strong> 。</p><blockquote><p>如果读者接触过C++，那么可以将类理解为一种 <strong>模板</strong> ，而每个实例都是对于模板的一种创建过程。</p></blockquote><h3 id="类的特点与必要性"><a href="#类的特点与必要性" class="headerlink" title="类的特点与必要性"></a>类的特点与必要性</h3><p>类的代码可重用，这极大程度上降低了代码语言的重复性，同时有效提高了便捷度。<br>通常而言，Java中的类具有以下三种特点：</p><ul><li>继承性</li><li>多态性</li><li>封装性</li></ul><p>这三种特点的具体表现将在以下详细阐述。</p><h3 id="类的定义-实例的声明"><a href="#类的定义-实例的声明" class="headerlink" title="类的定义 &amp; 实例的声明"></a>类的定义 &amp; 实例的声明</h3><p>Java是面向对象的编程语言，这就意味着类是Java中的基础构成部分，任何一个Java程序均离不开类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token punctuation">[</span><span class="token keyword">public</span> <span class="token operator">/</span> <span class="token keyword">private</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">abstract</span> <span class="token operator">/</span> <span class="token keyword">final</span><span class="token punctuation">]</span> <span class="token keyword">class</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token punctuation">[</span><span class="token keyword">extends</span> class_name<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>property_type<span class="token punctuation">></span></span> var1<span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span>property_type<span class="token punctuation">></span></span> var2<span class="token punctuation">;</span>        function1 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    function2 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//若在编写中需要使用这个类，则利用以下语句进行声明：</span><span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span> <span class="token generics"><span class="token punctuation">&lt;</span>var_name<span class="token punctuation">></span></span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generics"><span class="token punctuation">&lt;</span>class_name<span class="token punctuation">></span></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句能够表示一个Java类的定义，其中public &#x2F; private 表示类的访问权限，abstract &#x2F; final表示类是否为抽象类 &#x2F; 是否能被继承，内部的var1 表示变量声明，而后的function表示方法（具体函数）。</p><p>如同我们此前讲过的那样，Java类中可以声明所有的数据类型，但在声明过后，如果不进行初始化，Java会使用 <strong>默认值自动对其进行初始化操作</strong> ，默认值如下：</p><ul><li>int: 0</li><li>double &#x2F; float: 0.0</li><li>char: “\u0000”</li><li>boolean: false</li><li>数组: NULL</li></ul><p>除此之外，Java中的类允许 <strong>方法</strong> 的定义，类似于C中的一个函数，可以进行这种类中可能涉及的操作，并返回相应的值。</p><p>与此同时，Java的类，类中的变量声明，类中的方法定义，均可以在前方添加 <strong>访问控制符</strong> 具体请看下文对于访问控制符的内容。</p><p>需要注意的是，类的名称通常使用大写字母开头，请尽可能养成这样的习惯，这有利于我们的程度可读性。</p><h3 id="类中的构造函数与this关键字"><a href="#类中的构造函数与this关键字" class="headerlink" title="类中的构造函数与this关键字"></a>类中的构造函数与this关键字</h3><p>在Java中的类中，常见用private对其内变量进行修饰，以此保证类的运行安全性。这种定义方式被称为 <strong>类的封装</strong> 。但这样做的后果是，无法从类的外部对类内部的变量直接进行更改，因此，Java的类提供了一种 <strong>构造函数</strong> 的方法，它与类同名，可以接受外部参数并以此根据其规则改变内部参量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Teacher</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以看出，在这里，从外部传入的参数叫age，name，但对象内也有叫做同样名字的参量。因此，Java引出了 <strong>this</strong> 关键字，在变量名前方加入this. ，则表示指向 <strong>当前对象内的参数</strong> 。我们能通过这样的特性，对类内的私有参量进行赋值。</p><p>对类的封装能够使编译者或程序使用者在对类进行操作时更有条理，也避免了外部随意修改类内部代码的情况。</p><p>此外，在一个类中的一个方法需要利用其所在类内的另一个方法时，可以使用&lt;this.method_name&gt;来对其进行调用。</p><h3 id="类中方法的重载"><a href="#类中方法的重载" class="headerlink" title="类中方法的重载"></a>类中方法的重载</h3><p>Java中的类允许存在多个重名的方法，这被称为 <strong>重载(Overload)</strong> ，而重载的要求为两个同名函数的参数列表必须有区别。</p><h3 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h3><p>Java类中的方法允许传入多个同类型的参数，具体定义方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setnames</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> names<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>利用这样的定义，可以直接传入多个String。</p><p>这里提供另一种写法，其用途与上述定义相似，区别在于其基于数组传入参数，因此从外部调用时需要先行构造数组：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setnames</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> names<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h3><p>为了考虑一个文件，一个类在其他位置的访问权限，Java中提出了 <strong>访问控制修饰符</strong> 的概念。</p><p>Java有4类访问控制修饰符：</p><ul><li>private：仅仅允许同一个类中的方法来访问。</li><li>default：同一个包里文件都可以访问。</li><li>protected：不仅仅同一个包中，只要是它的子类，均可以访问。</li><li>public：完全公开。</li></ul><p>此外，Java中规定了，在一个源文件中（.java）， <strong>允许且仅允许</strong> 一个 <strong>public</strong> 类的存在，请在编写中注意这一点。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>当两个类具有相同的属性时，我们往往可以使用 <strong>继承</strong> 的方法进行定义。<br>这种情况下，有父类与子类之分，子类具有父类的全部属性和方法，同时也可以进行相应更具体属性、方法的添加。</p><p>这种方法常用 <strong>extends</strong> 关键字来进行操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">protected</span> <span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Java中，所有后方没有进行extend的类，都会在编译时自动扩展为 <strong>extends Object</strong> ，这是因为Object类是java中所有类的父类，是个默认定义。因此，Java中除了Object类之外，严格来说其他的类均有父类。</p><p>当然，这其中也必然涉及到一些父类的属性我们不希望继承到子类中，或者希望在子类中对父类的方法进行覆盖，这就涉及到修饰符的问题了。</p><blockquote><p>额外提一句，其实C++中有继承的方法，并且允许多亲继承，即一个子类有多个父类，但这种方法在两个父类的方法名相同时会引起冲突。Java考虑到了这一点，并不允许多亲继承。</p></blockquote><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们也会遇到，在子类中已经对父类的方法进行覆盖，但我们仍然希望调用父类中的特定方法的情况，我们常用 <strong>super</strong> 来进行操作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> x <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"Manager"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子类的构造方法"><a href="#子类的构造方法" class="headerlink" title="子类的构造方法"></a>子类的构造方法</h3><p>Java基于子类必须基于父类这一原则，声明了子类的构造方法必须首先调用父类的构造方法，这种构造可以是显性的，也可以是隐性的。</p><p>这就代表着子类的构造函数必定会对父类的构造函数进行引用，而这里也常常出现一个很不容易发现的问题：<br>如果父类中没有无参的构造方法，而子类中的构造方法内又没有明确声明要使用父类的哪种有参构造方法，则每次构造子类对象时，都会默认先调用父类的无参构造方法，这就导致了编译错误。</p><p>这段话听起来有点绕腾：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Preson</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Preson</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">,</span> <span class="token keyword">int</span> score<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>score <span class="token operator">=</span> score<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上的代码是会报错的，因为其子类的构造方法在编译过程中会默认在最前方加一句：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于先对父类的构造方法进行访问。而这里父类没有无参构造方法。</p><p>因此，请在父类中写出无参构造方法，或者在子类中申明一个构造方法，使用super关键字，对父类的含参构造方法进行调用。</p><h3 id="final-sealed-permits"><a href="#final-sealed-permits" class="headerlink" title="final &#x2F; sealed &amp; permits"></a>final &#x2F; sealed &amp; permits</h3><p>Java中，可以用final或sealed来对类进行修饰，分别表示 <strong>该类不允许进一步继承</strong> 以及 <strong>只允许指定类继承</strong> 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">permits</span> <span class="token class-name">Student</span><span class="token punctuation">,</span> <span class="token class-name">Teacher</span><span class="token punctuation">&#123;</span>    <span class="token comment">//表示Person类只允许Student以及Teacher类进行继承</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">&#123;</span>    <span class="token comment">//表示Student类不允许再进一步被继承</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="向上转型-Upcasting-向下转型-Downcasting-instanceof"><a href="#向上转型-Upcasting-向下转型-Downcasting-instanceof" class="headerlink" title="向上转型(Upcasting) &amp; 向下转型(Downcasting) &amp; instanceof"></a>向上转型(Upcasting) &amp; 向下转型(Downcasting) &amp; instanceof</h3><p>由于Java中子类具有父类的全部功能，因此在Java中定义一个父类对象，让其指向子类，这是 <strong>被允许的</strong> 。</p><p>比如，拿上文中的类举例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Student</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> p <span class="token operator">=</span> s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这是可以的。</p><p>但是，当我们想反过来的时候，这个操作就不一定能成了：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Person</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Person</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Student</span> s3 <span class="token operator">=</span> s1<span class="token punctuation">;</span> <span class="token comment">//允许，因为s1实质上指向的是一个Student对象</span><span class="token class-name">Student</span> s4 <span class="token operator">=</span> s2<span class="token punctuation">;</span> <span class="token comment">//不允许，因为s2实质上指向的是一个Person对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因此，为了确保向下转型不会出错，java提供了一种操作符叫 <strong>instanceof</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">s1 <span class="token keyword">instanceof</span> <span class="token class-name">Student</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述语句可以判断s1对象指向的到底是不是Student，并返回相应的布尔变量。</p><p>从Java 14开始，可以直接在判断的类后面加名字，从而达成直接转型：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>s1 <span class="token keyword">instanceof</span> <span class="token class-name">Student</span> stu1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，如果s1是Student，会直接转型为stu1，并执行输出语句。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="子类对父类方法的覆写-Override"><a href="#子类对父类方法的覆写-Override" class="headerlink" title="子类对父类方法的覆写(Override)"></a>子类对父类方法的覆写(Override)</h3><p>在子类中，如果希望对父类中的某个方法进行重写，可以进行 <strong>Override</strong> 操作。</p><p>具体方法为：在子类中定义一个与父类的某一个方法</p><ul><li>方法名相同</li><li>返回类型相同（也可以返回该类型的子类型）</li><li>参数列表相同</li></ul><p>的方法。</p><blockquote><p>子类中覆盖父类的方法，其访问限制必须要比父类的相应方法更宽泛。如：</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getdetails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这种定义是不被允许的。</p></blockquote><h3 id="覆写与转型"><a href="#覆写与转型" class="headerlink" title="覆写与转型"></a>覆写与转型</h3><p>我们不妨设想这样一种情况：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name">Person</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stuent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">get_age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不妨想一想这时候调用的是哪一个get_age方法？</p><p>事实证明，Java中调用方法是根据对象的实际类型来调用的，而非其声明类型。</p><p>这就引出了一个很重要的概念。</p><h3 id="多态是个啥"><a href="#多态是个啥" class="headerlink" title="多态是个啥"></a>多态是个啥</h3><p>上文中，我们知道了Java在调用方法时，会根据对象的实际类型决定调用什么方法。</p><p>这就是多态的重要特性， <strong>针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</strong> 。</p><p>这使得，如果我们定义某个函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get_all_name</span><span class="token punctuation">(</span><span class="token class-name">Person</span> s1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s1<span class="token punctuation">.</span><span class="token function">get_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样的一个函数可以传入Person类，也同样可以传入Person的子类Student类，而在调用它们的get_name()方法时，Java会自动根据其实际类型来决定调用什么方法，这为我们省去了很多麻烦。</p><h3 id="异构集合体"><a href="#异构集合体" class="headerlink" title="异构集合体"></a>异构集合体</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">;</span>list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Manager 是Employee的子类</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这种定义是合法的。</p><p>可以看出，这个集合中不仅仅存在Employee类型，还存在其子类Manager类型。<br>但当我们需要对其进行操作时，我们需要得知当前操作的对象到底是什么类型，此时，我们常用前文中的 <strong>instanceof</strong> 关键字来确定一个对象到底是否是某个类型。</p><hr><p>这篇博文写的比较仓促，可能会存在诸多不足之处，博主会在后续空闲时间尽力补足。</p><p>下一篇博文会涉及到更深入一些的面向对象的操作，这篇博文先到这里~</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-3</title>
      <link href="/posts/7075.html"/>
      <url>/posts/7075.html</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈是什么"><a href="#栈是什么" class="headerlink" title="栈是什么"></a>栈是什么</h3><p><em><strong>栈</strong></em> 是另一种数据结构，其插入 &#x2F; 删除操作仅能在表的端点进行。</p><p>我们将允许进行插入 &#x2F; 删除操作的一端称为 <strong>栈顶</strong> ， 另一端称为 <strong>栈底</strong> 。<br>可以看出，栈的操作规则代表着其先进入的元素会被压在栈中，若想删除，则只能等到比其后进入的元素全部删除后才能进行。我们称这种规则为 <strong>后进先出</strong> 。</p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p>栈含有以下几种基本操作：</p><ul><li>InitStack：初始化</li><li>StackLength：求长</li><li>GetTop：获得栈顶元素</li><li>Push：入栈</li><li>StackTraverse：遍历</li><li>Pop：出栈</li><li>ClearStack：置空</li><li>StackEmpty：判空</li><li>DestoryStack：销毁</li></ul><h3 id="栈的存储结构"><a href="#栈的存储结构" class="headerlink" title="栈的存储结构"></a>栈的存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>我们常用一组地址连续的存储单元来对栈进行存储，即C中的数组。<br>数组的上界（maxsize）用于表示栈的最大容量，而单独设置一个指针Top用来指向当前栈顶在数组中的位置。</p><p>需要注意的是，栈底的位置往往是固定的，但栈顶的位置会随着入栈 &#x2F; 出栈的操作而变化。</p><p>定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> Maxsize n<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    Elemtype stack<span class="token punctuation">[</span>Maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里同时也对栈的各类操作进行一些说明：</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">InitStack</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    s<span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>；<span class="token comment">//直接将栈顶的指针定为-1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">Push</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> Elemtype e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>top<span class="token operator">></span>Maxsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//此时栈满，即将上溢出</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        s<span class="token punctuation">.</span>top<span class="token operator">++</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>s<span class="token punctuation">.</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>出栈的操作与入栈相似，只需要考虑是否下溢出即可，这里不再详述。</p><h5 id="取顶"><a href="#取顶" class="headerlink" title="取顶"></a>取顶</h5><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status <span class="token function">GetTop</span><span class="token punctuation">(</span>sqstack <span class="token operator">&amp;</span>s<span class="token punctuation">,</span> Elemtype <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>top<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">//此时栈空</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        e <span class="token operator">=</span> s<span class="token punctuation">.</span>stack<span class="token punctuation">[</span>s<span class="token punctuation">.</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其余操作在此不再详述。</p><h4 id="基于动态存储的栈管理"><a href="#基于动态存储的栈管理" class="headerlink" title="基于动态存储的栈管理"></a>基于动态存储的栈管理</h4><p>上文中基于数组的栈管理方法无法得心应手的进行栈扩容，而由此我们引出基于动态内存管理的方法。</p><p>它的定义如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">Stack_Int_Size</span> <span class="token expression"><span class="token number">100</span><span class="token punctuation">;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">Stack_Increment</span> <span class="token expression"><span class="token number">10</span><span class="token punctuation">;</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token operator">*</span>base<span class="token punctuation">;</span> <span class="token comment">//指向栈底</span>    Elemtype <span class="token operator">*</span>top<span class="token punctuation">;</span> <span class="token comment">//指向栈顶的下一个元素</span>    <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>sqstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的管理方法使得每次当栈满时，我们可以进行realloc操作重新扩容栈：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>top<span class="token operator">-</span>S<span class="token punctuation">.</span>base<span class="token operator">>=</span>S<span class="token punctuation">.</span>stacksize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//栈满，追加存储空间</span>    S<span class="token punctuation">.</span>base <span class="token operator">=</span> <span class="token punctuation">(</span>Elemtype<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>stacksize <span class="token operator">+</span> Stack_Incerment<span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elemtype<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    S<span class="token punctuation">.</span>top <span class="token operator">=</span> S<span class="token punctuation">.</span>base <span class="token operator">+</span> S<span class="token punctuation">.</span>stacksize<span class="token punctuation">;</span> <span class="token comment">//先将栈顶定出来</span>    S<span class="token punctuation">.</span>stacksize <span class="token operator">+=</span> Stack_Increment<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这种定义方法，判断栈满和栈空的语句分别为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">S<span class="token punctuation">.</span>top <span class="token operator">-</span> S<span class="token punctuation">.</span>base <span class="token operator">></span> S<span class="token punctuation">.</span>stacksize<span class="token punctuation">;</span> <span class="token comment">//栈满</span>S<span class="token punctuation">.</span>top <span class="token operator">==</span> S<span class="token punctuation">.</span>base <span class="token comment">//栈空</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="多个栈共享空间"><a href="#多个栈共享空间" class="headerlink" title="多个栈共享空间"></a>多个栈共享空间</h4><p>在实际运用栈时，我们通常为了节省空间，防止空间浪费，会让多个栈同时使用一片存储空间，这通常表现为分配一个足够大的数组给多个栈，而后利用栈的动态存储特性，来对其进行存储空间的扩充。</p><p>以下，对两个栈的空间共享方法进行简要说明：</p><p>总体思路在于将两个栈的栈底至于 <strong>数组的两端</strong> ，而后在两个栈需要扩充空间时，将其栈顶向数组中间移动。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype stack<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top1<span class="token punctuation">,</span> top2<span class="token punctuation">;</span> <span class="token comment">//分别用于指向两个栈的栈顶位置</span><span class="token punctuation">&#125;</span> dustack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果用指针来表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token operator">*</span>m<span class="token punctuation">;</span> <span class="token comment">//整片区域的头指针</span>    Elemtype <span class="token operator">*</span>top1<span class="token punctuation">,</span> <span class="token operator">*</span>top2<span class="token punctuation">;</span>     <span class="token keyword">int</span> stacksize<span class="token punctuation">;</span>  <span class="token comment">//整片区域的大小</span><span class="token punctuation">&#125;</span> dustack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种结构的栈，要判断是否上溢，则需要用到以下语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>top1 <span class="token operator">==</span> top2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//上溢</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里给出入栈的写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>top1 <span class="token operator">==</span> top2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"上溢"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        top1<span class="token operator">++</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>top1<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        top2<span class="token operator">--</span><span class="token punctuation">;</span>        c<span class="token punctuation">[</span>top2<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="链式栈存储结构"><a href="#链式栈存储结构" class="headerlink" title="链式栈存储结构"></a>链式栈存储结构</h4><p>在栈的大小并不能确定时，采用链式存储结构能够更加轻松的扩栈，缩栈。</p><p>具体在C语言中，即链表的存储方式，但有所不同的是，此处链表的 <strong>头结点</strong> 指向的是栈的 <strong>栈顶</strong> ，因此每次对栈进行操作，相当于是对头结点的位置进行相关的改变。</p><p>链栈的定义方式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">snode</span><span class="token punctuation">&#123;</span>    Elemtype data<span class="token punctuation">;</span>    snode<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> linkstack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>链栈的进栈操作在这里给出：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>linkstack top<span class="token punctuation">,</span> Elemtype x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    snode<span class="token operator">*</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>snode<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>snode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span> <span class="token comment">//内存满，栈上溢</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        t<span class="token operator">-></span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>        t<span class="token operator">-></span>next <span class="token operator">=</span> top<span class="token punctuation">;</span> <span class="token comment">//t的指针域指向原先的头节点</span>        top <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment">//将头结点改成t的位置</span>        <span class="token keyword">return</span> OK<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，只要内存不爆满，链栈是不会有上溢这种错误出现的，这也是为什么链栈更加灵活的原因。</p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><blockquote><p>讲了一堆，现在该看看栈这种后进先出的玩意到底有什么用了</p></blockquote><h4 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h4><p>算法原理：</p><p><strong>N &#x3D; (N div d)×d + N mod d</strong></p><p>其中，d是进制数</p><p>举例：<br>（1348）<sub>10</sub> &#x3D; (2504) <sub>8</sub><br>具体计算为：  </p><ul><li>1348&#x2F;8 &#x3D; 168; 1348%8 &#x3D; 4;</li><li>168&#x2F;8 &#x3D; 21; 168%8 &#x3D; 0;</li><li>21&#x2F;8 &#x3D; 2； 21%8 &#x3D; 5；</li><li>2&#x2F;8 &#x3D; 0；2%8 &#x3D; 2；</li></ul><p>将每次取余计算的结果逆序链接，则能得到2504的结果</p><p>抽象为实现代码即：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">conversion</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">InitStack</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//初始化一个栈</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//N不得0时，持续循环</span>        <span class="token function">Push</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> N<span class="token operator">%</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        N <span class="token operator">=</span> N<span class="token operator">/</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">StackEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//栈不空，则循环</span>        <span class="token function">Pop</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取出栈顶元素，存在e中</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，如果涉及到16进制的转换操作，需要对相应的字母与数字之间的关系进行建立，然后再进行算法的进一步优化，这里不再详述</p><h4 id="括号检验"><a href="#括号检验" class="headerlink" title="括号检验"></a>括号检验</h4><p>在表达式中，括号的对应是十分重要的一环，往往这种工作编译器会帮我们做完，如果需要我们自己进行编写，则需要借助栈这种结构。</p><p>如下的括号，都是符合书写格式的：<br>（ [ ] [ ] ）, ( ( [ ] ) )</p><p>但当出现如：<br>( [ ) ]<br>这一类的括号时，如何判断其是否符合要求，就是我们的任务。</p><p>总结一下，我们在检验括号时，出现的不匹配的现象，往往有三种可能：</p><ul><li>到来的右括号并不是 <strong>被期待的</strong></li><li>到来的是 <strong>不速之客</strong></li><li>直到最后，被 <strong>期待</strong> 的括弧也没到来。</li></ul><p>由此，我们可以设计出这样的算法：</p><p>从表达式左侧开始逐字符扫描，如果遇到左括弧，则入栈。<br>当遇到右括弧时：</p><ul><li>如果栈空：则右括弧必定多余，报错</li><li>如果栈非空，则将右括弧与栈顶元素比较：<br>  · 如果栈顶元素能与右括弧匹配，则栈顶元素出栈<br>  · 如果栈顶元素不匹配，则正常入栈</li></ul><p>当表达式扫描完成时，如果此时栈空，则表达式无误，若非空，则报错。</p><h4 id="行编辑程序问题"><a href="#行编辑程序问题" class="headerlink" title="行编辑程序问题"></a>行编辑程序问题</h4><p>如果让我们设计一个输入编辑器，我们应当如何设计？</p><p>一个最简单的设计思路是，用户输入一个字符，则存入一个字符。但这样显然是不合理的，如果用户输入错误，我们也应当给用户相应的挽回余地，对吧。</p><p>因此，至少需要有退格（backspace）的机制。<br>这里举一个例子，如果以“#”作为退格符号，用户输入的内容如下：</p><pre class="line-numbers language-none"><code class="language-none">whli##ilr#e（s#*s)    putchar(*s&#x3D;#++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>则有效的输入内容为：</p><pre class="line-numbers language-none"><code class="language-none">while (*s)    putchar(*s++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因此，这种方式十分符合栈的存储方式，思路为：<br>我们接收到一个字符，如果字符不是退格符，则压入栈顶；<br>如果字符是退格符，则令一个栈顶元素出栈。</p><blockquote><p>上述例子只是一个最简单的行编辑程序，更多的符号如回车（enter），上档（shift）等可以自行思考。</p></blockquote><h4 id="表达式求值问题"><a href="#表达式求值问题" class="headerlink" title="表达式求值问题"></a>表达式求值问题</h4><p>我们向程序中输入一个表达式，我们希望能够输出它的结果，这是如何被计算出来的？</p><p>要理解这个问题，我们首先应当介绍一下 <strong>算符优先法</strong> 。</p><p>我们先将一个表达式分成三部分：</p><ul><li>界限符：即左括号，右括号，表达式终止符等</li><li>运算符：即算术运算符，逻辑运算符，关系运算符等</li><li>操作数：常数，变量等</li></ul><p>本文中仅仅以简单算术表达式的例子做抛砖引玉作用。<del>（其实是博主水平不够）</del></p><p>要实现这个算法，我们需要设计两个栈，即：</p><ul><li>运算符栈：OPTR栈</li><li>操作数栈：OPND栈</li></ul><p>算法基本思想如下：</p><ul><li>我们首先将操作数栈为空栈，将起始符#入栈</li><li>依次读入字符，如果是操作数，则存入OPND栈，如果是运算符，我们就将当前读入的操作符与栈顶的操作符做优先级比较，并根据比较结果决定要不要进行相关的运算。直到我们的运算符栈里面只有两个#为止。</li></ul><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Chap.3/%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级"></p><blockquote><p>这里可以看出，相同的运算符，优先级默认是前者大于后者的，这点是为了使得“&#x3D;”这个优先级仅在括号的判断中出现，防止歧义。</p></blockquote><p>操作符之间的优先级很重要：</p><ul><li>如果读入的操作符优先级大于栈顶的操作符优先级：则该操作符入栈。</li><li>如果读入的操作符优先级等于栈顶的操作符优先级：则该操作符必定是括号。</li><li>如果读入的操作符优先级小于栈顶的操作符优先级：则直接取操作数栈的栈顶两个元素进行运算。</li></ul><p>这里给出一个运算式例子：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Chap.3/%E8%BF%90%E7%AE%97%E4%BE%8B%E5%AD%90.png" alt="例：3*(7-2)"></p><blockquote><p>更多的应用有迷宫求解，递归的实现，地图染色等等，这里不再详述。</p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>只允许在表的一端进行插入，在另一段进行删除的线性表<br>先进先出</p><h3 id="队列的基本操作："><a href="#队列的基本操作：" class="headerlink" title="队列的基本操作："></a>队列的基本操作：</h3><ul><li>EnQueue(&amp;Q, e) 入队</li><li>DeQueue(&amp;Q, &amp;e) 出队</li><li>InitQueue(&amp;Q) 初始化</li><li>QueueEmpty(Q) 判空</li><li>DestoryQueue(&amp;Q) 销毁</li><li>QueueLength(Q) 求长</li><li>ClearQueue(&amp;Q) 置空</li><li>GetHead(Q, &amp;e) 求头</li><li>QueueTraverse(Q, visit()) 遍历</li></ul><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>采用数组进行存储：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    Elemtype <span class="token function">queue</span><span class="token punctuation">(</span>maxsize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span> <span class="token comment">//front表示队头，rear表示队尾</span><span class="token punctuation">&#125;</span>queue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>入队，改变队尾指针<br>出队，改变队头指针</p><p>队空：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">==</span> rear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>队满：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rear <span class="token operator">==</span> maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="顺序存储-改进"><a href="#顺序存储-改进" class="headerlink" title="顺序存储-改进"></a>顺序存储-改进</h3><p>显然，总有一个时刻，front指针与rear指针均指向数组的maxsize处的元素，但整个数组并没有被填满，反而前面空余了很多空间。这种情况被称为 <strong>假溢出</strong> 。</p><p>假溢出一般有两种解决方式：</p><ul><li>出队后，令整个队列左移。（涉及大量元素的移动）</li><li>将Queue[0]接到Queue[maxsize-1]的后方，形成队列环（参考上一章中循环链表的思想）</li></ul><p>入队时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rear <span class="token operator">=</span> <span class="token punctuation">(</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出队时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">=</span> <span class="token punctuation">(</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>maxsize<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这种方法中，还有个问题，即队满和队空的判断语句均为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">front <span class="token operator">==</span> rear<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于这个问题，有两种解决方法：</p><ul><li><p>可以采用 <strong>设置标志位</strong> 的方法进行改进：<br>队空的情况只能由出队操作引起<br>队满的操作只能由入队操作引起<br>因此，加一个标志位 <strong>flag</strong> ，将其初始化为“delete”， 进行入队时，更改其为“enter”。由此判断队空还是队满。</p></li><li><p>可以少用一个存储空间<br>这时，队空则仍然由front &#x3D;&#x3D; rear来判断，队满则可使用front &#x3D;&#x3D; rear-1的方式来进行判断。</p></li></ul><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p>顾名思义，使用链表对队列进行存储</p><p>当然，对于队列的链表而言，我们需要有队头与队尾两个指针来对整个队列进行维护</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    node<span class="token operator">*</span> front<span class="token punctuation">,</span> rear<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>链队列初始化时，只需要分配出头结点即可，此后利用rear &#x3D; front来进行初始化<br>销毁时，从队头开始遍历，分次释放所有的结点  </p><p>入队：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">node<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>Q<span class="token punctuation">.</span>rear <span class="token operator">=</span> p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>本篇仅对栈和队列的基础定义与一些简单应用做出了阐述，后续有时间会补充更多的细节。</p><p>本篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.2</title>
      <link href="/posts/36543.html"/>
      <url>/posts/36543.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-程序设计基础"><a href="#Java-程序设计基础" class="headerlink" title="Java 程序设计基础"></a>Java 程序设计基础</h1><blockquote><p>本章将正式步入Java的内容，但说在前面，由于此前有C语言的基础章节，而Java的语法又跟C语言极其相似，因此在谈到某些具体语句时，博主将不再讲述的过于详细，请读者自行查找C语言章节中的内容。</p></blockquote><h2 id="有关引入包"><a href="#有关引入包" class="headerlink" title="有关引入包"></a>有关引入包</h2><p>上述语句中 <strong>import</strong> 语句相当于Java中的引入语句，它的作用是引入一个 <strong>包(Package)</strong> ，用于在本文件中使用。类比C语言，这类似于C中的引入头文件操作。</p><p>至于具体的包，我们将在后续的文章中具体提及。</p><h2 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h2><p>Java中有三种注释：</p><ul><li><p>单行注释：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F; 这是一条单行注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>多行注释</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;*这是一个多行注释*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>文件注释</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;**&#x2F;*这是一个文件注释&#x2F;*用于在文件头部对文件的具体功能进行说明*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="关于数据类型"><a href="#关于数据类型" class="headerlink" title="关于数据类型"></a>关于数据类型</h2><h3 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h3><p>类似于C语言，Java中也有多种数据类型：</p><ul><li>整数：<br>byte, short, int, long</li><li>浮点数：<br>float, double</li><li>字符型：<br>char</li><li>布尔型：<br>boolean</li></ul><p>在C中，对short，int， long的定义并不明确，只有笼统的：long&gt;int&gt;short （这里指的是内存占用大小），这就导致不同的编译器，不同的系统上可能会导致很严重的兼容性问题。<br>Java看到了这一点，为了兼容性，其对每个数据类型的大小进行了准确的定义。</p><ul><li>byte: 1</li><li>short: 2</li><li>int: 4</li><li>long: 8</li><li>float: 4</li><li>double: 8</li><li>char: 2</li><li>boolean: 4</li></ul><p>在这里，还需要进行三点说明：</p><ul><li>Java中不允许直接进行低精度类型赋予高精度类型的操作。这就代表着<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> x1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>是不被允许的。</li></ul><p>如果要强行赋值，请利用强制类型转化：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>x1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Java中，byte类，short类在运行后所得到的类型， <em><strong>均为int型</strong></em> ，因此请注意这种类型的编译错误：<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> x1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">byte</span> x3 <span class="token operator">=</span> x1 <span class="token operator">+</span> x2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>虽然x1, x2均为byte型，但其两者相加时，自动转为了int型，这时候将其值赋给x3，会发生溢出报错。</p><ul><li>在Java中定义float类型时，需要在值后方加一个f。</li></ul><h3 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h3><p>Java中定义常量时，需要在定义语句前加 <strong>final</strong> 语句。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">double</span> <span class="token constant">PI</span> <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="关于-var-关键字"><a href="#关于-var-关键字" class="headerlink" title="关于 var 关键字"></a>关于 var 关键字</h3><p><strong>var</strong> 关键字是一种用于偷懒的方法，当类型名过长时，可以在定义语句中使用var关键字来代替前方的类型名。</p><h3 id="关于数据类型的运算"><a href="#关于数据类型的运算" class="headerlink" title="关于数据类型的运算"></a>关于数据类型的运算</h3><h4 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h4><p>Java中的运算规则，与C大体上相同，在此前没有提过的有一种叫做 <strong>位移运算</strong> 的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 0111</span>n<span class="token operator">&lt;&lt;</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 1110</span>n<span class="token operator">>></span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 0000 ...... 0011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述语句被称作位移运算，可以看出，这种运算方式是以整数的二进制表示方法为基础的。<br><strong>左移加倍，右移减半</strong></p><p>需要注意的是，右移操作并不会移动符号位，如果想要把符号位一并移动，请使用 <strong>&gt;&gt;&gt;</strong> 关键字</p><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>与位移运算相似的在数字二进制表达式上进行操作的还有一种，称为 <em><strong>位运算</strong></em> 。</p><p>其包括四种类型：</p><ul><li>位与运算符：&amp;<br>如果参与运算的两个数字的某一个二进制位同时取1，其结果该位上才为1，否则置0</li><li>位或运算符：｜<br>如果参与运算的两个数字的某一个二进制位同时取0，其结果上该位才取0，否则为1</li><li>位异或运算符：^<br>如果参与运算的两个数字的某一个二进制位不同，其结果上该位才取1，否则置0</li><li>位取反运算符：~<br>将一个数字的每一个二进制位上的数都取其相反数。</li></ul><h2 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h2><p><strong>字符串</strong> 是Java中的一种引用类，在Java中十分常用，因此在这里单独提一句：</p><p>字符串可以用 <strong>+</strong> 进行连接定义：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"World"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于多行字符串，可以使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> <span class="token string">""</span>" <span class="token class-name">Hello</span><span class="token punctuation">,</span><span class="token class-name">Java</span><span class="token class-name">Programming</span><span class="token class-name">World</span> <span class="token string">""</span>"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>来进行定义。</p><p>字符串还可以是一个空值，即：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要知道的是，字符串是不可以直接改变的，因为其是一种引用变量（关于引用，会在下文中提及），往往需要StringBuilder类进行修改。</p><h2 id="关于数组"><a href="#关于数组" class="headerlink" title="关于数组"></a>关于数组</h2><p><strong>数组</strong> 同样是Java中的一种引用对象，其定义方法如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intarray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，Java中的数组与C语言中的数组并不是一回事，其意义为定义一个引用变量，这个引用变量会指向一个长度为26的数组变量.</p><p>相当于， <strong>intarray</strong> 只是一个变量，而这个数组是一个对象，用 <strong>new</strong> 关键字来创建，它被存在另一个位置，而intarray 仅仅是指向了它。</p><p>相似的，如果我定义了一个字符串数组，则事情更加复杂一些。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str_array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里，str_array指向了一个长度为10的字符串数组，这个数组在另外一个位置，但由于字符串也是一种对象，在定义字符串时，也是通过引用的方式进行定义的，因此相当于这个长度为10的数组，里面是10个引用变量，这10个引用变量会各自指向一个字符串，它们也不一定存储在同一片区域。</p><p>这同样也代表着，一旦你创建了这个数组对象，你就不能更改这个对象的大小了。如果需要扩容，你只能重新创建一个更大的对象，然后把这个引用对象指向这个全新的对象。</p><p>这里，希望读者尽力理解，辅以网络上的其他资料对 <em><strong>引用</strong></em> 的机制进行了解。</p><p>了解后，我们可以在此引入另一个概念：</p><h2 id="关于多维数组"><a href="#关于多维数组" class="headerlink" title="关于多维数组"></a>关于多维数组</h2><p>在C中，我们定义二维数组必定是一个整齐的，如2＊5的，它每个次级数组的长度必须是一致的。</p><p>但由于Java中，数组是一种引用变量，我们其实可以定义不整齐的二维数组。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> two_dim_arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//代表定义了一个有四个子变量的数组</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>two_dim_arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//次级数组的长度可以不同，因为它们可以并不存储在同一片区域中，不需要考虑到对齐问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-2</title>
      <link href="/posts/56162.html"/>
      <url>/posts/56162.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构-Chap-2-线性表"><a href="#数据结构-Chap-2-线性表" class="headerlink" title="数据结构 Chap.2 线性表"></a>数据结构 Chap.2 线性表</h1><h2 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h2><p>线性表是一种最简单的数据结构，其表现为一系列有顺序的元素集合。<br>自然，线性表需要满足如下标准：</p><ul><li>有 <strong>第一元素</strong> 与 <strong>最后元素</strong></li><li>除了第一元素之外，每个元素都有它的 <strong>后继</strong> ，除了最后元素之外，每个元素都有它的 <strong>前驱</strong> 。</li><li>同一线性表内的元素必定具有相同的特性。</li></ul><h2 id="线性表的相关操作"><a href="#线性表的相关操作" class="headerlink" title="线性表的相关操作"></a>线性表的相关操作</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>首先，我们来了解一些线性表的基本操作。<br>它们包括：</p><ul><li>初始化: InitList</li><li>销毁: DestoryList</li><li>判断是否为空: ListEmpty</li><li>求长度: ListLength</li><li>求指定元素的前驱: PriorElem</li><li>求指定元素的后继: NextElem</li><li>提取指定元素: GetElem</li><li>定位: LocateElem</li><li>遍历: ListTraverse</li><li>置空: ClearList</li><li>改变指定元素的值: PutElem</li><li>插入元素: ListInsert</li><li>删除元素: ListDelete</li></ul><p>这里对定位操作进行些许说明：<br>该操作的意义为在线性表中找到第一个符合某个条件的元素，并返回其位置。<br>一般而言，若未找到，则返回-1。</p><p>需要明确的是，上述表述仅仅关系了这些操作是 <strong>做什么的</strong> ，并没有深究应当如何实现这种操作，具体应当如何实现，应当依靠读者使用的语言，采用的具体结构而定。</p><p>上述基础运算也可以构成更进一步的应用，如线性表的有序合并，拆分，排序等。</p><h3 id="应用事例"><a href="#应用事例" class="headerlink" title="应用事例"></a>应用事例</h3><h4 id="两个线性表-LA-与-LB-的合并"><a href="#两个线性表-LA-与-LB-的合并" class="headerlink" title="两个线性表 LA 与 LB 的合并"></a>两个线性表 LA 与 LB 的合并</h4><p>该操作可以分为三步：</p><ul><li>从LB中依次取出每个元素</li><li>观察LB中取出的元素在LA中是否存在</li><li>若不存在，则存入LA中</li></ul><p>若写成代码块：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token keyword">union</span><span class="token punctuation">(</span>List <span class="token operator">&amp;</span>LA<span class="token punctuation">,</span> List LB<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    LA_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LA<span class="token punctuation">)</span><span class="token punctuation">;</span>    LB_len <span class="token operator">=</span> <span class="token function">ListLength</span><span class="token punctuation">(</span>LB<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> LB_len <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">GetElem</span><span class="token punctuation">(</span>LB<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//取第i个元素赋予e</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">LocateElem</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> e<span class="token punctuation">,</span> equal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">ListInsert</span><span class="token punctuation">(</span>LA<span class="token punctuation">,</span> LA_len<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将e插入LA的最后</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处，给出了一个很基础的操作代码块，后续在无必要的情况下，将不会这样详细的给出具体步骤。</p><p>回归正题，这个算法需要在遍历LB内每个元素的同时也遍历LA中的每个元素来进行查重，因此我们可以计算出其时间复杂度：<br><em><strong>O(ListLength(LA) * ListLength(LB))</strong></em></p><h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><blockquote><p>前面讲的内容比较概括性，也相对抽象，以下将具体讲述线性表的表示方法。</p></blockquote><h3 id="什么是顺序表示"><a href="#什么是顺序表示" class="headerlink" title="什么是顺序表示"></a>什么是顺序表示</h3><p><em><strong>顺序表示</strong></em> 正如其名，线性表中的数据结构在内存中的表示也是有顺序的，具体表现为前一个元素紧挨着后一个元素。再简单一点，顺序表示可以通俗的理解为C中的 <strong>数组</strong> 。</p><h3 id="用C语言实现线性表的顺序存储"><a href="#用C语言实现线性表的顺序存储" class="headerlink" title="用C语言实现线性表的顺序存储"></a>用C语言实现线性表的顺序存储</h3><h4 id="线性表的初始化：InitList"><a href="#线性表的初始化：InitList" class="headerlink" title="线性表的初始化：InitList"></a>线性表的初始化：InitList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">L<span class="token punctuation">.</span>Elem <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> List_Elem_Size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的容量扩展：ExtendList"><a href="#线性表的容量扩展：ExtendList" class="headerlink" title="线性表的容量扩展：ExtendList"></a>线性表的容量扩展：ExtendList</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">NewBase <span class="token operator">=</span> <span class="token punctuation">(</span>ElemType<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ElemType<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>List_Elem_Size <span class="token operator">+</span> Expand_Size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该算法的时间复杂度为O(1)</p><h4 id="线性表的元素定位：LocateElem"><a href="#线性表的元素定位：LocateElem" class="headerlink" title="线性表的元素定位：LocateElem"></a>线性表的元素定位：LocateElem</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>L<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>statment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//定位到符合statment语句的元素</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="线性表的元素插入：ListInsert"><a href="#线性表的元素插入：ListInsert" class="headerlink" title="线性表的元素插入：ListInsert"></a>线性表的元素插入：ListInsert</h4><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>elem<span class="token punctuation">[</span>L<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p<span class="token operator">>=</span>q<span class="token punctuation">;</span> p<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将插入位置后方的元素分别向后移动一位</span><span class="token operator">*</span>p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//插入元素e</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>线性表的删除操作与插入操作类似，在此不再详述。</p><h3 id="顺序存储线性表的优劣"><a href="#顺序存储线性表的优劣" class="headerlink" title="顺序存储线性表的优劣"></a>顺序存储线性表的优劣</h3><p>顺序存储的优点主要表现在以下两方面：</p><ul><li>存储时不需要为了表述元素之间的关系而额外花费内存空间</li><li>可以实现元素的随机读取</li></ul><p>顺序存储的缺点主要表现在以下两方面：</p><ul><li>必须分配连续存储空间给线性表，在内存连续片段较小时，有初始化失败的可能性</li><li>在插入 &#x2F; 删除元素时，需要大量移动元素，造成不便</li></ul><h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><h3 id="什么是链式表示"><a href="#什么是链式表示" class="headerlink" title="什么是链式表示"></a>什么是链式表示</h3><p><em><strong>链式表示</strong></em> ， 每个数据元素单独存储，它们在内存中可以是连续的，也可以是分散的，它们之间的关系通过每个数据元素附带的一个指针域进行连接。说的更具体化一些，即用结构体将指针于数据元素包装在一起，它们链式存储中的一个数据元素。在C语言中常常通过链表表示。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>这里需要对 <strong>链表</strong> 这一概念进行引入。<br>链表即指代如同上述表达中提及的，一个数据域附带一个指针域形成的结构。其主要分为以下几类：</p><ul><li>单链表</li><li>双链表</li><li>循环链表（单 &#x2F; 双）</li><li>静态链表</li></ul><p>让我们先从最基础的单链表讲起</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>顾名思义，单链表的连接方式是单向的，即我们只能通过前一个元素的指针域找到它的后继，而无法通过后一个元素找到其前驱。<br>其通常在C语言中以这样的方式进行结点定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">&#123;</span>    ElemType Elem<span class="token punctuation">;</span>    Node<span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以得知，只要得知第一个结点，就可以通过每个结点指针域中的指针得知其下一个结点，从而实现链表的一系列操作，因此，我们一般称单链表的第一个结点为 <strong>头结点</strong> 。</p><p>注：有时为了方便，头结点的数据域中不进行存储。</p><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><h5 id="单链表的元素提取：List-GetElem"><a href="#单链表的元素提取：List-GetElem" class="headerlink" title="单链表的元素提取：List_GetElem"></a>单链表的元素提取：List_GetElem</h5><p>不同于顺序存储，链式存储在提取元素时必须通过头结点分部向后寻找指定位置的元素。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_GetElem</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType <span class="token operator">&amp;</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    e <span class="token operator">=</span> p<span class="token operator">-></span>Elem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h5 id="单链表的元素插入：List-Insert"><a href="#单链表的元素插入：List-Insert" class="headerlink" title="单链表的元素插入：List_Insert"></a>单链表的元素插入：List_Insert</h5><p>同样，链式存储的元素插入与顺序存储差异极大。<br>我们需要先找到插入位置的前一个元素，这之后只需要改变这个元素与被插入元素的指针域即可。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">List_Insert</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">,</span> ElemType e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> new_node <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//链表的每次插入都需要手动创建一个新结点</span>    p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>place<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_node<span class="token operator">-></span>ElemType <span class="token operator">=</span> e<span class="token punctuation">;</span>    new_node<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>    p<span class="token operator">-></span>next <span class="token operator">=</span> new_node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><p>单链表的元素删除相比元素插入仅仅多了一个free（释放内存）的操作，即将删除的结点释放掉，这里不再详述。</p><h5 id="单链表的置空操作：ClearList"><a href="#单链表的置空操作：ClearList" class="headerlink" title="单链表的置空操作：ClearList"></a>单链表的置空操作：ClearList</h5><p>与删除操作类似。</p><p>核心：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ClearList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> L<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>L<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        Node<span class="token operator">*</span> p <span class="token operator">=</span> L<span class="token operator">-></span>next<span class="token punctuation">;</span>        L<span class="token operator">-></span>next <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    L<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该算法的时间复杂度为O(ListLength(L))</p><h4 id="单链表的改进"><a href="#单链表的改进" class="headerlink" title="单链表的改进"></a>单链表的改进</h4><p>从上述应用中我们可以看出，单链表的运用很依赖于链表本身的一些特殊结点与位置，那我们不妨改进一下单链表，单独为它设置一个结构体，用于存储这些特殊的位置和个数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">sruct List<span class="token punctuation">&#123;</span>    Node<span class="token operator">*</span> Head<span class="token punctuation">,</span> Tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过这种定义，我们可以清晰的明确一个链表的头、尾结点，以及其元素总个数。</p><h4 id="单链表：注意事项"><a href="#单链表：注意事项" class="headerlink" title="单链表：注意事项"></a>单链表：注意事项</h4><p>可以看到，在以上操作中，我们在函数内对单链表进行操作，往往不会直接使用其头结点，而是单独定义一个指针，再通过移动这个指针来操作链表内的元素。<br>这是因为，如果直接对头结点的Head指针进行移动，由于函数的参数是Head的地址，因此在函数中你对Head的每一次移动都是永久性的，函数结束后Head指针的地址并不会还原，你会丢失前面的元素。<br>因此，请务必注意这一点。</p><h3 id="其他形式的链表"><a href="#其他形式的链表" class="headerlink" title="其他形式的链表"></a>其他形式的链表</h3><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p><strong>双链表</strong> 是对单链表的改进，其相比于单链表，一个数据元素占用的内存更大，这是因为它不仅仅能通过一个元素找到它的后继，同时也能找到它的前驱。</p><p>我们常常这样定义一个双链表的结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">DuNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token comment">//数据域</span>    DuNode<span class="token operator">*</span> prior<span class="token punctuation">;</span>    DuNode<span class="token operator">*</span> next<span class="token punctuation">;</span>    <span class="token comment">//指针域</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上，我们通过prior来指向元素的前驱，通过next来指向元素的后继。</p><p>由于指针域的增加，对一个双向链表进行操作时的指针域更改会更加复杂一些，但道理总归相似，请读者自行类比即可。<br>需要特殊说明的是，双向链表在进行插入、删除操作时，需要更改其前驱的next指针，也需要更改其后继的prior指针。</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表</strong> 是将链表最后一个元素指向了这个链表的头结点，从而实现了让这个链表首尾相接的效果。<br>此时，判断元素是否是最后一个元素的依据也不是其后继是不是 NULL ，而变成了是不是头结点。</p><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p><strong>静态链表</strong> 是在某些没有指针这个设定的高级语言中应用的，它通常这样定义一个结点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">StaticNode</span><span class="token punctuation">&#123;</span>    ElemType elem<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述链表是通过数组来实现的，数组中的一个元素就是一个结点，同时其通过游标cur来表示其结点在链表中的位次。<br>这种链表通过游标来指示其下一个元素的位置，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这就是链表的第1个元素所在的下标位置</span>S<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token comment">//这是链表第2个元素所在的下标位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>虽然这种链表仍然需要一个相对较大的存储空间，但其在插入 &#x2F; 删除元素时，仍然只需要改变指针，而不用移动元素，因此其仍然具备链式存储结构的主要优点。</p><p>这种链表的顺链查找通常会这样写：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">i <span class="token operator">=</span> S<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span> <span class="token comment">//S[0]相当于头结点</span><span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&amp;&amp;</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">!=</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    i <span class="token operator">=</span> S<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链式存储的优劣"><a href="#链式存储的优劣" class="headerlink" title="链式存储的优劣"></a>链式存储的优劣</h3><p>链式存储的优势体现在：</p><ul><li>插入 &#x2F; 删除时，无需大量移动元素</li><li>不需要一大块连续的存储空间</li><li>扩充表的规模很容易</li></ul><p>链式存储的主要劣势：</p><ul><li>无法随机访问表内元素，访问时间长短与元素在表内的位置相关。</li></ul><p>至此，关于线性表的大致内容梳理完成。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-Chap.1</title>
      <link href="/posts/36863.html"/>
      <url>/posts/36863.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-入门"><a href="#Java-入门" class="headerlink" title="Java 入门"></a>Java 入门</h1><blockquote><p>本文旨在让读者大致了解Java，并对其中的一些基本内容进行说明</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>在学习Java之前，我们首先应当了解Java的一些细节</p></blockquote><h3 id="Java是什么？"><a href="#Java是什么？" class="headerlink" title="Java是什么？"></a>Java是什么？</h3><p>Java是由SUN公司开发的一种编程语言，如今已被Oracle收购。</p><p>但时至今日，Java已经不仅仅是一门编程语言，Java包含着许多方面：</p><ul><li>一类编程语言</li><li>一种开发环境</li><li>一种应用运行环境</li></ul><p>得益于Java本身强大的兼容性，其不仅仅在服务器端的应用中占据着一席之地，同样在PC，移动端应用开发上有广大的应用场景。</p><h3 id="Java迄今的地位"><a href="#Java迄今的地位" class="headerlink" title="Java迄今的地位"></a>Java迄今的地位</h3><p>迄今为止，Java在编程语言使用率上仍然占据着第四名的位置。这得益于其兼容性；易于理解的编译语言；内置的内存处理机制等等。</p><h3 id="Java的不同版本"><a href="#Java的不同版本" class="headerlink" title="Java的不同版本"></a>Java的不同版本</h3><p>SUN公司曾经为Java设定了三个版本，这种分类标准被沿用至今：</p><ul><li>Java SE (Standard Edition)</li><li>Java EE (Enterprise Edition)</li><li>Java ME (Micro Edition)</li></ul><p>三者之间的关系为：EE &gt; SE &gt; ME</p><h3 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h3><p><em><strong>JDK</strong></em> 是Java Development Kit 的简称。<br><em><strong>JRE</strong></em> 是Java Runtime Environment 的简称。<br><em><strong>JVM</strong></em> 是Java Virtual Machine 的简称。</p><p>Java在每台计算机上会内置一个虚拟机，即JVM。代码会先编译为Java字节码，而后放在JVM上运行，以此很好的保证了Java在各个平台上的兼容性。</p><p>JRE是Java运行的环境，而JDK比JRE更大一层，其中除了JRE外还内置了编译器、调试器等工具。</p><h2 id="编译入门"><a href="#编译入门" class="headerlink" title="编译入门"></a>编译入门</h2><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>与C不同，Java的配置过程稍显复杂，也需要更多的时间与步骤。</p><p>整体而言，分为 下载JDK -&gt; 配置环境变量 -&gt; 运行IDE 三个步骤。</p><p>本笔记的运行全程以JDK-20为环境，在VScode上进行java的编写。<br>博主在这个方面不做详细阐述，请自行上网搜索</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-Chap-1</title>
      <link href="/posts/55842.html"/>
      <url>/posts/55842.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在此前C语言的章节中，曾提到过一个十分有名的等式：算法 + 数据结构 &#x3D; 程序。本部分的博文会从C语言的角度来对数据结构进行相应的阐述，有利于理清思路，也可以以相似的想法套用至其它编译语言中。</p></blockquote><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="1-数据结构的概念"><a href="#1-数据结构的概念" class="headerlink" title="1. 数据结构的概念"></a>1. 数据结构的概念</h2><blockquote><p>何为数据结构？</p></blockquote><p>在编程的过程中，我们通常遇到的问题能够被分为两类：</p><ol><li>数值计算问题</li><li>非数值计算问题</li></ol><p>数值计算问题往往是能够通过明确的数学公式进行解决的，编译的过程需要思考的问题相对较少。而非数值计算问题则涉及的方面更多，也更考验编译者的抽象思维，这一过程中就涉及到选取正确的数据存储方式，以此使我们在计算机上能够更加便利地对数据进行操作，数据结构的概念由此产生。</p><p>我们定义数据结构时，往往通过三方面进行考虑。</p><ul><li>数据的逻辑结构：即信息的组织方式</li><li>数据的存储结构：即信息在计算机上的存储方式</li><li>数据的运算：即在计算机上应当如何处理这些数据</li></ul><p>以下举出两例，进行相关的说明：</p><ol><li><p>表：</p><p> 表的逻辑结构往往是线性的，这意味着其中的数据组与组之间关系并不十分强烈，因此可以采用在计算机中采用顺序（数组）或链式（链表）存储方式。运算也往往包含插、删、改、查四种方式。</p></li><li><p>图：</p><p> 图的逻辑结构体现在结点与结点之间，其组与组之间的关系更加复杂，因为任意两组数据之间均有可能产生联系。因此在存储时，既要考虑结点本身信息的存储，也要考虑结点之间的关系如何构建。运算相应添加了关键路径、最短路径的问题等。</p></li></ol><p>通过上述示例，我们能看出 <strong>数据结构往往解决的是非数值计算问题，它意在数据组织的基础上解决复杂程序的设计问题</strong>。</p><h2 id="2-数据的结构"><a href="#2-数据的结构" class="headerlink" title="2. 数据的结构"></a>2. 数据的结构</h2><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是能够被输入到计算机中进行存储、操作的符号的总称。其衍生出的名词还有：</p><ul><li>数据元素：即数据中的一个个体</li><li>数据项：数据中的一个个体可能有多项数据，这其中每一项数据都能被称作数据项</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>数据元素之间存在某种关系，这种关系被称为逻辑结构。</p><p>常见的逻辑结构有：</p><ul><li>集合</li><li>线性结构</li><li>树形结构</li><li>图 &#x2F; 网状结构</li></ul><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>将数据结构在计算机中存储，表示的方式称为存储结构。它也可以理解为逻辑结构在计算机中的映像。（如二进制、顺序存储映像、链式存储映像等）</p><p>由于某些数据的逻辑结构极其相似，因此统一用一类存储结构对它们进行存储，这种特定的存储结构叫做 <strong>数据类型</strong> （如数组，链表等具体类型）</p><p>同时，对相应数据类型的操作有时也极其相似，因此对相应一类操作起个名，叫 <strong>抽象数据类型（Abstract Data Type）</strong> （不同的教材中叫法不同）<br>这与很多编译语言中的 <strong>类</strong> 的概念十分类似。</p><h3 id="Abstract-Data-Type（ADT）"><a href="#Abstract-Data-Type（ADT）" class="headerlink" title="Abstract Data Type（ADT）"></a>Abstract Data Type（ADT）</h3><h4 id="重要特征"><a href="#重要特征" class="headerlink" title="重要特征"></a>重要特征</h4><p>由于ADT本身的性质，其具有两个重要的特征：</p><ul><li>数据抽象：ADT强调数据本身的性质，而其中的操作是一致的，因此对于其本身与外部用户的接口具有严格的要求。</li><li>数据封装：其内部的实现细节往往对外部用户隐藏。</li></ul><h4 id="ADT的定义"><a href="#ADT的定义" class="headerlink" title="ADT的定义"></a>ADT的定义</h4><pre class="line-numbers language-none"><code class="language-none">ADT抽象数据类型名&#123;    数据对象：    数据关系：    &#x2F;&#x2F;以上两种定义利用伪码描述    基本操作：        基本操作名（参数表）        初始条件：        操作结果：&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基本操作的参数表中含有两种参数：</p><ol><li>赋值参数：为操作提供输入值</li><li>引用参数（以&amp;开头）：可返回操作结果</li></ol><p>初始条件表明了该种操作需要满足的条件，可以为空。<br>操作结果表明了数据结构的变化状况，以及此操作后应当返回怎样的结果。</p><h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><p>算法，是对特定问题解决步骤的描述，根据时间、空间占用量的不同有优劣之分。</p><h3 id="算法的特点"><a href="#算法的特点" class="headerlink" title="算法的特点"></a>算法的特点</h3><p>首先，算法必须具有以下五条基本性质：</p><ul><li>有穷性</li><li>确定性（指令明确）</li><li>可行性（每条指令都可被执行）</li><li>有输入（0或多个）</li><li>有输出（0或多个）</li></ul><p>其次，要写出一个 <strong>好的算法</strong> ，则还应当有如下特点进行辅助：</p><ul><li>正确性</li><li>可读性</li><li>健壮性（程序不会轻易崩溃）</li><li>高效率 &amp; 低存储量</li></ul><blockquote><p>正确性、可读性、健壮性自然不必多言，下面从高效率与低存储量方面进行说明。</p></blockquote><h3 id="算法执行时间"><a href="#算法执行时间" class="headerlink" title="算法执行时间"></a>算法执行时间</h3><p>首先，明确一下与执行时间密切相关的因素：</p><ul><li>算法策略</li><li>问题规模</li><li>使用语言</li><li>机器代码质量</li><li>机器性能</li></ul><p>在我们的控制范围内的，主要是算法策略与使用语言。其中又以算法策略为重点优化对象。</p><p>这里我们继续细分， <em><strong>算法 &#x3D; 控制结构 + 原操作</strong></em><br>其中控制结构主要指程序的顺序、分支与循环，而原操作则指固有数据类型的操作。</p><p>形成习惯的是，算法中原操作的重复次数往往与算法的执行时间成正比，因此以 <strong>原操作在算法中重复执行的次数</strong> 作为算法执行时间的衡量准则，称为 <strong>时间复杂度</strong> ，以 <em><strong>O(n)</strong></em> 表示。<br>下面举几例常见的时间复杂度：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token comment">//O(1) 常量阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">++</span>x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n) 线性阶</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token operator">++</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//O(n^2)  平方阶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里提出两个经典的问题供读者思考，有兴趣也可以自行搜索相应解答：</p><ul><li>折半查找的算法时间复杂度</li><li>汉诺塔问题递归解法的时间复杂度</li></ul><p>请务必注意，上文中的 <strong>原操作</strong> 指的是 <strong>ADT中的一次基本操作</strong> ，如对于折半查找来说，即进行一次折半操作，对于汉诺塔问题来说，则是挪一次盘子的操作。<br><strong>请务必不要将原操作理解为一条语句！</strong></p><h3 id="算法占用空间"><a href="#算法占用空间" class="headerlink" title="算法占用空间"></a>算法占用空间</h3><p>相对应的，算法本身的操作也需要相应的存储空间，这也就产生了 <strong>空间复杂度</strong> 的概念，不过博主至今并未了解相应的计算机制，烦请读者自行搜索。</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好久不见</title>
      <link href="/posts/62537.html"/>
      <url>/posts/62537.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于此前的断更"><a href="#关于此前的断更" class="headerlink" title="关于此前的断更"></a>关于此前的断更</h2><p>距离上一次更新已经有半年之久，这期间主要是由于博主的学习与生活琐事所致，今后会尽力维持更新</p><h2 id="关于此后的内容"><a href="#关于此后的内容" class="headerlink" title="关于此后的内容"></a>关于此后的内容</h2><p>会有偏向性的转向C++与Java方面，另外，（如果博主能够学会相应的表述）可能会有一些数学方面的简记</p><p>好了，下篇博文见~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.8</title>
      <link href="/posts/34435.html"/>
      <url>/posts/34435.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><blockquote><p>在一个C语言程序中，除了自行编写程序之外，我们还想到应该如何对计算机内依然存在的文件进行操作，这就引出了本文的主题。</p></blockquote><h3 id="内存与外存"><a href="#内存与外存" class="headerlink" title="内存与外存"></a>内存与外存</h3><p>要描述文件，首先需要从内存，外存两个概念说起。</p><p>内存的概念，此前曾多次提及，是各类变量，算法储存的位置，并会在程序运行结束后及时释放。<br>内存中的数据会在关机后立刻消失。  </p><blockquote><p>如果对DIY有一定了解，则会常常听到“内存条”，就是这东西。</p></blockquote><p>外存则是永久存放各类文件，数据的地方，其中的数据在关机后不会消失。</p><blockquote><p>同样的，接触到的固态硬盘，机械硬盘，以及延伸至各类u盘，软盘，都属于外存的范畴。</p></blockquote><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><p><strong>文件</strong> 是数据的集合，也是操作系统储存数据的基本方法。</p><p>文件有以下基本属性：</p><ol><li>文件名</li><li>占用空间</li><li>存储位置</li><li>文件类型</li><li>读写属性</li><li>创建，访问，修改时间</li><li>….</li></ol><p>操作系统为了使各种各样的文件有序的存储，衍生出了 <strong>目录</strong> 这一概念（即文件夹）</p><p>要通过程序操作文件，就必须要求相应的高级语言具有相应的文件操纵能力。</p><p>我们要达到的目的就是通过C语言程序访问文件，即对文件进行相关的输入（input），输出（output）操作。<br>为了简化书写，对输入输出，下文中简称为（I&#x2F;O）</p><h3 id="C语言中的文件形式"><a href="#C语言中的文件形式" class="headerlink" title="C语言中的文件形式"></a>C语言中的文件形式</h3><p>C语言将文件看成一个二进制流或字符流：</p><ol><li>二进制流（常用于二进制文件）：<br>相当于把文件看成很多0&#x2F;1序列，这种方式更有利于计算机的信息读取，保存，写入，但不利于阅读。</li><li>字符流（常用于文本文件）：<br>将文件看成很多字符序列的组合，每行后有一个换行符。这种形式很适合I&#x2F;O操作。</li></ol><p>与此同时，C语言在其标准库中加入了相应函数，包括：</p><ul><li>打开文件</li><li>关闭文件</li><li>读写文件</li></ul><h2 id="2-文件的打开与关闭"><a href="#2-文件的打开与关闭" class="headerlink" title="2. 文件的打开与关闭"></a>2. 文件的打开与关闭</h2><h3 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h3><p>在C语言中打开文件常用 <strong>fopen</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span>fp  <span class="token comment">//定义文件类型指针</span>fp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"这里写你的文件名（别忘加后缀）"</span><span class="token punctuation">,</span> <span class="token string">"这里写打开方式"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>fp<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//这里处理无法打开的情况</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>几个注意事项：</p><ol><li>如果打开文件成功，则返回一个FILE类型的指针地址，并且此后的文件操作都通过这个指针进行。<br>如果打开失败，则返回空指针。<br>因此利用C语言打开文件后一定要检查是否打开成功。</li><li>c语言有很多种文件打开方式：<ul><li>“r”: 打开文本文件，只读</li><li>“w”: 新建文本文件（或者删除原本的内容），只写</li><li>“a”: 打开文本文件，追加</li><li>“r+”: 打开文本文件，可以读+写</li><li>“w+”: 新建文本文件（删除原来的内容），可以读+写</li><li>“a+”: 打开文本文件，可以读+追加</li></ul></li><li>如果用二进制模式打开文件则在打开方式后加b，即：”rb”,”ab+”等。</li></ol><h3 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h3><p>在C语言中关闭文件常用 <strong>fclose</strong> 函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几点注意事项：</p><ul><li>对于执行写入操作的文件，会将缓冲区内的内容写入文件中，然后关闭文件。</li><li>对于只读文件，会丢弃缓冲区内的内容，然后关闭文件</li><li>程序退出时，所有文件会自动关闭</li></ul><h3 id="三个标准文件指针"><a href="#三个标准文件指针" class="headerlink" title="三个标准文件指针"></a>三个标准文件指针</h3><p>C语言中，有三个自动生成的标准文件指针：</p><ul><li>stdin（标准输入流）</li><li>stdout（标准输出流）</li><li>stderr（标准错误流）</li></ul><p>stdin一般与键盘相连接，stdout一般与显示器相连接。</p><h2 id="3-文件的操作"><a href="#3-文件的操作" class="headerlink" title="3. 文件的操作"></a>3. 文件的操作</h2><blockquote><p>文件的读写涉及到多个函数，这其中还包括顺序读写与随机读写两种类型。</p></blockquote><h3 id="文件的顺序读写"><a href="#文件的顺序读写" class="headerlink" title="文件的顺序读写"></a>文件的顺序读写</h3><h4 id="字符读写函数：fgetc-fputc"><a href="#字符读写函数：fgetc-fputc" class="headerlink" title="字符读写函数：fgetc &amp; fputc"></a>字符读写函数：fgetc &amp; fputc</h4><p>首先对fgetc函数进行说明。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>pp<span class="token operator">=</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//通过只读模式打开一个文件</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从文件指针的位置读取一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgetc函数只能对以”r”（只读）, “r+”（只读写）的文件进行操作。</li><li>fgetc函数通过文件内部的位置指针进行读取。</li><li>每次读取一个字符，则文件指针fp向后移动一个位置。若读取失败（如读取到最后一个字符时），则返回EOF。<br>注：在应用时，可以利用这个特性进行循环读入：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span><span class="token function">fgetc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过这种方式实现对文件的整体输出。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>此后是fputc函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> c<span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token function">fputc</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在p所指向的位置写入一个字符</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>被fput操作的文件只能是通过”w”, “w+”, “a”所打开的文件。</li><li>每写入一个字符，则字符指针fp向后移动一个位置。若写入失败，返回EOF。</li></ul><h4 id="字符串读写函数：fgets-fputs"><a href="#字符串读写函数：fgets-fputs" class="headerlink" title="字符串读写函数：fgets &amp; fputs"></a>字符串读写函数：fgets &amp; fputs</h4><p>先对fgets进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//这里权且为了说明写了n，正常情况下这种写法不合规</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开的过程</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在fp的位置读取n-1个字符，并将其放入str中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>几点说明：</p><ul><li>fgets函数如果遇到了换行符或EOF，则自动结束读取。</li><li>fgets函数的返回值为字符数组的首地址。</li><li>若读取失败，则返回NULL。</li></ul><p>在对fputs进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>FILE <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">fputs</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在p的位置将str送入文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>该函数执行成功则返回0，否则则返回EOF。</p><h4 id="格式化读写函数：fscanf-fprintf"><a href="#格式化读写函数：fscanf-fprintf" class="headerlink" title="格式化读写函数：fscanf &amp; fprintf"></a>格式化读写函数：fscanf &amp; fprintf</h4><p>从名字就能看出来，这两个函数与scanf以及printf的功能及其类似，区别在于这两个函数的操作对象是文件，而scanf，printf的操作对象为键盘。（标准输入设备）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">//省略文件打开过程</span><span class="token function">fscanf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将文件中的数据读取并存储在变量中</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将变量中的数据写入到文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="数据块读写函数-fread-fwrite"><a href="#数据块读写函数-fread-fwrite" class="headerlink" title="数据块读写函数 fread &amp; fwrite"></a>数据块读写函数 fread &amp; fwrite</h4><p>fread与fwrite常用于二进制文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fread</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fp的位置开始每次读4个字节，读5次，并存入fa所在的地址中。（fa，fp均为指针）</span><span class="token function">fwrite</span><span class="token punctuation">(</span>fa<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从fa的位置每次取4个字节，取5次，并放入fp所指向的文件中。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="文件定位函数：rewind-fseek"><a href="#文件定位函数：rewind-fseek" class="headerlink" title="文件定位函数：rewind &amp; fseek"></a>文件定位函数：rewind &amp; fseek</h4><p>先对rewind进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rewind</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将fp放置到文件开头</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在对fseek进行说明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>fseek函数比较复杂：</p><ul><li>第一个参数fp为文件指针。</li><li>第二个参数为偏移量（一个long型变量）。</li><li>第三个参数为偏移起始点：<ul><li>SEEK_SET：代表文件开头（也可以用0代替）</li><li>SEEK_CUR：代表现在fp所在的位置（也可以用1代替）</li><li>SEEK_END：代表文件末尾（也可以用2代替）</li></ul></li></ul><h3 id="文件的检测"><a href="#文件的检测" class="headerlink" title="文件的检测"></a>文件的检测</h3><h4 id="错误检测：ferror"><a href="#错误检测：ferror" class="headerlink" title="错误检测：ferror"></a>错误检测：ferror</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ferror</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//检测被操作文件的当前状态，正常则返回0，错误则返回1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="清除出错：clearerr"><a href="#清除出错：clearerr" class="headerlink" title="清除出错：clearerr"></a>清除出错：clearerr</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">clearerr</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将所有文件错误标志与文件结束标志强制置0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上，是文件操作的所有函数。<br>确实很复杂，并且博主用的也确实很少 <del>（现在谁还用C语言编辑文档啊.jpg）</del><br>随用随取吧。</p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.7</title>
      <link href="/posts/33475.html"/>
      <url>/posts/33475.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态数据结构"><a href="#动态数据结构" class="headerlink" title="动态数据结构"></a>动态数据结构</h1><h2 id="1-动态存储管理"><a href="#1-动态存储管理" class="headerlink" title="1. 动态存储管理"></a>1. 动态存储管理</h2><h3 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h3><p>在此前的编程过程中，我们所声明的存储大小都是静态的，数组有大小，变量有类型。这固然已经能够满足很多需求，但相应的，有些数据大小未知的情形我们便无法很完美的解决。在此举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> student<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//这种先输入再创建的情况是不合规的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此前，我们的解决方法大多都是创建一个足够大的数组，从而能够达成目标，但这样做势必会浪费许多存储空间。</p><p>因此，引入我们的正题——动态存储分配。</p><h3 id="动态存储"><a href="#动态存储" class="headerlink" title="动态存储"></a>动态存储</h3><p>在C语言中，动态存储主要依赖于两个标准库以及四个函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//两个标准库：</span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>malloc<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token comment">//四个函数：</span>malloccallocreallocfree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来会一个个介绍</p><h4 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//分配一个大小为n个int的存储空间，并将其首地址赋给p，如果分配失败则返回空指针。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//如果p是空指针，则直接退出程序，返回值0。</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放程序中被分配的空间。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>malloc可以通过指针的形式来创建一个大小由用户自行输入的存储空间。</p><h4 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//务必注意calloc函数与malloc函数的写法区别。</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>calloc函数可以通过指针的方式来创建一个大小由用户自行输入的存储空间 <font color=Aqua> <strong>并将其中的元素自动赋值为0</strong> </font></p><h4 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> n<span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//通过以上的语句已经分配了一个空间</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//现在发现原先分配的空间不够，需要重新分配。</span>n<span class="token operator">=</span>n<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//将原先的n变为2倍。</span><span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>q<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//重新分配一个大小为n的存储区域，将首地址赋值给一个新的指针q；</span><span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    p<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>  <span class="token comment">//若分配失败，p仍然指向原来的存储区；若成功，p指向新存储区。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//释放原先p所指向的存储块。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="一点注意事项"><a href="#一点注意事项" class="headerlink" title="一点注意事项"></a>一点注意事项</h4><ol><li>请务必注意区分malloc, calloc, realloc的用法以及写法区别。</li><li>malloc, calloc, realloc三种函数通常情况下返回的都是通用指针，因此在给具体类型指针赋值时需要进行强制类型转换（具体原理见上一章：指针）</li></ol><h2 id="2-自定义类型"><a href="#2-自定义类型" class="headerlink" title="2. 自定义类型"></a>2. 自定义类型</h2><blockquote><p>此前提到过一种自定义类型——宏定义define，但宏定义只能做到简单的字符替换，从而在各种计算，定义中产生不可预知的后果，因此在这里给出更加通用的自定义类型。</p></blockquote><h3 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ULI<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>tppedef会用最后的一个词来代替前面的类型。<br>常用于简化程序书写。</p><p>但是typedef在程序书写时不仅仅是简单替换，这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IP</span> <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span> </span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token operator">*</span> P<span class="token punctuation">;</span><span class="token comment">//若之后想要定义两个指针</span>IP a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>  <span class="token comment">//等价于int *a, b; 会发现b不是指针</span>P m<span class="token punctuation">,</span> n<span class="token punctuation">;</span>  <span class="token comment">//这时候m, n都是指针</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-结构"><a href="#3-结构" class="headerlink" title="3. 结构"></a>3. 结构</h2><blockquote><p>C语言中虽然提供了很多变量类型，但是如果我们需要很多不同类型变量的结合体，则仅仅使用C语言提供的变量则显得效率低下。因此，产生了可以自定义的结构类型。</p></blockquote><h3 id="结构类型的定义"><a href="#结构类型的定义" class="headerlink" title="结构类型的定义"></a>结构类型的定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>  <span class="token comment">//这样就定义了一个名叫POINT的结构类型，之后可以直接使用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在程序中常用的结构可以通过上述方式来进行定义，从而简化此后需要使用相应模型时的书写过程。</p><p>需要注意的是，结构定义时其成员可以包含其他结构，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    POINT center<span class="token punctuation">;</span>    <span class="token keyword">double</span> radius<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>CIRCLE<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，结构存在单位大小，但结构的单位大小并不是简简单单的将各个元素的大小加到一起，因此在计算结构大小时建议使用sizeof运算符。（这种状况的出现原因为结构体内的对齐问题，具体请自行搜索）</p><h3 id="结构类型的访问"><a href="#结构类型的访问" class="headerlink" title="结构类型的访问"></a>结构类型的访问</h3><p>在C语言中，结构的访问有其规则。</p><p>如果结构类型相同，则可以直接通过整体相等来赋值<br>如果需要对一个结构里的成员进行编辑，则使用 .<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT A<span class="token punctuation">,</span> B<span class="token punctuation">;</span>A<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>A<span class="token punctuation">.</span>y<span class="token operator">=</span><span class="token number">3.2</span><span class="token punctuation">;</span>A<span class="token operator">=</span>B<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><p>相应的，结构既然是自定义的数据类型，同样也可以定义一个以自定义结构为元素的数组。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//相当于创建了一个由四个POINT组成的数组。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，与数组相似，结构数组也可以用指针表示：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">double</span> x<span class="token punctuation">;</span>    <span class="token keyword">double</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>POINT<span class="token punctuation">;</span>POINT PT<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>POINT <span class="token operator">*</span>P<span class="token punctuation">;</span>P<span class="token operator">=</span>PT<span class="token punctuation">;</span><span class="token comment">//这里P就与PT数组的首地址绑定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>引出了通过指针如何访问结构内的成员，比如我要用指针访问上述数组中第二个点中的X坐标值：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//这种表达过于繁琐，因此C语言提供了另一种方法</span><span class="token punctuation">(</span>P<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">-></span>x<span class="token operator">=</span><span class="token number">2.2</span><span class="token punctuation">;</span>  <span class="token comment">//与上面的表达等价</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-补充</title>
      <link href="/posts/4308.html"/>
      <url>/posts/4308.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文的目的在于对此前C语言的笔记进行相应的补充，同时整理一下博主遇到的一些有趣的函数。</p></blockquote><h2 id="1-知识点补充-编程疑难解决"><a href="#1-知识点补充-编程疑难解决" class="headerlink" title="1. 知识点补充 &amp; 编程疑难解决"></a>1. 知识点补充 &amp; 编程疑难解决</h2><h3 id="关于scanf"><a href="#关于scanf" class="headerlink" title="关于scanf"></a>关于scanf</h3><ol><li>在没有特殊说明的情况下，scanf遇到空格，回车等特殊字符会停止，因此在输入字符后需要回车时，不用在scanf后特地打出\n这样的转义字符。</li><li>用scanf时，字符与数字最好分开输入，不然很容易报错，具体原理貌似是%c与%d的输入规则不同。</li></ol><h3 id="关于程序运行时间成本的降低"><a href="#关于程序运行时间成本的降低" class="headerlink" title="关于程序运行时间成本的降低"></a>关于程序运行时间成本的降低</h3><p>运行程序时常常会出现运行时间过长，无法以一个理想的时间得出结果的情况。有以下几种解决办法：</p><ol><li>程序中是否出现了&lt;math.h&gt;中的pow函数，因为pow函数的运算方式为浮点运算，速度较慢，如果运算不需要用到浮点数，可以尝试自己写一个更简单的函数进行改进。</li><li>程序中是否有三层以上的循环，一般来说不会遇到这么复杂的循环，可以尝试改变算法。</li><li>程序中是否有各种递归算法，如果有，尝试改写成循环写法。</li></ol><h3 id="关于排序"><a href="#关于排序" class="headerlink" title="关于排序"></a>关于排序</h3><blockquote><p>在前面的章节中曾经讲过冒泡排序，这是C语言的一种最基础的排序算法，当我们遇到一些更加复杂 &#x2F; 数据更多的情况时，冒泡排序就显得过于简陋，效率也不够看了。</p></blockquote><h4 id="qsort函数（首选）"><a href="#qsort函数（首选）" class="headerlink" title="qsort函数（首选）"></a>qsort函数（首选）</h4><p>QSORT函数位于 &lt;stdlib.h&gt; 中，其原型如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">qsort</span><span class="token punctuation">(</span>  <span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> nmemb<span class="token punctuation">,</span>  <span class="token class-name">size_t</span> size<span class="token punctuation">,</span>  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先别急着头疼，这里会一个个解释。</p><ol><li><p>void* base:<br><strong>base</strong> 是一个指针，该指针指向数组的首地址。(通常直接传入数组名即可)</p></li><li><p>nuemb:<br><strong>nuemb</strong> 是个 <strong>无符号整数类型</strong>，用size_t表示，这个值表示数组内元素个数。(通常可以直接使用 <em>sizeof(数组名)&#x2F;sizeof(数组单个元素大小)</em> 来计算得出)</p></li><li><p>size:<br><strong>size</strong> 表示数组内每个元素的大小。</p></li><li><p>*compar:<br>这一部分是qsort的核心部分，指向的是一个比较两个元素的值的函数，直接决定了排序的顺序。这玩意是要自己写的。这里详细论述：</p><p>首先说明这一函数如何决定排序顺序：<br>当这一函数返回值小于0，则将 p1 指向的元素放在 p2 之前；<br>大于0，将 p1 指向的元素放在 p2 之后；<br>等于0，顺序 <strong>不确定</strong> 。</p><p>再说明这个函数的一些注意事项： </p><ol><li>注意传入数据格式：<br>传入的是两个通用指针，因此在函数内使用时请务必转换成相应类型指针再进行计算。</li><li>务必注意这个函数返回值为0时，排序顺序是随机的！</li></ol></li></ol><h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><h4 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h4><p>字符串的输入有几种方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fgets</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><del>一般而言，博主更常用gets_s。</del><br>tmd，经过紧接着几个月的拷打之后，还是fgets比较好使…</p><p>但需要注意，关于gets的三种输入函数都存在回车问题，即当这几个函数上面有scanf的时候，会出现函数读入回车导致跳过原本预期中字符串输入的过程，对此有两种解决方式：</p><ol><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于清空缓冲区内的数据。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在gets（gets_s，fgets）的前面加一个：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用于读入此前的回车进而防止其影响字符串输入。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>博主用第二种方法更多一些。</p><h4 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式不会补充回车</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//该方式会自动补充回车，效果同printf("%s\n", str);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="读入不定个数个字符串"><a href="#读入不定个数个字符串" class="headerlink" title="读入不定个数个字符串"></a>读入不定个数个字符串</h4><p>常用gets_s的返回值进行操作。<br>这里进行说明：</p><p>gets_s是有返回值的，具体返回值为输入字符串的地址（相当于返回一个指针）。如果输入不成功则返回一个空指针。</p><p>因此常用这个性质：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">gets_s</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token comment">//需要结束输入时则使用CTRL+Z进行结尾。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="字符串的各种转化"><a href="#字符串的各种转化" class="headerlink" title="字符串的各种转化"></a>字符串的各种转化</h4><blockquote><p>假设一串字符串中存着一个5位的整数，我们想用这个值进行计算，这时候如果再用循环进行转化，就太慢，也不优雅（笑</p></blockquote><p>好在，C语言其实是有相应的命令的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">atoi</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为int</span><span class="token function">atol</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为long</span><span class="token function">atof</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//字符串转化为double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这一系列函数通通位于 &lt;stdlib.h&gt; 中，传入的参数都是字符串的首地址（可以直接写字符串名）<br>这三个函数可以极大程度上提高我们的效率。</p><h3 id="关于指针"><a href="#关于指针" class="headerlink" title="关于指针"></a>关于指针</h3><h4 id="指针的地址？-指针所指向的地址？"><a href="#指针的地址？-指针所指向的地址？" class="headerlink" title="指针的地址？ 指针所指向的地址？"></a>指针的地址？ 指针所指向的地址？</h4><p>这是两码事。</p><p>指针的地址可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><p>而指针所指向的地址则可以通过：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%x"</span><span class="token punctuation">,</span> ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进行查看。</p><h3 id="关于精度（老大难）"><a href="#关于精度（老大难）" class="headerlink" title="关于精度（老大难）"></a>关于精度（老大难）</h3><p>有些oj会要求咱们将小数保留至两位精度（类似的），这种情况下如果我们计算到对应的精度（如0.01）大概率会出现一些奇奇怪怪的错误，要注意这种题求解时按照比题目要求精度高一位的精度来做。（常常在枚举题目中看到这玩意）</p><h2 id="2-一些有趣的函数"><a href="#2-一些有趣的函数" class="headerlink" title="2. 一些有趣的函数"></a>2. 一些有趣的函数</h2><blockquote><p>这个条目仅仅用于记录博主遇到过的觉得有一定利用意义的函数。</p></blockquote><h3 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h3><p>利用&lt;stdlib.h&gt;中的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数的功能为得到0~ RAND_MAX 之间的整数，不同系统的RAND_MAX不一样，反正够用</p><p>如果要得到一个范围内的数，比如3-10之间的数，可以用如下方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> random<span class="token punctuation">;</span>  random<span class="token operator">=</span><span class="token number">3</span><span class="token operator">+</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">//前面的3为最小值，rand后面取余的数为区间宽度。</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> random<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述算法还有个问题，该函数生成的是伪随机数，如果种子不刷新，则生成的随机数是有规律的。<br>因此建议每次使用该函数之前，都多引用一个库，并在主函数中加一句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤的目的是在每次运行程序之前都刷新种子。（通过time(0)这个随时间变化的变量，而这个变量存储在 &lt;time.h&gt; 中。）</p><p>需要注意的是，这个语句请务必加在主函数中，而非是一个调用多次的子函数或迭代很快的循环中，由于time(0)是一个只统计到秒的变量，因此如果过快地多次重置，则会发现你生成的随机数都是同一个数。</p><h3 id="求素数"><a href="#求素数" class="headerlink" title="求素数"></a>求素数</h3><p>用空间换时间</p><p>具体算法：</p><ol><li>令n&#x3D;2，如果n是素数，则划掉序列中所有n的倍数。</li><li>令n等于下一个没有划掉的元素，回到步骤2。</li></ol><h2 id="3-关于C"><a href="#3-关于C" class="headerlink" title="3.关于C++"></a>3.关于C++</h2><p>其实博主本来不打算在这里写C++的东西，但是耐不住学校的安排着实比较无奈，略写吧。</p><h3 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h3><p>C++里面的引用其实比较类似于C里面的指针，只不过不用再使用解引用符了，可以直接通过名称来访问原本的地址，这一点在函数传参的时候尤为常用。</p><h3 id="关于malloc"><a href="#关于malloc" class="headerlink" title="关于malloc"></a>关于malloc</h3><p>这一部分博主着实不是非常确定，但确实出现过在C++中利用malloc却出现报错的情况，在网上查了一下相关资料，发现C++中最好使用新的内存申请方法，即 <strong>new</strong> 关键字。</p><h3 id="关于STL"><a href="#关于STL" class="headerlink" title="关于STL"></a>关于STL</h3><p>这里仅仅会列举一些STL的常见错误，以及一些博主认为需要额外说明的玩意。</p><h4 id="关于push-back后iterator的报错"><a href="#关于push-back后iterator的报错" class="headerlink" title="关于push_back后iterator的报错"></a>关于push_back后iterator的报错</h4><p>在C++中提供了迭代器，即iterator的用法，这东西通常可以用于迭代各类STL容器。</p><p>但有一个事得额外讲一下，vector这个容器相比于正常数组的好处在于其可以随时通过库函数方便的调整它的大小，看起来很美好，其实际底层原理是在原先的数组空间不够时直接将整个数组移到另一个内存地址。</p><p>这在平常是没什么问题的，但是如果你恰好设置了一个迭代器，我们会发现迭代器根本没有转移到新的位置（能转移就有鬼了），而这个时候我们再操作这个迭代器，就会报错。</p><p>所以，在调整数组大小时，尤其需要注意iter的位置。</p><hr><p>本文会随着博主编程经历的增长持续更新。</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.6</title>
      <link href="/posts/16898.html"/>
      <url>/posts/16898.html</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="1-指针概述"><a href="#1-指针概述" class="headerlink" title="1. 指针概述"></a>1. 指针概述</h2><p><strong>指针</strong> 在C语言中有着十分重要的作用，其特点体现在其极高的灵活性上，并且能够十分方便的在不同函数间传递。</p><p>要理解指针到底是个啥，需要从一个基础概念 <strong>地址</strong> 说起。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>此前的章节中，曾提到过编程时的各种变量以及算法是储存在 <strong>内存</strong> 中的，而内存在储存数据时对不同的数据都有一个编号，这个编号就被称为 <strong>地址</strong> 。</p><p>在编程过程中，系统会根据程序中的变量名对不同的数据进行存储，相应的，不同的变量占用的内存大小也不尽相同。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span>    <span class="token comment">//4个字节</span><span class="token keyword">char</span>   <span class="token comment">//1个字节</span><span class="token keyword">float</span>  <span class="token comment">//4个字节</span><span class="token keyword">double</span> <span class="token comment">//8个字节</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>有了地址这个概念，相应的，程序需要调用相应变量时，就会通过地址找到内存中对应的部分进行调用，这个过程被称为 <strong>寻址</strong> 。</p><p>寻址有两种方式：  </p><ol><li><p>直接寻址</p><p><strong>直接寻址</strong> 指的是直接按变量的地址存取变量的值<br>平时用的如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这些都属于直接寻址。</p></li><li><p>间接寻址</p><p>与直接寻址不同， <strong>间接寻址</strong> 是以地址跳转的方式来存取变量的值。</p><p>这就涉及到了本章的核心—— <strong>指针</strong> ，因为指针所存储的就是地址。</p></li></ol><h2 id="2-指针的使用"><a href="#2-指针的使用" class="headerlink" title="2. 指针的使用"></a>2. 指针的使用</h2><h3 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h3><p>同样的，指针变量也有不同的类型，以下给出几例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span><span class="token keyword">float</span> <span class="token operator">*</span>pf<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要提出的是，指针变量可以指向任何类型，不仅仅局限于常见的变量类型，还包括函数，结构体等等。</p><h3 id="指针的赋值"><a href="#指针的赋值" class="headerlink" title="指针的赋值"></a>指针的赋值</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//上面是一种赋值方式</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token comment">//这是另一种赋值方式</span><span class="token comment">//请格外注意，这种赋值方式是不合规的！</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针变量常用取地址符号 <strong>&amp;</strong> 进行一系列的赋值操作。<br>此外，只能赋给指针与其指针类型对应的变量的地址。（如：整形指针只能赋予其整形变量的地址）</p><h3 id="指针相关的运算符"><a href="#指针相关的运算符" class="headerlink" title="指针相关的运算符"></a>指针相关的运算符</h3><p>与指针相关的运算符有两个： <strong>&amp;</strong> 以及 * 。</p><p>&amp;的意义为取地址，可以将其后方的变量的地址提取出来。<br>*的意义为解引用，只能操作有指针意义的值。</p><p>这里给出*的使用例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">//等价于a++;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//等价于printf("%d", a);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里还需要提一下指针的常用情景，此前曾经提过，由于形参的限制，在函数中直接交换另一个函数中的变量是不可取的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span>a<span class="token punctuation">;</span>    a<span class="token operator">=</span>b<span class="token punctuation">;</span>    b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“3 5”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但在这里，指针可以完成这个操作，因为指针直接指向相应变量的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    t<span class="token operator">=</span><span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token operator">*</span>a<span class="token operator">=</span><span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token operator">*</span>b<span class="token operator">=</span>t<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出为：“5 3”</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这也是为什么说指针很灵活的原因之一。</p><h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>C语言中提供了一个特殊的指针值，被称为空指针，表示该指针变量闲置。常见写法为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//也可以写成int *p=0; 但这种写法不常用</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="通用指针"><a href="#通用指针" class="headerlink" title="通用指针"></a>通用指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过上述语句可以定义一个通用指针，该指针可以被任何类型的变量地址赋值。<br>但需要注意的是，当使用该指针为其他非通用指针赋值时，需要做类型转换。下面给出一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token keyword">int</span> <span class="token operator">*</span>pt<span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，可以接受任何变量的地址。</span>pt<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">;</span>  <span class="token comment">//p为通用指针，但pt为整形指针，因此赋值时需要进行强制类型转换。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在日常使用中，通用指针的作用并非进行各类计算，而是常用于动态内存分配函数malloc, calloc中，这点在本文靠后的位置中会提及。</p><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p>野指针：也叫悬空指针，即指针的地址是无效地址，或者未分配存储空间的地址。 <del>（指针指到别的地方去了）</del></p><h2 id="3-指针与数组"><a href="#3-指针与数组" class="headerlink" title="3. 指针与数组"></a>3. 指针与数组</h2><blockquote><p>在使用多次后，会逐渐发现数组和指针其实十分类似 <del>（就一个玩意）</del></p></blockquote><h3 id="数组的存储方式"><a href="#数组的存储方式" class="headerlink" title="数组的存储方式"></a>数组的存储方式</h3><p>在进入正题之前，咱们先来回顾一下数组如何在内存中进行存储。<br>在上一章，提到过数组名其实就是个地址，这里给出更具体的阐释：</p><p>数组名是一个 <strong>基类型为数组元素基类型</strong> 的地址常量。</p><p>解释一下，定义一个数组，其实就是在内存中开辟了一片区域，其每个单元大小都是一个数组元素的大小，然后给数组名关联上那片区域的起始位置的地址。</p><p>说到这里，是不是想到了什么？<br>指针也是个地址，因此用指针去访问数组中的元素是完全可行的。</p><h3 id="访问数组的指针"><a href="#访问数组的指针" class="headerlink" title="访问数组的指针"></a>访问数组的指针</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p， i<span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>  <span class="token comment">//这里也可以写成p=&amp;a[0]; 一个道理。</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//上述代码的输出结果为"1 1 1 1 1"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述例子，可以发现我们通过将数组名与指针关联，进而实现了通过指针对数组中的元素进行访问。</p><p>需要注意的是：<br>当我们将数组的首地址赋值给指针时，指针就同样具有了 <strong>单位</strong> 这一概念，即其关联的数组的一个元素的大小。<br>因此，这时下列表达式便都存在意义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>a<span class="token punctuation">;</span>p<span class="token operator">++</span><span class="token punctuation">;</span>p<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以，现在数组元素的访问便有了两种方法：</p><ol><li>下标：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>指针：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h3><p>先回顾一下二维数组的定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以理解为先创建了一个长度为5的数组，这个数组里每个单位又有五个整形元素。</p><p>因此，如果用指针操作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> tdarray<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token comment">//也可以通过这种方式进行赋值</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>p<span class="token operator">=</span>tdarray<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出6，相当于tdarray[1][2]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于*(*(p+i)+j)做出一些解释：</p><ol><li>p+i：相当于第i行的地址</li><li>*(p+i)：相当于第i行第1个元素的地址</li><li>*(p+i)+j：相当于第i行第j个元素的地址</li><li>*( *(p+i)+j)：相当于第i行第j个元素</li></ol><h3 id="一些额外说明"><a href="#一些额外说明" class="headerlink" title="一些额外说明"></a>一些额外说明</h3><p>需要明确的是，上面的阐述过程中一直将数组名与数组首地址画了等号，这其实并不十分准确，但因为这种阐述方法易于理解，因此采纳了这种方式。</p><p>实际上，大多数情况下，数组名都可以与数组首地址划等号，除了以下两种情况：</p><ol><li>使用sizeof运算符计算数组大小时<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//结果为20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>使用&amp;取地址符号时</li></ol><h2 id="4-指针与字符串"><a href="#4-指针与字符串" class="headerlink" title="4. 指针与字符串"></a>4. 指针与字符串</h2><p>同样的道理，此前的字符数组定义为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显然，str作为字符串名也是一个地址，因此，我们也可以用指针来达成同样的效果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>str<span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>需要注意的是，指针所代表的字符串的起始位置是其地址，终止位置是第一个“\0”。</p><p>下面拿一道例题进行说明：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ABCDE"</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> arr<span class="token punctuation">;</span> ptr <span class="token operator">&lt;</span> arr<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span> ptr<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//该程序运行结果为：</span><span class="token comment">//  ABCDE</span><span class="token comment">//  BCDE</span><span class="token comment">//  CDE</span><span class="token comment">//  DE</span><span class="token comment">//  E</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-指针数组"><a href="#5-指针数组" class="headerlink" title="5. 指针数组"></a>5. 指针数组</h2><blockquote><p>请务必区分指针数组与指针形式的二维数组</p></blockquote><p>如果我们想定义一个由指针元素构成的数组：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句的意义为定义了一个有四个元素的指针数组。</p><p><font color=red>注意：二维数组的定义方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></font><p>产生二者区别的根本原因在于[]的运算优先级高于*，因此前者代表着定义了一个由四个指针元素组成的数组，而后者则仅仅是一个指针，这个指针内对应的地址含有四个元素。</p><p>由于博主对于指针数组的应用实在过少，这里先暂且搁置，待后续补充。</p><h2 id="6-命令行参数"><a href="#6-命令行参数" class="headerlink" title="6. 命令行参数"></a>6. 命令行参数</h2><p>在每个程序的主函数中，都会有这样一个语句：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>事实上，main后面的括号里是可以填东西的。其完整形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里做出一点说明：</p><ol><li><p>argc是一个整形变量，由系统自动赋值，其值为后续*argv[]字符指针数组的个数。</p></li><li><p>*argv[]是一个字符指针数组，可以接受多个字符串。</p></li><li><p>至于这些字符串如何输入，是通过windows用户终端（cmd）里面执行相应程序的exe文件时需要输入的内容。</p><p>这里给出一例：<br>在终端中找到对应的exe文件（cd 对应文件地址），之后输入：</p><pre class="line-numbers language-none"><code class="language-none">你的文件名.exe Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样的话，argv[0]便被赋值为”你的文件名.exe”，argv[1]被赋值为”Hello”, argc[2]被赋值为”World”。<br>argc则被赋值为3。</p><p>这些参数可以在C语言程序中使用。</p></li></ol><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.5</title>
      <link href="/posts/17218.html"/>
      <url>/posts/17218.html</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="1-数组概述"><a href="#1-数组概述" class="headerlink" title="1. 数组概述"></a>1. 数组概述</h2><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><p><strong>数组</strong> 是一种能够包含多个 <strong>同类型数据</strong> 的复合结构。</p><p>可以理解为一个连续的存储空间，被切分为了多个存储单元</p><h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>数组的定义需要三个要素：  </p><ol><li>数组元素类型</li><li>数组名称</li><li>数组的大小</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">double</span> m<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：</p><ol><li>数组方括号内的只能是 <strong>字面量</strong> 或 <strong>枚举常量</strong>，不能是变量（已赋值的也不行） ；<br>如：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token keyword">int</span> m<span class="token punctuation">[</span>N<span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">enum</span><span class="token punctuation">&#123;</span>X<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">[</span>X<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//以上是合法的数组定义</span><span class="token comment">//以下是不合法的数组定义</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//注：该种定义方法在C99标准中被允许</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在常规编程中，数组的大小不宜太大（博主最高使用过长度为10000的数组），过大的数组可能会引起报错。<br>如真的需要使用一个很大的存储空间，请参考后一篇文章： <strong>指针</strong></li></ol><h3 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h3><h4 id="基本操作：元素访问"><a href="#基本操作：元素访问" class="headerlink" title="基本操作：元素访问"></a>基本操作：元素访问</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>值得一提的是，变量不能出现在数组定义的方括号中，但可以出现在使用数组时的方括号中。如：</p><h4 id="常用操作：批量赋值"><a href="#常用操作：批量赋值" class="headerlink" title="常用操作：批量赋值"></a>常用操作：批量赋值</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">9</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种用法是可行的。</p><p>注：<br>利用 <strong>for</strong> 循环对数组内的元素进行统一赋值是十分常见的用法，但这一过程中常常会出现 <strong>越界访问</strong> 问题。</p><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>三种方法：  </p><ol><li>直接初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>注：直接初始化不能使用除了常量之外的任何表达式。</li><li>部分初始化<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会将未提到的元素自动赋值0。</li><li>直接写数组<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这种初始化方法会在编译过程中自动给出数组的大小。</li></ol><h4 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h4><p>问题在于，C语言的参数传递是值传递，因此无法简单的在函数中使用数组。</p><p>解决方案：将数组在内存中存储的地址传递给函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数组的基本使用至此以叙述完毕，接下来会阐述一些常用的数组及其用法。</p><h2 id="2-一维数值型数组的应用"><a href="#2-一维数值型数组的应用" class="headerlink" title="2. 一维数值型数组的应用"></a>2. 一维数值型数组的应用</h2><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p><strong>排序</strong> 是十分常见的可以用数组解决的问题之一，在本篇博文中，仅仅展示出一个基本的方法—— <strong>冒泡排序</strong> 。</p><p><strong>冒泡排序</strong> 的基本思路是运用嵌套for循环对数组进行操作，每一轮循环都将最大的数挪到数组后方相应位置。</p><p>这里给出参考代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">bubblesort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]是需要排序的数组，n是数组的大小</span>   <span class="token keyword">int</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span>n<span class="token operator">-</span>i1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">>=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> m<span class="token punctuation">;</span>  <span class="token comment">//m是个临时变量</span>            m<span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token operator">=</span>array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>m<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>         <span class="token comment">//如果前一个元素大于（等于）后一个元素，则将两个元素交换</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">//排序完成，如需输出：</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要标注的是，关于排序还有不少改进方法，如 <strong>选择排序</strong> ， <strong>插入排序</strong> 等，在后面的进阶训练篇章中会有提及。</p><h3 id="查找问题"><a href="#查找问题" class="headerlink" title="查找问题"></a>查找问题</h3><p><strong>查找</strong> 即在数组中寻找某个元素</p><h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><p>线性查找的思路是最简单的，即从头到尾全过一遍，找到相应元素便返回。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token comment">//array[]为要进行查找的数组，n为数组大小，goal为要查找的元素</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>goal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>         count<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> count<span class="token punctuation">;</span>   <span class="token comment">//数组中每个等于goal的元素下标均输出，并返回出现次数（count）</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很明显，这种查找方法在数组已经排好序的情况下是效率较低的。这样就衍生出了另一种查找方法—— <strong>折半查找</strong> 。</p><p>同样的，在后续进阶文章中会提及。</p><h3 id="插入，删除问题"><a href="#插入，删除问题" class="headerlink" title="插入，删除问题"></a>插入，删除问题</h3><p>插入，删除的操作方法相比于查找就多了一步，因此此处不再详细阐述，给出思路。</p><p>插入：<br>找到插入位置-&gt;将后面的元素全部往后挪一位-&gt;将要插入的元素放进去</p><p>删除：<br>找到要删除的元素-&gt;将后面的元素往前挪一位</p><h2 id="3-字符数组-字符串"><a href="#3-字符数组-字符串" class="headerlink" title="3. 字符数组 &#x2F; 字符串"></a>3. 字符数组 &#x2F; 字符串</h2><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>顾名思义， <strong>字符串常量</strong> 即由一连串字符组成的常量。<br>在C语言中规定： <strong>\0</strong> 是字符串结尾的标志。<br>即：如果定义了一个内容为”C programming”的字符串，那它在存储空间内的存储方式为：”C programming\0”</p><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p><strong>字符数组</strong> 可以用来存储字符串。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>与其他数组定义方式相同：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> array<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：定义字符数组时需要考虑”\0”占据的一个大小。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化字符数组有多种方法。</p><ol><li><p>逐个字符赋值：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> task<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token char">'C'</span><span class="token punctuation">,</span> <span class="token char">'p'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'o'</span><span class="token punctuation">,</span> <span class="token char">'g'</span><span class="token punctuation">,</span> <span class="token char">'r'</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//其中未声明初始值的元素会自动赋值为 '\0'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>直接定义字符串常量：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"That's a string"</span><span class="token punctuation">;</span><span class="token comment">//未定义初始大小的字符串常量会自动设定其大小为链长+1（用于存储 \0）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>需要注意的是，这种方法只能用于初始化，不能用于赋值。</p></li></ol><h4 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入&#x2F;输出"></a>输入&#x2F;输出</h4><p>C语言中的scanf（visual studio中为scanf_s）以及printf函数为字符串设定了单独的输入输出格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但很遗憾，由于scanf的限制，这样的输入不适用于列中带有空格的字符串。因为scanf遇到空格会中止。</p><p>因此，以下部分引入新的标准库&lt;string.h&gt;</p><h3 id="概述"><a href="#概述" class="headerlink" title="&lt;string.h&gt;概述"></a>&lt;string.h&gt;概述</h3><p>在C语言中，涉及到字符串，这个标准库几乎是逃不过去的，因为其中涉及到了许多很好用的操作字符串的函数。</p><h4 id="字符串输入函数-gets"><a href="#字符串输入函数-gets" class="headerlink" title="字符串输入函数 gets"></a>字符串输入函数 gets</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">gets</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数遇到空格不会终止，当遇到回车时会中止输入，并自动在最后多赋值一个 \0</p><h4 id="字符串输出函数-puts"><a href="#字符串输出函数-puts" class="headerlink" title="字符串输出函数 puts"></a>字符串输出函数 puts</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C programming"</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会输出括号中的字符串，并在最后自动加上回车。</p><h4 id="字符串长度函数-strlen"><a href="#字符串长度函数-strlen" class="headerlink" title="字符串长度函数 strlen"></a>字符串长度函数 strlen</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"I'm editing a blog"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数会自动计算括号内字符串的实际长度。（不含 \0）</p><h4 id="字符串复制函数-strcpy"><a href="#字符串复制函数-strcpy" class="headerlink" title="字符串复制函数 strcpy"></a>字符串复制函数 strcpy</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> <span class="token string">"blog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">strcpy</span><span class="token punctuation">(</span>str2<span class="token punctuation">,</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容复制到前面的字符串中。<br>需要注意的是前面的字符串需要够大来容纳后面的字符串。</p><h4 id="字符串比较函数-strcmp"><a href="#字符串比较函数-strcmp" class="headerlink" title="字符串比较函数 strcmp"></a>字符串比较函数 strcmp</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Beijing"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Shanghai"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出0</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> str3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//输出一个非0的值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该函数会比较前后两字符串的值，相同则输出0，不相同则输出非0；</p><h4 id="字符串连接函数-strcat"><a href="#字符串连接函数-strcat" class="headerlink" title="字符串连接函数 strcat"></a>字符串连接函数 strcat</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Programming"</span><span class="token punctuation">,</span> str2<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"c language"</span><span class="token punctuation">;</span><span class="token function">strcat</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将str2的内容接到str后面</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该函数可以将后面字符串的内容接到前面的字符串后面。</p><h3 id="一点补充"><a href="#一点补充" class="headerlink" title="一点补充"></a>一点补充</h3><p>字符串的操作方法十分繁杂，包括最简单的gets，puts函数的各种变体也有很多，在这里不过多赘述，在后面的文章中还会相应提及。</p><h2 id="4-二维数组"><a href="#4-二维数组" class="headerlink" title="4. 二维数组"></a>4. 二维数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述方式表示定义一个5*5的二维数组。</p><h3 id="赋值-使用"><a href="#赋值-使用" class="headerlink" title="赋值&#x2F;使用"></a>赋值&#x2F;使用</h3><p>二维数组的赋值常用两个for循环嵌套进行</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>i1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i1<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i1<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i2<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i2<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若二维数组作为函数参数使用，则需要使用如下格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//二维数组前面的一维长度不需要给出，但后面的二维长度必须给出</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>综上，关于数组的一些基本概念已经梳理完毕了。</p><p>下一章的指针，相对而言更加复杂，理解难度也更高，但归根结底与数组的原理极其相似，熟练应用后指针反而更加灵活。 <del>（虽然我现在还不能熟练应用）</del></p><p>这篇博文就到这里~~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.4</title>
      <link href="/posts/33667.html"/>
      <url>/posts/33667.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-函数概述"><a href="#1-函数概述" class="headerlink" title="1. 函数概述"></a>1. 函数概述</h2><p><strong>函数</strong> 是C语言中的基本单位，具体表现为一段代码，可重复使用从而实现某种功能。</p><p>在C语言的源文件中，仅能存在一个 <strong>main函数</strong> （程序入口）以及多个子函数（名称可自定）</p><p>注：C语言不允许函数的嵌套定义，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token function">function2</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此类函数定义方式是不被允许的。</p><h2 id="2-函数的定义，调用，声明"><a href="#2-函数的定义，调用，声明" class="headerlink" title="2. 函数的定义，调用，声明"></a>2. 函数的定义，调用，声明</h2><p>这里直接列举定义，调用以及声明的方法：</p><ol><li>定义：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">double</span> num<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>声明：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>调用：<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">double</span> fact<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>几个要注意的点：</p><ol><li><p>函数的返回值类型必须与函数类型相同（第一个词写的啥返回啥）</p></li><li><p><strong>void</strong> 关键字可以指函数类型，此时函数无返回结果，也可用于描述参数，此时函数无参数。</p></li><li><p>关于实参与形参：<br>定义&#x2F;声明函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的a, b称为形参，函数执行完毕后即清除相应内存。</p><p>与此不同，调用函数时：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> result<span class="token punctuation">;</span><span class="token keyword">double</span> n<span class="token operator">=</span><span class="token number">4.2</span><span class="token punctuation">;</span>result<span class="token operator">=</span><span class="token function">function1</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的m, n被称为实参。</p><p>在调用函数时，会将实参中的值自左向右传递给形参<br>（上例中即会先将m的值传给a，将n的值传给b）<br>此后再进行函数的下一步语句。</p><p>注意：实参传递给形参相应值是 <Font color=CornflowerBlue><em><strong>单向传递</strong></em> </Font></p></li><li><p>关于函数的结束：两种方法  </p><ol><li>执行完最后一条语句</li><li>遇到了return，返回了相应值</li></ol></li><li><p>一般而言，可以在主函数前定义相应函数并在主函数中进行调用，但如果想在主函数后定义相应函数，则需要在主函数前进行函数声明。</p></li><li><p>c语言中的函数允许多级调用（也叫嵌套调用）<br><strong>明确一点，只是允许多级调用，但不允许嵌套定义（在前面有提及）</strong></p></li></ol><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h2><p><strong>递归</strong> 指的是一个函数中存在调用自己本身这个函数的行为，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>      x<span class="token operator">=</span>n<span class="token operator">+</span><span class="token function">fact</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现，在fact函数中，若n!&#x3D;1，则会重复调用fact自身。</p><p><strong>一个特点：</strong><br> 递归可以转化为循环，但递归写法常常更加简洁，更加易读，相应的，递归的计算复杂度（不确定这个词是否准确）会更高，时间成本也会更高。<br>   举出一个比较合适的例子：斐波那契数列<br>   首先写出递归写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> result<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token operator">||</span>i<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">fibo</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   然后再给出循环写法：<br>   <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fibo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token keyword">long</span> f1<span class="token punctuation">,</span> f2<span class="token punctuation">,</span> result<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      result<span class="token operator">=</span>f1<span class="token operator">+</span>f2<span class="token punctuation">;</span>      f1<span class="token operator">=</span>f2<span class="token punctuation">;</span>      f2<span class="token operator">=</span>result<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   明显看出，编辑时，循环写法涉及到的细节更多，包括for循环的数量问题，f1, f2, result等变量的重新赋值等，而递归写法编程难度要简单许多。</p><p>   但同时，也需要承认，在递归写法中，对许多量都需要进行重复运算，比如每算一次fibo(5)就要算一次fibo(4)和fibo(3)，但这时算fibo(4)则再次涉及到了fibo(3)的运算，这种运算量如果多次叠加，时间成本是很恐怖的。</p><p>综上，请在递归降低编程难度这一特点能够弥补上它自己本身的效率开销时，再进行递归算法的使用。</p><p>进一步的问题解决敬请期待C语言进阶训练篇章。 <del>（我直接挖坑）</del></p><h2 id="4-预编译"><a href="#4-预编译" class="headerlink" title="4. 预编译"></a>4. 预编译</h2><p>在本系列笔记的第二节中曾提及：预编译这一说法，这里给出详细说明。</p><p>预编译命令共三类：  </p><ol><li><p>文件引入</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一类编译命令还有一种写法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"...（你自己的文件名）"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一种写法，是在系统头文件中寻找响应文件并引入，如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>math<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token operator">&lt;</span>stdlib<span class="token punctuation">.</span>h<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二种写法，是现在编程文件所在目录下进行文件查找，若找不到，再到系统指定目录下寻找响应文件</p><p>无论如何，文件引入的根本目的是实现多文件编程，使得在这个编程文件中可以使用其他文件中所定义的函数。<br><Font color=cornflowerblue> <strong>其具体原理是用指定文件的内容代替相应的命令行</strong> </Font></p><p>这里存在一种简单易行的方法进行多文件编程，即将你的函数一并写到一个文件中，命名为&lt;file1.h&gt;，此后在需要使用函数的地方预编译： <strong>include &lt;file1.h&gt;</strong> 即可。</p><p>但当头文件有很多个时，会遇到另一个问题，参考如下例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件file1.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file2.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;math.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file3.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file4.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file1.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file2.h></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//这是文件file5.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.3></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;file.4></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当出现必须要同时引用 file3 与 file4 时，会出现对 file1 与 file2 的重复引用（即引用了两次，会报错）<br>因此这里给出方法，在每个文件前都加上一行代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此代码代表本文件仅引用一次。</p></li><li><p>宏定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">name</span> <span class="token expression">maintext</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>宏定义的作用 <strong>maintext</strong> 来替换正文中出现的 <strong>name</strong><br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UD</span> <span class="token expression"><span class="token keyword">unsigned</span> <span class="token keyword">double</span></span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>UD x<span class="token punctuation">,</span> y<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的UD x, y; 作用等同于unsigned double x, y;  </p><p>几个注意事项：</p><ol><li>宏定义后面没有引号，与文件引入相同。</li><li>宏定义是简单替换，会将maintext原封不动的替换到name的位置，容易造成计算方面的错误，因此不推荐频繁使用。</li></ol></li><li><p>条件编译</p><p>用于仅对c程序中的一部分进行编译，另一部分不编译。（通过if，else实现）<br>具体格式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">expression1</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">elif</span> <span class="token expression">expression2</span></span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> </span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>局部&#x2F;全局变量</p><p><strong>局部变量</strong> 指的是在函数内定义的变量，仅仅能在函数内部生效。（包括主函数）<br>注意：在复合语句中定义的变量生效范围仅为该复合语句内部。</p><p><strong>全局变量</strong> 指的是在函数外定义的变量，作用范围从定义处到函数源文件结束。</p></li></ol><p>这里单开一块单独说明变量的问题。</p><h2 id="5-动态-静态储存变量"><a href="#5-动态-静态储存变量" class="headerlink" title="5. 动态&#x2F;静态储存变量"></a>5. 动态&#x2F;静态储存变量</h2><p>程序在内存的分布区域是有规划的，分为：</p><ol><li>程序区：存放用户代码</li><li>静态存储区：存放全局数据与静态数据（在程序执行完毕后再释放相应内存）</li><li>动态存储区：存放动态数据（在相应函数执行完毕后便释放对应内存区域）</li><li>寄存器（ <strong>CPU内</strong> ）：将某些用的很多的动态变量存入CPU相应的存储区域中，加快程序执行速度</li></ol><p>由此，可将变量按照存储方式分类：</p><ol><li><p>自动变量<br><strong>自动变量</strong> 存储在动态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">auto</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但由于auto关键字往往可省略，因此任何函数中的未加说明的变量定义均为自动变量。</p></li><li><p>静态变量<br><strong>静态变量</strong> 存储在静态存储区中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>静态变量在函数执行完毕后将不会被销毁，并会在后续对其进行操作时保留对其进行的改变。</p></li><li><p>寄存器变量<br><strong>寄存器变量</strong> 存储在寄存器中，定义方式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">register</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>几个要注意的要点：  </p><ol><li>只有动态变量可以作为寄存器变量</li><li>寄存器变量不能无限定义，因为寄存器数目有限</li></ol></li><li><p>全局变量<br><strong>全局变量</strong> 存储在静态存储区中，定义方式为在函数外部进行相应定义：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>extern可以通过在多文件编程中进行使用，但是在另一个文件中使用本文件的全局变量时需要加上extern前缀说明。<br>这里举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这是文件A的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token comment">//这是文件B的内容</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>     <span class="token comment">//x存在，但是定义在别的地方</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>需要注意的是，全局变量、静态变量的使用会降低程序可读性，增加编程复杂度，故请适量使用。</p><p>此外，添加一点补充：  </p><ol><li><p>在嵌套作用域中出现同名变量名定义时，内层作用域的同名变量在这其中会遮盖外层变量。<br>这里浅举一例：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>   <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">5</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>很明显，在内部作用域中b被重新定义的b&#x3D;2覆盖，当执行完毕后b的值重新变回5。</p></li><li><p>需要注意，多个源文件中不能有重名的全局变量，否则在某一个文件中对全局变量进行引用时会出现链接问题</p></li><li><p>C语言中的常量定义：</p><ol><li>enum<br><strong>enum</strong> 代表枚举常量，仅能定义整数常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>N<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">,</span> M<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这样定义出的常量在函数编译过程中值不会改变</li><li>const<br><strong>const</strong> 代表常量，可以定义各种常量<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">double</span> m<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">long</span> r<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>同样，这样定义出的常量在函数编译过程中值不会改变</li></ol></li></ol><p>至此，函数以及各类预编译事项便具体说明完毕。</p><p>接下来就是一些比较复杂的数据处理了，如数组，指针等。</p><p>这篇博文先到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.3</title>
      <link href="/posts/16834.html"/>
      <url>/posts/16834.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><h2 id="1-三种基本结构"><a href="#1-三种基本结构" class="headerlink" title="1. 三种基本结构"></a>1. 三种基本结构</h2><ol><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ol><h2 id="2-关系，逻辑，条件的相关语句"><a href="#2-关系，逻辑，条件的相关语句" class="headerlink" title="2. 关系，逻辑，条件的相关语句"></a>2. 关系，逻辑，条件的相关语句</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>六个： <strong>&lt; &lt;&#x3D; &#x3D;&#x3D; &gt; &gt;&#x3D;</strong><br><strong>注：在C语言中，&#x3D;&#x3D;表示相等，&#x3D;表示赋值，勿混淆</strong></p><h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>在C语言中，用 <strong>1</strong> 表示表达式为真，用 <strong>0</strong> 表示表达式为假<br>如：  </p><ol><li>表达式： <strong>8&gt;4</strong> 为真，值为1</li><li>表达式： <strong>0&#x3D;&#x3D;1</strong> 为假，值为0</li></ol><p>这里引入一种语句： <strong>条件运算符</strong><br>写为：？：<br>如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">></span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述语句表示：<br>若a&gt;b，则x&#x3D;a，反之，则x&#x3D;b</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>三个： <strong>! &amp;&amp; ||</strong><br>分别表示：非，与，或</p><h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3><p>对于 ! 表达式，会对该表达式求值，以该值的否定为结果<br>对于 &amp;&amp; 表达式，会对两侧表达式分别求值，只有两侧表达式值均为1时，整个表达式值才为1，否则均为0<br>对于 || 表达式，会对两侧表达式分别求值，只有两侧表达式值均为0时，整个表达式值才为0，否则均为1</p><h3 id="短路特性（重点关注）"><a href="#短路特性（重点关注）" class="headerlink" title="短路特性（重点关注）"></a>短路特性（重点关注）</h3><p>逻辑表达式求值时，只有系统判定必须计算下一个运算符才能得出表达式的值时，才会进行计算 <del>（多绕的慌啊）</del></p><p>举个例子：  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> x<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token operator">=</span> a <span class="token operator">&amp;&amp;</span> b <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当上述例子输入时，第一个数值（即a的值）输入0时，则不会计算b &amp;&amp; c这一部分的值，而会直接将x的值赋值为0</p><h2 id="3-顺序结构程序设计"><a href="#3-顺序结构程序设计" class="headerlink" title="3. 顺序结构程序设计"></a>3. 顺序结构程序设计</h2><p><em><strong>自上而下，逐行运行</strong></em></p><p>主要由以下部分组成：</p><ol><li>赋值语句</li><li>复合语句</li><li>函数调用语句</li></ol><p><em>赋值，函数调用在前面的章节已经有过叙述，这里仅对复合语句做简要说明</em></p><p>复合语句指一组语句，可以由 <strong>{}</strong> 框在中间</p><h2 id="4-选择结构程序设计"><a href="#4-选择结构程序设计" class="headerlink" title="4. 选择结构程序设计"></a>4. 选择结构程序设计</h2><p>选择结构需要利用此前的关系，逻辑表达式来阐述条件</p><p>两种常用语句： <strong>if ; switch</strong></p><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>有三种形式：  </p><ol><li>if：条件成立后执行</li><li>if-else：条件成立则执行if后的语句，反之则执行else后的语句</li><li>else-if：用于增加if-else中的条件个数</li></ol><p>最完备的一种情况：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>条件<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">(</span>条件n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    表达式n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p><em>用于实现多分支选择结构</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> E1<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> E2<span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">default</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简而言之，通过对variable（即变量）的值进行判断从而决定要执行的语句<br>当variable&#x3D;&#x3D;E1时，执行case E1中的语句<br>后续同理<br>如果variable的值不等于其中的任意一个case，则执行default中的语句</p><p><strong>注</strong>：  </p><ol><li>执行语句时，只有遇到 <strong>break</strong> 或 <strong>}</strong> 才会终止，故这里推荐在每一个case后均加上break</li><li>default并不是必须的，如果不加default，则variable不符合要求时不会执行任何语句</li><li>variable不仅仅可以是数值，也可以是字符形式</li></ol><h2 id="5-循环程序结构设计"><a href="#5-循环程序结构设计" class="headerlink" title="5. 循环程序结构设计"></a>5. 循环程序结构设计</h2><p>与选择结构类似地，同样需要利用关系、逻辑表达式进行条件的阐述</p><p>常用语句： <strong>while ; for ; do-while</strong></p><h3 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即：当condition为真（即condition非零）时，执行while内语句，执行完毕后重新判断condition，直至condition为假</p><p><strong>注</strong>：<br>当执行语句时遇到诸如 <strong>break ; return ; goto</strong> 之类的语句时，会跳出while循环</p><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>expr1 <span class="token punctuation">;</span> expr2 <span class="token punctuation">;</span> expr3<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要做出一点说明：  </p><ol><li><strong>expr1</strong> 表示初始条件</li><li><strong>expr2</strong> 表示需要满足的条件</li><li><strong>expr3</strong> 表示每次执行完一次语句后要做出的改变</li></ol><p>给出一例方便理解：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">50</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上述语句表示：i 的初始值为0；每次执行完语句后 i 自增1，直到 i 大于五十时结束循环</p><p><strong>注</strong>：  </p><ol><li>for结构中每个表达式都可以省略，但分号不可省略</li><li>for结构和while结构可以互相转化，下属while语句与上述for语句等价<pre class="line-numbers language-c" data-language="c"><code class="language-c">expr1<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>expr2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> expr3<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>特殊语句同样可以跳出for循环，如 <strong>break ; goto ; return</strong> 等</li></ol><h3 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a>do-while 语句</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>与 while 的区别在于这种语句会先将语句执行一遍再判断</p><h3 id="循环中的常见问题"><a href="#循环中的常见问题" class="headerlink" title="循环中的常见问题"></a>循环中的常见问题</h3><ol><li>循环可以相互嵌套，但一般不超过三层（会极大降低运行效率）</li><li>一般不用浮点数对循环进行控制，原因是浮点数存在误差，容易增减循环次数</li></ol><p>以上</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈《阿凡达2：水之道》</title>
      <link href="/posts/54708.html"/>
      <url>/posts/54708.html</url>
      
        <content type="html"><![CDATA[<p><em>阅前提醒：本片博文是在博主仅仅对阿凡达1的剧情略知一二的情形下的观影体验，文章中的观点难免有失偏颇，仅代表个人看法</em></p><blockquote><p><strong>阿凡达2：一部“徒有其表”的科幻作品</strong></p></blockquote><h2 id="剧情梗概"><a href="#剧情梗概" class="headerlink" title="剧情梗概"></a>剧情梗概</h2><blockquote><p>博主的梗概极其简略，肯定无法将电影中的细节进行呈现，这里还请读者有兴趣的话自行观看</p></blockquote><p>阿凡达2采用了一个非常“合家欢”的剧本</p><p>几个基本设定：  </p><ol><li>故事发生的星球叫做：潘多拉星</li><li>该星球上存在着名为“纳美”的原始土著</li><li>纳美人与潘多拉星的自然环境有着一种天然的“联系”，能使他们免遭人类的追捕</li><li>人类通过将自己的记忆转移至阿凡达体内，可以防止自己被潘多拉星的自然环境所针对</li></ol><p>本作剧情：<br>男主在变为纳美族后，了解到人类要取自己性命，为了不拖累自己的森林部族，便主动禅让，并与其家人一同离开森林部族，前往海洋部族，寻求其庇护。<br>在海洋部族的时段，男主学习了海洋部族的各类技能，但仍旧无法逃过人类的追捕，自己的孩子以及海洋部族首领的孩子均被人类所绑架，以此要挟男主主动投降。<br>最终男主在海洋部族及自然的帮助下，击退了前来追杀自己的人类队伍。</p><p>对，在我的眼中这部电影中真正可以说是 <strong>剧情相关</strong> 的部分就这么多，但就是这些内容，居然能拍了长达 <strong>三小时</strong> ？！</p><h2 id="一些亮点"><a href="#一些亮点" class="headerlink" title="一些亮点"></a>一些亮点</h2><p>咱先谈谈这部电影哪里好</p><h3 id="画面，音乐，特效"><a href="#画面，音乐，特效" class="headerlink" title="画面，音乐，特效"></a>画面，音乐，特效</h3><p>可以承认的是，这部电影在这些基础层面，可以说的上是好好学生了，这一系列的基本功打的极其扎实。画面上，很干净，很透亮，对于一部“水战”的主题电影，这是一个很好的加分项；音乐上，至少头一次看，不会有很大的违和感，该起该落，情感把控都还算可以；特效上，阿凡达1就是凭这个打出名声的，不多赘述</p><h3 id="运镜！"><a href="#运镜！" class="headerlink" title="运镜！"></a>运镜！</h3><p>这点我一定得夸一下，这部电影的运镜节奏非常合适，它不会像某些科幻片一样让你感觉到一种“看不过来”的感觉，也不会显得过于拖沓，这带来的观影效果提升确实很明显</p><h2 id="吐槽-（正片开始）"><a href="#吐槽-（正片开始）" class="headerlink" title="吐槽 （正片开始）"></a>吐槽 <del>（正片开始）</del></h2><p>好了，该夸的夸完了，现在该骂一骂了</p><h3 id="剧本"><a href="#剧本" class="headerlink" title="剧本"></a>剧本</h3><p>首先从我认为最无法理解的地方说起<br>2022年的 <strong>“科幻巨制”</strong> ，却给我看出了一股子儿女情长，并肩加上一些环境保护的“陈词滥调”，我觉得多少有些无聊了吧</p><p>我可以接受电影以“家庭”，“环境”为主旨，但我不认可为了这所谓的主旨而把剧情的合理性抛之脑后的做法</p><p>我认为本作的不合理处包括并不限于：</p><ol><li>男主明知 <em>人类想要掠夺整个潘多拉星，他自己仅仅是个导火索</em> 的事实，却仍然选择逃窜到另一个部族</li><li>在人类已然找上门时，男主仍在坚守自己“忍一时风平浪静”的岁月静好思想</li><li>在男主终于打算前往一战时，海洋部族仅仅是开场露了个面，此后便在整场决战中 <strong>“销声匿迹”</strong> 了</li></ol><h3 id="节奏"><a href="#节奏" class="headerlink" title="节奏"></a>节奏</h3><p>其次，说说这个剧情带来的副作用——整个影片的剧情发展拖沓的令人发指</p><p>不同于此前所提及的“运镜”相关的节奏恰当，本片的剧情进展十分缓慢，依我看来，这部电影的主线完全可以在2小时内结束，能拖到3小时的原因在于影片中存在许多“不必要”的铺垫</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>很多细节上的处理完全为主线服务，而完全忽视了与背景的契合度</p><p>在此略举几例：<br>在太空时代，科技领先潘多拉星多少倍的人类，时至如今，其飞行器的前窗仍然能被纳美人一箭射穿。<br>以及科技如此发达的人类社会，在绑架男主几个孩子时，“固执”地使用 <strong>皮带</strong> 将几个孩子拷在船上，在男主初次成功救出部分人质后，仍然“执拗”地使用 <em><strong>皮带</strong></em> 将剩余人质拷在船上。 <del>（好家伙你搁这玩梅开二度呢？）</del></p><p>无力吐槽。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>阿凡达2的基础是好的，甚至可以说是杰出的，但抵不过剧情，细节上的硬伤带来的观感下降</p><p>如果奔着画面和特效所带来的震撼，可以尝试<br>如果奔着剧情去，大可不必了</p><p>本篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Movies </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.2</title>
      <link href="/posts/5828.html"/>
      <url>/posts/5828.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计初步"><a href="#程序设计初步" class="headerlink" title="程序设计初步"></a>程序设计初步</h1><h2 id="1-程序的基本结构"><a href="#1-程序的基本结构" class="headerlink" title="1.程序的基本结构"></a>1.程序的基本结构</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><Font color=CornflowerBlue> <em><strong>函数</strong></em> </Font> 是C语言程序的基本单位<br>函数以 <strong>{}</strong> 为开始&#x2F;结束标志<br>作为一个程序，必须有一个主函数，即 <strong>main</strong> 函数<br>每个函数由语句构成，每个语句以 <strong>；</strong> 结尾</p><h3 id="预编译命令"><a href="#预编译命令" class="headerlink" title="预编译命令"></a>预编译命令</h3><p>每个C语言程序都含有预编译命令<br>预编译命令有三类：  </p><ol><li>宏定义  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#define PI 3.14<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>文件引入  <pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>条件编译 <del>（我没用过）</del><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifdef<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释在程序的编译与运行中均不起作用，仅仅增加程序可读性<br>具体格式:  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;这是一条注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h2><h3 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h3><p>C语言源程序只能存在基本字符，否则无法通过编译<br>基本字符包括：  </p><ol><li>大小写字母</li><li>数字</li><li>其他的可显示字符</li><li>特殊字符</li></ol><p>注： <strong>程序中所有的字符（除了注释中的内容）必须是英文格式</strong></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符用于标识程序中的名字，描述变量（其实就是你给函数或变量取的名）<br>分为三类：  </p><ol><li>用户自定义标识符</li><li>预定义标识符</li><li>关键字</li></ol><p>几个重要特征：</p><ol><li>标识符只能由 <strong>字母，数字及下划线</strong> 组成</li><li>标识符对大小写敏感</li></ol><p>关于关键字：<br>系统给其赋予了特定功能，不能用于其他目的<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">intfloatdoublecharbreak...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><p>C语言中的数据区分类型</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>基本类型<ol><li>整形：int</li><li>字符型：char</li><li>浮点型：<ol><li>单精度浮点型：float</li><li>双精度浮点型：double</li></ol></li></ol></li><li>构造类型<ol><li>数组类型</li><li>结构体类型</li><li>共用体类型</li><li>枚举类型</li></ol></li><li>指针类型</li><li>空类型</li></ol><p><strong>限于章节原因，本处仅对基本类型进行说明</strong></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="整形（int）"><a href="#整形（int）" class="headerlink" title="整形（int）"></a>整形（int）</h4><p>用于描述整数<br>取值范围：$-2^{31}$~$2^{31}-1$</p><h4 id="浮点型（float，double）"><a href="#浮点型（float，double）" class="headerlink" title="浮点型（float，double）"></a>浮点型（float，double）</h4><p>用于描述实数<br>其中 <strong>float</strong> 与 <strong>double</strong> 的区别在于前者精度更低，占用内存也更小<br><em><strong>由于计算机以指数形式存储浮点型，因此存在误差</strong></em></p><h4 id="字符型（char）"><a href="#字符型（char）" class="headerlink" title="字符型（char）"></a>字符型（char）</h4><p>用于存储单个字符信息<br>存储的是对应字符的 <strong>ASCⅡ码</strong><br>在此举一例：  </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;%c&quot;, 63);printf(&quot;%c&quot;, ?);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两条语句的输出结果应当都是字符 ‘ <strong>？</strong>’</p><h3 id="基本数据类型的扩充"><a href="#基本数据类型的扩充" class="headerlink" title="基本数据类型的扩充"></a>基本数据类型的扩充</h3><h4 id="短整型（short-int-short）"><a href="#短整型（short-int-short）" class="headerlink" title="短整型（short int &#x2F; short）"></a>短整型（short int &#x2F; short）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围更小，占用内存也更小<br>取值范围：$-2^{15}$~$2^{15}-1$</p><h4 id="长整型（long-int-long）"><a href="#长整型（long-int-long）" class="headerlink" title="长整型（long int &#x2F; long）"></a>长整型（long int &#x2F; long）</h4><p>与 <strong>整形（int）</strong> 的区别在于取值范围大于等于int的范围，主要用于处理一些比较大的整数问题</p><h4 id="无数据类型（unsigned）"><a href="#无数据类型（unsigned）" class="headerlink" title="无数据类型（unsigned）"></a>无数据类型（unsigned）</h4><p><strong>unsigned</strong> 可以加在 <strong>int, short, long, char</strong> 的前面，取消其二进制数第一位表示符号的限制，因此unsigned类型只能表示正数</p><h3 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量 &amp; 常量"></a>变量 &amp; 常量</h3><p><em>顾名思义，变量在函数编译过程中可变，而常量不可变</em></p><p>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">double x &#x3D; 2.3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一语句中，x是被定义出来的变量，2.3是个常量</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>系统在编译过程中会为变量分配相应的内存空间，不同类型的变量被分配的空间不同</p><p>变量的定义：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;char c;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>变量的赋值：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i;i &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>分类：</p><ol><li>整形常量</li><li>实型常量</li><li>字符型常量</li><li>字符串常量</li><li>符号常量</li></ol><h5 id="关于字符型常量参与计算"><a href="#关于字符型常量参与计算" class="headerlink" title="关于字符型常量参与计算"></a>关于字符型常量参与计算</h5><p>由于字符型常量存储的是相应字符的 <strong>ASCⅡ码</strong>，因此可以将其作为整形进行相应计算<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char c &#x3D; &#39;a&#39;;c &#x3D; c - 32;printf(&quot;%c&quot;, c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里的输出结果应该是 ‘A’</p><h5 id="关于转义字符"><a href="#关于转义字符" class="headerlink" title="关于转义字符"></a>关于转义字符</h5><p>用转义字符表示 <strong>ASCⅡ码</strong> 中不可打印的功能性字符<br>如：换行表示为‘ <em><strong>\n</strong></em> ’, 制表（tab）表示为‘ <em><strong>\t</strong></em> ’, …</p><h5 id="关于字符串常量"><a href="#关于字符串常量" class="headerlink" title="关于字符串常量"></a>关于字符串常量</h5><p>字符串常量利用双引号括起来，可表示多个字符的集合<br>如：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&quot;Hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-数据的输入与输出"><a href="#4-数据的输入与输出" class="headerlink" title="4. 数据的输入与输出"></a>4. 数据的输入与输出</h2><h3 id="输出函数printf"><a href="#输出函数printf" class="headerlink" title="输出函数printf"></a>输出函数printf</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;格式控制串&quot;, 输出表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>格式控制串决定输出的数据类型，分别表示为：</p><ol><li><strong>%d</strong> -&gt; <strong>int</strong></li><li><strong>%f</strong> -&gt; <strong>float&#x2F;double</strong></li><li><strong>%c</strong> -&gt; <strong>char</strong></li><li><strong>%ld</strong> -&gt; <strong>long</strong></li><li><strong>%s</strong> -&gt; <strong>字符串</strong></li></ol><h3 id="输入函数scanf（在Visual-Studio中为scanf-s）"><a href="#输入函数scanf（在Visual-Studio中为scanf-s）" class="headerlink" title="输入函数scanf（在Visual Studio中为scanf_s）"></a>输入函数scanf（在Visual Studio中为scanf_s）</h3><p>一般格式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">scanf(&quot;格式控制串&quot;, 地址表列);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：<br>格式控制串与printf大抵相同，但是这里将 <strong>double</strong> 的格式控制串更改为了 <strong>%lf</strong><br>同时后面的地址表列为地址，故需要在变量前加上取地址符号 <strong>&amp;</strong></p><h3 id="字符型数据的输入与输出"><a href="#字符型数据的输入与输出" class="headerlink" title="字符型数据的输入与输出"></a>字符型数据的输入与输出</h3><p>C语言为字符型数据设定了新的输入方式（ <strong>getchar</strong> ）与新的输出方式（ <strong>putchar</strong> ）<br>格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putchar</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-运算符与表达式"><a href="#5-运算符与表达式" class="headerlink" title="5.运算符与表达式"></a>5.运算符与表达式</h2><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符是C语言中表示相应运算的特殊符号<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="运算符表"></p><p>关于运算符的运算顺序与层级，博主认为依靠个人的编程经验与计算习惯可以判断，故这里不再详述。</p><p>几点提示：  </p><ol><li>C语言中整形除以整形得出的数字还是整形，如：  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这个语句的输出应当是1</li><li><strong>size of</strong> 是个运算符，不是个函数，要记牢</li><li>自增（减）时，如果符号在前，就先加减，再运算，反之，若符号在后，就先运算，再加减</li><li>关于 <strong>+，*，%</strong> 与 <strong>&#x3D;</strong> 的连用： <pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>等价于：<pre class="line-numbers language-c" data-language="c"><code class="language-c">a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>上述法则对于 *，%同样适用，不再赘述</li></ol><h2 id="6-数据类型的转换"><a href="#6-数据类型的转换" class="headerlink" title="6.数据类型的转换"></a>6.数据类型的转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>在运算时，如果程序识别到两个不同类型的数据进行运算，会以 <em><strong>向高看齐</strong></em> 的原则进行格式转换<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/%E5%90%91%E9%AB%98%E7%9C%8B%E9%BD%90.png" alt="向高看齐"></p><p>注意：此时可能会出现数值溢出的问题，通常警告为：</p><pre class="line-numbers language-none"><code class="language-none">warning: overflow in implicit constant conversion<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>在编程过程中，如果需要令一个变量以另一个数据类型参与运算，可以采用强制类型转换的方式，具体格式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">double</span> x<span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span>i <span class="token operator">+</span> <span class="token number">3.14</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，上述过程中对原本为整形的 i 进行了强制类型转换，将其转换为 double 类型参与运算</p><p>需要注意的是，强制类型转换后，被转换的变量类型是不变的，即 i 仍然是int型变量</p><h2 id="7-数学函数"><a href="#7-数学函数" class="headerlink" title="7.数学函数"></a>7.数学函数</h2><p>在C语言中有相应的对各种数学函数进行定义的库： <strong>&lt;math.h&gt;</strong><br>在需要使用时，在函数前进行相应的预编译即可</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.2/math.h.png" alt="math.h中的常用函数"></p><p>以上，是编程前需要了解的一些知识</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言程序设计-Chap.1</title>
      <link href="/posts/32835.html"/>
      <url>/posts/32835.html</url>
      
        <content type="html"><![CDATA[<h1 id="程序设计概述"><a href="#程序设计概述" class="headerlink" title="程序设计概述"></a>程序设计概述</h1><h2 id="1-程序设计语言"><a href="#1-程序设计语言" class="headerlink" title="1.程序设计语言"></a>1.程序设计语言</h2><p><em>计算机语言：计算机能够接受和处理的具有一定格式的语言</em>  </p><h3 id="发展历程："><a href="#发展历程：" class="headerlink" title="发展历程："></a>发展历程：</h3><ol><li>机器语言：二进制</li><li>汇编语言：少许助记符号</li><li>高级语言：  <ol><li>面向过程：Basic， C等</li><li>面向对象：Java， C++等</li></ol></li></ol><h2 id="2-程序设计基本概念"><a href="#2-程序设计基本概念" class="headerlink" title="2.程序设计基本概念"></a>2.程序设计基本概念</h2><h3 id="五部曲：（我自己起的）"><a href="#五部曲：（我自己起的）" class="headerlink" title="五部曲：（我自己起的）"></a>五部曲：<del>（我自己起的）</del></h3><ol><li>分析</li><li>确定算法</li><li>编程</li><li>调试</li><li>优化、改进</li></ol><h3 id="程序-数据结构-算法"><a href="#程序-数据结构-算法" class="headerlink" title=" 程序 &#x3D; 数据结构 + 算法 "></a><Font color=CornflowerBlue> <em><strong>程序 &#x3D; 数据结构 + 算法</strong></em> </Font></h3><h3 id="算法的特性："><a href="#算法的特性：" class="headerlink" title="算法的特性："></a>算法的特性：</h3><ol><li>有穷性：有终点</li><li>确定性：定义清晰</li><li>有零个或多个输入</li><li>至少有一个输出</li><li>可行性：每一步都得可行</li></ol><h3 id="如何描述算法？"><a href="#如何描述算法？" class="headerlink" title="如何描述算法？"></a>如何描述算法？</h3><ol><li><em><strong>流程图</strong></em> ：最常用的方法</li><li>结构流程图：<del>我没用过</del></li><li>伪代码：对相应代码块进行简写</li></ol><p>关于流程图的图例：<br><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Chap.1/%E6%B5%81%E7%A8%8B%E5%9B%BE%E5%9B%BE%E4%BE%8B.png" alt="流程图图例"></p><h2 id="3-结构化程序设计"><a href="#3-结构化程序设计" class="headerlink" title="3.结构化程序设计"></a>3.结构化程序设计</h2><p><em>顾名思义，将“程序设计”这个流程结构化，标准化</em></p><h3 id="三种基本结构"><a href="#三种基本结构" class="headerlink" title="三种基本结构"></a>三种基本结构</h3><ol><li>顺序：循序渐进</li><li>选择：涉及到判断，选择支线 <del>（不要介意这个游戏内常见的用语）</del></li><li>循环：涉及到判断，并是否返回执行</li></ol><h2 id="4-程序的实现环境"><a href="#4-程序的实现环境" class="headerlink" title="4.程序的实现环境"></a>4.程序的实现环境</h2><h3 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h3><ol><li>输入设备</li><li>输出设备</li><li>外存&amp;内存</li><li>CPU：<ol><li>运算器</li><li>控制器</li></ol></li></ol><h3 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h3><ol><li>操作系统</li><li>编辑程序</li><li>编译程序</li><li>连接程序</li></ol><h3 id="一些解释："><a href="#一些解释：" class="headerlink" title="一些解释："></a>一些解释：</h3><p>用高级语言编写出来的文件叫做 <strong>源程序</strong> ，不能直接执行<br>因此，需要先将其转换为可执行程序，这一过程称为 <strong>C程序的加工</strong><br>C程序的加工分为两步：  </p><ol><li>编译：具体表现为将 <em><strong>.c</strong></em> 程序转换为 <em><strong>.obj</strong></em> 程序</li><li>链接：将 <em><strong>.obj</strong></em> 程序与其他目标程序&#x2F;库装配，形成 <em><strong>.exe</strong></em>文件</li></ol><p>后续过程中如果涉及到编程，博主会以 <em><strong>Visual Studio 2022</strong></em> 为运行环境</p><p>这篇博文就到这里~</p>]]></content>
      
      
      <categories>
          
          <category> Study Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博第一篇</title>
      <link href="/posts/32455.html"/>
      <url>/posts/32455.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于这个博客"><a href="#关于这个博客" class="headerlink" title="关于这个博客"></a>关于这个博客</h2><p>这个博客来源于博主的一时兴起。</p><p>想发点啥但没有很系统的方法，之后发现了个人博客是个挺自在的地方，故就这样了。</p><h2 id="关于博客的内容"><a href="#关于博客的内容" class="headerlink" title="关于博客的内容"></a>关于博客的内容</h2><p>初步确定为进行个人学习笔记的整理，以及各种博主想说的（包括但不限于各种评价，各种想法…）</p><h2 id="后续更新计划"><a href="#后续更新计划" class="headerlink" title="后续更新计划"></a>后续更新计划</h2><p>· 博客的美化工作，会持续，长期进行</p><p>· 各类二级界面的创建与完善</p><p>· 后续内容的持续跟进…</p><p>目前就这些啦~</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客的搭建流程</title>
      <link href="/posts/23043.html"/>
      <url>/posts/23043.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建流程概述"><a href="#搭建流程概述" class="headerlink" title="搭建流程概述"></a>搭建流程概述</h2><h3 id="Step-1：Nodejs的下载及配置"><a href="#Step-1：Nodejs的下载及配置" class="headerlink" title="Step 1：Nodejs的下载及配置"></a>Step 1：Nodejs的下载及配置</h3><p><em>本博客是以Hexo为基本框架，以Github Page为雏形的个人博客，而在Windows上装载Hexo的最佳方法是通过Git（一个应用，内置了Linux的些许命令）从Github上克隆相应仓库，同时Hexo的运行需要Nodejs所提供的环境</em></p><p>首先前往Nodejs官网：<strong>nodejs.org</strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Nodejs.png" alt="Nodejs官网"></p><p>这边我选择的是左边的18.12.1版本，相对来说比较稳定<br>安装过程很简单，按照默认配置来就可以<del>（无脑下一步）</del></p><p>此后会涉及到两个环境变量的配置：<br>这里附上一篇博文，我觉得人家讲的比我清楚<del>（水平有限，见谅）</del>  </p><blockquote><p><a href="https://blog.csdn.net/zimeng303/article/details/112167688">https://blog.csdn.net/zimeng303/article/details/112167688</a></p></blockquote><p>注：下载完后可以通过cmd（快捷键Ctrl+X，选中其中的 <strong>终端(管理员)</strong> ）检验一下Nodejs是否成功下载并运行了，一并检查一下npm是否成功安装（npm是一个在安装Nodejs后自动给你附带安装的东西，后面会用到）<br>具体命令：</p><pre class="line-numbers language-none"><code class="language-none">&#123;node -v  npm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错才对</p><h3 id="Step-2-将npm更改为国内镜像源提供的cnpm"><a href="#Step-2-将npm更改为国内镜像源提供的cnpm" class="headerlink" title="Step 2: 将npm更改为国内镜像源提供的cnpm"></a>Step 2: 将npm更改为国内镜像源提供的cnpm</h3><p><em>本步骤的目的在于更换npm组件，由于原版npm在后续流程中极其容易报错，因此本步骤至少在博主创建博客时是必要的</em></p><p>命令为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>本步骤需要等待一段时间（安装耗时）</p><p>等待其安装完成后，分别输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm  cnpm -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>应该都不会报错</p><p><strong>注：本步骤中博主遇到了报错情况，提示为：</strong></p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm : 无法加载文件 D:\nodejs\node_global\cnpm.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170 中的 about_Execution_Policies&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种情况下，可以通过命令解除限制：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Set-ExecutionPolicy RemoteSigned -Scope Process&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>解除限制后再次输入cnpm相关命令即可</p><h3 id="Step-3-正式安装Hexo（主角登场）"><a href="#Step-3-正式安装Hexo（主角登场）" class="headerlink" title="Step 3: 正式安装Hexo（主角登场）"></a>Step 3: 正式安装Hexo<del>（主角登场）</del></h3><p><em>上文有提到，本博客以Hexo为基本框架</em></p><p>仍然是在cmd中，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install -g hexo-cli&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待其安装成功后，再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo -v&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>若没报错，说明安装成功</p><h3 id="Step-4-下载Git"><a href="#Step-4-下载Git" class="headerlink" title="Step 4: 下载Git"></a>Step 4: 下载Git</h3><p><em>上文有提到，通过Git可以有效装载运行Hexo，并与相关的Github仓库进行配套使用</em></p><p>前往Git官网：<strong><a href="https://git-scm.com/">https://git-scm.com/</a></strong></p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/Git.png" alt="Git官网"></p><p>博主采用的是2.39.0版本</p><p>同样的，下载，安装<del>（无脑下一步）</del></p><p>接下来仍然涉及到一个环境变量的设置：<br>把刚刚Git安装目录下的bin文件夹打开，复制相应的文件路径，将其添加到<strong>环境变量-系统变量-Path</strong>里面</p><h3 id="Step-5：新建一个用于操作你的博客的文件夹"><a href="#Step-5：新建一个用于操作你的博客的文件夹" class="headerlink" title="Step 5：新建一个用于操作你的博客的文件夹"></a>Step 5：新建一个用于操作你的博客的文件夹</h3><p><em>接下来就是正式的博客搭建环节</em></p><p>在你的电脑中随意一个位置（你得能记住奥）创建一个新文件夹，取名Blog<br>此后点进那个文件夹，右键空白处，点击<strong>Git Bash Here</strong><br>这时应该会出现一个黑框，像这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/gitbash.png" alt="Git控制台界面"></p><p>在其中输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo init&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里大概率会出现两个问题：<br>（1）显示经过多少多少毫秒之后连接错误<br>（2）显示无法成功安装，让你人工输入<em>npm install</em></p><p>如果是第一个错误，请你给git挂上代理（自行搜索）<br>如果是第二个错误，这时候之前做的就有用了，这时直接输入<em>npm install</em>大概率会报错，所以我们输入:</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果没有报错，就大概率成了，这时候看向你的Blog文件夹，如果有一个叫<em>node_modules</em>的文件夹，就可以放心进行下一步了</p><h3 id="Step-6-尝试第一次启动本地服务器"><a href="#Step-6-尝试第一次启动本地服务器" class="headerlink" title="Step 6: 尝试第一次启动本地服务器"></a>Step 6: 尝试第一次启动本地服务器</h3><p>在刚刚那个Git控制台中再次输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果显示：</p><pre class="line-numbers language-none"><code class="language-none">&#123;Hexo running at ______(这里是一个地址）_________, Press Ctrl+C to stop.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>说明成功了，现在在浏览器内打开那个地址，就可以看到一个初步的网页，上面有 <strong>Hexo</strong>标识</p><p>我们先Ctrl+C将其关闭</p><h3 id="Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接"><a href="#Step-7-建立Github账号，并通过SSH-key将其与你的电脑连接" class="headerlink" title="Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接"></a>Step 7: 建立Github账号，并通过SSH key将其与你的电脑连接</h3><p>这边需要你创建一个自己的Github账号<br>牢记你的注册邮箱以及用户名，密码</p><p>创建一个新的库（repository），将这个库的名字改为 <em><strong>你的账户名.github.io</strong></em>  (这一步很重要！)  </p><p>此后进行SSH与Github的绑定,这里还是给出链接  </p><blockquote><p><a href="https://blog.csdn.net/qq_35703954/article/details/87446876">https://blog.csdn.net/qq_35703954/article/details/87446876</a></p></blockquote><p>绑定成功后，需要对Blog文件夹中的一个文件进行些许更改<br>那个文件叫： <em><strong>_config.yml</strong></em></p><p>注：这个文件可以使用记事本打开，但是我强烈建议有需求的各位下载VScode打开这个文件，自行搜索就可以。</p><p>咱们继续：<br>打开后将文件翻到最后，有一个 <em><strong>deploy：…</strong></em> ，将deploy以下的部分全部删除，改为：</p><pre class="line-numbers language-none"><code class="language-none">&#123;deploy:    type: git    repository: 你自己刚刚创建的GitHub的那个项目地址（下文会写如何查看）    branch: main&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em><strong>几个需要注意的点</strong></em><br>· 注意格式，deploy后面的内容是有缩进的，以及冒号后面的空格。<br>· 项目地址的查看方法：<br>前往你的GitHub相应项目中，右上角有一个 <em><strong>code</strong></em> 按钮，长这样：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code.png" alt="Code"><br>点击它，会出现这样的一个界面：</p><p><img src="https://mug-chensblog-1310677143.cos.ap-beijing.myqcloud.com/%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/code-1.png" alt="点击Code之后的界面"><br>选中那个 <em><strong>HTTPS</strong></em>， 之后将底下的链接复制，粘贴至上面的 <em><strong>_config.yml</strong></em> 文件的repository后面</p><h3 id="Step-8-装载部署工具"><a href="#Step-8-装载部署工具" class="headerlink" title="Step 8: 装载部署工具"></a>Step 8: 装载部署工具</h3><p>还是 <em><strong>Blog</strong></em> 文件夹，还是右键 <strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;cnpm install hexo-deployer-git --save&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待安装完成，之后输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等待生成完成（不报错），之后再输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这之后再输入你的库的名称（即 <em><strong>你的账户名.github.io</strong></em>）到浏览器地址栏中，应该就能看到刚刚那个有Hexo的界面了</p><h3 id="Step-9-编写博文"><a href="#Step-9-编写博文" class="headerlink" title="Step 9: 编写博文"></a>Step 9: 编写博文</h3><p><em><strong>Blog</strong></em>文件夹，右键，<strong>Git Bash Here</strong><br>输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo n 你想起的文章名&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后应该会出现一个提示，在你的 <em>source-_posts</em>文件夹内生成了一个markdown文件，这就是你撰写新博客的地方</p><p>注：这也是为什么我推荐安装vscode，因为vscode只需要安装两个插件就可以做到编写，预览Markdown文件，很方便（方法请自行搜索）</p><p>写完你的博文之后，保存，返回 <em><strong>blog</strong></em>文件夹，<strong>Git Bash Here</strong>，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo cl&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo g&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo d&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>处理完后，输入：</p><pre class="line-numbers language-none"><code class="language-none">&#123;hexo s&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一套流程下来，你的博文就可以被成功上传到那个网页中</p><h2 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h2><p>此次博客的搭建，从整体而言是相对繁琐的，同时中间掉了很多次坑，往往一个坑都得花费1-2个小时进行查询，修补，一套流程下来基本上花了有两天时间。</p><p>回过头来，再看这一整个流程，缺乏的就是一个整体框架，如果一股脑冲进去，会做着做着迷失了方向，就不知道该做什么了</p><p>故此，在这里整理下整套流程，供读者参考，更是供自己反思优化</p><p>关于美化，应该不会再整理步骤了，因为各种模板包里面都有详尽的使用说明，并且不同的模板操作方式不同，待读者自行探索了</p><p>这篇博文就到这里</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

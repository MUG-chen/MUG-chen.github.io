---
title: Java-Chap.2
cover: false
tags: Java Programming
catrgories: Study Notes
summary: Java 笔记 第二部分
abbrlink: 36543
date: 2023-09-26 22:06:30
---

# Java 程序设计基础

>本章将正式步入Java的内容，但说在前面，由于此前有C语言的基础章节，而Java的语法又跟C语言极其相似，因此在谈到某些具体语句时，博主将不再讲述的过于详细，请读者自行查找C语言章节中的内容。


## 有关引入包

上述语句中 **import** 语句相当于Java中的引入语句，它的作用是引入一个 **包(Package)** ，用于在本文件中使用。类比C语言，这类似于C中的引入头文件操作。

至于具体的包，我们将在后续的文章中具体提及。

## 关于注释

Java中有三种注释：
- 单行注释：
```Java
// 这是一条单行注释
```

- 多行注释
```Java
/*
这是一个多行注释
*/
```

- 文件注释
```Java
/**
/*这是一个文件注释
/*用于在文件头部对文件的具体功能进行说明
*/
```

## 关于数据类型

### 关于变量

类似于C语言，Java中也有多种数据类型：
- 整数：
byte, short, int, long
- 浮点数：
float, double
- 字符型：
char
- 布尔型：
boolean

在C中，对short，int， long的定义并不明确，只有笼统的：long>int>short （这里指的是内存占用大小），这就导致不同的编译器，不同的系统上可能会导致很严重的兼容性问题。  
Java看到了这一点，为了兼容性，其对每个数据类型的大小进行了准确的定义。
- byte: 1
- short: 2
- int: 4
- long: 8
- float: 4
- double: 8
- char: 2
- boolean: 4

在这里，还需要进行三点说明：
- Java中不允许直接进行低精度类型赋予高精度类型的操作。这就代表着
```java
long x1 = 1;
int a = x1;
```
是不被允许的。

如果要强行赋值，请利用强制类型转化：
```java
int a = (int)x1;
```

- Java中，byte类，short类在运行后所得到的类型， ***均为int型*** ，因此请注意这种类型的编译错误：
```java
byte x1 = 1, x2 = 2;
byte x3 = x1 + x2;
```

虽然x1, x2均为byte型，但其两者相加时，自动转为了int型，这时候将其值赋给x3，会发生溢出报错。

- 在Java中定义float类型时，需要在值后方加一个f。

### 关于常量

Java中定义常量时，需要在定义语句前加 **final** 语句。
```java
final double PI = 3.14;
```

### 关于 var 关键字

**var** 关键字是一种用于偷懒的方法，当类型名过长时，可以在定义语句中使用var关键字来代替前方的类型名。

### 关于数据类型的运算

#### 位移运算

Java中的运算规则，与C大体上相同，在此前没有提过的有一种叫做 **位移运算** 的方法：
```java
int n = 7;  // 0000 ...... 0111
n<<1;  // 0000 ...... 1110
n>>2;  // 0000 ...... 0011
```

上述语句被称作位移运算，可以看出，这种运算方式是以整数的二进制表示方法为基础的。  
**左移加倍，右移减半**

需要注意的是，右移操作并不会移动符号位，如果想要把符号位一并移动，请使用 **>>>** 关键字

#### 位运算

与位移运算相似的在数字二进制表达式上进行操作的还有一种，称为 ***位运算*** 。

其包括四种类型：
- 位与运算符：&
如果参与运算的两个数字的某一个二进制位同时取1，其结果该位上才为1，否则置0
- 位或运算符：｜
如果参与运算的两个数字的某一个二进制位同时取0，其结果上该位才取0，否则为1
- 位异或运算符：^
如果参与运算的两个数字的某一个二进制位不同，其结果上该位才取1，否则置0
- 位取反运算符：~
将一个数字的每一个二进制位上的数都取其相反数。

## 关于字符串

**字符串** 是Java中的一种引用类，在Java中十分常用，因此在这里单独提一句：

字符串可以用 **+** 进行连接定义：
```java
String str1 = "Hello";
String str2 = "World";
String str3 = str1 + str2;
```

对于多行字符串，可以使用：
```java
String """ Hello,
Java
Programming
World """
```
来进行定义。

字符串还可以是一个空值，即：
```java
String str = null;
```

需要知道的是，字符串是不可以直接改变的，因为其是一种引用变量（关于引用，会在下文中提及），往往需要StringBuilder类进行修改。

## 关于数组

**数组** 同样是Java中的一种引用对象，其定义方法如下：
```java
int[] intarray = new int[26];
```

需要注意的是，Java中的数组与C语言中的数组并不是一回事，其意义为定义一个引用变量，这个引用变量会指向一个长度为26的数组变量.

相当于， **intarray** 只是一个变量，而这个数组是一个对象，用 **new** 关键字来创建，它被存在另一个位置，而intarray 仅仅是指向了它。

相似的，如果我定义了一个字符串数组，则事情更加复杂一些。
```java
String[] str_array = new String[10];
```

这里，str_array指向了一个长度为10的字符串数组，这个数组在另外一个位置，但由于字符串也是一种对象，在定义字符串时，也是通过引用的方式进行定义的，因此相当于这个长度为10的数组，里面是10个引用变量，这10个引用变量会各自指向一个字符串，它们也不一定存储在同一片区域。

这同样也代表着，一旦你创建了这个数组对象，你就不能更改这个对象的大小了。如果需要扩容，你只能重新创建一个更大的对象，然后把这个引用对象指向这个全新的对象。

这里，希望读者尽力理解，辅以网络上的其他资料对 ***引用*** 的机制进行了解。

了解后，我们可以在此引入另一个概念：

## 关于多维数组

在C中，我们定义二维数组必定是一个整齐的，如2＊5的，它每个次级数组的长度必须是一致的。

但由于Java中，数组是一种引用变量，我们其实可以定义不整齐的二维数组。

```java
int[][] two_dim_arr = new int[4][]; //代表定义了一个有四个子变量的数组
two_dim_arr[0] = new int[11];
two_dim_arr[1] = new int[9];
two_dim_arr[2] = new int[3];
two_dim_arr[3] = new int[12];
//次级数组的长度可以不同，因为它们可以并不存储在同一片区域中，不需要考虑到对齐问题
```

